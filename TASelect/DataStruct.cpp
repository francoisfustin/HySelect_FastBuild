//////////////////////////////////////////////////////////////////////////
//  DataStruct.cpp : implementation file
//////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include <math.h>
#include <float.h>

#if defined(TACBX) && !defined(PRODUCTION) && !defined(BOOTLOADER)
#include "peg.hpp"
#include "cbx_res.hpp"
#include "CBXDataStructEntries.hpp"
#include "TASensorEntries.hpp"
#include "TAWarning.hpp"
#endif

#include "Utilities.h"

#include "DataStruct.h"

#ifndef PRODUCTION
#include "Hydronic.h"
#include "global.h"
#include "DataBase.h"
#include "DataBObj.h"
#include "Units.h"

#include "DataStruct.h"

#ifndef  TACBX
#include "MainFrm.h"
#include "TASelect.h"
#include "ProductSelectionParameters.h"
#include "Select.h"
#include "MyToolTipCtrl.h"		// To comment ?	
#include "DlgPasteHM.h"			// To comment ?	
#include "HydroMod.h"
#include "EnBitmapPatchWork.h"
#include "HMInclude.h"
#include "RegAccess.h"
#else
#ifndef BOOTLOADER
#include "TAMethod.h"
#include "TALocalize.hpp"
#include "Sensor.hpp"
#endif
#ifndef WIN32
#include "crc.h"
#ifndef BOOTLOADER
#include "SystemTime.hpp"
#endif
#else
#include "Win32Pal.hpp"
#endif
#endif
#endif


///////////////////////////////////////////////////////////////////////////////////
//
//								CEquation
//
///////////////////////////////////////////////////////////////////////////////////
CEquation::CEquation()
{
	memset( &m_CalibDate, 0, sizeof( m_CalibDate ) );
	m_EquType = EqT_None;
	m_nOrder = 0;
	m_SensorType = est_None;			// Type of connected device
	m_SensorVersion = 0;
	m_SensorMac = 0;
}
CEquation::CEquation( eEquType EType, unsigned char ucOrder )
{
	memset( &m_CalibDate, 0, sizeof( m_CalibDate ) );
	m_EquType = EType;
	SetEquationSize( ucOrder );
	m_SensorType = est_None;			// Type of connected device
	m_SensorVersion = 0;
	m_SensorMac = 0;
}

#ifdef TACBX
void CEquation::PatchEquation (TempSensorCalibrationImage_t CalibrationImage)
{
	if (CalibrationImage.type == TEMP_SENSOR_DPTN)		//DPTN/SPTP
	{
		SetSensorType(CEquation::est_DPTN);
		SetEquationType(CEquation::EqT_Ntc);
		SetEquationSize(5);
	}
	else if (CalibrationImage.type == TEMP_SENSOR_DTS)
	{
		if (CalibrationImage.equationType == EqT_Ntc)	//DTS with SPTP pcba
		{
			SetSensorType(CEquation::est_DPTN);
			SetEquationType(CEquation::EqT_Ntc);
			SetEquationSize(5);
		}
		else											//Original DTS
		{
			SetSensorType(CEquation::est_DTS);
			SetEquationType(CEquation::EqT_Poly);		// Set "Poly" in place of "Linear"
			SetEquationSize(4);
		}
	}
}
#endif

// Polynomial order
bool CEquation::SetEquationSize( char Order )
{
	if( Order > MAXPOLYORDER )
	{
		return false;
	}

	m_nOrder = Order;
	m_dCoefs.resize( 0, 0.0 );
	m_usCoefs.resize( 0, 0 );
	m_dCoefs.resize( Order, 0.0 );

	if( EqT_Linear == m_EquType ||  EqT_Linear_Unsigned == m_EquType )
	{
		m_usCoefs.resize( Order, 0 );
	}

	return true;
}
//  Equation coeficients, y = K + Ax + Bx^2 + Cx^3 + ....
//  In: K = Coef(0), A = Coef(1), B = Coef(2), ...
//  Out: true if Coef <= Order
bool CEquation::SetEquationCoefs( char nCoef, double dVal )
{
	if( nCoef >= m_nOrder )
	{
		return false;
	}

	m_dCoefs[nCoef] = dVal;
	return true;
}

bool CEquation::SetEquationCoefs( char nCoef, unsigned short uiXval, double dYval )
{
	if( nCoef >= m_nOrder )
	{
		return false;
	}

	m_dCoefs[nCoef] = dYval;
	m_usCoefs[nCoef] = uiXval;
	return true;

}

unsigned short  CEquation::GetEquationYCoefs( char nCoef )
{
	if( nCoef >= m_nOrder )
	{
		return false;
	}

	return m_usCoefs[nCoef];
}

double  CEquation::GetEquationCoefs( char nCoef )
{
	if( nCoef >= m_nOrder )
	{
		return false;
	}

	return m_dCoefs[nCoef];
}

double CEquation::Solve( double dVal )
{
	double dReturnValue = 0.0;

	switch( m_EquType )
	{
		default:
			break;

		case EqT_None:
			break;

		case EqT_Poly:
		{
			for( char i = 0; i < m_nOrder; i++ )
			{
				dReturnValue += m_dCoefs[i] * pow( dVal, i );
			}
		}
		break;

		case EqT_Linear_Unsigned:
		{
			if( dVal < 0 )
			{
				dVal += 65536;
			}
		}

		// NO BREAK !!
		case EqT_Linear:
		{
			unsigned int i = 1;

			while( i < m_usCoefs.size() && i < ( ( unsigned int )( m_nOrder - 1 ) ) && ( ( double )m_usCoefs[i] ) < dVal )
			{
				i++;
			}

			double dif1 = m_usCoefs[i] - m_usCoefs[i - 1];
			double dif2 = dVal - m_usCoefs[i - 1];

			if( dif1 )
			{
				dReturnValue = m_dCoefs[i - 1] + ( ( m_dCoefs[i] - m_dCoefs[i - 1] ) * dif2 / dif1 );
			}
		}
		break;

		case EqT_Ntc:
		{
			// For Ntc, dVal is UNSIGNED 0...65535
			if( dVal == 0 )		// Overflow
			{
				return -273.15;
			}

			if( dVal < 0 )
			{
				dVal += 65536;
			}

			double dDenom = m_dCoefs[1] - dVal;

			if( dDenom <= 0 )
			{
				return -273.15;
			}

			double resist = ( dVal * m_dCoefs[0] ) / dDenom; 	// Calculate resistance

			if( resist <= 0 )
			{
				return -273.15;
			}

			dDenom = m_dCoefs[2] + m_dCoefs[3] * log( resist ) + m_dCoefs[4] * pow( log( resist ), 3 );

			if( dDenom <= 0 )
			{
				return -273.15;
			}

			dReturnValue = 1 / dDenom;	//Steinhel-Hart
			dReturnValue -= 273.15;
		}
		break;
	}

	return dReturnValue;
}

CEquation &CEquation::operator =( CEquation &Eq )
{
	SetSensorType( Eq.GetSensorType() );
	SetSensorVersion( Eq.GetSensorVersion() );
	SetSensorMac( Eq.GetSensorMac() );
	SetCalibrationDate( Eq.GetCalibrationDate() );
	SetEquationType( Eq.GetEquationType() );
	SetEquationSize( Eq.GetEquationSize() );

	if( EqT_Linear == GetEquationType() || EqT_Linear_Unsigned == GetEquationType() )
	{
		for( int i = 0; i < GetEquationSize(); i++ )
		{
			SetEquationCoefs( i, Eq.GetEquationYCoefs( i ), Eq.GetEquationCoefs( i ) );
		}
	}
	else
	{
		for( int i = 0; i < GetEquationSize(); i++ )
		{
			SetEquationCoefs( i, Eq.GetEquationCoefs( i ) );
		}
	}

	return *this;
}

void CEquation::Copy( CEquation *pEquation )
{
	if( NULL != pEquation )
	{
		pEquation->SetSensorType( GetSensorType() );
		pEquation->SetSensorVersion( GetSensorVersion() );
		pEquation->SetSensorMac( GetSensorMac() );
		pEquation->SetEquationType( GetEquationType() );
		pEquation->SetCalibrationDate( GetCalibrationDate() );
		pEquation->SetEquationSize( GetEquationSize() );
		pEquation->m_dCoefs.resize( m_dCoefs.size() );

		for( unsigned i = 0; i < m_dCoefs.size(); i++ )
		{
			pEquation->m_dCoefs[i] = m_dCoefs[i];
		}

		if( m_usCoefs.size() )
		{
			pEquation->m_usCoefs.resize( m_usCoefs.size() );

			for( unsigned i = 0; i < m_usCoefs.size(); i++ )
			{
				pEquation->m_usCoefs[i] = m_usCoefs[i];
			}
		}
	}
}

#ifndef PRODUCTION

#define CEQUATION_VERSION	2
void CEquation::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CEQUATION_VERSION;
	WriteData<>( outf, Version );
	
	// Info.
	WriteData<>( outf, m_EquType );
	WriteData<>( outf, m_CalibDate );
	WriteData<>( outf, m_nOrder );
	
	int size = m_dCoefs.size();
	WriteData<>( outf, size );

	for( unsigned i = 0; i < m_dCoefs.size(); i++ )
	{
		WriteDouble( outf, m_dCoefs[i] );
	}

	size = m_usCoefs.size();
	WriteData<>( outf, size );

	for( unsigned i = 0; i < m_usCoefs.size(); i++ )
	{
		WriteData<>( outf, m_usCoefs[i] );
	}

	WriteData<>( outf, m_SensorType );
	WriteData<>( outf, m_SensorVersion );
	WriteData<>( outf, m_SensorMac );
}

bool CEquation::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CEQUATION_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CEQUATION_VERSION )
	{
		return false;
	}

	// Info
	inpf.read( (char *)&m_EquType, sizeof( m_EquType ) );
	inpf.read( (char *)&m_CalibDate, sizeof( m_CalibDate ) );
	inpf.read( (char *)&m_nOrder, sizeof( m_nOrder ) );
	
	m_dCoefs.clear();
	unsigned size = 0;
	inpf.read( (char *)&size, sizeof( size ) );
	m_dCoefs.resize( size );

	for( unsigned i = 0; i < size; i++ )
	{
		m_dCoefs[i] = ReadDouble( inpf );
	}

	m_usCoefs.clear();
	inpf.read( (char *)&size, sizeof( size ) );

	if( size )
	{
		m_usCoefs.resize( size );

		for( unsigned i = 0; i < size; i++ )
		{
			unsigned short us;
			inpf.read( (char *)&us, sizeof( unsigned short ) );
			m_usCoefs[i] = us;
		}
	}

	if( Version > 1 )
	{
		inpf.read( (char *)&m_SensorType, sizeof( m_SensorType ) );
		inpf.read( (char *)&m_SensorVersion, sizeof( m_SensorVersion ) );
		inpf.read( (char *)&m_SensorMac, sizeof( m_SensorMac ) );
	}

	return true;
}

void CEquation::SetEquationType( eEquType EquType )
{
	// m_usCoefs only needed when equation type is linear or linear unsigned
	if( m_EquType == EqT_Linear || m_EquType == EqT_Linear_Unsigned )
	{
		if( EquType != EqT_Linear && EquType != EqT_Linear_Unsigned )
		{
			m_usCoefs.resize( 0, 0 );
		}
	}
	else if( m_EquType != EqT_Linear && m_EquType != EqT_Linear_Unsigned )
	{
		if( EquType == EqT_Linear || EquType == EqT_Linear_Unsigned )
		{
			m_usCoefs.resize( m_nOrder, 0 );
		}
	}

	m_EquType = EquType;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CTADataStructX
//
///////////////////////////////////////////////////////////////////////////////////

CTADataStructX::CTADataStructX()
	: CDatastruct( CDataBase::TADatastructX )
{
	SetVersion( CTADATASTRUCTX_FORMAT_VERSION );
	
	// TASCOPE-59.
	m_iTAScopeVersion = 0;
}

void CTADataStructX::Write( OUTSTREAM outf )
{
	// version nÂ°
	short Version = _ttoi( CTADATASTRUCTX_FORMAT_VERSION );
	WriteFileIdentificator( outf, Version );
	WriteHeader( outf );
	WriteObjects( outf );
}

void CTADataStructX::WriteHeader( OUTSTREAM outf )
{
	// Version.
	short Version = 2;
	outf.write( (const char *)(LPCTSTR)&Version, sizeof( Version ) );

	// Write UID if exist.
	WriteString( outf, GetUID().c_str() );

	// TAScope SW version
#ifdef TACBX
	#ifndef BOOTLOADER
		WriteString( outf, VersionInfo.cbx_version );
	#endif
#else
	WriteString( outf, _T("") );
#endif

	WriteShortInfoList( outf );
}

// Buffered read
// TACBX : use ReadFileFast()
void CTADataStructX::Read( INPSTREAM inpf )
{
	HYSELECT_TRY
	{
		short nVersion = CDataBase::ReadFileIdentificator( inpf );

		if( 0 == nVersion )
		{
			HYSELECT_THROW( _T("Database version can't be 0.") );
		}

		// Clear the actual database content.
		MakeEmpty();

#ifndef TACBX
		swprintf_s( m_tcVersion, _DATABASE_VERSION_LENGTH + 1, L"%d", nVersion );
#else
		_string str = int2wstr( nVersion );
		_tcsncpy_s( m_tcVersion, _DATABASE_VERSION_LENGTH + 1, str.c_str(), str.size() + 1 );
#endif

		_string strUID;
		ReadHeader( inpf, nVersion, &strUID, this );
		SetUID( strUID );

		// Create Dummy object to read DataStruct short Infos.
		IDPTR IDPtr;

		CreateObject( IDPtr, CLASS( CDS_PlantX ) );
		CDS_PlantX *pPlant = static_cast<CDS_PlantX *>( IDPtr.MP );
		ReadShortInfosList( inpf, pPlant );

		// DeleteObject, force locker, this object coming from a established DB was written by standard write function,
		// that means it was located into a table and locked by this table.
		// This table is not yet existing (header reading, DB is yet created) so we cannot unlock this Dummy object!
		DeleteObject( IDPtr, true );
		ReadObjects( inpf, nVersion );
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CTADataStructX::Read'.") )
}

bool CTADataStructX::ReadHeader( INPSTREAM  inpf, short Version, _string *pStrUID, CTADataStructX *pDS )
{
	short nHeaderVersion = 0;
	inpf.read( (char *)(LPCTSTR)&nHeaderVersion, sizeof( nHeaderVersion ) );

	if( nHeaderVersion < 1 || nHeaderVersion > 2 )
	{
		return false;
	}

	if( nHeaderVersion >= 2 )
	{
		TCHAR tcBuffer[1024];

		if( false == ReadString( inpf, tcBuffer, sizeof( tcBuffer ) ) )
		{
			return false;
		}

		if( NULL != pStrUID )
		{
			*pStrUID = tcBuffer;
		}
	}

	TCHAR tcBuffer[128];

	if( false == ReadString( inpf, tcBuffer, sizeof( tcBuffer ) ) )
	{
		return false;    //SW Version
	}
	
	char cBuffer[256];
	wcstombs( cBuffer, tcBuffer, 256 );
	
	// TASCOPE-59.
	if( NULL != pDS && DSXType_TADSX == pDS->GetDSType() && NULL != strstr( cBuffer, "TA-SCOPE v") )
	{
		// The version in 'tadsx.tsc' is encoded in this way "TA-SCOPE v2.1.0.3".
		int iCurNumber = 1000;
		int iVersion = 0; 
		char *pcVersion = cBuffer + strlen("TA-SCOPE v");
		char *pcToken = strtok( pcVersion, "." );
		
		while( NULL != pcToken )
		{
			int iNbr = atoi( pcToken );
			iVersion += ( ( iNbr & 0xFF ) * iCurNumber );
			pcToken = strtok( NULL, "." );
			iCurNumber /= 10;
		}
		
		pDS->SetTAScopeVersion( iVersion );
	}

	return true;
}

void CTADataStructX::ReadShortInfosList( INPSTREAM  inpf, CDS_PlantX *pPlant )
{
	if( NULL == pPlant )
	{
		return;
	}

	// Version.
	BYTE Version = 1;
	inpf.read( (char *)&Version, sizeof( Version ) );

	TCHAR str[128];
	ReadString( inpf, str, sizeof( str ) );

	pPlant->ReadAccess( inpf );
}

void CTADataStructX::WriteShortInfoList( OUTSTREAM outf )
{
	// Version.
	BYTE Version = 1;
	WriteData<>( outf, Version );

	WriteString( outf, _T("ShortInfo") );
	
	CDS_PlantX *pPlant = static_cast<CDS_PlantX *>( Get( _T("PLANT_INFO") ).MP );

	if( NULL != pPlant )
	{
		pPlant->WriteAccess( outf );
	}
}

void CTADataStructX::Init()
{
	HYSELECT_TRY
	{
		CDataBase::Init();

		// Initialize the CBX data structure
		// Create the default main tables and their skeleton
		IDPTR TabIDptr, ObjIDptr;

		//====================================
		// Parameter table
		// Misc. table used to store user preferences as Unit, Plant Information
		//====================================
		CreateObject( TabIDptr, CLASS( CTable ), _T("PARAM_TAB") );
		CTable *pParamTable = static_cast<CTable *>( TabIDptr.MP );
		pParamTable->SetName( _T("Parameter table") );
		Access().Insert( TabIDptr );

		//===============================================
		// Create basic Water characteristics working object for QM
		//===============================================
		CreateObject( ObjIDptr, CLASS( CDS_WaterCharacteristic ), _T("PARAM_WC") );
		pParamTable->Insert( ObjIDptr );

		//===============================================
		// Create basic Water characteristics working object for datastruct, only one water char for datastructX
		//===============================================
		CreateObject( ObjIDptr, CLASS( CDS_WaterCharacteristic ), _T("PARAM_HMXWC") );
		pParamTable->Insert( ObjIDptr );

		// Technical Parameters
		CreateObject( ObjIDptr, CLASS( CDS_TechnicalParameter ), _T("PARAM_TECH") );
		pParamTable->Insert( ObjIDptr );

		// Plant Information
		CreateObject( ObjIDptr, CLASS( CDS_PlantX ), _T("PLANT_INFO") );
		pParamTable->Insert( ObjIDptr );

		// Get plant name.
		CDS_PlantX *pPlant = dynamic_cast<CDS_PlantX *>( ObjIDptr.MP );

		if( NULL == pPlant )
		{
			HYSELECT_THROW( _T("Internal error: 'PLANT_INFO' object is created but it's not a 'CDS_PlantX' object.") );
		}

#ifdef TACBX
		pPlant->SetString( CDS_PlantX/*::ePlant*/::Name, LS( SID_DEFAULT_PLANT ) );
#else
		pPlant->SetString( CDS_PlantX/*::ePlant*/::Name, (LPCTSTR)TASApp.LoadLocalizedString( IDS_DEFAULT_PLANT ) );
#endif

#ifdef WIN32
		pPlant->SetLastModDate( __time32_t( NULL ) );
#else
#ifndef BOOTLOADER
		pPlant->SetLastModDate( SystemTime::getUTCTime() );
#endif
#endif

		//====================================
		// Water characteristic table
		// Table that contains all Water characteristic used during measurement (Piping table, Quick measurement table)
		//====================================
		CreateObject( TabIDptr, CLASS( CTable ), _T("WC_TAB") );
		static_cast<CTable *>( TabIDptr.MP )->SetName( _T("Water char table QM and Log") );
		Access().Insert( TabIDptr );

		//====================================
		// Piping table
		// Table used for storing hydraulic network
		//====================================
		CreateObject( TabIDptr, CLASS( CDS_HMXTable ), _T("PIPING_TAB") );
		static_cast<CTable *>( TabIDptr.MP )->SetName( _T("Piping table") );
		Access().Insert( TabIDptr );

		//====================================
		// Quick measurement table
		// Table used to store saved quick measurement
		//====================================
		CreateObject( TabIDptr, CLASS( CDS_QMTable ), _T("QUICKMEAS_TAB") );
		static_cast<CTable *>( TabIDptr.MP )->SetName( _T("Quick measurement table") );
		Access().Insert( TabIDptr );

		//====================================
		// Temporary Table
		// Used to store temporary quick measurement
		//====================================
		CreateObject( TabIDptr, CLASS( CDS_QMTable ), _T("QMTEMP_TAB") );
		static_cast<CTable *>( TabIDptr.MP )->SetName( _T("Temporary QM table") );
		Access().Insert( TabIDptr );

		//====================================
		// Logged data table
		// Table used to store saved logging (CDS_LogDataX)
		//====================================
		CreateObject( TabIDptr, CLASS( CDS_LogTable ), _T("LOGGEDDATA_TAB") );
		static_cast<CTable *>( TabIDptr.MP )->SetName( _T("Logged data table") );
		Access().Insert( TabIDptr );
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CTADataStructX::Init'.") )
}

// Recursive function that reset all name for a module
// If iPos != 0 rename only module with position >= iPos
void CTADataStructX::RenameAllCircuits( CTable *pTab )
{
	if( NULL == pTab )
	{
		return;
	}

	bool bTable = ( IDcmp( L"PIPING_TAB", pTab->GetIDPtr().ID ) == 0 ); //(dynamic_cast<CDS_HydroModX *>(pTab)==0);

	for( IDPTR IDPtr = pTab->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pTab->GetNext( IDPtr.MP ) )
	{
		CDS_HydroModX *pHMX = static_cast<CDS_HydroModX *>( IDPtr.MP );

		if( NULL == pHMX )
		{
			continue;    // ERROR!!!!!
		}

		bool bAuto = ( *pHMX->GetHMName()->c_str() == '*' );

		// First level into the piping_tab should be renamed with letters
		if( true == bAuto )
		{
			pHMX->SetHMName( ComposeHMName( pHMX, '*', bAuto, L"", !bTable ) );
		}

		// Process Children
		RenameAllCircuits( pHMX );
	}
}

_string CTADataStructX::ComposeHMName( int iPos, TCHAR *pHMName, bool bTop, _string strPrefix, bool bNumber )
{
	_string tmpstr;

	if( 0 == iPos )
	{
		return tmpstr;
	}

	_string str;
	_string strSuffix;

	if( true == bNumber )
	{
		strSuffix = to_string<int>( iPos );
	}
	else
	{
		strSuffix = Base26Convert( iPos - 1 );
	}

	tmpstr = '*';

	if( true == strPrefix.empty() )
	{
		// Based on Parent Name

		if( true == bTop )
		{
			str = strSuffix.c_str();
		}
		else
		{
			int i = 0;

			if( *pHMName == '*' )
			{
				i = 1;
			}

			str = _string( pHMName + i ) + L"." + strSuffix;
		}
	}
	else
	{
		//Based on the prefix
		str = strPrefix + strSuffix;
	}

	tmpstr += str;
	return tmpstr;
}

// Compose a HM Name based on the parent Name or on a prefix
// index characters will be composed with letters or figure
_string CTADataStructX::ComposeHMName( CDS_HydroModX *pHM, TCHAR cStar, bool bAuto, _string strPrefix, bool bNumber )
{
	_string tmpstr;

	if( NULL == pHM )
	{
		return tmpstr;
	}

	_string str;

	// Automatic
	if( true == bAuto )
	{
		_string strSuffix;

		if( true == bNumber )
		{
			strSuffix = to_string<int>( pHM->GetPosition() );
		}
		else
		{
			strSuffix = Base26Convert( pHM->GetPosition() - 1 );
		}

		if( cStar != _T('\0') )
		{
			tmpstr = cStar;
		}

		if( true == strPrefix.empty() )
		{
			// Based on Parent Name
			int i = 0;
			CDS_HydroModX *pPHMX = dynamic_cast<CDS_HydroModX *>( pHM->GetIDPtr().PP );

			if( NULL == pPHMX )
			{
				// Parent is a table, we are at the top level
				CTable *pTab = dynamic_cast<CTable *>( pHM->GetIDPtr().PP );

				if( NULL != pTab )
				{
					str = strSuffix.c_str();
				}
				else
				{
					ASSERT( 0 );
					return( _T("") );
				}
			}
			else
			{
				if( _T('*') == *pPHMX->GetHMName()->c_str() )
				{
					i = 1;
				}

				str = _string( pPHMX->GetHMName()->c_str() + i ) + _T("." )+ strSuffix;
			}
		}
		else
		{
			//Based on the prefix
			str = strPrefix + strSuffix;
		}

		tmpstr += str;
	}

	return tmpstr;
}

// Delete HydroModX and all children
void CTADataStructX::DeleteHMX( CDS_HydroModX *pHMX )
{
	if( NULL == pHMX )
	{
		return;
	}

	DeleteHMXBranch( pHMX );
	int iPos = pHMX->GetPosition();
	IDPTR IDPtr = pHMX->GetIDPtr();
	CTable *pTab = static_cast<CTable *>( IDPtr.PP );
	pTab->Remove( IDPtr );
	DeleteObject( IDPtr );
	RemoveIndexHole( pTab, iPos );
}

// Update design flow for all parents modules up to the main table
//	Reset TABalance flags for all ancestor...
void CTADataStructX::UpdateParentDesignQResetBal( CDS_HydroModX *pHMX, bool bResetBalancing )
{
	if( NULL == pHMX )
	{
		return;
	}

	CDS_HydroModX *pPHM = pHMX;

	// Return to the pump
	while( NULL != pPHM )
	{
		//	Reset TABalance flags for all ancestor...
		if( true == bResetBalancing )
		{
			pPHM->ResetTABalanceMode( CDS_HydroModX::etabmNoBalancing );
		}

		// Go one step above
		pHMX = pPHM;
		pPHM = dynamic_cast<CDS_HydroModX *>( pHMX->GetIDPtr().PP );
	}

	if( NULL != pHMX )
	{
		if( true == pHMX->GetpSch()->GetpSchCateg()->IsSecondarySideExist() )		// This is a 2wInj
		{
			pHMX->SetDesignFlow( pHMX->GetDesignFlow( CDS_HydroModX::InSecondary ) );
		}
		else
		{
			pHMX->SetDesignFlow( pHMX->GetDesignFlow( CDS_HydroModX::InPrimary ) );
		}
	}
}

// Recursive function delete all HMX children
void CTADataStructX::DeleteHMXBranch( CDS_HydroModX *pHMX )
{
	if( NULL == pHMX )
	{
		return;
	}

	//Loop on GetFirst() continuously because removing objects inside the loop
	for( IDPTR IDPtr = pHMX->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pHMX->GetFirst() )
	{
		CDS_HydroModX *pChildHMX = static_cast<CDS_HydroModX *>( IDPtr.MP );	// Static cast Only HydroModX are stored into HydroModX
		DeleteHMXBranch( pChildHMX );
		IDPtr.PP->Remove( IDPtr );
		DeleteObject( IDPtr );
	}
}

// Reindex the modules of pTab if the deleted index generates a hole in the indexing
void CTADataStructX::RemoveIndexHole( CTable *pTab, int iDeletedIndex )
{
	for( IDPTR IDPtr = pTab->GetFirst(); *IDPtr.ID ; IDPtr = pTab->GetNext( IDPtr.MP ) )
	{
		int index = ( static_cast<CDS_HydroModX *>( IDPtr.MP ) )->GetPosition();

		if( index > iDeletedIndex )
		{
			( static_cast<CDS_HydroModX *>( IDPtr.MP ) )->SetPosition( index - 1 );
		}
	}
}

// Used to insert modules
void CTADataStructX::CreatePosGap( CTable *pTab, int iFromPos, int iGap )
{
	for( IDPTR IDPtr = pTab->GetFirst(); _T('\0') != *IDPtr.ID ; IDPtr = pTab->GetNext( IDPtr.MP ) )
	{
		int iIndex = ( static_cast<CDS_HydroModX *>( IDPtr.MP ) )->GetPosition();

		if( iIndex > iFromPos )
		{
			( static_cast<CDS_HydroModX *>( IDPtr.MP ) )->SetPosition( iIndex + iGap );
		}
	}
}

// Move HM into a new position into the current module
void CTADataStructX::MoveCircuitInModule( CDS_HydroModX *pHMX, UINT uiNewPos )
{
	if( NULL == pHMX )
	{
		return;
	}

	UINT uiCurPos = pHMX->GetPosition();

	if( uiCurPos == uiNewPos )
	{
		return;
	}

	CTable *pTab = static_cast<CTable *>( pHMX->GetIDPtr().PP );

	if( NULL == pTab )
	{
		return;
	}

	if( uiCurPos < uiNewPos )
	{
		for( IDPTR IDPtr = pTab->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pTab->GetNext( IDPtr.MP ) )
		{
			CDS_HydroModX *pHM = dynamic_cast<CDS_HydroModX *>( IDPtr.MP );

			if( NULL == pHM )
			{
				continue;
			}

			if( pHM->GetPosition() <= uiCurPos )
			{
				continue;
			}

			if( pHM->GetPosition() > uiNewPos )
			{
				continue;
			}

			pHM->SetPosition( pHM->GetPosition() - 1 );
		}

		pHMX->SetPosition( uiNewPos );
	}
	else // (CurPos>NewPos)
	{
		for( IDPTR IDPtr = pTab->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pTab->GetNext( IDPtr.MP ) )
		{
			CDS_HydroModX *pHM = dynamic_cast<CDS_HydroModX *>( IDPtr.MP );

			if( NULL == pHM )
			{
				continue;
			}

			if( pHM->GetPosition() < uiNewPos )
			{
				continue;
			}

			if( pHM->GetPosition() > uiCurPos )
			{
				continue;
			}

			pHM->SetPosition( pHM->GetPosition() + 1 );
		}

		pHMX->SetPosition( uiNewPos );
	}
}

// Clean Balancing and Index flags for a line of HMX
void CTADataStructX::CleanBalancingFlags( CDS_HydroModX *pHMX )
{
	if( NULL == pHMX )
	{
		return;
	}

	// For the current module.
	pHMX->ResetTABalanceMode( CDS_HydroModX::etabmNoBalancing );
	
	// For his parent.
	CDS_HydroModX *pPHMX = dynamic_cast<CDS_HydroModX *>( pHMX->GetIDPtr().PP );
	CleanBalancingFlags( pPHMX );
}


CDS_WaterCharacteristic *CTADataStructX::FindWC( CWaterChar *pWC )
{
	CTable *pTab = dynamic_cast<CTable *>( Get( _T("WC_TAB") ).MP );

	for( IDPTR idptr = pTab->GetFirst(); _T('\0') != *idptr.ID; idptr = pTab->GetNext( idptr.MP ) )
	{
		CDS_WaterCharacteristic *pCDSWC = dynamic_cast<CDS_WaterCharacteristic *>( idptr.MP );

		if( NULL == pCDSWC )
		{
			continue;
		}

		CWaterChar *pWaterChar = pCDSWC->GetpWCData();

		if( true == pWaterChar->Compare( *pWC, false ) )
		{
			return pCDSWC;
		}
	}

	return NULL;
}

CDS_WaterCharacteristic *CTADataStructX::AddIfNotExist( CWaterChar *pWC )
{
	HYSELECT_TRY
	{
		CDS_WaterCharacteristic *pWaterChar = FindWC( pWC );

		//if it doesn't exist (pWC == NULL) it must be added
		if( NULL == pWaterChar )
		{
			CTable *pWCTab = static_cast<CTable *>( Get( _ID( WC_TAB ) ).MP );

			if( NULL == pWCTab )
			{
				return NULL;
			}

			IDPTR WCIDptr;
			CreateObject( WCIDptr, CLASS( CDS_WaterCharacteristic ) );
			pWCTab->Insert( WCIDptr );

			pWaterChar = static_cast<CDS_WaterCharacteristic *>( WCIDptr.MP );
			*pWaterChar->GetpWCData() = *pWC;
			Modified();
		}

		return pWaterChar;
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CTADataStructX::AddIfNotExist'.") )
}

////////////////////////////////////////////////////////////////////////////////
// Find a Module or a valve with name matching str
CDS_HydroModX *CTADataStructX::FindHydroMod( _string str, CTable *pTab, CDS_HydroModX *pHMToSkip, CDatastruct::FindMode eFindMode )
{
	return CDatastruct::FindHydroMod( str.c_str(), pTab, pHMToSkip, eFindMode );
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CTAMetaData
//
// This class will help HySelect to know information about all .tsc project files that 
// are existing in the TA-Scope currently connected.
//
// Effectively, once the TA-Scope is connected to the PC and we launch the 'TA-Scope communication' dialog
// (In the 'Communication\Data transfer' ribbon) we can either download from the TA-Scope to HySelet or upload to the 
// TA-Scope from HySelect. To know what is available in the TA-Scope, we will launch a special command
// (RUN_GENERATE_METADATA -> see the 'ServiceManager::service_RUN_GENERATE_METADATA' method in the 'ServiceManager.cpp' file)
// When the TA-Scope receives this command, it calls the 'CBXDataStruct::WriteTSCInfos' method.
// (See the 'ProtocolCommands::RUN_GENERATE_METADATA' case state in the 'SupportServices::handlePacket' method in the 'SupportServices.cpp' file).
// The 'CBXDataStruct::WriteTSCInfos' method runs all the '.tsc' files available in the TA-Scope and writes in 
// the 'MetaFile.tmd' file short information about each file. For each file, this method creates a 'CDS_PlantX' object in which
// information are saved. Once finished, this file is downloaded by HySelect and put in the 'Maintenance' subfolder of the
// TA-Scope (Generally in 'c:\Users\%USERNAME\Documents\HySelect\TAScope\Int\Maintenance' for INT version for example).
// So, HySelect runs this file and can now have information about all the projects in the TA-Scope instead of downloading all the '.tsc' files themselves.
//
///////////////////////////////////////////////////////////////////////////////////

CTAMetaData::CTAMetaData()
	: CDataBase( CDataBase::TAMetaData )
{
	SetVersion( CTAMETADATA_FORMAT_VERSION );
}

void CTAMetaData::Write( OUTSTREAM outf )
{
	// Version number.
	short nVersion = _ttoi( CTAMETADATA_FORMAT_VERSION );
	WriteFileIdentificator( outf, nVersion );
	WriteHeader( outf );
	WriteObjects( outf );
}

void CTAMetaData::WriteHeader( OUTSTREAM outf )
{
	// Version number.
	short nVersion = 1;
	outf.write( ( const char * )(LPCTSTR)&nVersion, sizeof( nVersion ) );

	// TAScope SW version.
	WriteString( outf, _T("TAScope MetaData:") );

#ifdef TACBX
#ifndef BOOTLOADER
	WriteString( outf, VersionInfo.cbx_version );
#endif
#else
	WriteString( outf, _T("") );
#endif
}

void CTAMetaData::ReadHeader( INPSTREAM inpf, short nVersion, std::list<_string> *pList )
{
	HYSELECT_TRY
	{
		short nHeaderVersion = 0;
		inpf.read( (char *)(LPCTSTR)&nHeaderVersion, sizeof( nHeaderVersion ) );

		if( nHeaderVersion < 1 )
		{
			HYSELECT_THROW( _T("Metadata header version can't be lower than 1.") );
		}

		TCHAR tcBuffer[1024];

		if( false == ReadString( inpf, tcBuffer, sizeof( tcBuffer ) ) )
		{
			HYSELECT_THROW( _T("Can't read the TA-Scope metadata.") );
		}

		if( false == ReadString( inpf, tcBuffer, sizeof( tcBuffer ) ) )
		{
			HYSELECT_THROW( _T("Can't read the software version.") );
		}
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CTAMetaData::ReadHeader'.") )
}

// Buffered read
// TACBX : use ReadFileFast()
void CTAMetaData::Read( INPSTREAM inpf )
{
	HYSELECT_TRY
	{
		short nVersion = CDataBase::ReadFileIdentificator( inpf );

		if( 0 == nVersion )
		{
			HYSELECT_THROW( _T("Metadata file version can't be equal to 0.") );
		}

		// Clear the actual database content.
		MakeEmpty();

#ifndef TACBX
		swprintf_s( m_tcVersion, _DATABASE_VERSION_LENGTH + 1, L"%d", nVersion );
#else
		_string str = int2wstr( nVersion );
		_tcsncpy_s( m_tcVersion, _DATABASE_VERSION_LENGTH + 1, str.c_str(), str.size() );
#endif

		ReadHeader( inpf, nVersion );
		ReadObjects( inpf, nVersion );
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CTAMetaData::Read'.") )
}

void CTAMetaData::Init()
{
	HYSELECT_TRY
	{
		CDataBase::Init();
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CTAMetaData::Init'.") )
}

#ifdef TACBX

///////////////////////////////////////////////////////////////////////////////////
//
//								CTAPersistData
//
///////////////////////////////////////////////////////////////////////////////////

CTAPersistData::CTAPersistData()
	: CDataBase( CDataBase::TAPersistData )
{
	SetVersion( CTAPERSISTDATA_FORMAT_VERSION );
}

void CTAPersistData::Write( OUTSTREAM outf )
{
	// Version.
	short Version = _ttoi( CTAPERSISTDATA_FORMAT_VERSION );
	WriteFileIdentificator( outf, Version );
	WriteHeader( outf );
	WriteObjects( outf );
}

void CTAPersistData::FillMissingUnits()
{
	IDPTR ObjIDptr;
	CDimValue dv;

	ObjIDptr = Get( _T("UNIT_USER") );
	CDB_MultiString *pStr = static_cast<CDB_MultiString *>( ObjIDptr.MP );

	CDB_DefaultUnits *pDefaultUnits = dynamic_cast<CDB_DefaultUnits *>( GetpTADB()->Get( _T("DEFAULT_UNITS") ).MP );

	CUnitDatabase *pDB = dv.AccessUDB();

	// TASCOPE-84: Units changed in HYS-1367 and then HYS-1518 causes a crash in some circumstances.
	// But we didn't change the 'CTAPERSISTDATA_FORMAT_VERSION' version.
	// See the card for more details.
	// TASCOPE-85: When reading a 4004 version, we reset all the unit in the 'CUnitDatabase'.
	// But the 'CDB_MultiString' "UNIT_USER" is not changed! So, when leaving TA-Scope, this is this old 'CDB_MultiString' object that is
	// written in the 'TAPersistaData.tpd'.
	if( _ttoi( GetVersion() ) < 4005 )
	{
		pStr->DeleteAllLines();

		for( int iPhys = 0; iPhys < _UNITS_NUMBER_OF; iPhys++ )
		{
			pDB->SetDefaultUnit( iPhys, 0 );
			pStr->AddKey( iPhys, _T("0") );
		}
	}
	else
	{
		if( 4005 == _ttoi( GetVersion() ) )
		{
			// TASCOPE-89: Yet a new unit added in HySelect and not managed in the TA-Scope
			// The previous version contained 29 units, now we have the additional "_U_ENERGY" unit.
			pStr->AddKey( 29, _T("0") );
		}

		for( int iPhys = 0; iPhys < _UNITS_NUMBER_OF; iPhys++ )
		{
			LPCTSTR pText = pStr->GetString( iPhys );

			if( _T('\0') == *pText )
			{
				pStr->SetString( iPhys, int2wstr( pDefaultUnits->GetLocalizedDefaultUnits( iPhys ) ) );
			}
	
			pDB->SetDefaultUnit( iPhys, wstr2int( pStr->GetString( iPhys ) ) );
		}
	}
}

bool CTAPersistData::FillMissingFields()
{
	HYSELECT_TRY
	{
		// Initialize the PersistData structure
		// Create the default main tables and their skeleton
		IDPTR TabIDptr, ObjIDptr;

		//====================================
		// Parameter table: PARAM_TABLE
		//====================================
		TabIDptr = Get( _T("PARAM_TABLE") );

		if( NULL == TabIDptr.MP )
		{
			CreateObject( TabIDptr, CLASS( CTable ), _T("PARAM_TABLE") );
			( static_cast<CTable *>( TabIDptr.MP ) )->SetName( _T("Parameter Table") );
			Access().Insert( TabIDptr );
		}

		// Technical Parameters
		ObjIDptr = Get( _T("PARAM_TECH") );

		if( NULL == ObjIDptr.MP )
		{
			CreateObject( ObjIDptr, CLASS( CDS_TechnicalParameter ), _T("PARAM_TECH") );
			( static_cast<CTable *>( TabIDptr.MP ) )->Insert( ObjIDptr );
		}

		// Table for storing user parameters
		TabIDptr = Get( _T("USER_TABLE") );

		if( NULL == TabIDptr.MP )
		{
			CreateObject( TabIDptr, CLASS( CTable ), _T("USER_TABLE") );
			( static_cast<CTable *>( TabIDptr.MP ) )->SetName( _T("User Parameter Table") );
			Access().Insert( TabIDptr );
		}

		// User Parameters
		ObjIDptr = Get( _T("PARAM_USER") );

		if( NULL == ObjIDptr.MP )
		{
			CreateObject( ObjIDptr, CLASS( CDB_MultiString ), _T("PARAM_USER") );
			( static_cast<CTable *>( TabIDptr.MP ) )->Insert( ObjIDptr );
		}

		CDB_MultiString *pStr = static_cast<CDB_MultiString *>( ObjIDptr.MP );

		if( NULL == pStr )
		{
			return false;
		}

		if( L'\0' == *pStr->GetString( name ) )
		{
			pStr->SetString( name, L"Hh" );
		}

		if( L'\0' == *pStr->GetString( Backlight ) )
		{
			pStr->SetString( Backlight, L"50" );
		}

		if( L'\0' == *pStr->GetString( TimeToDim ) )
		{
			pStr->SetString( TimeToDim, L"2" );
		}

		if( L'\0' == *pStr->GetString( TimeToSleep ) )
		{
			pStr->SetString( TimeToSleep, L"2" );
		}

		if( L'\0' == *pStr->GetString( TimeToOff ) )
		{
			pStr->SetString( TimeToOff, L"5" );
		}

		if( L'\0' == *pStr->GetString( KeyBeep ) )
		{
			pStr->SetString( KeyBeep, L"0" );
		}

		if( L'\0' == *pStr->GetString( ErrorBeep ) )
		{
			pStr->SetString( ErrorBeep, L"1" );
		}

		if( L'\0' == *pStr->GetString( dateformat ) )
		{
			pStr->SetString( dateformat, L"0" );
		}

		if( L'\0' == *pStr->GetString( timeformat ) )
		{
			pStr->SetString( timeformat, L"0" );
		}

		if( L'\0' == *pStr->GetString( dotdash ) )
		{
			pStr->SetString( dotdash, L"0" );
		}

		if( L'\0' == *pStr->GetString( ShowOldValve ) )
		{
			pStr->SetString( ShowOldValve, L"0" );
		}

		if( L'\0' == *pStr->GetString( ShowAllValve ) )
		{
			pStr->SetString( ShowAllValve, L"0" );
		}

		if( L'\0' == *pStr->GetString( DoNotShowInfoMsg ) )
		{
			pStr->SetString( DoNotShowInfoMsg, L"0" );
		}

		if( L'\0' == *pStr->GetString( RadioEnable ) )
		{
			pStr->SetString( RadioEnable, L"1" );
		}

		if( L'\0' == *pStr->GetString( LanguageId ) )
		{
			pStr->SetString( LanguageId, L"0" );
		}

		if( L'\0' == *pStr->GetString( LogRefNum ) )
		{
			pStr->SetString( LogRefNum, L"1" );
		}

		if( L'\0' == *pStr->GetString( PipeSerie ) )
		{
			pStr->SetString( PipeSerie, L"STEEL_GEN" );
		}

		if( L'\0' == *pStr->GetString( UseTwoDpS ) )
		{
			pStr->SetString( UseTwoDpS, L"0" );
		}

		if( L'\0' == *pStr->GetString( PanChannel ) )
		{
			pStr->SetString( PanChannel, L"24" );
		}

		if( L'\0' == *pStr->GetString( UseDpFilter ) )
		{
			pStr->SetString( UseDpFilter, L"1" );
		}

		if( L'\0' == *pStr->GetString( DpFilterOrangeLevel ) )
		{
			pStr->SetString( DpFilterOrangeLevel, L"2" );
		}

		if( L'\0' == *pStr->GetString( DpFilterRedLevel ) )
		{
			pStr->SetString( DpFilterRedLevel, L"10" );
		}

		// Units Parameters
		ObjIDptr = Get( _T("UNIT_USER") );

		if( NULL == ObjIDptr.MP )
		{
			CreateObject( ObjIDptr, CLASS( CDB_MultiString ), _T("UNIT_USER") );
			( static_cast<CTable *>( TabIDptr.MP ) )->Insert( ObjIDptr );
		}

		// Clipboard
		ObjIDptr = Get( _T("CLIPBOARD_USER") );

		if( NULL == ObjIDptr.MP )
		{
			CreateObject( ObjIDptr, CLASS( CDB_MultiString ), _T("CLIPBOARD_USER") );
			( static_cast<CTable *>( TabIDptr.MP ) )->Insert( ObjIDptr );
		}

		pStr = static_cast<CDB_MultiString *>( ObjIDptr.MP );

		if( NULL == pStr )
		{
			return false;
		}

		for( int n = 0; n < 10; n++ )
		{
			if( L'\0' == *pStr->GetString( n ) )
			{
				pStr->SetString( n, L" " );
			}
		}

		// WARNING_SCREENS
		ObjIDptr = Get( _T("WARNING_SCREENS") );

		if( NULL == ObjIDptr.MP )
		{
			CreateObject( ObjIDptr, CLASS( CDB_MultiString ), _T("WARNING_SCREENS") );
			( static_cast<CTable *>( TabIDptr.MP ) )->Insert( ObjIDptr );
		}

		pStr = static_cast<CDB_MultiString *>( ObjIDptr.MP );

		if( NULL == pStr )
		{
			return false;
		}

		PEGINT iNbrWarning = CTAWarning::GetNumberOfWarning();

		for( int n = 0; n < iNbrWarning; n++ )	// Attention - max screens = 25 (was 20 before)
		{
			if( L'\0' == *pStr->GetString( n ) )
			{
				pStr->SetString( n, L"1" );    // Default to true
			}
		}

		Modified( false );
		return true;
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CTAPersistData::FillMissingFields'.") )
}
#endif



///////////////////////////////////////////////////////////////////////////////////
//
//								CTADatastruct
//
///////////////////////////////////////////////////////////////////////////////////
CTADatastruct::CTADatastruct()
	: CDatastruct( CDataBase::TADatastruct )
{
	SetVersion( CTADATASTRUCT_FORMAT_VERSION );

#ifndef TACBX
	m_bCheckAllModules = false;
	m_mapHMList.clear();
#endif
}

void CTADatastruct::Read( INPSTREAM inpf )
{
	HYSELECT_TRY
	{
		// Version.
		short nVersion = 0;
		nVersion = ReadFileIdentificator( inpf );
		MakeEmpty();

#ifndef TACBX
		swprintf_s( m_tcVersion, _DATABASE_VERSION_LENGTH + 1, L"%d", nVersion );
#else
		_string str = int2wstr( nVersion );
		_tcsncpy_s( m_tcVersion, _DATABASE_VERSION_LENGTH + 1, str.c_str(), str.size() );
#endif

		ReadHeader( inpf, nVersion );
		ReadObjects( inpf, nVersion );

#ifndef TACBX
		// Add the missing parts in TADS structure if necessary.
		CreateTSPProjTable();

		// HYS-1590: Verify that there are no pipe series or pipes encoded with the old manner ("{AAAA}_GEN_ID").
		// We must first rename all the old IDs before. And only after we go to the following code to verify if some 
		// pipes are new for the HySelect user pipe database.
		// Remark: We are not working on the user pipe database but well on the "PIPE_TAB" in the current CTADatastruct by passing "this"
		// as argument.
		// For more details about operation, see comments in the 'RenameOldPipsIDs' method.
		bool bOldPipeRenamed = TASApp.GetpPipeDB()->RenameOldPipeIDs( this );

		// Now we have to rename old IDs in the project in file. It means we need to run all the 'CDS_Hydromod' objects and also
		// to verify in all the product selections.
		// In the same time, we will prepare a list of pipe series that are not yet in HySelect or that are deleted now in HySelect.
		std::vector<CString> vecPipeSeriesInProjectNotInHySelect;
		std::vector<CString> vecPipeSeriesInProjectButDeletednInHySelect;
		VerifyPipeSeriesWhenOpeningProject( &vecPipeSeriesInProjectNotInHySelect, &vecPipeSeriesInProjectButDeletednInHySelect );

		// Retrieve the pointer on the "PIPE_TAB" just read in the projet.
		CTable *pPipeTab = TASApp.GetpPipeDB()->GetPipeTab( this, false );

		// This variable will tell us if a temporary user pipe database has been created or not.
		// See comment in the code below when creating the temporary user pipe database.
		bool bWorkWithTemporaryPipeTable = false;

		if( NULL != pPipeTab )
		{
			if( vecPipeSeriesInProjectNotInHySelect.size() > 0 )
			{
				// HySelect project files that you try to open contains pipes unavailable in your pipes user database.
				// -Press "Yes" to import them and complete your pipes user database.
				// -Press "No" to use temporarily pipes database available with the project.
				CString str1 = TASApp.LoadLocalizedString( IDS_IMPORTPIPESFROMFILE );
			
				// HySelect project files that you try to open contains pipes unavailable in your pipes user database. 
				// Due to conflicting pipes definition these pipes could not be imported. We will temporarily use pipe database provided within project file.
				CString str2 = TASApp.LoadLocalizedString( IDS_USEPIPESFROMFILE );

				if( false == TASApp.GetpPipeDB()->FindDuplicate( this )
						&& IDYES == AfxMessageBox( str1, MB_YESNO | MB_ICONEXCLAMATION, 0 ) ) // Import series in UserDB
				{
					// We copy only pipe series that are user in the tsp file but not yet in HySelect.
					// In this case, IDs in the vector point on objects that are in the "PIPE_TAB" table in the tsp file (Current CTADtastruct).
					// This is why here we add the pointer on the right database in the second argument from where with ID we will retrieve the pipe series.
					TASApp.GetpPipeDB()->CopyPipeSeriesFrom( vecPipeSeriesInProjectNotInHySelect, this );
				}
				else  // Use it temporarily to open the file
				{
					if( true == TASApp.GetpPipeDB()->FindDuplicate( this ) )
					{
						AfxMessageBox( str2, MB_OK | MB_ICONINFORMATION, 0 );
					}

					TASApp.GetpPipeDB()->DeletePipeTab();
					TASApp.GetpPipeDB()->CopyFrom( TASApp.GetpTADB() );

					// We copy only pipe series that are user in the tsp file but not yet in HySelect.
					// In this case, IDs in the vector point in object that are in the "PIPE_TAB" table in the tsp file (Current CTADtastruct).
					// This is why here we add the pointer on the right database in the second argument from where with ID we will retrieve the pipe series.
					TASApp.GetpPipeDB()->CopyPipeSeriesFrom( vecPipeSeriesInProjectNotInHySelect, this );

					TASApp.GetpPipeDB()->SetSaveDB( false );

					bWorkWithTemporaryPipeTable = true;
				}
			}

			if( vecPipeSeriesInProjectButDeletednInHySelect.size() > 0 )
			{
				// Can happen when opening a tsp file with a pipe that has been meanwhile deleted from HySelect.

				// The current project file contains some pipes that are now deleted from the HySelect database.
				// We will temporarily allow you to use these deleted pipes only for this project.
				CString str1 = TASApp.LoadLocalizedString( IDS_PIPESFROMTSPARENOWDELETED );
				AfxMessageBox( str1, MB_OK | MB_ICONEXCLAMATION, 0 );

				if( false == bWorkWithTemporaryPipeTable )
				{
					TASApp.GetpPipeDB()->DeletePipeTab();
					TASApp.GetpPipeDB()->CopyFrom( TASApp.GetpTADB() );
					TASApp.GetpPipeDB()->SetSaveDB( false );

					bWorkWithTemporaryPipeTable = true;
				}

				TASApp.GetpPipeDB()->ResetDeletedFlag( vecPipeSeriesInProjectButDeletednInHySelect );
			}
		}
		else if( eBool3::eb3True == IsHMCalcMode() && vecPipeSeriesInProjectNotInHySelect.size() > 0 )
		{
			// HYS-1536 : Open old project that contains missing pipes with a specific message which tells us 
			// the project cannot be loaded.
			CString	str;
			CDS_ProjectRef *ref = GetpProjectRef();
			CString strtmp = ref->GetString( ref->Name );

			if( false == strtmp.IsEmpty() )
			{
				strtmp = strtmp.Right( strtmp.GetLength() - strtmp.ReverseFind( '\\' ) - 1 );
			}
			
			FormatString( str, AFXMSG_USERPIPESERIESMISSING, strtmp );
			AfxMessageBox( str, MB_OK | MB_ICONINFORMATION, 0 );
			Modified( false );
			HYSELECT_THROW( _T( "Old project with missing pipes can not be loaded." ) );
		}

		if( true == bWorkWithTemporaryPipeTable )
		{
			// If we create a temporary user pipe database, we need to update all IDPtr in the project.
			UpdatePipeIDPtrs();
		}

		// HYS-1590: In all cases we call these three following methods to force a refresh of the pipe combos.
		// Fill the ribbon bar with the new list of pipes.
		// For project.
		pMainFrame->FillPipeSeriesCB();

		// For product selection.
		pMainFrame->FillProductSelPipeSeriesCB();

		// Send message to notify that the pipe database has been modified.
		::AfxGetApp()->m_pMainWnd->PostMessage( WM_USER_PIPECHANGE, ( WPARAM )WM_UPC_ForProject );

		// Can remove now all the pipes that are in the 'CTADatastruct'.
		// Remark: We are not working on the user pipe database but well on the "PIPE_TAB" in the current CTADatastruct by passing "this"
		// as argument.
		TASApp.GetpPipeDB()->DeletePipeTab( this );
		
		if( nVersion < 4008 )
		{
			// Processing of HM selected products.
			CTable *pTab = GetpHydroModTable();

			if( NULL != pTab )
			{
				CleanUnNeededSelectedProduct( pTab );
			}

			pTab = GetpHUBSelectionTable();

			if( NULL != pTab )
			{
				CleanUnNeededSelectedProduct( pTab );
			}

			CleanOtherUnNeededSelectedProduct();

			// Processing of TBV-C and TBV-CM that has been moved from CDS_SelManBv to CDS_SelBCV with possible re edition
			UpgradeTBVCSelection();
		
			// Processing of CDS_SelManBv refactoring
			UpgradeManBvSelection();
		
			// Processing of CDS_SelDpC refactoring
			UpgradeDpCSelection();
		}

		if( nVersion < 4010 )
		{
			// Processing of CDS_SelRadSet refactoring in CDS_SSelRadSet.
			UpgradeRadSetSelection();
		}

		if( nVersion < 4012 )
		{
			// Processing of CDS_DirectSel refactoring into CDS_SSelXXX.
			UpgradeDirectSelSelection();
		}

		if( nVersion < 4015 )
		{
			// Some Waterchar created inside the scope was not correctly inserted in the WC_TAB
			CTable *pWCTab = static_cast<CTable *>( Get( L"WC_TAB" ).MP );

			if( NULL != pWCTab )
			{
				for( IDPTR IDPtr = GetpTADB()->Access().GetFirst(); *IDPtr.ID; IDPtr = GetpTADB()->Access().GetNext() )
				{
					if( NULL == IDPtr.PP )
					{
						CDS_WaterCharacteristic *pWC = dynamic_cast<CDS_WaterCharacteristic *>( IDPtr.MP );

						if( NULL != pWC )
						{
							pWCTab->Insert( IDPtr );
						}

						//DeleteObject(IDPtr, true);
					}
				}
			}

			// 			DA50_???J   -->   DA50_???I
			// 			DA50_???L   -->   DA50_???K
			// 			DA50_???N   -->   DA50_???M
			// 			DA50_???P   -->   DA50_???O
			UpgradeDA50IDPTR();
		}

#endif

	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CTADatastruct::Read'.") )
}

#ifndef TACBX
IDPTR CTADatastruct::FoundPipe( CString strPipeSeriesName, CString strPipeSizeName )
{
	IDPTR retIDPtr;
	CTable *pTab = TASApp.GetpPipeDB()->GetPipeTab( NULL, false );

	if( NULL == pTab )
	{
		ASSERTA_RETURN( retIDPtr );
	}

	for( retIDPtr = pTab->GetFirst(); NULL != retIDPtr.MP; retIDPtr = pTab->GetNext() )
	{
		if( strPipeSeriesName == ( static_cast<CTable *>( retIDPtr.MP ) )->GetName() )
		{
			break;
		}
	}

	// Pipe series found?
	if( NULL != retIDPtr.MP )
	{
		pTab = static_cast<CTable *>( retIDPtr.MP );

		for( retIDPtr = pTab->GetFirst(); NULL != retIDPtr.MP; retIDPtr = pTab->GetNext() )
		{
			CDB_Pipe *pPipe = dynamic_cast<CDB_Pipe *>( retIDPtr.MP );

			if( NULL != pPipe && 0 == strPipeSizeName.CompareNoCase( pPipe->GetName() ) )
			{
				break;
			}
		}
	}

	return retIDPtr;
}

void CTADatastruct::UpgradeTBVCSelection()
{
	try
	{
		// Scan all ManBv
		CStringArray TableID;
		TableID.Add( _T("REGVALV_TAB") );
		CTable *pCtrlTab = static_cast<CTable *>( Get( _T("CTRLVALVE_TAB") ).MP );

		if( NULL == pCtrlTab )
		{
			HYSELECT_THROW( _T("Internal error: Can't retrieve the 'CTRLVALVE_TAB' table from the database.") );
		}

		CArray<IDPTR> IDptrToRemove;

		for( int i = 0; i < TableID.GetSize(); i++ )
		{
			CTable *pTab = static_cast<CTable *>( Get( TableID[i] ).MP );

			if( NULL == pTab )
			{
				continue;
			}

			for( IDPTR idptr = pTab->GetFirst(); NULL != idptr.MP; idptr = pTab->GetNext( idptr.MP ) )
			{
				CDS_SelManBv *pSel = dynamic_cast<CDS_SelManBv *>( idptr.MP );

				if( NULL == pSel )
				{
					continue;
				}

				CDB_ControlValve *pCV = dynamic_cast<CDB_ControlValve *>( pSel->GetValveIDPtr().MP );

				if( NULL == pCV )
				{
					continue;
				}

				CDB_ControlProperties *pCtrlProp = dynamic_cast<CDB_ControlProperties *>( pCV->GetCtrlPropIDPtr().MP );

				if( false == pCtrlProp )
				{
					HYSELECT_THROW( _T("Internal error: 'CDB_ControlProperties' object is not defined for the '%s' valve."),  pSel->GetValveIDPtr().ID );
				}

				// Create an CDS_SelBCV entry
				IDPTR IDPtrBCV = _NULL_IDPTR;
				CreateObject( IDPtrBCV, CLASS( CDS_SSelBCv ) );
				pCtrlTab->Insert( IDPtrBCV );
				
				CDS_SSelBCv *pBCv = dynamic_cast<CDS_SSelBCv *>( IDPtrBCV.MP );
				
				// CDS_SSelBCv.
				pBCv->SetOpening( pSel->GetSetting() );
				
				// CDS_SSelCtrl.
				pBCv->SetProductIDPtr( pSel->GetValveIDPtr() );
				pBCv->SetCtrlProp( pCtrlProp->GetCv2w3w() );
				pBCv->SetCtrlType( pCtrlProp->GetCtrlType() );
				
				// CDS_SelProd.
				pBCv->SetFlowDef( CDS_SelProd::efdFlow );
				pBCv->SetQ( pSel->GetFlow() );
				
				// Store as CB user choice current Type, family, connection,...completely open *** ALL
				// Try to identify Pipe
				IDPTR pipeIDPtr = FoundPipe( pSel->GetPipeName(), pSel->GetPipeSize() );

				if( NULL != pipeIDPtr.MP )
				{
					pBCv->SetPipeSeriesID( pipeIDPtr.PP->GetIDPtr().ID );
					pBCv->GetpSelPipe()->SetPipeID( pipeIDPtr.ID );
				}

				//else
				//	SetPipeUnavailable(true );

				pBCv->GetpSelPipe()->SetLinDp( pSel->GetLinDp() );
				pBCv->GetpSelPipe()->SetLinDpFlag( pSel->GetLinDpFlag() );
				pBCv->GetpSelPipe()->SetU( pSel->GetU() );
				pBCv->GetpSelPipe()->SetUFlag( pSel->GetUFlag() );
				pBCv->GetpSelPipe()->SetTpFlag( pSel->GetTpFlag() );

				pBCv->GetpSelectedInfos()->SetReference( CSelectedInfos::eRef1, pSel->GetRef1() );
				pBCv->GetpSelectedInfos()->SetReference( CSelectedInfos::eRef2, pSel->GetRef2() );
				pBCv->GetpSelectedInfos()->SetQuantity( pSel->GetQuantity() );
				pBCv->GetpSelectedInfos()->SetPrice( pSel->GetPrice() );
				pBCv->GetpSelectedInfos()->SetRemark( pSel->GetRemark() );
				pBCv->GetpSelectedInfos()->SetRemarkIndex( pSel->GetRemarkIndex() );
				pBCv->GetpSelectedInfos()->SetRowIndex( pSel->GetRowIndex() );
				CWaterChar *pwc = pBCv->GetpSelectedInfos()->GetpWCData();
				pSel->GetWC( pwc );

				IDptrToRemove.Add( idptr );
			}

			for( int j = 0; j < IDptrToRemove.GetCount(); j++ )
			{
				pTab->Remove( IDptrToRemove[j] );
				DeleteObject( IDptrToRemove[j] );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CTADatastruct::UpgradeTBVCSelection'."), __LINE__, __FILE__ );
		throw;
	}
}

void CTADatastruct::UpgradeManBvSelection()
{
	try
	{
		// Scan all ManBv.
		CStringArray TableID;
		TableID.Add( _T("REGVALV_TAB") );
		CArray<IDPTR> IDptrToRemove;

		for( int i = 0; i < TableID.GetSize(); i++ )
		{
			CTable *pTab = static_cast<CTable *>( Get( TableID[i] ).MP );

			if( NULL == pTab )
			{
				continue;
			}

			for( IDPTR idptr = pTab->GetFirst(); NULL != idptr.MP; idptr = pTab->GetNext( idptr.MP ) )
			{
				CDS_SelManBv *pSel = dynamic_cast<CDS_SelManBv *>( idptr.MP );

				if( NULL == pSel )
				{
					continue;
				}

				if( NULL == pSel->GetValveIDPtr().MP )
				{
					IDptrToRemove.Add( idptr );
					continue;
				}

				// Create an CDS_SelBV entry
				IDPTR IDPtrBV = _NULL_IDPTR;
				CreateObject( IDPtrBV, CLASS( CDS_SSelBv ) );
				pTab->Insert( IDPtrBV );

				CDS_SSelBv *pBv = dynamic_cast<CDS_SSelBv *>( IDPtrBV.MP );

				// CDS_SSelBv.
				pBv->SetOpening( pSel->GetSetting() );
				pBv->SetProductIDPtr( pSel->GetValveIDPtr() );
				pBv->SetTypeID( ( static_cast<CDB_TAProduct *>( pSel->GetValveIDPtr().MP ) )->GetTypeIDPtr().ID );
				
				// CDS_SelProd.
				pBv->SetFlowDef( CDS_SelProd::efdFlow );
				pBv->SetQ( pSel->GetFlow() );
				
				// Store as CB user choice current Type, family, connection,...completely open *** ALL
				// Try to identify Pipe.
				IDPTR pipeIDPtr = FoundPipe( pSel->GetPipeName(), pSel->GetPipeSize() );

				if( NULL != pipeIDPtr.MP )
				{
					pBv->SetPipeSeriesID( pipeIDPtr.PP->GetIDPtr().ID );
					pBv->GetpSelPipe()->SetPipeID( pipeIDPtr.ID );
				}

				pBv->GetpSelPipe()->SetLinDp( pSel->GetLinDp() );
				pBv->GetpSelPipe()->SetLinDpFlag( pSel->GetLinDpFlag() );
				pBv->GetpSelPipe()->SetU( pSel->GetU() );
				pBv->GetpSelPipe()->SetUFlag( pSel->GetUFlag() );
				pBv->GetpSelPipe()->SetTpFlag( pSel->GetTpFlag() );

				pBv->GetpSelectedInfos()->SetReference( CSelectedInfos::eRef1, pSel->GetRef1() );
				pBv->GetpSelectedInfos()->SetReference( CSelectedInfos::eRef2, pSel->GetRef2() );
				pBv->GetpSelectedInfos()->SetQuantity( pSel->GetQuantity() );
				pBv->GetpSelectedInfos()->SetPrice( pSel->GetPrice() );
				pBv->GetpSelectedInfos()->SetRemark( pSel->GetRemark() );
				pBv->GetpSelectedInfos()->SetRemarkIndex( pSel->GetRemarkIndex() );
				pBv->GetpSelectedInfos()->SetRowIndex( pSel->GetRowIndex() );
				
				CWaterChar *pwc = pBv->GetpSelectedInfos()->GetpWCData();
				pSel->GetWC( pwc );

				IDptrToRemove.Add( idptr );
			}

			for( int j = 0; j < IDptrToRemove.GetCount(); j++ )
			{
				pTab->Remove( IDptrToRemove[j] );
				DeleteObject( IDptrToRemove[j] );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CTADatastruct::UpgradeManBvSelection'."), __LINE__, __FILE__ );
		throw;
	}
}

void CTADatastruct::UpgradeDA50IDPTR()
{
	// Also implemented in CDS_HydroMod::CDpC::Read( INPSTREAM inpf )
	// 			DA50_???J   -->   DA50_???I
	// 			DA50_???L   -->   DA50_???K
	// 			DA50_???N   -->   DA50_???M
	// 			DA50_???P   -->   DA50_???O
	CMapStringToString TableID;
	TableID[ _T("DA50_???J" ) ] = _T( "DA50_???I");
	TableID[ _T("DA50_???L" ) ] = _T( "DA50_???K");
	TableID[ _T("DA50_???N" ) ] = _T( "DA50_???M");
	TableID[ _T("DA50_???P" ) ] = _T( "DA50_???O");
	
	CTable *pTab = static_cast<CTable *>( Get( _T("DPCONTR_TAB") ).MP );

	if( NULL == pTab )
	{
		return;
	}

	for( IDPTR IDPtrDpC = pTab->GetFirst(); NULL != IDPtrDpC.MP; IDPtrDpC = pTab->GetNext( IDPtrDpC.MP ) )
	{
		CDS_SSelDpC *pDpC = dynamic_cast<CDS_SSelDpC *>( IDPtrDpC.MP );
		CString strDpCID = pDpC->GetDpCIDPtr( ).ID;

		if( 0 == strDpCID.Find( _T("DA50_") ) )
		{
			CString strKey;
			CString strNewID;

			for( POSITION pos = TableID.GetStartPosition(); pos != NULL; )
			{
				TableID.GetNextAssoc( pos, strKey, strNewID );
				bool bMatch = WildcardMatch( (LPCTSTR) strDpCID, strKey );

				if( true == bMatch )
				{
					strDpCID.Replace( strDpCID.Right( 1 ), strNewID.Right( 1 ) );
					IDPTR newidptr = TASApp.GetpTADB()->Get( strDpCID );

					if( NULL == newidptr.MP )
					{
						ASSERT_RETURN;
					}

					pDpC->SetDpCIDPtr( newidptr );
				}
			}
		}
	}
}

void CTADatastruct::UpgradeDpCSelection()
{
	try
	{
		// Scan all DpC.
		CStringArray TableID;
		TableID.Add( _T("DPCONTR_TAB") );
		CArray<IDPTR> IDptrToRemove;

		for( int i = 0; i < TableID.GetSize(); i++ )
		{
			CTable *pTab = static_cast<CTable *>( Get( TableID[i] ).MP );

			if( NULL == pTab )
			{
				continue;
			}

			for( IDPTR idptr = pTab->GetFirst(); NULL != idptr.MP; idptr = pTab->GetNext( idptr.MP ) )
			{
				CDS_SelDpC *pSel = dynamic_cast<CDS_SelDpC *>( idptr.MP );

				if( NULL == pSel )
				{
					continue;
				}

				if( NULL == pSel->GetDpCIDPtr().MP )
				{
					IDptrToRemove.Add( idptr );
					continue;
				}

				// Create an 'CDS_SSelDpC' entry.
				IDPTR IDPtrDpC = _NULL_IDPTR;
				CreateObject( IDPtrDpC, CLASS( CDS_SSelDpC ) );
				pTab->Insert( IDPtrDpC );

				CDS_SSelDpC *pDpC = dynamic_cast<CDS_SSelDpC *>( IDPtrDpC.MP );

				// Copy info in the 'CDS_SSelDpC' class.
				pDpC->SetDpCIDPtr( pSel->GetDpCIDPtr() );
				pDpC->SetDpStab( pSel->GetDpStab() == 0 ? eDpStab::DpStabOnBranch : eDpStab::DpStabOnCV );
				pDpC->SetKv( pSel->GetKvCv() );
				pDpC->SetDpL( pSel->GetDpL() );
				pDpC->SetMvLoc( pSel->GetMvLoc() == 0 ? eMvLoc::MvLocPrimary : eMvLoc::MvLocSecondary );

				// Copy info in the 'CDS_SSel' base class.
				pDpC->SetFlowDef( CDS_SelProd::efdFlow );
				pDpC->SetQ( pSel->GetFlow() );
				pDpC->SetProductIDPtr( pSel->GetValveIDPtr() );
				pDpC->SetOpening( pSel->GetSetting() );

				// Store as CB user choice current Type, family, connection,...completely open *** ALL
				// Try to identify Pipe
				IDPTR pipeIDPtr = FoundPipe( pSel->GetPipeName(), pSel->GetPipeSize() );

				if( NULL != pipeIDPtr.MP )
				{
					pDpC->SetPipeSeriesID( pipeIDPtr.PP->GetIDPtr().ID );
					pDpC->GetpSelPipe()->SetPipeID( pipeIDPtr.ID );
				}

				pDpC->GetpSelPipe()->SetLinDp( pSel->GetLinDp() );
				pDpC->GetpSelPipe()->SetLinDpFlag( pSel->GetLinDpFlag() );
				pDpC->GetpSelPipe()->SetU( pSel->GetU() );
				pDpC->GetpSelPipe()->SetUFlag( pSel->GetUFlag() );
				pDpC->GetpSelPipe()->SetTpFlag( pSel->GetTpFlag() );

				pDpC->GetpSelectedInfos()->SetReference( CSelectedInfos::eRef1, pSel->GetRef1() );
				pDpC->GetpSelectedInfos()->SetReference( CSelectedInfos::eRef2, pSel->GetRef2() );
				pDpC->GetpSelectedInfos()->SetQuantity( pSel->GetQuantity() );
				pDpC->GetpSelectedInfos()->SetPrice( pSel->GetPrice() );
				pDpC->GetpSelectedInfos()->SetRemark( pSel->GetRemark() );
				pDpC->GetpSelectedInfos()->SetRemarkIndex( pSel->GetRemarkIndex() );
				pDpC->GetpSelectedInfos()->SetRowIndex( pSel->GetRowIndex() );
				
				CWaterChar *pwc = pDpC->GetpSelectedInfos()->GetpWCData();
				pSel->GetWC( pwc );

				IDptrToRemove.Add( idptr );
			}

			for( int j = 0; j < IDptrToRemove.GetCount(); j++ )
			{
				pTab->Remove( IDptrToRemove[j] );
				DeleteObject( IDptrToRemove[j] );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CTADatastruct::UpgradeDpCSelection'."), __LINE__, __FILE__ );
		throw;
	}
}

void CTADatastruct::UpgradeRadSetSelection()
{
	try
	{
		CStringArray TableID;
		TableID.Add( _T("RADSET_TAB") );
		CArray<IDPTR> IDptrToRemove;

		for( int i = 0; i < TableID.GetSize(); i++ )
		{
			CTable *pTab = static_cast<CTable *>( Get( TableID[i] ).MP );

			if( NULL == pTab )
			{
				continue;
			}

			for( IDPTR idptr = pTab->GetFirst(); NULL != idptr.MP; idptr = pTab->GetNext( idptr.MP ) )
			{
				CDS_SelRadSet *pOldSelRadSet = dynamic_cast<CDS_SelRadSet *>( idptr.MP );

				if( NULL == pOldSelRadSet )
				{
					continue;
				}

				IDPTR TrvIDPtr = pOldSelRadSet->GetTrvIDPtr();

				if( NULL == TrvIDPtr.MP )
				{
					continue;
				}

				CDB_TAProduct *pTAProduct = dynamic_cast<CDB_TAProduct *>( TrvIDPtr.MP );

				if( NULL == pTAProduct )
				{
					continue;
				}

				// Create an CDS_SSelRadSet entry.
				IDPTR IDPtrNewRadSet = _NULL_IDPTR;
				CreateObject( IDPtrNewRadSet, CLASS( CDS_SSelRadSet ) );
				pTab->Insert( IDPtrNewRadSet );

				CDS_SSelRadSet *pNewSelRadSet = dynamic_cast<CDS_SSelRadSet *>( IDPtrNewRadSet.MP );

				// Transfer all supply valve data.
				pNewSelRadSet->SetSupplyValveIDPtr( TrvIDPtr );
				pNewSelRadSet->SetSupplyValveFamilyID( pTAProduct->GetFamilyIDPtr().ID );
				pNewSelRadSet->SetSupplyValveTypeID( pTAProduct->GetTypeIDPtr().ID );
				pNewSelRadSet->SetSupplyValveVersionID( pTAProduct->GetVersionIDPtr().ID );
				pNewSelRadSet->SetSupplyValveConnectID( pTAProduct->GetConn2IDPtr().ID );
				pNewSelRadSet->SetSupplyValveActuatorIDPtr( _T("") );
				pNewSelRadSet->SetSupplyValveDp( pOldSelRadSet->GetTrvDp() );
				pNewSelRadSet->SetSupplyValveOpening( pOldSelRadSet->GetTrvSetting() );

				// Before there was not accessory on supply valve.
				CAccessoryList *pclAccessoryList = pNewSelRadSet->GetSupplyValveAccessoryList();
				pclAccessoryList->Clear();

				// Transfer all return valve data.
				IDPTR RvIDPtr = pOldSelRadSet->GetValveIDPtr();
				pTAProduct = NULL;

				if( NULL != RvIDPtr.MP )
				{
					pTAProduct = dynamic_cast<CDB_TAProduct *>( RvIDPtr.MP );
				}

				if( NULL != pTAProduct )
				{
					pNewSelRadSet->SetReturnValveIDPtr( RvIDPtr );
					pNewSelRadSet->SetReturnValveFamilyID( pTAProduct->GetFamilyIDPtr().ID );
					pNewSelRadSet->SetReturnValveVersionID( pTAProduct->GetVersionIDPtr().ID );
					pNewSelRadSet->SetReturnValveConnectID( pTAProduct->GetConn2IDPtr().ID );
					pNewSelRadSet->SetReturnValveOpening( pOldSelRadSet->GetSetting() );
					pNewSelRadSet->SetReturnValveDp( pOldSelRadSet->GetDp() );
				}
				else
				{
					pNewSelRadSet->SetReturnValveIDPtr( _T("") );
					pNewSelRadSet->SetReturnValveFamilyID( _T("") );
					pNewSelRadSet->SetReturnValveVersionID( _T("") );
					pNewSelRadSet->SetReturnValveConnectID( _T("") );
					pNewSelRadSet->SetReturnValveOpening( 0.0 );
					pNewSelRadSet->SetReturnValveDp( 0.0 );
				}

				pNewSelRadSet->SetReturnValveMode( pOldSelRadSet->GetRetVMode() );

				// Before there was not accessory on return valve.
				pclAccessoryList = pNewSelRadSet->GetReturnValveAccessoryList();
				pclAccessoryList->Clear();

				// Fill radiator set infos.
				RadInfo_struct rRadInfos;
				rRadInfos.dFlow = pOldSelRadSet->GetFlow();

				if( pOldSelRadSet->GetDpTot() > 0.0 )
				{
					rRadInfos.bAvailableDpChecked = true;
					rRadInfos.dAvailableDp = pOldSelRadSet->GetDpTot();
				}
				else
				{
					rRadInfos.bAvailableDpChecked = false;
					rRadInfos.dAvailableDp = 0.0;
				}

				rRadInfos.dSupplyTemperature = pOldSelRadSet->GetTs();
				rRadInfos.dReturnTemperature = pOldSelRadSet->GetTr();
				rRadInfos.dRoomTemperature = pOldSelRadSet->GetTi();
				rRadInfos.dRequiredHeatOutput = pOldSelRadSet->GetPReq();
				rRadInfos.dMinPower = 0;
				rRadInfos.dRecommendedPower = 0;
				rRadInfos.dInstalledPower = pOldSelRadSet->GetPInst();
				rRadInfos.dMinDT = 0;
				rRadInfos.dRequiredDT = 0;
				rRadInfos.dNCSupplyT = pOldSelRadSet->GetNCTs();
				rRadInfos.dNCReturnT = pOldSelRadSet->GetNCTr();
				rRadInfos.dNCRoomT = pOldSelRadSet->GetNCTi();

				// Actuator type not saved in previous version.
				pNewSelRadSet->SetActuatorType( ActuatorType::AT_ThermoStatic );

				// No flow limited control valve in previous version.
				pNewSelRadSet->SetRadiatorValveType( 0 );

				// No insert valve in previous version.
				pNewSelRadSet->SetSVInsertName( _T("") );

				// No thermostatic head combo in previous version.
				pNewSelRadSet->SetActuatorTypeID( _T("") );
				pNewSelRadSet->SetActuatorFamilyID( _T("") );
				pNewSelRadSet->SetActuatorVersionID( _T("") );

				// Variables in CDS_SSel.
				pNewSelRadSet->SetDp( pOldSelRadSet->GetDpTot() );

				// Variables in CDS_SelProd.
				pNewSelRadSet->SetQ( pOldSelRadSet->GetFlow() );
				pNewSelRadSet->SetFlowDef( CDS_SelProd::efdFlow );
				pNewSelRadSet->SetPower( 0 );
				pNewSelRadSet->SetDT( 0 );
				pNewSelRadSet->SetSelectedAsAPackage( false );
				pNewSelRadSet->SetFromDirSel( false );

				// Store as CB user choice current Type, family, connection,...completely open *** ALL
				// Try to identify Pipe
				IDPTR pipeIDPtr = FoundPipe( pOldSelRadSet->GetPipeName(), pOldSelRadSet->GetPipeSize() );

				if( NULL != pipeIDPtr.MP )
				{
					pNewSelRadSet->SetPipeSeriesID( pipeIDPtr.PP->GetIDPtr().ID );
					pNewSelRadSet->GetpSelPipe()->SetPipeID( pipeIDPtr.ID );
				}

				// Pipe informations.
				pNewSelRadSet->GetpSelPipe()->SetLinDp( pOldSelRadSet->GetLinDp() );
				pNewSelRadSet->GetpSelPipe()->SetLinDpFlag( pOldSelRadSet->GetLinDpFlag() );
				pNewSelRadSet->GetpSelPipe()->SetU( pOldSelRadSet->GetU() );
				pNewSelRadSet->GetpSelPipe()->SetUFlag( pOldSelRadSet->GetUFlag() );
				pNewSelRadSet->GetpSelPipe()->SetTpFlag( pOldSelRadSet->GetTpFlag() );

				// Selected informations.
				pNewSelRadSet->GetpSelectedInfos()->SetReference( CSelectedInfos::eRef1, pOldSelRadSet->GetRef1() );
				pNewSelRadSet->GetpSelectedInfos()->SetReference( CSelectedInfos::eRef2, pOldSelRadSet->GetRef2() );
				pNewSelRadSet->GetpSelectedInfos()->SetQuantity( pOldSelRadSet->GetQuantity() );
				pNewSelRadSet->GetpSelectedInfos()->SetPrice( pOldSelRadSet->GetPrice() );
				pNewSelRadSet->GetpSelectedInfos()->SetRemark( pOldSelRadSet->GetRemark() );
				pNewSelRadSet->GetpSelectedInfos()->SetRemarkIndex( pOldSelRadSet->GetRemarkIndex() );
				pNewSelRadSet->GetpSelectedInfos()->SetRowIndex( pOldSelRadSet->GetRowIndex() );

				// Water characteristic informations.
				CWaterChar *pwc = pNewSelRadSet->GetpSelectedInfos()->GetpWCData();
				pOldSelRadSet->GetWC( pwc );

				IDptrToRemove.Add( idptr );
			}

			for( int j = 0; j < IDptrToRemove.GetCount(); j++ )
			{
				pTab->Remove( IDptrToRemove[j] );
				DeleteObject( IDptrToRemove[j] );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CTADatastruct::UpgradeRadSetSelection'."), __LINE__, __FILE__ );
		throw;
	}
}

void CTADatastruct::UpgradeDirectSelSelection()
{
	try
	{
		CTable *pTab = static_cast<CTable *>( Get( _T("DIRSEL_TAB") ).MP );

		if( NULL == pTab )
		{
			HYSELECT_THROW( _T("Internal error: Can't retrieve the 'DIRSEL_TAB' table from the database.") );
		}

		CArray<IDPTR> IDptrToRemove;

		for( IDPTR idptr = pTab->GetFirst(); _T('\0') != *idptr.ID; idptr = pTab->GetNext( idptr.MP ) )
		{
			CDS_DirectSel *pDirectSel = dynamic_cast<CDS_DirectSel *>( idptr.MP );

			if( NULL == pDirectSel )
			{
				continue;
			}

			if( _T('\0') == *pDirectSel->GetValveIDPtr().ID )
			{
				continue;
			}

			CDB_TAProduct *pTAProduct = dynamic_cast<CDB_TAProduct *>( GetpTADB()->Get( pDirectSel->GetValveIDPtr().ID ).MP );

			if( NULL == pTAProduct )
			{
				continue;
			}

			// 'pParent' is here the table in TADB and not TADS!!
			CTable *pParentDB = pTAProduct->GetIDPtr().PP;

			if( NULL == pParentDB )
			{
				continue;
			}

			IDPTR TableIDPtr = pParentDB->GetIDPtr();

			if( _T('\0') == *TableIDPtr.ID )
			{
				continue;
			}

			// Before using 'CDS_SSelXXX' in TASelect, there was only CDS_SelManBv, CDS_SelRadSet and CDS_SelDpC.
			IDPTR IDPtr;

			if( 0 == _tcscmp( TableIDPtr.ID, _T("REGVALV_TAB") ) )
			{
				TASApp.GetpTADS()->CreateObject( IDPtr, CLASS( CDS_SSelBv ) );
			}
			else if( 0 == _tcscmp( TableIDPtr.ID, _T("DPCONTR_TAB") ) )
			{
				TASApp.GetpTADS()->CreateObject( IDPtr, CLASS( CDS_SSelDpC ) );
			}
			else if( 0 == _tcscmp( TableIDPtr.ID, _T("TRVALV_TAB") ) )
			{
				TASApp.GetpTADS()->CreateObject( IDPtr, CLASS( CDS_SSelRadSet ) );
			}
			else
			{
				HYSELECT_THROW( _T("Internal error: '%s' is not recognized as an old selection table."), TableIDPtr.ID );
			}

			CDS_SSel *pSSel = dynamic_cast<CDS_SSel *>( IDPtr.MP );

			if( NULL == pSSel )
			{
				continue;
			}

			// CDS_SelProd
			// Remark: in direct selection, there is no flow (or Power/DT).
			//         Let default values and change only needed ones.
			pSSel->SetFromDirSel( true );
			pSSel->SetTypeID( pTAProduct->GetTypeIDPtr().ID );
			pSSel->SetFamilyID( pTAProduct->GetFamilyIDPtr().ID );
			pSSel->SetMaterialID( pTAProduct->GetBodyMaterialIDPtr().ID );
			pSSel->SetConnectID( pTAProduct->GetConnectIDPtr().ID );
			pSSel->SetVersionID( pTAProduct->GetVersionIDPtr().ID );
			pSSel->SetPNID( pTAProduct->GetPNIDPtr().ID );

			pSSel->GetpSelectedInfos()->SetReference( CSelectedInfos::eRef1, pDirectSel->GetRef1() );
			pSSel->GetpSelectedInfos()->SetReference( CSelectedInfos::eRef2, pDirectSel->GetRef2() );
			pSSel->GetpSelectedInfos()->SetQuantity( pDirectSel->GetQuantity() );
			pSSel->GetpSelectedInfos()->SetPrice( pDirectSel->GetPrice() );
			pSSel->GetpSelectedInfos()->SetRemark( pDirectSel->GetRemark() );
			pSSel->GetpSelectedInfos()->SetRemarkIndex( pDirectSel->GetRemarkIndex() );
			pSSel->GetpSelectedInfos()->SetRowIndex( pDirectSel->GetRowIndex() );
			
			CWaterChar *pwc = pSSel->GetpSelectedInfos()->GetpWCData();
			pDirectSel->GetWC( pwc );

			pSSel->SetProductIDPtr( _NULL_IDPTR );

			if( 0 == _tcscmp( TableIDPtr.ID, _T("REGVALV_TAB") ) )
			{
				pSSel->SetProductIDPtr( pDirectSel->GetValveIDPtr() );

				// Newly created object must be inserted in TADS (and not TADB)!
				CTable *pParentDS = static_cast<CTable *>( TASApp.GetpTADS()->Get( _T("REGVALV_TAB") ).MP );

				if( NULL == pParentDS )
				{
					continue;
				}

				pParentDS->Insert( IDPtr );
			}
			else if( 0 == _tcscmp( TableIDPtr.ID, _T("DPCONTR_TAB") ) )
			{
				// CDS_SSel.
				pSSel->SetProductIDPtr( _NULL_IDPTR );

				// CDS_SSelDpC.
				CDS_SSelDpC *pSSelDpC = static_cast<CDS_SSelDpC *>( pSSel );

				if( NULL == pSSelDpC )
				{
					continue;
				}

				pSSelDpC->SetDpCIDPtr( pDirectSel->GetValveIDPtr() );

				// Newly created object must be inserted in TADS (and not TADB)!
				CTable *pParentDS = static_cast<CTable *>( TASApp.GetpTADS()->Get( _T("DPCONTR_TAB") ).MP );

				if( NULL == pParentDS )
				{
					continue;
				}

				pParentDS->Insert( IDPtr );
			}
			else if( 0 == _tcscmp( TableIDPtr.ID, _T("TRVALV_TAB") ) )
			{
				pSSel->SetProductIDPtr( pDirectSel->GetValveIDPtr() );

				// Newly created object must be inserted in TADS (and not TADB)!
				CTable *pParentDS = static_cast<CTable *>( TASApp.GetpTADS()->Get( _T("TRVALV_TAB") ).MP );

				if( NULL == pParentDS )
				{
					continue;
				}

				pParentDS->Insert( IDPtr );
			}

			IDptrToRemove.Add( idptr );
		}

		for( int i = 0; i < IDptrToRemove.GetCount(); i++ )
		{
			pTab->Remove( IDptrToRemove[i] );
			DeleteObject( IDptrToRemove[i] );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CTADatastruct::UpgradeDirectSelSelection'."), __LINE__, __FILE__ );
		throw;
	}
}

void CTADatastruct::CleanOtherUnNeededSelectedProduct()
{

	// Code modification 12/2010
	// Selected product created with HM are not needed anymore.
	// For old tsp files they should be removed.
	// This function scan all selected product Tab to remove orphan selected product
	CStringArray TableID;
	TableID.Add( _T("REGVALV_TAB") );
	TableID.Add( _T("DPCONTR_TAB") );
	TableID.Add( _T("RADSET_TAB") );
	TableID.Add( _T("SELHUB_TAB") );
	TableID.Add( _T("PARTDEF_TAB") );
	TableID.Add( _T("CTRLVALVE_TAB") );

	for( int i = 0; i < TableID.GetSize(); i++ )
	{
		CTable *pTab = static_cast<CTable *>( Get( TableID[i] ).MP );

		if( NULL == pTab )
		{
			continue;
		}

		for( IDPTR idptr = pTab->GetFirst(); NULL != idptr.MP; )
		{
			bool bShouldbeRemoved = false;

			// Normally, we don't need anymore the code under 'if' condition but well under the 'else'. Because there is
			// no more CDS_SelThing (it is 'CDS_SelManBv', 'CDS_SelRadSet' and 'CDS_SelDpc' classes that are changed when reading a
			// old HySelect Project file).
			CDS_SelThing *pSel = dynamic_cast<CDS_SelThing *>( idptr.MP );

			if( NULL != pSel )
			{
				if( _T('\0') != *pSel->GetModuleID() )
				{
					bShouldbeRemoved = true;    // In all case remove HM associated product.
				}
				else
				{
					if( _NULL_IDPTR != pSel->GetValveIDPtr() )			// Verify empty selected product.
					{
						bShouldbeRemoved = false;
					}
					else
					{
						if( true == pSel->IsClass( _T("CDS_SelDpC") ) )
						{
							bShouldbeRemoved = ( !*( static_cast<CDS_SelDpC *>( pSel ) )->GetDpCID() ) ? true : false;
						}
						else if( true == pSel->IsClass( ( _T("CDS_SelRadSet") ) ) )
						{
							bShouldbeRemoved = ( !*( static_cast<CDS_SelRadSet *>( pSel ) )->GetTrvID() ) ? true : false;
						}
					}
				}
			}
			else
			{
				CDS_SelProd *pSelProd = dynamic_cast<CDS_SelProd *>( idptr.MP );

				if( NULL != pSelProd )
				{
					bShouldbeRemoved = ( _T('\0') != *pSelProd->GetHMID() ) ? true : false;
				}
			}

			IDPTR idptrsave = idptr;
			idptr = pTab->GetNext( idptr.MP );

			if( true == bShouldbeRemoved )
			{
				idptrsave.PP->Remove( idptrsave );
				DeleteObject( idptrsave );
			}
		}
	}
}

void CTADatastruct::CleanUnNeededSelectedProduct( CTable *pTab )
{
	//	Code modification 12/2010
	// Selected product created with HM are not needed anymore.
	// For old tsp files they should be removed.
	// This function will scan recursively all HM to remove deprecated SelThingID
	for( IDPTR idptr = pTab->GetFirst(); NULL != idptr.MP; idptr = pTab->GetNext( idptr.MP ) )
	{
		CDS_HydroMod *pHM = dynamic_cast<CDS_HydroMod *>( idptr.MP );

		if( NULL != pHM )
		{
			// Recursive scan
			if( true == pHM->IsaModule() )
			{
				CleanUnNeededSelectedProduct( pHM );
			}

			// Pre-setting correction
			if( true == pHM->IsHMCalcMode() )
			{
				if( NULL != pHM->GetpBv() )
				{
					pHM->SetPresetting( pHM->GetpBv()->GetSetting() );
					pHM->SetCBIValveID( pHM->GetpBv()->GetIDPtr().ID );
				}

				if( NULL != pHM->GetpCV() && true == pHM->GetpCV()->IsPresettable() )
				{
					pHM->SetPresetting( pHM->GetpCV()->GetSetting() );
					pHM->SetCBIValveID( pHM->GetpCV()->GetCvIDPtr().ID );
				}
			}

			CString SelID = pHM->GetDepecratedSelThingID();

			if( true == SelID.IsEmpty() )
			{
				continue;
			}

			IDPTR SelIDPtr = Get( (LPCTSTR)SelID );
			CDS_SelThing *pSelObj = dynamic_cast<CDS_SelThing *>( SelIDPtr.MP );

			if( NULL != pSelObj )
			{
				// Before removing object update CDS_Hydromod::m_CBIValveID; needed for CBI compatibility
				pHM->SetCBIValveID( pSelObj->GetValveIDPtr().ID );
				CDS_HydroMod::CMeasData *pMD = pHM->GetpMeasDataForCBI();

				if( NULL != pMD )
				{
					pMD->SetTAPID( ( wchar_t * )pHM->GetCBIValveID() );
				}

				SelIDPtr.PP->Remove( SelIDPtr );
				DeleteObject( SelIDPtr );
			}
		}
	}
}
#endif

void CTADatastruct::Write( OUTSTREAM outf )
{
	// Version nÂ°.
	short Version = _ttoi( CTADATASTRUCT_FORMAT_VERSION );
	WriteFileIdentificator( outf, Version );
	WriteHeader( outf );
	WriteObjects( outf );
}

void CTADatastruct::Init()
{
	HYSELECT_TRY
	{
		CDataBase::Init();

#ifndef TACBX
		SetVersion( CTADATASTRUCT_FORMAT_VERSION );
	
		// Initialize the data structure
		// Create the default main tables and their skeleton
		IDPTR TabIDptr, ObjIDptr;

		//====================================
		// Parameter table: PARAM_TABLE
		//====================================
		CreateObject( TabIDptr, CLASS( CTable ), _T("PARAM_TABLE") );
		( static_cast<CTable *>( TabIDptr.MP ) )->SetName( _T("Parameter Table") );
		Access().Insert( TabIDptr );

		// Create basic CData and CTable for PARAM_TABLE
		//===============================================

		// Technical Parameters
		CreateObject( ObjIDptr, CLASS( CDS_TechnicalParameter ), _T("PARAM_TECH") );
		( static_cast<CTable *>( TabIDptr.MP ) )->Insert( ObjIDptr );

		// Water characteristics
		CreateObject( ObjIDptr, CLASS( CDS_WaterCharacteristic ), _T("PARAM_WC") );
		( static_cast<CTable *>( TabIDptr.MP ) )->Insert( ObjIDptr );

		// Individual selection parameters.
		CreateObject( ObjIDptr, CLASS( CDS_IndSelParameter ), _T("PARAM_INDSEL") );
		( static_cast<CTable *>( TabIDptr.MP ) )->Insert( ObjIDptr );

		// Batch selection parameters.
		CreateObject( ObjIDptr, CLASS( CDS_BatchSelParameter ), _T("PARAM_BATCHSEL") );
		( static_cast<CTable *>( TabIDptr.MP ) )->Insert( ObjIDptr );

		// Wizard selection parameters.
		CreateObject( ObjIDptr, CLASS( CDS_WizardSelParameter ), _T("PARAM_WIZARDSEL") );
		( static_cast<CTable *>( TabIDptr.MP ) )->Insert( ObjIDptr );
		
		// Page Setup Parameters.
		CreateObject( ObjIDptr, CLASS( CDB_PageSetup ), _T("PARAM_PAGESETUP") );
		( static_cast<CTable *>( TabIDptr.MP ) )->Insert( ObjIDptr );

		// Project References.
		CreateObject( ObjIDptr, CLASS( CDS_ProjectRef ), _T("PROJECT_REF") );
		( static_cast<CTable *>( TabIDptr.MP ) )->Insert( ObjIDptr );

		CString str = TASApp.LoadLocalizedString( IDS_DEFAULT_PLANT );
		( static_cast<CDS_ProjectRef *>( ObjIDptr.MP ) )->SetString( CDS_ProjectRef::Name, (LPCTSTR)str );

		// User References.
		CreateObject( ObjIDptr, CLASS( CDS_UserRef ), _T("USER_REF") );
		( static_cast<CTable *>( TabIDptr.MP ) )->Insert( ObjIDptr );

		//====================================
		// Project table: PROJ_TABLE
		//====================================
		CreateTSPProjTable();

		ReInitTechAndSSelParam();
#endif
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CTADatastruct::Init'.") )
}

#ifndef TACBX
//////////////////////////////////////////////////////////////////////
// Create TSP Project table: PROJ_TABLE, PARTDEF_TAB, SSEL_TABLE, etc.
void CTADatastruct::CreateTSPProjTable()
{
	try
	{
		IDPTR PrjTabIDPtr = _NULL_IDPTR;
		IDPTR SSelTabIDPtr = _NULL_IDPTR;
		IDPTR ClipBoardTabIDPtr = _NULL_IDPTR;
		IDPTR ObjIDptr = _NULL_IDPTR;
		PrjTabIDPtr = Get( L"PROJ_TABLE" );
		SSelTabIDPtr = Get( L"SSEL_TABLE" );

		CTable *pclClipboardTable = GetpClipboardTable();
		ClipBoardTabIDPtr = ( NULL != pclClipboardTable ) ? pclClipboardTable->GetIDPtr() : _NULL_IDPTR;

		if( NULL == PrjTabIDPtr.MP )
		{
			CreateObject( PrjTabIDPtr, CLASS( CTable ), L"PROJ_TABLE" );
			( static_cast<CTable *>( PrjTabIDPtr.MP ) )->SetName( L"Project Table" );
			Access().Insert( PrjTabIDPtr );
		}

		ObjIDptr = CreateObjectInParentTable( PrjTabIDPtr, L"PERSIST_DATA", CLASS( CDS_PersistData ) );
		ObjIDptr = CreateObjectInParentTable( PrjTabIDPtr, L"PROJ_WC", CLASS( CDS_WaterCharacteristic ) );

		// Create CDS_ProjectParams in the Project Table that contains all general parameters.
		//ID will be initialized in CRightViewGenParam::ShowHMCalcGenParam.
		if( NULL == Get( L"GENERAL_PARAMS" ).MP )
		{
			CreateObject( ObjIDptr, CLASS( CDS_ProjectParams ), L"GENERAL_PARAMS" );
			( static_cast<CTable *>( PrjTabIDPtr.MP ) )->Insert( ObjIDptr );
		}

		ObjIDptr = CreateObjectInParentTable( PrjTabIDPtr, L"TMPSAVEDATA_TAB", CLASS( CTable ), L"Temporary saved data Table" );
		ObjIDptr = CreateObjectInParentTable( PrjTabIDPtr, L"PIPING_TAB", CLASS( CTableHM ), L"Piping Table" );
		ObjIDptr = CreateObjectInParentTable( PrjTabIDPtr, L"TMPHUB_TAB", CLASS( CTableHM ), L"Temporary Hub Table" );
		ObjIDptr = CreateObjectInParentTable( PrjTabIDPtr, L"SELHUB_TAB", CLASS( CTableHM ), L"Selected Hub Table" );
		ObjIDptr = CreateObjectInParentTable( PrjTabIDPtr, L"HUBCVTEMP_TAB", CLASS( CTable ), L"Temporary HUB CV Table" );
		ObjIDptr = CreateObjectInParentTable( PrjTabIDPtr, L"LOGDATA_TAB", CLASS( CDS_LogTable ), L"Logged Data Table" );

		// Temporary logdataTABLE (inserted into the LOGDATA_TAB).
		// Used to store logged data before user validation.
		ObjIDptr = CreateObjectInParentTable( ObjIDptr, L"TMPLOGDATA_TAB", CLASS( CDS_LogTable ), L"Temporary Logged Data Table" );

		//====================================
		// Water characteristic table that contains all Water characteristic used during measurement (Piping table, Quick measurement table)
		//====================================
		ObjIDptr = CreateObjectInParentTable( PrjTabIDPtr, L"WC_TAB", CLASS( CTable ), L"Water char table QM" );
		ObjIDptr = CreateObjectInParentTable( PrjTabIDPtr, L"QUICKMEAS_TAB", CLASS( CDS_QMTable ), L"Quick Measurement Table" );

		//====================================
		// Single selection table: SSEL_TABLE
		//====================================
		if( NULL == Get( L"SSEL_TABLE" ).MP )
		{
			CreateObject( SSelTabIDPtr, CLASS( CTable ), L"SSEL_TABLE" );
			( static_cast<CTable *>( SSelTabIDPtr.MP ) )->SetName( L"Single selection table" );
			Access().Insert( SSelTabIDPtr );
		}

		ObjIDptr = CreateObjectInParentTable( SSelTabIDPtr, L"REGVALV_TAB", CLASS( CTable ), L"Balancing valve table" );
		ObjIDptr = CreateObjectInParentTable( SSelTabIDPtr, L"DPCONTR_TAB", CLASS( CTable ), L"DpC Table" );
		ObjIDptr = CreateObjectInParentTable( SSelTabIDPtr, L"DPCBCVALVE_TAB", CLASS( CTable ), L"DpC and B&C valve table" );
		ObjIDptr = CreateObjectInParentTable( SSelTabIDPtr, L"CTRLVALVE_TAB", CLASS( CTable ), L"Control valve table" );
		ObjIDptr = CreateObjectInParentTable( SSelTabIDPtr, L"SHUTOFF_TAB", CLASS( CTable ), L"Shut-off table" );

		// Used to store "partially defined" objects (CDS_DirectSel class) created with the CBI  and therefore unreferenced in TADB.
		ObjIDptr = CreateObjectInParentTable( SSelTabIDPtr, L"PARTDEF_TAB", CLASS( CTable ), L"Partially defined object table" );
		ObjIDptr = CreateObjectInParentTable( SSelTabIDPtr, L"RADSET_TAB", CLASS( CTable ), L"Radiator set table" );
		ObjIDptr = CreateObjectInParentTable( SSelTabIDPtr, L"AIRVENTSEP_TAB", CLASS( CTable ), L"Air vent & separator table" );
		ObjIDptr = CreateObjectInParentTable( SSelTabIDPtr, L"PRESSMAINT_TAB", CLASS( CTable ), L"Pressure maintenance product table" );
		ObjIDptr = CreateObjectInParentTable( SSelTabIDPtr, L"SAFETYVALVE_TAB", CLASS( CTable ), L"Safety valve table" );
		ObjIDptr = CreateObjectInParentTable( SSelTabIDPtr, L"6WAYCTRLVALV_TAB", CLASS( CTable ), L"6-way valve table" );
		ObjIDptr = CreateObjectInParentTable( SSelTabIDPtr, L"TAPWATERCTRL_TAB", CLASS( CTable ), L"Tap water control table" );
		ObjIDptr = CreateObjectInParentTable( SSelTabIDPtr, L"SMARTCONTROLVALVE_TAB", CLASS( CTable ), L"Smart control valve table" );
		ObjIDptr = CreateObjectInParentTable( SSelTabIDPtr, L"SMARTDPC_TAB", CLASS( CTable ), L"Smart differential pressure controller table" );
		ObjIDptr = CreateObjectInParentTable( SSelTabIDPtr, L"FLOORHCTRL_TAB", CLASS( CTable ), L"Floor heating control table" );

		// Used to help the 6-way valve selection. The 'CDS_SSel6WayValve' objects are saved in the '6WAYCTRLVALV_TAB' defined just above.
		// But, in this class we create also the needed 'CDS_SSelPIBCv' and 'CDS_SSelBv' objects. We can't save these objects in their
		// respective table ('REGVALV_TAB' and 'CTRLVALVE_TAB'). Otherwise they will be considered as a individual selection of 
		// regulating valve or pressure independent balancing & control valve alone. Also we cannot save them in the '6WAYCTRLVALV_TAB'.
		// Because when running this table to show all 6-way valve selections, we will need to check everywhere in the code that it is
		// well a 'CDS_SSel6WayValve' and not the ''CDS_SSelPIBCv' and 'CDS_SSelBv' ones.
		// This is why we need this table to save all the 'CDS_SSelPIBCv' and 'CDS_SSelBv'.
		ObjIDptr = CreateObjectInParentTable( SSelTabIDPtr, L"6WAYCTRLVALVHELPER_TAB", CLASS( CTable ), L"6-way valve table helper" );
		

		//====================================
		// Clipboard table: CLIPBOARD_TABLE
		//====================================
		if( NULL == GetpClipboardTable() )
		{
			CreateObject( ClipBoardTabIDPtr, CLASS( CTable ), L"CLIPBOARD_TABLE" );
			( static_cast<CTable *>( ClipBoardTabIDPtr.MP ) )->SetName( L"Clipboard table" );
			Access().Insert( ClipBoardTabIDPtr );	
		}

		//=================================================
		// Batch selection parameter table: PARAM_BATCHSEL
		//=================================================
		if( NULL == GetpBatchSelParameter() )
		{
			IDPTR ParamTableIDPtr = Get( L"PARAM_TABLE" );

			if( _NULL_IDPTR == ParamTableIDPtr )
			{
				HYSELECT_THROW( _T("Internal error: Can't retrieve the 'PARAM_TABLE' table from the database.") );
			}

			CreateObject( ObjIDptr, CLASS( CDS_BatchSelParameter ), L"PARAM_BATCHSEL" );
			( static_cast<CTable *>( ParamTableIDPtr.MP ) )->Insert( ObjIDptr );
		}

		//=================================================
		// Wizard selection parameter table: PARAM_WIZARDSEL
		//=================================================
		if( NULL == GetpWizardSelParameter() )
		{
			IDPTR ParamTableIDPtr = Get( L"PARAM_TABLE" );
			
			if( _NULL_IDPTR == ParamTableIDPtr )
			{
				HYSELECT_THROW( _T("Internal error: Can't retrieve the 'PARAM_TABLE' table from the database.") );
			}

			CreateObject( ObjIDptr, CLASS( CDS_WizardSelParameter ), L"PARAM_WIZARDSEL" );
			( static_cast<CTable *>( ParamTableIDPtr.MP ) )->Insert( ObjIDptr );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CTADatastruct::CreateTSPProjTable'."), __LINE__, __FILE__ );
		throw;
	}
}

///////////////////////////////////////////////////////////////////////////////////////////
// Recursive function that scan all TADS to verify existence of ID
void CTADatastruct::CheckTables( CTable *pTab )
{
	if( NULL == pTab )
	{
		pTab = &this->Access();
	}

	// Extend() is called into GetFirst/GetNext.
	for( IDPTR idptr = pTab->GetFirst(); _T('\0') != *idptr.ID; idptr = pTab->GetNext( idptr.MP ) )
	{
		if( true == idptr.MP->IsaTable() )
		{
			CheckTables( static_cast<CTable *>( idptr.MP ) );
		}
	}
}

//////////////////////////////////////////////////////
// Initialize the content of Tech and SSel parameters
void CTADatastruct::ReInitTechAndSSelParam()
{
	// Recover last selected technical parameters from the registry (useful when starting a document from scratch).
	double dValue;
	CDS_TechnicalParameter *pTech = GetpTechParams();
	CDS_TechnicalParameter *pTADBTech = static_cast<CDS_TechnicalParameter *>( GetpTADB()->Get( _T("PARAM_TECH") ).MP );

	// Initialize TADS with TADB Tech param content.
	pTADBTech->Copy( pTech );

	// Apply user modifications.
	// !!! Non-interfaced parameters do not need to be read from registry,
	// !!! they are already loaded from TADB (see previous instruction line)
	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "ValvMinDp") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetValvMinDp( dValue );
		// HYS-2024: Set valvMin2Dp according to ValveMinDp because it should be greather when ValvMinDp is changed in Tech. Param.
		pTech->SetValvMin2Dp( dValue + 3000 );
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "ValvMaxDp") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetValvMaxDp( dValue );
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "FoMinDp") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetFoMinDp( dValue );
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "FoMaxDp") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetFoMaxDp( dValue );
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "VtriMinDp") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetVtriMinDp( dValue );
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "VtriMaxDp") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetVtriMaxDp( dValue );
	}

	pTech->SetSizeShiftAbove( ::AfxGetApp()->GetProfileInt( _T("DialogTechParam" ), _T( "SizeShiftAbove"), 0 ) );

	pTech->SetSizeShiftBelow( ::AfxGetApp()->GetProfileInt( _T("DialogTechParam" ), _T( "SizeShift"), -2 ) );

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "PipeMaxDp") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetPipeMaxDp( dValue );
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "PipeMaxVel") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetPipeMaxVel( dValue );
	}

	// HYS-1878: 3- Read pipe min velocity. Because the value can now be changed by user.
	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "PipeMinVel") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetPipeMinVel( dValue );
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "PipeTargDp") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetPipeTargDp( dValue );
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "PipeTargVel") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetPipeTargVel( dValue );
	}

	pTech->SetPipeVtargUsed( ::AfxGetApp()->GetProfileInt( _T("DialogTechParam" ), _T( "PipeVtargUsed"), 0 ) );

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "TrvDefDpTot") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetTrvDefDpTot( dValue );
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "TrvDefRoomT") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetTrvDefRoomT( dValue );
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "TrvDefSupplyT") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetTrvDefSupplyT( dValue );
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "CvMinAuthor") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetCVMinAuthor( dValue );
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "CvMinAuthCstFlow") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetCVMinAuthCstFlow( dValue );
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "CvMinDpProp") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetCVMinDpProp( dValue );
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "CvMaxDpProp") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetCVMaxDpProp( dValue );
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "CvMinDpOnOff") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetCVMinDpOnoff( dValue );
	}

	pTech->SetCVDefKvReynard( ::AfxGetApp()->GetProfileInt( _T("DialogTechParam" ), _T( "CvDefKvReynard"), 1 ) );

	pTech->SetCVUseDpCBand( ::AfxGetApp()->GetProfileInt( _T("DialogTechParam" ), _T( "CvUseDpCPBand"), 0 ) );


	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "PICvMinDp") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetPICvMinDp( dValue );
	}

	pTech->SetPICvHide( ::AfxGetApp()->GetProfileInt( _T("DialogTechParam" ), _T( "PICvHide"), 0 ) );

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DpCMinDp") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetDpCMinDp( dValue );
	}

	pTech->SetDpCHide( ::AfxGetApp()->GetProfileInt( _T("DialogTechParam" ), _T( "DpCHide"), 0 ) );
	pTech->SetDpCfDpCMvWithSameSizeOnly( ::AfxGetApp()->GetProfileInt( _T("DialogTechParam" ), _T( "MvWithSameSize"), 0 ) );

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DpCBCVDpcmin") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetDpCBCVDpcmin( dValue );
	}

	TechParam_struct *pTechParamStruct = pTech->GetTechParamStructure();
	int iValue = ::AfxGetApp()->GetProfileInt( _T("DialogTechParam" ), _T( "ProjectType"), ProjectType::InvalidProjectType );

	if( ProjectType::Heating == iValue || ProjectType::Cooling == iValue )
	{
		pTechParamStruct->m_eProjectType = ( ProjectType )iValue;
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultPrjCoolingTps") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTechParamStruct->m_dDefaultPrjCoolingTps = dValue;
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultPrjHeatingTps") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTechParamStruct->m_dDefaultPrjHeatingTps = dValue;
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultPrjCoolingDT") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTechParamStruct->m_dDefaultPrjCoolingDT = dValue;
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultPrjHeatingDT") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTechParamStruct->m_dDefaultPrjHeatingDT = dValue;
	}

	// HYS-1230: All the water characteristic info for product selection are now read at the end.

	pTechParamStruct->m_strDefaultPrjCoolingAdditID = ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultPrjCoolingAdditID"),
			pTechParamStruct->m_strDefaultPrjCoolingAdditID.c_str() );

	pTechParamStruct->m_strDefaultPrjHeatingAdditID = ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultPrjHeatingAdditID"),
			pTechParamStruct->m_strDefaultPrjHeatingAdditID.c_str() );

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultPrjCoolingPcWeight") ), &dValue ) == RD_OK )
	{
		pTechParamStruct->m_dDefaultPrjCoolingPcWeight = dValue;
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultPrjHeatingPcWeight") ), &dValue ) == RD_OK )
	{
		pTechParamStruct->m_dDefaultPrjHeatingPcWeight = dValue;
	}

	// Overwrite project temperature, DT and additive with values coming from registry.
	CDS_WaterCharacteristic *pWC = GetpWCForProject();
	IDPTR IDPtrAdditive = TASApp.GetpTADB()->Get( pTech->GetDefaultPrjAdditID() );

	if( _NULL_IDPTR != IDPtrAdditive )
	{
		pWC->SetAdditFamID( IDPtrAdditive.PP->GetIDPtr().ID );
		pWC->SetAdditID( IDPtrAdditive.ID );
		pWC->GetpWCData()->UpdateFluidData( pTech->GetDefaultPrjTps(), pTech->GetDefaultPrjPcWeight() );
	}
	else
	{
		pWC->SetTemp( pTech->GetDefaultPrjTps() );
		pWC->UpdateFluidData( pTech->GetDefaultPrjTps() );
	}

	// HYS-1230: All the water characteristic info for product selection are now read at the end.

	// Variables for pressure maintenance.
	iValue = ::AfxGetApp()->GetProfileInt( _T("DialogTechParam" ), _T( "UseVesselPressureVolumeLimit"), 0 );
	pTech->SetUseVesselPressureVolumeLimit( ( 0 == iValue ) ? false : true );

	if( RD_OK == ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "PressureVolumeLimit") ), &dValue ) && dValue != 0.0 )
	{
		pTech->SetPressureVolumeLimit( dValue );
	}
	
	// HYS-1126: Retrieve the value of checkbox 'SimplifyPst'
	iValue = ::AfxGetApp()->GetProfileInt( _T("DialogTechParam" ), _T( "UseSimplyPst"), 0 );
	pTech->SetUseSimplyPst( ( 0 == iValue ) ? false : true );

	iValue = ::AfxGetApp()->GetProfileInt( _T("DialogTechParam" ), _T( "MaxNumberOfVesselsInParallel"), 4 );
	pTech->SetMaxNumberOfAdditionalVesselsInParallel( iValue );

	iValue = ::AfxGetApp()->GetProfileInt( _T("DialogTechParam" ), _T( "MaxNumberOfVentoInParallel"), 2 );
	pTech->SetMaxNumberOfVentoInParallel( iValue );

	if( RD_OK == ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "VesselSelectionRangePercentage") ), &dValue ) && dValue >= 0.0 )
	{
		pTechParamStruct->m_dVesselSelectionRangePercentage = dValue;
	}

	// HYS-1763: Read from registry
	iValue = ::AfxGetApp()->GetProfileInt( _T( "DialogTechParam" ), _T( "DefaultSmartCVLocation" ), 1 );
	pTech->SetDefaultSmartCVLoc( iValue );

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "SmartValveDpMaxForBestSuggestion") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTechParamStruct->m_dSmartValveDpMaxForBestSuggestion = dValue;
	}

	// HYS-1930: New hydronic circuit: auto-adapting variable flow decoupling circuit: add default secondary pump Hmin.
	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultSecondaryPumpHMin") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTechParamStruct->m_dDefaultSecondaryPumpHMin = dValue;
	}
	

	// Pipe series.
	pTech->SetDefaultPipeSerieID( (LPCTSTR)::AfxGetApp()->GetProfileString( _T("Pipe Series" ), _T( "Default Pipe Series"),
			pTADBTech->GetDefaultPipeSerieID() ) );

	// Check if default pipe series is not hidden or deleted.
	bool bResetGenericPipe = false;
	CString strDefaultPipeSeries = pTech->GetDefaultPipeSerieID();

	if( true == strDefaultPipeSeries.IsEmpty() || false == pTech->GetDefaultPipeSerieIDPtr().MP->IsSelectable() )
	{
		// The generic pipe series is intentionnaly set to the first position.
		CData *pData = NULL;
		CRank List;
		int iCount = TASApp.GetpTADB()->GetPipeSerieList( &List, CTADatabase::ForHMCalc );

		if( iCount > 0 && List.GetFirstT<CData *>( strDefaultPipeSeries, pData ) )
		{
			if( NULL == pData )
			{
				ASSERT( 0 );
			}
			else
			{
				pTech->SetDefaultPipeSerieID( pData->GetIDPtr().ID );
			}
		}

		List.PurgeAll();
	}

	// Establish a list of pipe series available into the register.
#define MAX_KEY_LENGTH 255
#define MAX_VALUE_NAME 16383
	CList <CString> PipeSerielist;
	HKEY hKey;
	CString path;
	path.Format( _T("Software\\%s\\%s\\Pipe Series"), TASApp.m_pszRegistryKey, ::AfxGetAppName() );

	if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER, (LPCTSTR)path, 0, KEY_READ, &hKey ) )
	{
		TCHAR    achClass[MAX_PATH] = TEXT( "" );	// Buffer for class name.
		DWORD    cchClassName = MAX_PATH;			// Size of class string.
		DWORD    cSubKeys = 0;						// Number of subkeys.
		DWORD    cbMaxSubKey;						// Longest subkey size.
		DWORD    cchMaxClass;						// Longest class string.
		DWORD    cValues;							// Number of values for key.
		DWORD    cchMaxValue;						// Longest value name.
		DWORD    cbMaxValueData;					// Longest value data.
		DWORD    cbSecurityDescriptor;				// Size of security descriptor.
		FILETIME ftLastWriteTime;					// Last write time.

		DWORD retCode;

		TCHAR  achValue[MAX_VALUE_NAME];
		DWORD cchValue = MAX_VALUE_NAME;

		// Get the class name and the value count.
		retCode = RegQueryInfoKey(
					  hKey,                    // Key handle.
					  achClass,                // Buffer for class name.
					  &cchClassName,           // Size of class string.
					  NULL,                    // Reserved.
					  &cSubKeys,               // Number of subkeys.
					  &cbMaxSubKey,            // Longest subkey size.
					  &cchMaxClass,            // Longest class string.
					  &cValues,                // Number of values for this key.
					  &cchMaxValue,            // Longest value name.
					  &cbMaxValueData,         // Longest value data.
					  &cbSecurityDescriptor,   // Security descriptor.
					  &ftLastWriteTime );      // Last write time.

		if( 0 != cValues )
		{
			for( DWORD i = 0, retCode = ERROR_SUCCESS; i < cValues; i++ )
			{
				cchValue = MAX_VALUE_NAME;
				achValue[0] = '\0';
				retCode = RegEnumValue( hKey, i, achValue, &cchValue, NULL, NULL, NULL, NULL );

				if( ERROR_SUCCESS == retCode )
				{
					CString ValueFound = achValue;

					if( _T("Default Pipe Series") != ValueFound )
					{
						PipeSerielist.AddHead( ValueFound );
					}
				}
			}
		}
	}

	// Refresh pipe series hidden status.
	CTable *pTab = TASApp.GetpPipeDB()->GetPipeTab();
	ASSERT( NULL != pTab );
	CTable *pPipeSeriesSteelGen = static_cast<CTable *>( pTab->Get( L"STEEL_GEN" ).MP );

	for( IDPTR IDPtr = pTab->GetFirst( CLASS( CTable ) ); '\0' != *IDPtr.ID; IDPtr = pTab->GetNext() )
	{
		CTable *pPipeSeriesTab = static_cast<CTable *>( IDPtr.MP );

		if( true == pPipeSeriesTab->IsDeleted() )
		{
			continue;
		}

		if( false == pPipeSeriesTab->IsAvailable() )
		{
			continue;
		}

		// Into the registry we store the availability of pipe series that means NOT hidden flag.
		bool fHidden = ::AfxGetApp()->GetProfileInt( _T("Pipe Series"), IDPtr.ID, !IDPtr.MP->IsHidden() ) ? false : true;

		// STEEL_GEN never hidden.
		fHidden = ( pPipeSeriesSteelGen == pPipeSeriesTab ) ? false : fHidden;
		pPipeSeriesTab->SetHidden( fHidden );

		for( IDPTR IDPtrPipe = pPipeSeriesTab->GetFirst(); '\0' != *IDPtrPipe.ID; IDPtrPipe = pPipeSeriesTab->GetNext() )
		{
			IDPtrPipe.MP->SetHidden( fHidden );
		}

		POSITION Pos = PipeSerielist.Find( IDPtr.ID );

		if( Pos )
		{
			PipeSerielist.RemoveAt( Pos );
		}
	}

	// Clean registry if needed, remove non existing pipe series.
	if( PipeSerielist.GetCount() > 0 )
	{
		if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER, (LPCTSTR)path, 0, KEY_SET_VALUE, &hKey ) )
		{
			while( 0 != PipeSerielist.GetCount() )
			{
				CString str = PipeSerielist.GetHead();
				PipeSerielist.RemoveHead();
				RegDeleteValue( hKey, (LPCTSTR)str );
			}
		}
	}

	// Recover last selected individual selection parameters from the registry.
	// (useful when starting a document from scratch).
	CDS_IndSelParameter *pclIndSelParameters = GetpIndSelParameter();

	if( NULL != pclIndSelParameters )
	{
		pclIndSelParameters->ReadFromRegistry();
	}

	CDS_BatchSelParameter *pclBatchSelParameters = GetpBatchSelParameter();

	if( NULL != pclBatchSelParameters )
	{
		pclBatchSelParameters->ReadFromRegistry();
	}

	CDS_WizardSelParameter *pclWizardSelParameters = GetpWizardSelParameter();

	if( NULL != pclWizardSelParameters )
	{
		pclWizardSelParameters->ReadFromRegistry();
	}

	CDS_ProjectParams *pclProjectParameters = GetpProjectParams();
	pclProjectParameters->GetpHmCalcParams()->ResetPrjParams( false, GetVersion() );

	// HYS-1230: Complete review of the way we manage the water characteristic for product selection.
	iValue = ::AfxGetApp()->GetProfileInt( _T("DialogTechParam" ), _T( "ApplicationType"), ProjectType::InvalidProjectType );
	
	// ChangeOver application type is excluded 
	if( ProjectType::Heating == iValue || ProjectType::Cooling == iValue || ProjectType::Solar == iValue )
	{
		pTechParamStruct->m_eProductSelectionApplicationType = (ProjectType)iValue;
	}
	else if( ChangeOver == iValue )
	{
		pTechParamStruct->m_eProductSelectionApplicationType = Heating;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// For product selection in heating.
	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISHeatingTps") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetDefaultISHeatingTps( dValue );
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISHeatingDT") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetDefaultISHeatingDT( dValue );
	}

	_string strString = ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISHeatingAdditID"), pTech->GetDefaultISHeatingAdditID() );
	pTech->SetDefaultISHeatingAdditID( strString );

	if( RD_OK == ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISHeatingPcWeight") ), &dValue ) )
	{
		pTech->SetDefaultISHeatingPcWeight( dValue );
	}
	
	// HYS-1263 : Save the Family addit.
	IDPTR AdditID = TASApp.GetpTADB()->Get( pTech->GetDefaultISHeatingAdditID() );
	
	if( NULL != AdditID.PP )
	{
		pTech->GetDefaultISHeatingWC()->SetAdditFamID( AdditID.PP->GetIDPtr().ID );
	}

	if( 0 == wcscmp( strString.c_str(), _T("OTHER_FLUID") ) )
	{
		// HYS-1230: Read density only if user was on 'Other fluid'.
		if( RD_OK == ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISHeatingDensity") ), &dValue ) && dValue != 0.0 )
		{
			pTech->GetDefaultISHeatingWC()->SetDens( dValue );
		}

		// HYS-1230: Read kinematic viscosity only if user was on 'Other fluid'.
		if( RD_OK == ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISHeatingKinematicViscosity") ), &dValue ) && dValue != 0.0 )
		{
			pTech->GetDefaultISHeatingWC()->SetKinVisc( dValue );
		}

		// HYS-1230: Read specific heat only if user was on 'Other fluid' and choose to put a value.
		iValue = ::AfxGetApp()->GetProfileInt( _T("DialogTechParam" ), _T( "DefaultISHeatingCheckSpecificHeat"), 0 );
		pTech->GetDefaultISHeatingWC()->SetCheckSpecifHeat( ( 0 == iValue ) ? false : true );

		if( 1 == iValue )
		{
			if( RD_OK == ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISHeatingSpecificHeat") ), &dValue ) && dValue != 0.0 )
			{
				pTech->GetDefaultISHeatingWC()->SetSpecifHeat( dValue );
			}
		}
	}
	else
	{
		pTech->GetDefaultISHeatingWC()->UpdateFluidData( pTech->GetDefaultISHeatingTps() );
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// For product selection in cooling.
	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISCoolingTps") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetDefaultISCoolingTps( dValue );
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISCoolingDT") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetDefaultISCoolingDT( dValue );
	}

	strString = ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISCoolingAdditID"), pTech->GetDefaultISCoolingAdditID() );
	pTech->SetDefaultISCoolingAdditID( strString );

	if( RD_OK == ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISCoolingPcWeight") ), &dValue ) )
	{
		pTech->SetDefaultISCoolingPcWeight( dValue );
	}

	// HYS-1263 : Save the Family addit
	AdditID = TASApp.GetpTADB()->Get( pTech->GetDefaultISCoolingAdditID() );
	
	if( NULL != AdditID.PP )
	{
		pTech->GetDefaultISCoolingWC()->SetAdditFamID( AdditID.PP->GetIDPtr().ID );
	}

	if( 0 == wcscmp( strString.c_str(), _T("OTHER_FLUID") ) )
	{
		// HYS-1230: Read density only if user was on 'Other fluid'.
		if( RD_OK == ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISCoolingDensity") ), &dValue ) && dValue != 0.0 )
		{
			pTech->GetDefaultISCoolingWC()->SetDens( dValue );
		}

		// HYS-1230: Read kinematic viscosity only if user was on 'Other fluid'.
		if( RD_OK == ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISCoolingKinematicViscosity") ), &dValue ) && dValue != 0.0 )
		{
			pTech->GetDefaultISCoolingWC()->SetKinVisc( dValue );
		}

		// HYS-1230: Read specific heat only if user was on 'Other fluid' and choose to put a value.
		iValue = ::AfxGetApp()->GetProfileInt( _T("DialogTechParam" ), _T( "DefaultISCoolingCheckSpecificHeat"), 0 );
		pTech->GetDefaultISCoolingWC()->SetCheckSpecifHeat( ( 0 == iValue ) ? false : true );

		if( 1 == iValue )
		{
			if( RD_OK == ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISCoolingSpecificHeat") ), &dValue ) && dValue != 0.0 )
			{
				pTech->GetDefaultISCoolingWC()->SetSpecifHeat( dValue );
			}
		}
	}
	else
	{
		pTech->GetDefaultISCoolingWC()->UpdateFluidData( pTech->GetDefaultISCoolingTps() );
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// For product selection in solar.
	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISSolarTps") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetDefaultISSolarTps( dValue );
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISSolarDT") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetDefaultISSolarDT( dValue );
	}

	strString = ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISSolarAdditID"), pTech->GetDefaultISSolarAdditID() );
	pTech->SetDefaultISSolarAdditID( strString );

	if( RD_OK == ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISSolarPcWeight") ), &dValue ) )
	{
		pTech->SetDefaultISSolarPcWeight( dValue );
	}

	// HYS-1263 : Save the Family addit
	AdditID = TASApp.GetpTADB()->Get( pTech->GetDefaultISSolarAdditID() );
	
	if( NULL != AdditID.PP )
	{
		pTech->GetDefaultISSolarWC()->SetAdditFamID( AdditID.PP->GetIDPtr().ID );
	}

	if( 0 == wcscmp( strString.c_str(), _T("OTHER_FLUID") ) )
	{
		// HYS-1230: Read density only if user was on 'Other fluid'.
		if( RD_OK == ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISSolarDensity") ), &dValue ) && dValue != 0.0 )
		{
			pTech->GetDefaultISSolarWC()->SetDens( dValue );
		}

		// HYS-1230: Read kinematic viscosity only if user was on 'Other fluid'.
		if( RD_OK == ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISSolarKinematicViscosity") ), &dValue ) && dValue != 0.0 )
		{
			pTech->GetDefaultISSolarWC()->SetKinVisc( dValue );
		}

		// HYS-1230: Read specific heat only if user was on 'Other fluid' and choose to put a value.
		iValue = ::AfxGetApp()->GetProfileInt( _T("DialogTechParam" ), _T( "DefaultISSolarCheckSpecificHeat"), 0 );
		pTech->GetDefaultISSolarWC()->SetCheckSpecifHeat( ( 0 == iValue ) ? false : true );

		if( 1 == iValue )
		{
			if( RD_OK == ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISSolarSpecificHeat") ), &dValue ) && dValue != 0.0 )
			{
				pTech->GetDefaultISSolarWC()->SetSpecifHeat( dValue );
			}
		}
	}
	else
	{
		pTech->GetDefaultISSolarWC()->UpdateFluidData( pTech->GetDefaultISSolarTps() );
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// For product selection in change-over - cooling side.
	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISChangeOverCoolingSideTps") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetDefaultISChangeOverTps( dValue, SideDefinition::CoolingSide );
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISChangeOverCoolingSideDT") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetDefaultISChangeOverDT( dValue, SideDefinition::CoolingSide );
	}

	strString = ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISChangeOverCoolingSideAdditID"), pTech->GetDefaultISChangeOverAdditID( SideDefinition::CoolingSide ) );
	pTech->SetDefaultISChangeOverAdditID( strString, SideDefinition::CoolingSide );

	if( RD_OK == ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISChangeOverCoolingSidePcWeight") ), &dValue ) )
	{
		pTech->SetDefaultISChangeOverPcWeight( dValue, SideDefinition::CoolingSide );
	}

	if( 0 == wcscmp( strString.c_str(), _T("OTHER_FLUID") ) )
	{
		// HYS-1230: Read density only if user was on 'Other fluid'.
		if( RD_OK == ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISChangeOverCoolingSideDensity") ), &dValue ) && dValue != 0.0 )
		{
			pTech->GetDefaultISChangeOverWC( SideDefinition::CoolingSide )->SetDens( dValue );
		}

		// HYS-1230: Read kinematic viscosity only if user was on 'Other fluid'.
		if( RD_OK == ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISChangeOverCoolingSideKinematicViscosity") ), &dValue ) && dValue != 0.0 )
		{
			pTech->GetDefaultISChangeOverWC( SideDefinition::CoolingSide )->SetKinVisc( dValue );
		}

		// HYS-1230: Read specific heat only if user was on 'Other fluid' and choose to put a value.
		iValue = ::AfxGetApp()->GetProfileInt( _T("DialogTechParam" ), _T( "DefaultISChangeOverCoolingSideCheckSpecificHeat"), 0 );
		pTech->GetDefaultISChangeOverWC( SideDefinition::CoolingSide )->SetCheckSpecifHeat( ( 0 == iValue ) ? false : true );

		if( 1 == iValue )
		{
			if( RD_OK == ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISChangeOverCoolingSideSpecificHeat") ), &dValue ) && dValue != 0.0 )
			{
				pTech->GetDefaultISChangeOverWC( SideDefinition::CoolingSide )->SetSpecifHeat( dValue );
			}
		}
	}
	else
	{
		// HYS-1263 : Save the Family addit
		AdditID = TASApp.GetpTADB()->Get( pTech->GetDefaultISChangeOverAdditID( SideDefinition::CoolingSide ) );
		
		if( NULL != AdditID.PP )
		{
			pTech->GetDefaultISChangeOverWC( SideDefinition::CoolingSide )->SetAdditFamID( AdditID.PP->GetIDPtr().ID );
		}
		pTech->GetDefaultISChangeOverWC( SideDefinition::CoolingSide )->UpdateFluidData( pTech->GetDefaultISChangeOverTps( SideDefinition::CoolingSide ) );
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// For product selection in change-over - heating side.
	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISChangeOverHeatingSideTps") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetDefaultISChangeOverTps( dValue, SideDefinition::HeatingSide );
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISChangeOverHeatingSideDT") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		pTech->SetDefaultISChangeOverDT( dValue, SideDefinition::HeatingSide );
	}

	strString = ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISChangeOverHeatingSideAdditID"), pTech->GetDefaultISChangeOverAdditID( SideDefinition::HeatingSide ) );
	pTech->SetDefaultISChangeOverAdditID( strString, SideDefinition::HeatingSide );

	if( RD_OK == ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISChangeOverHeatingSidePcWeight") ), &dValue ) )
	{
		pTech->SetDefaultISChangeOverPcWeight( dValue, SideDefinition::HeatingSide );
	}

	if( 0 == wcscmp( strString.c_str(), _T("OTHER_FLUID") ) )
	{
		// HYS-1230: Read density only if user was on 'Other fluid'.
		if( RD_OK == ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISChangeOverHeatingSideDensity") ), &dValue ) && dValue != 0.0 )
		{
			pTech->GetDefaultISChangeOverWC( SideDefinition::HeatingSide )->SetDens( dValue );
		}

		// HYS-1230: Read kinematic viscosity only if user was on 'Other fluid'.
		if( RD_OK == ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISChangeOverHeatingSideKinematicViscosity") ), &dValue ) && dValue != 0.0 )
		{
			pTech->GetDefaultISChangeOverWC( SideDefinition::HeatingSide )->SetKinVisc( dValue );
		}

		// HYS-1230: Read specific heat only if user was on 'Other fluid' and choose to put a value.
		iValue = ::AfxGetApp()->GetProfileInt( _T("DialogTechParam" ), _T( "DefaultISChangeOverHeatingSideCheckSpecificHeat"), 0 );
		pTech->GetDefaultISChangeOverWC( SideDefinition::HeatingSide )->SetCheckSpecifHeat( ( 0 == iValue ) ? false : true );

		if( 1 == iValue )
		{
			if( RD_OK == ReadDouble( ::AfxGetApp()->GetProfileString( _T("DialogTechParam" ), _T( "DefaultISChangeOverHeatingSideSpecificHeat") ), &dValue ) && dValue != 0.0 )
			{
				pTech->GetDefaultISChangeOverWC( SideDefinition::HeatingSide )->SetSpecifHeat( dValue );
			}
		}
	}
	else
	{
		// HYS-1263 : Save the Family addit
		AdditID = TASApp.GetpTADB()->Get( pTech->GetDefaultISChangeOverAdditID( SideDefinition::HeatingSide ) );
		
		if( NULL != AdditID.PP )
		{
			pTech->GetDefaultISChangeOverWC( SideDefinition::HeatingSide )->SetAdditFamID( AdditID.PP->GetIDPtr().ID );
		}
		
		pTech->GetDefaultISChangeOverWC( SideDefinition::HeatingSide )->UpdateFluidData( pTech->GetDefaultISChangeOverTps( SideDefinition::HeatingSide ) );
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Overwrite product selection temperature, DT and additive with values coming from registry.
	// 'GetpWCForProductSelection()->GetpWCData()' points on the 'PARAM_WC' object that is in the 'PARAM_TABLE' table.
	*GetpWCForProductSelection()->GetpWCData() = *pTech->GetDefaultISWC();
}

bool CTADatastruct::IsSomethingToPrint()
{
	const int iTable = 15;

	const TCHAR Tads[iTable][_ID_LENGTH + 1] =
	{
		_T("REGVALV_TAB"),
		_T("DPCONTR_TAB"),
		_T("RADSET_TAB"),
		_T("PARTDEF_TAB"),
		_T("CTRLVALVE_TAB"),
		_T("AIRVENTSEP_TAB"),
		_T("PRESSMAINT_TAB"),
		_T("DPCBCVALVE_TAB"),
		_T("SHUTOFF_TAB"),
		_T("SAFETYVALVE_TAB"),
		_T("6WAYCTRLVALV_TAB"),
		_T("TAPWATERCTRL_TAB"),
		_T("SMARTCONTROLVALVE_TAB"),
		_T("SMARTDPC_TAB"),
		_T("FLOORHCTRL_TAB")
	};

	CString str;
	CTable *pTab = NULL;

	// Selected products.
	for( int i = 0; i < iTable; i++ )
	{
		pTab = static_cast<CTable *>( Get( Tads[i] ).MP );

		if( NULL == pTab )
		{
			continue;
		}

		if( true == pTab->IsExist() )
		{
			return true;
		}
	}

	// Project.
	pTab = GetpHydroModTable();

	if( NULL == pTab )
	{
		return false;
	}

	if( true == pTab->IsExist() )
	{
		return true;
	}

	// Log data.
	pTab = static_cast<CTable *>( Get( _T("LOGDATA_TAB") ).MP );

	if( NULL == pTab )
	{
		return false;
	}

	if( true == pTab->IsExist( CLASS( CDS_LoggedData ) ) || true == pTab->IsExist( CLASS( CDS_LogDataX ) ) )
	{
		return true;
	}

	// Hub.
	pTab = GetpHUBSelectionTable();

	if( NULL == pTab )
	{
		return false;
	}

	if( true == pTab->IsExist( CLASS( CDS_HmHub ) ) )
	{
		return true;
	}

	// Quick measurements.
	pTab = GetpQuickMeasureTable();

	if( NULL == pTab )
	{
		return false;
	}

	if( true == pTab->IsExist( CLASS( CDS_HydroModX ) ) )
	{
		return true;
	}

	return false;
}

bool CTADatastruct::IsIndividualSelectionExist( void )
{
	int iTable = 11;
	TCHAR Tads[][_ID_LENGTH + 1] =
	{
		_T("REGVALV_TAB"),
		_T("DPCONTR_TAB"),
		_T("RADSET_TAB"),
		_T("PARTDEF_TAB"),
		_T("CTRLVALVE_TAB"),
		_T("AIRVENTSEP_TAB"),
		_T("PRESSMAINT_TAB"),
		_T("DPCBCVALVE_TAB"),
		_T("SHUTOFF_TAB"),
		_T("SAFETYVALVE_TAB"),
		_T("6WAYCTRLVALV_TAB"),
		_T("SMARTCONTROLVALVE_TAB"),
		_T("SMARTDPC_TAB")
	};
	CString str;

	// Selected product.
	for( int i = 0; i < iTable; i++ )
	{
		CTable *pTab = static_cast<CTable *>( Get( Tads[i] ).MP );

		if( NULL == pTab )
		{
			continue;
		}

		if( true == pTab->IsExist() )
		{
			return true;
		}
	}

	return false;
}

void CTADatastruct::CleanClipboard()
{
	BYTE bModified = IsModified();

	// Clean clipboard contents.
	CTable *pTab = GetpClipboardTable();
	ASSERT( NULL != pTab );

	if( NULL == pTab )
	{
		return;
	}

	// Loop on GetFirst() continuously because removing objects inside the loop.
	for( IDPTR IDPtr = pTab->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pTab->GetFirst() )
	{
		if( true == IDPtr.MP->IsHMFamily() )
		{
			DeleteTADSBranch( static_cast<CDS_HydroMod *>( IDPtr.MP ) );
			TRACE( _T("Delete Branch :%s\n"), IDPtr.ID );
		}

		pTab->Remove( IDPtr );
		DeleteObject( IDPtr );
	}

	Modified( bModified );
}

////////////////////////////////////////////////////////////////////////////////
//	Count recursively the number of HM which are descendant of pHM
//  (pHM is excluded from the count)
//  If bValvExcluded is true, all HM that are terminal HM are not included in
//  the count
int CTADatastruct::GetHMCount( CTable *pHM, bool bValvExcluded )
{
	int iCount = 0;

	if( NULL == pHM )
	{
		return iCount;
	}

	for( IDPTR IDPtr = pHM->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pHM->GetNext( IDPtr.MP ) )
	{
		if( false == bValvExcluded || true == ( static_cast<CDS_HydroMod *>( IDPtr.MP ) )->IsaModule() )
		{
			iCount++;

			// Count all children for this branch...
			iCount += GetHMCount( static_cast<CDS_HydroMod *>( IDPtr.MP ) );
		}
	}

	return iCount;
}

void CTADatastruct::DeleteHM( CDS_HydroMod *pHM )
{
	if( NULL == pHM )
	{
		return;
	}

	DeleteTADSBranch( pHM );

	// Delete associated valve in TADS
	CTable *pTab = static_cast<CTable *>( pHM->GetIDPtr().PP );
	ASSERT( NULL != pTab );

	int iPosition = pHM->GetPos();
	IDPTR idptr = pHM->GetIDPtr();
	pTab->Remove( idptr );
	DeleteObject( idptr );
	RemoveIndexHole( pTab, iPosition );
}

////////////////////////////////////////////////////////////////////////////////
//	Delete contents of one TADS Branch (recursive function)
void CTADatastruct::DeleteTADSBranch( CTable *pHM )
{
	if( NULL == pHM )
	{
		return;
	}

	//Loop on GetFirst() continuously because removing objects inside the loop
	for( IDPTR IDPtr = pHM->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pHM->GetFirst() )
	{
		CDS_HydroMod *p = dynamic_cast<CDS_HydroMod *>( IDPtr.MP );

		if( NULL != p )
		{
			// Delete associated valve in TADS
			// Delete all child for this branch....
			DeleteTADSBranch( p );
		}
		else
		{
			ASSERT( 0 );
		}

		TRACE( _T("Delete Branch :%s\n"), p->GetHMName() );
		pHM->Remove( IDPtr );
		DeleteObject( IDPtr );
	}
}

void CTADatastruct::DeleteSelectionFromTADS( IDPTR SelectionIDPtr )
{
	// The aim of this function is to decrement index of all selection that follow current to be deleted.

	// At now, there is two containers for selection: CDS_SelThing and CDS_SSel.
	// We need to check if 'SelectionIDPtr' belongs to one of them.

	// Take parent table of current selection.
	CTable *pTab = SelectionIDPtr.PP;
	int iRowIndex = 0;

	CDS_SelThing *pSelThing = dynamic_cast<CDS_SelThing *>( SelectionIDPtr.MP );

	if( NULL != pSelThing )
	{
		iRowIndex = pSelThing->GetRowIndex();

		// ReIndex the table.
		for( IDPTR idptr = pTab->GetFirst(); _T('\0') != *idptr.ID; idptr = pTab->GetNext() )
		{
			CDS_SelThing *pSelT = dynamic_cast<CDS_SelThing *>( idptr.MP );
			ASSERT( NULL != pSelT );

			if( NULL != pSelT )
			{
				if( pSelT->GetRowIndex() > iRowIndex )
				{
					pSelT->SetRowIndex( pSelT->GetRowIndex() - 1 );
				}
			}
		}
	}
	else
	{
		CDS_SelProd *pSSelProd = dynamic_cast<CDS_SelProd *>( SelectionIDPtr.MP );

		if( NULL != pSSelProd && NULL != pSSelProd->GetpSelectedInfos() )
		{
			iRowIndex = pSSelProd->GetpSelectedInfos()->GetRowIndex();

			for( IDPTR idptr = pTab->GetFirst(); _T('\0') != *idptr.ID; idptr = pTab->GetNext() )
			{
				// Removed the ASSERT on the 'pSelP'. In the parent table, it's totally possible to have other object than a 'CDS_SelProd'.
				// It's the case for actuator 'CDS_Actuator' that can be selected alone in direct selection.
				CDS_SelProd *pSelP = dynamic_cast<CDS_SelProd *>( idptr.MP );

				if( NULL == pSelP || NULL == pSelP->GetpSelectedInfos() )
				{
					continue;
				}

				if( pSelP->GetpSelectedInfos()->GetRowIndex() > iRowIndex )
				{
					pSelP->GetpSelectedInfos()->SetRowIndex( pSelP->GetpSelectedInfos()->GetRowIndex() - 1 );
				}
			}
		}
	}

	pTab->Remove( SelectionIDPtr );
	DeleteObject( SelectionIDPtr );
}

void CTADatastruct::DeleteValveFromTADS( CDS_HydroMod *pHM )
{
	// ????

	ASSERT( pHM->IsHMFamily() );
	pHM->SetCBISize( _T("") );
	pHM->SetCBIType( _T("") );
}

////////////////////////////////////////////////////////////////////////////////
// Check in PIPING_TAB, TMPHUB_TAB, SELHUBTAB_TAB if a name is already used
// return table where the name has been found
CTable *CTADatastruct::VerifyIfNameAlreadyExist( CString strName, CDS_HydroMod *pCurrentHM )
{
	CArray<CString> asTab;
	asTab.Add( _T("PIPING_TAB") );
	asTab.Add( _T("SELHUB_TAB") );
	asTab.Add( _T("TMPHUB_TAB") );

	for( int i = 0; i < asTab.GetCount(); i++ )
	{
		CTable *pTab = static_cast<CTable *>( Get( asTab.GetAt( i ) ).MP );
		ASSERT( NULL != pTab );

		if( NULL == pTab )
		{
			return false;
		}

		CDS_HydroMod *pHM = FindHydroMod( strName, pTab, pCurrentHM, CDatastruct::FindMode::Both );

		if( NULL != pHM )
		{
			return pTab;
		}
	}

	return NULL;
}

////////////////////////////////////////////////////////////////////////////////
// Find a Module or a valve with name matching str
CDS_HydroMod *CTADatastruct::FindHydroMod( CString str, CTable *pTab, CDS_HydroMod *pHMToSkip, CDatastruct::FindMode eFindMode )
{
	if( NULL == pTab )
	{
		return NULL;
	}

	for( IDPTR IDPtr = pTab->GetFirst(); '\0' != *IDPtr.ID; IDPtr = pTab->GetNext( IDPtr.MP ) )
	{
		if( static_cast<CDS_HydroMod *>( IDPtr.MP ) != pHMToSkip )
		{
			CString strHMName = ( static_cast<CDS_HydroMod *>( IDPtr.MP ) )->GetHMName();

			switch( eFindMode )
			{
				case CDatastruct::FindMode::OnlyModules:

					if( true == ( static_cast<CDS_HydroMod *>( IDPtr.MP ) )->IsaModule() )
					{
						if( 0 == str.CompareNoCase( strHMName ) )
						{
							return ( static_cast<CDS_HydroMod *>( IDPtr.MP ) );
						}
					}

					break;

				case CDatastruct::FindMode::OnlyValves:

					if( false == ( static_cast<CDS_HydroMod *>( IDPtr.MP ) )->IsaModule() )
					{
						if( 0 == str.CompareNoCase( strHMName ) )
						{
							return ( static_cast<CDS_HydroMod *>( IDPtr.MP ) );
						}
					}

					break;

				default:

					if( 0 == str.CompareNoCase( strHMName ) )
					{
						return ( static_cast<CDS_HydroMod *>( IDPtr.MP ) );
					}

					break;
			}
		}

		CDS_HydroMod *pHM = static_cast<CDS_HydroMod *>( IDPtr.MP );

		if( true == pHM->IsaModule() )
		{
			CDS_HydroMod *pHMFind = FindHydroMod( str, pHM, pHMToSkip, eFindMode );

			if( NULL != pHMFind )
			{
				return pHMFind;
			}
		}
	}

	return NULL;
}

////////////////////////////////////////////////////////////////////////////////
// Find a Module or a valve with the correct uid
CDS_HydroMod *CTADatastruct::FindHydroMod( unsigned short uid, CTable *pTab )
{
	if( NULL == pTab )
	{
		return NULL;
	}

	for( IDPTR IDPtr = pTab->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pTab->GetNext( IDPtr.MP ) )
	{
		if( ( static_cast<CDS_HydroMod *>( IDPtr.MP ) )->GetUid() == uid )
		{
			return ( static_cast<CDS_HydroMod *>( IDPtr.MP ) );
		}

		if( ( static_cast<CDS_HydroMod *>( IDPtr.MP ) )->IsaModule() )
		{
			CDS_HydroMod *pHM = FindHydroMod( uid, static_cast<CTable *>( IDPtr.MP ) );

			if( pHM )
			{
				return pHM;
			}
		}
	}

	return NULL;
}

////////////////////////////////////////////////////////////////////////////////
// Replace HydroMod uid with a new one
void CTADatastruct::SetHMUid( CTable *pTab )
{
	CDS_ProjectParams *pPrjParams = GetpProjectParams();
	ASSERT( NULL != pPrjParams );

	if( false == pTab->IsClass( CLASS( CTableHM ) ) )
	{
		ASSERT( true == pTab->IsHMFamily() );

		if( false == pTab->IsHMFamily() )
		{
			return;
		}

		( static_cast<CDS_HydroMod *>( pTab ) )->SetUid( pPrjParams->GetNextUid() );
	}

	for( IDPTR IDPtr = pTab->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pTab->GetNext( IDPtr.MP ) )
	{
		if( true == ( static_cast<CDS_HydroMod *>( IDPtr.MP ) )->IsaModule() )
		{
			SetHMUid( static_cast<CTable *>( IDPtr.MP ) );
		}
		else
		{
			( static_cast<CDS_HydroMod *>( IDPtr.MP ) )->SetUid( pPrjParams->GetNextUid() );
		}
	}

}

////////////////////////////////////////////////////////////////////////////////
// Reset HydroMod level in function of his real position
void CTADatastruct::SetHMLevel( CTable *pTab, int iLevel )
{
	if( false == pTab->IsClass( CLASS( CTableHM ) ) )
	{
		ASSERT( true == pTab->IsHMFamily() );

		if( false == pTab->IsHMFamily() )
		{
			return;
		}

		( static_cast<CDS_HydroMod *>( pTab ) )->SetLevel( iLevel );
	}

	for( IDPTR IDPtr = pTab->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pTab->GetNext( IDPtr.MP ) )
	{
		if( ( static_cast<CDS_HydroMod *>( IDPtr.MP ) )->IsaModule() )
		{
			SetHMLevel( static_cast<CTable *>( IDPtr.MP ), iLevel + 1 );
		}
		else
		{
			( static_cast<CDS_HydroMod *>( IDPtr.MP ) )->SetLevel( iLevel + 1 );
		}
	}
}

////////////////////////////////////////////////////////////////////////////////
// str will be modified by making the last three characters to be
// "%AAA" where AAA is incremented until a non-existing name is found
// Limited to 3 capital alphabetical TCHAR 26 * 26 * 26-> 17576 variants !!!
// return the new composed string; if a new name can't be found return false and str =""
bool CTADatastruct::DifferentiateHMName( CTable *pTab, CString &str )
{
	int iLongNameIndex = 0;

	// Name will be modified by making the last 3 characters to be "%AAA" where AAA is incremented until a
	// non-existing name is found.
	int iInitPos = ( TASApp.GetModuleNameMaxChar() ) - 1 - 3;

	if( str.GetLength() <= iInitPos )
	{
		iInitPos = str.GetLength();
	}

	CString tmpstr;
	CString Initstr = str;
	bool bUnique = false;

	while( false == bUnique )
	{
		str = Initstr.Left( iInitPos ) + CString( '%' );
		int iIndex = iLongNameIndex;

		CString strIndex = Base26Convert( iIndex );

		str += strIndex;

		if( str.GetLength() > TASApp.GetModuleNameMaxChar() )
		{
			str.Empty();
			return false;
		}

		CDS_HydroMod *pHM = NULL;
		pHM = FindHydroMod( str, pTab );

		if( NULL == pHM )
		{
			bUnique = true;
		}

		iLongNameIndex++;
	}

	return true;
}

bool CTADatastruct::DifferentiateHMName( std::multimap<double, CDS_HydroMod *> *pmap, CDS_HydroMod *pHM, CString *pStr, int &iLongNameIndex )
{
	if( NULL == pmap )
	{
		return false;
	}

	std::multimap<double, CDS_HydroMod *>::iterator It;
	
	// Name will be modified by making the last 3 characters to be "%AAA" where AAA is incremented until a
	// non-existing name is found.
	CString str = *pStr;
	int iInitPos = ( TASApp.GetModuleNameMaxChar() ) - 1 - 3;

	if( str.GetLength() <= iInitPos )
	{
		iInitPos = str.GetLength();
	}

	CString strTemp;
	CString strInit = str;
	bool bUnique = false;

	while( false == bUnique )
	{
		str = strInit.Left( iInitPos ) + CString( '%' );
		int iIndex = iLongNameIndex;

		CString indexstr = Base26Convert( iIndex );

		str += indexstr;

		if( str.GetLength() > TASApp.GetModuleNameMaxChar() )
		{
			str.Empty();
			return false;
		}

		// Verify if the name is unique.
		bUnique = true;

		for( It = pmap->begin(); It != pmap->end() && bUnique == true; ++It )
		{
			if( It->second != pHM )
			{
				if( 0 == str.CompareNoCase( It->second->GetHMName() ) )
				{
					bUnique = false;
				}
			}
		}

		if( bUnique == true )
		{
			*pStr = str;
		}

		iLongNameIndex++;
	}

	return true;
}

////////////////////////////////////////////////////////////////////////////////
// Create a valve's name in function of his parent, or based on a Prefix
void CTADatastruct::ComposeValveName( const IDPTR &IDPtr, CTable *pTab, CString strPrefix )
{
	CString strTemp;

	// If Automatic.
	if( _T('*') == *( ( static_cast<CDS_HydroMod *>( IDPtr.MP ) )->GetHMName() ) )
	{
		if( NULL == ( static_cast<CDS_HydroMod *>( IDPtr.PP ) ) && true == strPrefix.IsEmpty() )
		{
			return;
		}

		if( true == strPrefix.IsEmpty() )
		{
			// Based on the parent name.
			int i = 0;

			if( _T('*') == *( static_cast<CDS_HydroMod *>( IDPtr.PP ) )->GetHMName() )
			{
				i = 1;
			}

			strTemp.Format( _T("*%s.%d"), (LPCTSTR)( static_cast<CDS_HydroMod *>( IDPtr.PP ) )->GetHMName() + i, ( static_cast<CDS_HydroMod *>( IDPtr.MP ) )->GetPos() );
		}
		else
		{
			//Based on the prefix.
			strTemp.Format( _T("*%s%d"), strPrefix, ( static_cast<CDS_HydroMod *>( IDPtr.MP ) )->GetPos() );
		}

		// If resulting valve name is larger than max. size, make it "Unnamed".
		if( strTemp.GetLength() > TASApp.GetModuleNameMaxChar() )
		{
			strTemp = _T("*") + TASApp.LoadLocalizedString( IDS_VALVENONAME );

			if( NULL == pTab )
			{
				pTab = TASApp.GetpTADS()->GetpHydroModTable();
			}

			ASSERT( NULL != pTab );
			DifferentiateHMName( pTab, strTemp );
		}

		// Set valve name in HM.
		( static_cast<CDS_HydroMod *>( IDPtr.MP ) )->SetHMName( (LPCTSTR)strTemp );
	}
	else
	{
		strTemp = ( static_cast<CDS_HydroMod *>( IDPtr.MP ) )->GetHMName();
	}

	// Set Ref 1 of associated valve in SelP
}

// Compose a HM Name based on the parent Name or on a prefix
// index characters will be composed with letters or figure
CString CTADatastruct::ComposeHUBHMName( CDS_HydroMod *pHM, TCHAR cStar, bool bAuto, CString strPrefix, bool bNumber )
{
	CString strTemp;

	// Automatic
	if( true == bAuto )
	{
		// Parent != HM family and Prefix is Empty go out
		if( false == pHM->GetIDPtr().PP->IsHMFamily() && true == strPrefix.IsEmpty() )
		{
			return strTemp;
		}

		CString strSuffix;

		if( true == bNumber )
		{
			strSuffix.Format( _T("%d"), pHM->GetPos() );
		}
		else
		{
			strSuffix = Base26Convert( pHM->GetPos() );
		}

		if( cStar != _T('\0') )
		{
			strTemp = cStar;
		}

		CString str;

		if( true == strPrefix.IsEmpty() )
		{
			// Based on Parent Name
			int i = 0;

			if( _T('*') == *( static_cast<CDS_HydroMod *>( pHM->GetIDPtr().PP ) )->GetHMName() )
			{
				i = 1;
			}

			str.Format( _T("%s.%s"), (LPCTSTR)( static_cast<CDS_HydroMod *>( pHM->GetIDPtr().PP ) )->GetHMName() + i, strSuffix );
		}
		else
		{
			//Based on the prefix
			str.Format( _T("%s%s"), strPrefix, strSuffix );
		}

		strTemp += str;

		// If resulting Valve Name is larger than max. size, make it "Unnamed"
		if( strTemp.GetLength() > TASApp.GetModuleNameMaxChar() )
		{
			strTemp = _T("*") + TASApp.LoadLocalizedString( IDS_VALVENONAME );

			CTable *pTab = GetpHUBSelectionTable();
			ASSERT( NULL != pTab );

			if( NULL != pTab )
			{
				DifferentiateHMName( pTab, strTemp );
			}
		}
	}

	return strTemp;
}

////////////////////////////////////////////////////////////////////////////////
// if the automatic rename character is present
// create a Root Module Name in function of his index
// if pHM == NULL create a name with index value
void CTADatastruct::ComposeRMName( CString &str, CDS_HydroMod *pHM, int iIndex )
{
	if( NULL == pHM )
	{
		if( -1 == iIndex )
		{
			return;
		}

		str = _T("*");
	}
	else
	{
		str = pHM->GetHMName();
		iIndex = pHM->GetPos() - 1;
	}

	if( _T('*') == str[0] )
	{
		str.Format( _T("*%s"), Base26Convert( iIndex ) );
	}
}

void CTADatastruct::CollectHMList( CTable *pTab, std::multimap<double, CDS_HydroMod *> *pmap )
{
	if( NULL == pTab )
	{
		return;
	}

	for( IDPTR idptr = pTab->GetFirst(); NULL != idptr.MP; idptr = pTab->GetNext( idptr.MP ) )
	{
		CDS_HydroMod *pHM = dynamic_cast<CDS_HydroMod *>( idptr.MP );

		if( NULL == pHM )
		{
			continue;
		}

		if( true == pHM->IsaModule() )
		{
			CollectHMList( pHM, pmap );
		}

		double dKey = pHM->GetLevel() * 10000 + pHM->GetPos();
		pmap->insert( std::make_pair( dKey, pHM ) );
	}
}

void CTADatastruct::RenameBranch( CTableHM *pTab )
{
	CDS_ProjectParams *pPrjParam = TASApp.GetpTADS()->GetpProjectParams();
	ASSERT( NULL != pPrjParam );

	// Collect all HM name below this node
	std::multimap<double, CDS_HydroMod *>mapHMName;
	std::multimap<double, CDS_HydroMod *>::iterator It;
	CollectHMList( pTab, &mapHMName );
	int iLongNameIndex = 0;

	// For each HM starting with a * rename it
	for( It = mapHMName.begin(); It != mapHMName.end(); ++It )
	{
		CDS_HydroMod *pHM = It->second;

		if( pHM->GetHMName().GetLength() > TASApp.GetModuleNameMaxChar() )
		{
			pHM->SetHMName( _T("*") );
		}
		else if( true == pPrjParam->IsCompatibleCBI() )
		{
			// If input is not compatible to the CBI mode...
			CCbiRestrString CbiRestrString;
			CString strName = pHM->GetHMName();

			if( false == CbiRestrString.CheckCBICharSet( &strName ) )
			{
				pHM->SetHMName( _T("*") );
			}
		}

		if( _T('*') != pHM->GetHMName()[0] )
		{
			// Name fixed
			continue;
		}

		if( 0 == pHM->GetLevel() )
		{
			CString str;
			TASApp.GetpTADS()->ComposeRMName( str, pHM, pHM->GetPos() );
			pHM->SetHMName( str );
		}
		else
		{
			CString str;
			CDS_HydroMod *pParentHM = dynamic_cast<CDS_HydroMod *>( pHM->GetIDPtr().PP );

			if( NULL != pParentHM )
			{
				str.Format( _T("%s.%d"), pParentHM->GetHMName(), pHM->GetPos() );

				if( 0 != str.CompareNoCase( pHM->GetHMName() ) )
				{
					if( str[0] != _T('*') )
					{
						CString strName = L"*" + str;
						str = strName;
					}

					pHM->SetHMName( str );
				}
			}

			// If resulting module nName is larger than max. size, make it "*Named%---".
			if( str.GetLength() > TASApp.GetModuleNameMaxChar() )
			{
				CTable *pTab = TASApp.GetpTADS()->GetpHydroModTable();
				ASSERT( NULL != pTab );

				CString strHMName = _T("*") + TASApp.LoadLocalizedString( IDS_VALVENONAME );

				// Erase the name of the current one because 'DifferentiateHMName' risks to give a different name if already exist.
				//pHM->SetHMName( _T("") );
				str = strHMName;

				if( true == DifferentiateHMName( &mapHMName, pHM, &str, iLongNameIndex ) )
				{
					strHMName = str;
					pHM->SetHMName( strHMName );
				}
			}
		}
	}
}

void CTADatastruct::ComputeFlow( CTable *pTab, bool bFromTop )
{
	if( NULL == pTab )
	{
		return;
	}

	double dTotalFlow = 0.0;

	if( true == bFromTop && false == pTab->IsClass( CLASS( CTableHM ) ) )
	{
		ASSERT( true == pTab->IsHMFamily() );

		if( false == pTab->IsHMFamily() )
		{
			return;
		}

		//from the top....
		IDPTR IDPtr = pTab->GetIDPtr();

		while( ( static_cast<CDS_HydroMod *>( IDPtr.MP ) )->GetLevel() )
		{
			IDPtr = IDPtr.PP->GetIDPtr();
		}

		ComputeFlow( static_cast<CDS_HydroMod *>( IDPtr.MP ) );
	}

	for( IDPTR IdpChild = pTab->GetFirst(); _T('\0') != *IdpChild.ID; IdpChild = pTab->GetNext( IdpChild.MP ) )
	{
		if( ( static_cast<CDS_HydroMod *>( IdpChild.MP ) )->IsaModule() )
		{
			ComputeFlow( static_cast<CDS_HydroMod *>( IdpChild.MP ) );
		}

		CDS_HydroMod *pHM = dynamic_cast<CDS_HydroMod *>( IdpChild.MP );

		if( false == pHM->IsPending() )
		{
			dTotalFlow += ( static_cast<CDS_HydroMod *>( IdpChild.MP ) )->GetQ();
		}
	}

	CDS_HydroMod *pHM = dynamic_cast<CDS_HydroMod *>( pTab );

	if( NULL != pHM )
	{
		if( true == pHM->IsaModule() )
		{
			// Remark: -1.0 is the value to tell that there is not yet diversity factor applied.
			if( pHM->GetDiversityFactor() != -1.0 && pHM->GetDiversityFactor() < 1.0 )
			{
				// We have diversity factor acting on this branch
				// consider flow saved during computing phase
				dTotalFlow = pHM->GetQ();
			}

			if( pHM->GetpSchcat() != NULL && true == pHM->GetpSchcat()->IsInjection() )
			{
				dTotalFlow = pHM->GetQ();
			}

			pHM->SetQDesign( dTotalFlow );
		}
	}
}

// Return a pointer on the first HydroMod stored in to the clipboard
// this pointer will be used to check hydromod's properties
bool CTADatastruct::IsClipBoardEmpty( CDS_HydroMod **ppHM )
{
	CTable *pTab = GetpClipboardTable();
	ASSERT( NULL != pTab );

	for( IDPTR idptr = pTab->GetFirst(); _T('\0') != *idptr.ID; idptr = pTab->GetNext() )
	{
		if( false == idptr.MP->IsHMFamily() )
		{
			continue;
		}

		// HydroMod present
		if( NULL != ppHM )
		{
			*ppHM = static_cast<CDS_HydroMod *>( idptr.MP );
		}

		return false;
	}

	if( NULL != ppHM )
	{
		*ppHM = NULL;
	}

	return true;
}

// pHMSrc is the source HydroMod that will be copied into the clipboard.
// pTab is used internally for recursivity.
IDPTR CTADatastruct::CopyHMToClipBoard( CDS_HydroMod *pHMSrc, CTable *pTab )
{
	try
	{
		if( NULL == pHMSrc )
		{
			HYSELECT_THROW( _T("Internal error: 'pHMSrc' argument can't be NULL.") );
		}

		// First call init pointer on the clipboard table.
		if( NULL == pTab )
		{
			CleanClipboard();
			pTab = GetpClipboardTable();

			if( NULL == pTab)
			{
				HYSELECT_THROW( _T("Internal error: Can't retrieve the clipboard table.") );
			}
		}

		// Create a new object and insert it into the clipboard table.
		IDPTR IDptrNew = _NULL_IDPTR;
		CreateObject( IDptrNew, pHMSrc->GetClassName() );
		pTab->Insert( IDptrNew );
		
		CDS_HydroMod *pHM = static_cast<CDS_HydroMod *>( IDptrNew.MP );

		if( true == pHMSrc->IsClass( CLASS( CDS_Hm2W ) ) )
		{
			CDS_Hm2W *pHm2W = static_cast<CDS_Hm2W *>( pHMSrc );
			pHm2W->Copy( static_cast<CDS_Hm2W *>( pHM ), false, true, true );
		}
		else if( true == pHMSrc->IsClass( CLASS( CDS_Hm2WInj ) ) )
		{
			CDS_Hm2WInj *pHm2WInj = static_cast<CDS_Hm2WInj *>( pHMSrc );
			pHm2WInj->Copy( static_cast<CDS_Hm2WInj *>( pHM ), false, true, true );
		}
		else if( true == pHMSrc->IsClass( CLASS( CDS_Hm3WInj ) ) )
		{
			CDS_Hm3WInj *pHm3WInj = static_cast<CDS_Hm3WInj *>( pHMSrc );
			pHm3WInj->Copy( static_cast<CDS_Hm3WInj *>( pHM ), false, true, true );
		}
		else if( true == pHMSrc->IsClass( CLASS( CDS_Hm3W ) ) )
		{
			CDS_Hm3W *pHm3W = static_cast<CDS_Hm3W *>( pHMSrc );
			pHm3W->Copy( static_cast<CDS_Hm3W *>( pHM ), false, true, true );
		}
		else if( true == pHMSrc->IsClass( CLASS( CDS_HmHub ) ) )
		{
		}
		else if( true == pHMSrc->IsClass( CLASS( CDS_HmHubStation ) ) )
		{
		}
		else
		{
			pHM->SetSchemeID( pHMSrc->GetSchemeID() );
			pHMSrc->Copy( pHM, false, true, true );
		}

		if( pHMSrc->IsaModule() )
		{
			for( IDPTR idptr = pHMSrc->GetFirst(); _T('\0') != *idptr.ID; idptr = pHMSrc->GetNext( idptr.MP ) )
			{
				CopyHMToClipBoard( static_cast<CDS_HydroMod *>( idptr.MP ), pHM );
			}
		}

		return IDptrNew;
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CTADatastruct::CopyHMToClipBoard'."), __LINE__, __FILE__ );
		throw;
	}
}

// Verify in clipboard if there are HM and if yes return true if HM are only module
// return false if there are at least one circuit, return undef if clipboard doesn't contains HM
eBool3 CTADatastruct::IsClipBoardContainsOnlyHMModule()
{
	CTable *pTab = GetpClipboardTable();
	ASSERT( NULL != pTab );

	if( _T('\0') == *pTab->GetFirst().ID )
	{
		return ( eb3Undef );
	}

	for( IDPTR idptr = pTab->GetFirst(); _T('\0') != *idptr.ID; idptr = pTab->GetNext() )
	{
		// Skip unrelated object
		if( false == idptr.MP->IsHMFamily() )
		{
			continue;
		}

		CDS_HydroMod *pHM = static_cast<CDS_HydroMod *>( idptr.MP );

		if( false == pHM->IsaModule() )
		{
			return ( eb3False );
		}
	}

	return eb3True;
}

// pTabTarget is the table where the clipboard content must be copied.
// pTab is used internally for recursivity.
IDPTR CTADatastruct::CopyHMFromClipBoard( CTable *pTabTarget, CTable *pTab )
{
	if( NULL == pTab )
	{
		pTab = GetpClipboardTable();
	}

	ASSERT( NULL != pTab );

	IDPTR IDptrNew = _NULL_IDPTR;

	for( IDPTR idptr = pTab->GetFirst(); _T('\0') != *idptr.ID; idptr = pTab->GetNext() )
	{
		if( false == idptr.MP->IsHMFamily() )
		{
			continue;
		}

		IDptrNew = CreateCopyHM( idptr, pTabTarget );
	}

	return IDptrNew;
}

//Create and insert a new HM into pTAbTrg
//Name, Uid are reseted.  If the copied HM is a module copy children too
IDPTR CTADatastruct::CreateCopyHM( IDPTR IDPtrSrc, CTable *pTabTrg, bool bNoChildren )
{
	try
	{
		CDS_HydroMod *pHMSrc = static_cast<CDS_HydroMod *>( IDPtrSrc.MP );

		IDPTR IDptrNew = _NULL_IDPTR;
		CreateObject( IDptrNew, pHMSrc->GetClassName() );
		pTabTrg->Insert( IDptrNew );

		CDS_HydroMod *pHMtrg = static_cast<CDS_HydroMod *>( IDptrNew.MP );

		if( true == pHMSrc->IsClass( CLASS( CDS_Hm2W ) ) )
		{
			CDS_Hm2W *pHm2W = static_cast<CDS_Hm2W *>( pHMSrc );
			pHm2W->Copy( static_cast<CDS_Hm2W *>( pHMtrg ), false, true, false );
		}
		else if( true == pHMSrc->IsClass( CLASS( CDS_Hm2WInj ) ) )
		{
			CDS_Hm2WInj *pHm2WInj = static_cast<CDS_Hm2WInj *>( pHMSrc );
			pHm2WInj->Copy( static_cast<CDS_Hm2WInj *>( pHMtrg ), false, true, false );
		}
		else if( true == pHMSrc->IsClass( CLASS( CDS_Hm3WInj ) ) )
		{
			CDS_Hm3WInj *pHm3WInj = static_cast<CDS_Hm3WInj *>( pHMSrc );
			pHm3WInj->Copy( static_cast<CDS_Hm3WInj *>( pHMtrg ), false, true, false );
		}
		else if( true == pHMSrc->IsClass( CLASS( CDS_Hm3W ) ) )
		{
			CDS_Hm3W *pHm3W = static_cast<CDS_Hm3W *>( pHMSrc );
			pHm3W->Copy( static_cast<CDS_Hm3W *>( pHMtrg ), false, true, false );
		}
		else if( true == pHMSrc->IsClass( CLASS( CDS_HmHub ) ) )
		{
		}
		else if( true == pHMSrc->IsClass( CLASS( CDS_HmHubStation ) ) )
		{
		}
		else
		{
			pHMtrg->SetSchemeID( pHMSrc->GetSchemeID() );
			pHMSrc->Copy( pHMtrg, false, true, false );
		}

		if( false == bNoChildren && true == pHMSrc->IsaModule() )
		{
			CopyHMFromClipBoard( static_cast<CTable *>( IDptrNew.MP ), pHMSrc );
		}

		return IDptrNew;
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CTADatastruct::CreateCopyHM'."), __LINE__, __FILE__ );
		throw;
	}
}

CDS_TechnicalParameter *CTADatastruct::GetpTechParams()
{
	return dynamic_cast<CDS_TechnicalParameter *>( Get( _T("PARAM_TECH") ).MP );
}

CDS_WaterCharacteristic *CTADatastruct::GetpWCForProductSelection()
{
	return dynamic_cast<CDS_WaterCharacteristic *>( Get( _T("PARAM_WC") ).MP );
}

CDS_WaterCharacteristic *CTADatastruct::GetpWCForProject()
{
	return dynamic_cast<CDS_WaterCharacteristic *>( Get( _T("PROJ_WC") ).MP );
}

CDS_ProjectParams *CTADatastruct::GetpProjectParams()
{
	return dynamic_cast<CDS_ProjectParams *>( Get( _T("GENERAL_PARAMS") ).MP );
}

CDS_IndSelParameter *CTADatastruct::GetpIndSelParameter()
{
	return dynamic_cast<CDS_IndSelParameter *>( Get( _T("PARAM_INDSEL") ).MP );
}

CDS_BatchSelParameter *CTADatastruct::GetpBatchSelParameter()
{
	return dynamic_cast<CDS_BatchSelParameter *>( Get( _T("PARAM_BATCHSEL") ).MP );
}

CDS_WizardSelParameter *CTADatastruct::GetpWizardSelParameter()
{
	return dynamic_cast<CDS_WizardSelParameter *>( Get( _T("PARAM_WIZARDSEL") ).MP );
}

CDS_PersistData *CTADatastruct::GetpPersistData()
{
	return dynamic_cast<CDS_PersistData *>( Get( _T("PERSIST_DATA") ).MP );
}

CDB_PageSetup *CTADatastruct::GetpPageSetup()
{
	return dynamic_cast<CDB_PageSetup *>( Get( _T("PARAM_PAGESETUP") ).MP );
}

CDS_ProjectRef *CTADatastruct::GetpProjectRef()
{
	return dynamic_cast<CDS_ProjectRef *>( Get( _T("PROJECT_REF") ).MP );
}

CDS_UserRef *CTADatastruct::GetpUserRef()
{
	return dynamic_cast<CDS_UserRef *>( Get( _T("USER_REF") ).MP );
}

CTable *CTADatastruct::GetpHydroModTable()
{
	return dynamic_cast<CTable *>( Get( _T("PIPING_TAB") ).MP );
}

CTable *CTADatastruct::GetpClipboardTable()
{
	return dynamic_cast<CTable *>( Get( _T("CLIPBOARD_TABLE") ).MP );
}

CTable *CTADatastruct::GetpHUBSelectionTable()
{
	return dynamic_cast<CTable *>( Get( _T("SELHUB_TAB") ).MP );
}

CTable *CTADatastruct::GetpLogDataTable()
{
	return dynamic_cast<CTable *>( Get( _T("LOGDATA_TAB") ).MP );
}

CTable *CTADatastruct::GetpQuickMeasureTable()
{
	return dynamic_cast<CTable *>( Get( _T("QUICKMEAS_TAB") ).MP );
}

IDPTR CTADatastruct::CopyFirstHMFromClipBoard( CTable *pTabTarget )
{
	return ( CopyNextHMFromClipBoard( pTabTarget, true ) );
}

IDPTR CTADatastruct::CopyNextHMFromClipBoard( CTable *pTabTarget, bool bFirst )
{
	IDPTR idptr = GetNextHMFromClipBoard( bFirst );

	if( _T('\0') == *idptr.ID )
	{
		return _NULL_IDPTR;
	}

	return CreateCopyHM( idptr, pTabTarget );
}

int CTADatastruct::GetCountHMClipboard()
{
	int iCount = 0;
	CTable *pTab = GetpClipboardTable();
	ASSERT( NULL != pTab );

	for( IDPTR IDPtr = pTab->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pTab->GetNext() )
	{
		if( true ==  IDPtr.MP->IsHMFamily() )
		{
			iCount++;
		}
	}

	return iCount;
}

IDPTR CTADatastruct::GetFirstHMFromClipBoard()
{
	return GetNextHMFromClipBoard( true );
}

// Return Next HM from the clipboard, used with GetFirstHMFromClipBoard
IDPTR CTADatastruct::GetNextHMFromClipBoard( bool bFirst )
{
	CTable *pTab = GetpClipboardTable();
	ASSERT( NULL != pTab );

	IDPTR IDPtr = ( true == bFirst ) ? pTab->GetFirst() : pTab->GetNext();

	for( ; _T('\0') != *IDPtr.ID; IDPtr = pTab->GetNext() )
	{
		if( false == IDPtr.MP->IsHMFamily() )
		{
			continue;
		}

		break;
	}

	if( _T('\0') == *IDPtr.ID )
	{
		return _NULL_IDPTR;
	}

	return IDPtr;
}

////////////////////////////////////////////////////////////////////////////////
// Duplicate a valve in selected valve and update ID in the hydraulic module
IDPTR CTADatastruct::DuplicateHydroMod( const IDPTR &IDPtrParent, const IDPTR &IDPtrSrc, bool bSetUID )
{
	try
	{
		// Test if object is complete.
		IDPTR IDptrNew = _NULL_IDPTR;

		if( true == IDPtrSrc.MP->IsClass( CLASS( CDS_HydroMod ) ) )
		{
			CreateObject( IDptrNew, CLASS( CDS_HydroMod ) );

			// Fix scheme.
			if( NULL == ( static_cast<CDS_HydroMod *>( IDPtrSrc.MP ) )->GetSchemeIDPtr().MP )
			{
				IDPTR idptr = TASApp.GetpTADB()->Get( L"BV" );
				( static_cast<CDS_HydroMod *>( IDptrNew.MP ) )->Init( idptr, static_cast<CTable *>( IDPtrParent.MP ) );
			}
			else
			{
				( static_cast<CDS_HydroMod *>( IDptrNew.MP ) )->Init( ( static_cast<CDS_HydroMod *>( IDPtrSrc.MP ) )->GetSchemeIDPtr(), static_cast<CTable *>( IDPtrParent.MP ) );
			}
		}
		else if( true == IDPtrSrc.MP->IsClass( CLASS( CDS_Hm2W ) ) )
		{
			CreateObject( IDptrNew, CLASS( CDS_Hm2W ) );
			
			( static_cast<CDS_Hm2W *>( IDptrNew.MP ) )->Init( ( static_cast<CDS_Hm2W *>( IDPtrSrc.MP ) )->GetSchemeIDPtr(), static_cast<CTable *>( IDPtrParent.MP ),
					( static_cast<CDS_Hm2W *>( IDPtrSrc.MP ) )->GetpCV()->IsTaCV() );
		}
		else if( true == IDPtrSrc.MP->IsClass( CLASS( CDS_Hm2WInj ) ) )
		{
			CreateObject( IDptrNew, CLASS( CDS_Hm2WInj ) );

			( static_cast<CDS_Hm2WInj *>( IDptrNew.MP ) )->Init( ( static_cast<CDS_Hm2WInj *>( IDPtrSrc.MP ) )->GetSchemeIDPtr(), static_cast<CTable *>( IDPtrParent.MP ),
					( static_cast<CDS_Hm2WInj *>( IDPtrSrc.MP ) )->GetpCV()->IsTaCV() );
		}
		else if( true == IDPtrSrc.MP->IsClass( CLASS( CDS_Hm3WInj ) ) )
		{
			CreateObject( IDptrNew, CLASS( CDS_Hm3WInj ) );
			( static_cast<CDS_Hm3WInj *>( IDptrNew.MP ) )->Init( ( static_cast<CDS_Hm3WInj *>( IDPtrSrc.MP ) )->GetSchemeIDPtr(), static_cast<CTable *>( IDPtrParent.MP ),
					( static_cast<CDS_Hm3WInj *>( IDPtrSrc.MP ) )->GetpCV()->IsTaCV() );
		}
		else if( true == IDPtrSrc.MP->IsClass( CLASS( CDS_Hm3W ) ) )
		{
			CreateObject( IDptrNew, CLASS( CDS_Hm3W ) );
			
			( static_cast<CDS_Hm3W *>( IDptrNew.MP ) )->Init( ( static_cast<CDS_Hm3W *>( IDPtrSrc.MP ) )->GetSchemeIDPtr(), static_cast<CTable *>( IDPtrParent.MP ),
					( static_cast<CDS_Hm3W *>( IDPtrSrc.MP ) )->GetpCV()->IsTaCV() );
		}
		else if( true == IDPtrSrc.MP->IsClass( CLASS( CDS_HmHub ) ) )
		{
			CreateObject( IDptrNew, CLASS( CDS_HmHub ) );
			
			( static_cast<CDS_HmHub *>( IDptrNew.MP ) )->Init( ( static_cast<CDS_HmHub *>( IDPtrSrc.MP ) )->GetBalTypeID(), static_cast<CTable *>( IDPtrParent.MP ) );
		}
		else if( true == IDPtrSrc.MP->IsClass( CLASS( CDS_HmHubStation ) ) )
		{
			CreateObject( IDptrNew, CLASS( CDS_HmHubStation ) );
			
			( static_cast<CDS_HmHubStation *>( IDptrNew.MP ) )->Init( ( static_cast<CDS_HmHubStation *>( IDPtrSrc.MP ) )->GetBalTypeID(), static_cast<CTable *>( IDPtrParent.MP ) );
		}
		else
		{
			HYSELECT_THROW( _T("Internal error: 'IDPtrSrc' object ('%s) is an unknown class."), IDptrNew.ID );
		}

		( static_cast<CDS_HydroMod *>( IDPtrSrc.MP ) )->Copy( static_cast<CDS_HydroMod *>( IDptrNew.MP ) );
		( static_cast<CTable *>( IDPtrParent.MP ) )->Insert( IDptrNew );

		if( true == bSetUID )
		{
			( static_cast<CDS_HydroMod *>( IDptrNew.MP ) )->SetUid( GetpProjectParams()->GetNextUid() );
		}

		Extend( &IDptrNew );
		return IDptrNew;
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CTADatastruct::DuplicateHydroMod'."), __LINE__, __FILE__ );
		throw;
	}
}

////////////////////////////////////////////////////////////////////////////////
// Create a copy of a branch
void CTADatastruct::CopyTADSBranch( CTable *pHMFrom, CTable *pHMTo, bool bSetUID )
{
	if( NULL == pHMFrom )
	{
		return;
	}

	for( IDPTR IDPtr = pHMFrom->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pHMFrom->GetNext( IDPtr.MP ) )
	{
		IDPTR idptrNewHM = DuplicateHydroMod( pHMTo->GetIDPtr(), IDPtr, bSetUID );
		CopyTADSBranch( static_cast<CDS_HydroMod *>( IDPtr.MP ), static_cast<CDS_HydroMod *>( idptrNewHM.MP ), bSetUID );
	}
}

////////////////////////////////////////////////////////////////////////////////
// Return the last used index for this branch
int CTADatastruct::GetLastBranchPos( CTable *pHM )
{
	if( NULL == pHM )
	{
		return 0;
	}

	int iMaxPos = 0;

	for( IDPTR IDPtr = pHM->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pHM->GetNext() )
	{
		if( ( static_cast<CDS_HydroMod *>( IDPtr.MP ) )->GetPos() > iMaxPos )
		{
			iMaxPos = ( static_cast<CDS_HydroMod *>( IDPtr.MP ) )->GetPos();
		}
	}

	return iMaxPos;
}

////////////////////////////////////////////////////////////////////////////////
// Verify if the new index is "free". If the position is not free shift up
// all HM indices >= NewPos
// !!! Must be called before the index of the inserted HM is set
// !!! (otherwise its index is also shifted up!)
void CTADatastruct::VerifyNewPos( CTable *pTab, int iNewPos )
{
	// Verify if NewPos is free
	bool bFree = true;
	IDPTR IDPtr = _NULL_IDPTR;

	for( IDPtr = pTab->GetFirst(); _T('\0') != *IDPtr.ID && true == bFree; IDPtr = pTab->GetNext() )
	{
		if( ( static_cast<CDS_HydroMod *>( IDPtr.MP ) )->GetPos() == iNewPos )
		{
			bFree = false;
		}
	}

	// If NewPos is not free, shift up
	if( false == bFree )
	{
		for( IDPtr = pTab->GetFirst(); _T('\0') != *IDPtr.ID ; IDPtr = pTab->GetNext() )
		{
			int iIndex = ( static_cast<CDS_HydroMod *>( IDPtr.MP ) )->GetPos();

			// if the position is not free create a hole by shifting up all items after the new's one
			if( iIndex >= iNewPos )
			{
				( static_cast<CDS_HydroMod *>( IDPtr.MP ) )->SetPos( iIndex + 1 );
			}
		}
	}
}

int CTADatastruct::VerifyAndCleanEmptySSelObj()
{
	CArray<CString> Tads;
	Tads.Add( CString( _T("REGVALV_TAB") ) );
	Tads.Add( CString( _T("DPCONTR_TAB") ) );
	Tads.Add( CString( _T("RADSET_TAB") ) );

	CArray<CData *> ObjToClean;

	for( int i = 0; i < Tads.GetCount(); i++ )
	{
		CTable *pTab = dynamic_cast<CTable *>( TASApp.GetpTADS()->Get( Tads.GetAt( i ) ).MP );

		if( NULL != pTab )
		{
			for( IDPTR idptr = pTab->GetFirst(); _T('\0') != *idptr.ID; idptr = pTab->GetNext() )
			{
				switch( i )
				{
					case 0:	// REGVALV_TAB
					{
						CDS_SelManBv *pSel = dynamic_cast<CDS_SelManBv *>( idptr.MP );

						if( NULL != pSel )
						{
							if( _T('\0') == *pSel->GetValveIDPtr().ID )
							{
								ObjToClean.Add( idptr.MP );
							}
						}

						break;
					}

					case 1:	// DPCONTR_TAB
					{
						CDS_SelDpC *pSel = dynamic_cast<CDS_SelDpC *>( idptr.MP );

						if( NULL != pSel )
						{
							if( _T('\0') == *pSel->GetDpCIDPtr().ID )
							{
								ObjToClean.Add( idptr.MP );
							}
						}

						break;
					}
				}
			}
		}
	}

	for( int i = 0; i < ObjToClean.GetCount(); i++ )
	{
		CData *pData = ObjToClean.GetAt( i );
		IDPTR IDPtr = pData->GetIDPtr();

		if( NULL != IDPtr.PP )
		{
			IDPtr.PP->Remove( IDPtr );
		}

		DeleteObject( IDPtr );
	}

	return ObjToClean.GetCount();
}

void CTADatastruct::VerifyBatchSelParameter()
{
	if( _ttoi( GetVersion() ) > 4233 )
	{
		return;
	}

	CDS_BatchSelParameter *pclBatchSelParameters = GetpBatchSelParameter();

	if( NULL == pclBatchSelParameters )
	{
		return;
	}

	pclBatchSelParameters->VerifyIntegrity();
}

void CTADatastruct::VerifyMeasTaBalDateTime()
{
	CTableHM *pHNTab = dynamic_cast<CTableHM *>( GetpHydroModTable() );
	ASSERT( NULL != pHNTab );

	if( NULL != pHNTab )
	{
		pHNTab->VerifyMeasTABalDateTime();
	}
}

void CTADatastruct::VerifyQuickMeasurements()
{
	CDS_HydroModX *pclHydroModX = dynamic_cast<CDS_HydroModX *>( GetpQuickMeasureTable() );

	if( NULL == pclHydroModX || 0 == pclHydroModX->GetItemCount() )
	{
		return;
	}

	// Sometimes there is a bug with the date & time of measures coming from TA Scope (Values are negative).
	// In this case, we reset the date & time. But we can't reset to 0. Because 0 is used to check if measures
	// exist or not. Thus we reset to 1. We increment each reseting because to check if two measures are the same
	// we check if they have the same date & time.
	int iMeasDateTime = 1;

	for( IDPTR IDPtr = pclHydroModX->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pclHydroModX->GetNext( IDPtr.MP ) )
	{
		CDS_HydroModX *pHMX = dynamic_cast<CDS_HydroModX *>( IDPtr.MP );

		if( NULL == pHMX )
		{
			continue;
		}

		__time32_t time = pHMX->GetMeasDateTime();

		if( time < 0 && pHMX->GetQMType() != CDS_HydroModX::QMundef )
		{
			pHMX->SetMeasDateTime( iMeasDateTime++ );
		}

		// No TABalDateTime for quick measure.
		pHMX->SetTABalDateTime( 0 );
	}
}

void CTADatastruct::VerifyWaterCharAndTechnicalParameters( ProjectType eOldSelectionApplicationType )
{
	if( NULL == GetpTechParams() || NULL == GetpWCForProject() || NULL == GetpWCForProductSelection() )
	{
		ASSERT_RETURN;
	}

	if( ChangeOver != GetpTechParams()->GetProductSelectionApplicationType() && ProjectType::ChangeOver == eOldSelectionApplicationType )
	{
		// HYS-1146 : If application type is not change-over but user was in change-over before opening the project, we reset the 
		// application type to change-over.
		GetpTechParams()->SetProductSelectionApplicationType( ChangeOver );
		CWaterChar *pWC = GetpWCForProductSelection()->GetpWCData();
		*pWC = *( GetpTechParams()->GetDefaultISChangeOverWC( CoolingSide ) );
	}
	else if( ChangeOver == GetpTechParams()->GetProductSelectionApplicationType() && ProjectType::ChangeOver != eOldSelectionApplicationType )
	{
		// HYS-1380: If application type is change-over but user was not in change-over before opening the project, we reset the
		// application type to the previous application type.
		GetpTechParams()->SetProductSelectionApplicationType( eOldSelectionApplicationType );
		CWaterChar* pWC = GetpWCForProductSelection()->GetpWCData();
		*pWC = *(GetpTechParams()->GetDefaultISWC());
	}
	else if( ChangeOver != GetpTechParams()->GetProductSelectionApplicationType() )
	{
		CWaterChar* pWC = GetpWCForProductSelection()->GetpWCData();
		// HYS-1622: Before this card, in some circumstances, CDS_WaterCharacteristic::m_WC.b_IsForChangeOver was set to true when we are not in changeOver.
		// For these old projects we have to set m_WC.b_IsForChangeOver with the correct value.
		if( true == pWC->GetIsForChangeOver() )
		{
			pWC->SetIsForChangeOver( false );
		}
	}

	if( GetpTechParams()->GetVersion() > 27 )
	{
		return;
	}

	GetpTechParams()->SetDefaultPrjTps( GetpWCForProject()->GetTemp() );
	GetpTechParams()->SetDefaultISTps( GetpWCForProductSelection()->GetTemp() );
}

void CTADatastruct::VerifyProjectAllWaterCharacteristics( bool bDeepestToHighest )
{
	CTableHM *pclNetwork = dynamic_cast<CTableHM *>( GetpHydroModTable() );
	ASSERT( NULL != pclNetwork );

	// HYS-1882: Add a boolean to determine how we loop through the project.
	pclNetwork->VerifyAllWaterCharacteristics( bDeepestToHighest );
}

void CTADatastruct::VerifyAllBVSecForAll3WayCircuits()
{
	int iVersion = _ttoi( GetVersion() );

	if( iVersion < 4045 || iVersion > 4047 )
	{
		return;
	}

	CTableHM *pclNetwork = dynamic_cast<CTableHM *>( GetpHydroModTable() );
	ASSERT( NULL != pclNetwork );

	pclNetwork->VerifyAllBVSecForAll3WayCircuits();
}

void CTADatastruct::AddUsedUserPipesBeforeSavingProject()
{
	// HYS-1590: We add only user pipes that are really used in the project.
	// We will run hydromod and product selection.
	std::vector<CTable *> vecUsedUserPipeSeriesInProject;

	_RunAllPipesInTheDatastruct( &CTADatastruct::_CheckIfUserPipeSeriesToAdd, (LPARAM)&vecUsedUserPipeSeriesInProject );

	TASApp.GetpPipeDB()->CopyPipeSeriesTo( vecUsedUserPipeSeriesInProject, TASApp.GetpPipeDB()->GetPipeTab( this ) );
}

void CTADatastruct::VerifyPipeSeriesWhenOpeningProject( std::vector<CString> *pvecPipeSeriesInProjectNotInHySelect, std::vector<CString> *pvecPipeSeriesInProjectButDeletednInHySelect )
{
	// HYS-1590: Verify old pipes IDs when opening a project.

	if( NULL == pvecPipeSeriesInProjectNotInHySelect || NULL == pvecPipeSeriesInProjectButDeletednInHySelect )
	{
		ASSERT_RETURN;
	}

	// We run hydromod and product selection to change all the references on pipe series and pipes that are made with old ID.
	// We can in the same time check if pipes used are or not in HySelect or are or not deleted.
	std::pair< std::vector<CString> *, std::vector<CString> *> pairParam( pvecPipeSeriesInProjectNotInHySelect, pvecPipeSeriesInProjectButDeletednInHySelect );
	_RunAllPipesInTheDatastruct( &CTADatastruct::_UpdateOneOldPipeID, (LPARAM)&pairParam );
}

////////////////////////////////////////////////////////////////////////////////
// Scan recursively a Hydromod table to verify and to correct if needed position in the module
// Return false if something as been corrected
bool CTADatastruct::VerifyAndCorrectPosition( CTable *pTab )
{
	if( NULL == pTab )
	{
		pTab = GetpHydroModTable();

		if( NULL == pTab )
		{
			return false;
		}
	}

	bool bReturn = true;
	CRank rkList;
	IDPTR IDPtr = _NULL_IDPTR;
	CDS_HydroMod *pHM = NULL;

	for( IDPtr = pTab->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pTab->GetNext( IDPtr.MP ) )
	{
		pHM = static_cast<CDS_HydroMod *>( IDPtr.MP );

		if( NULL == pHM )
		{
			continue;
		}

		if( true == pHM->IsaModule() )
		{
			bReturn = VerifyAndCorrectPosition( pHM );
		}

		rkList.Add( _T(""), pHM->GetPos(), ( LPARAM )pHM );
	}

	CString str;
	int iPos = 1;
	pHM = NULL;

	for( BOOL bContinue = rkList.GetFirstT<CDS_HydroMod *>( str, pHM ); TRUE == bContinue; bContinue = rkList.GetNextT<CDS_HydroMod *>( str, pHM ) )
	{
		if( NULL == pHM )
		{
			return false;
		}

		if( iPos != pHM->GetPos() )
		{
			bReturn = false;
			pHM->SetPos( iPos );
			ComposeValveName( pHM->GetIDPtr() );
		}

		iPos++;
	}

	return bReturn;
}

////////////////////////////////////////////////////////////////////////////////
// Change module position in his parent
void CTADatastruct::ChangePosition( CDS_HydroMod *pHM, int iNewPos )
{
	ASSERT( iNewPos > 0 );
	ASSERT( iNewPos <= GetLastBranchPos( pHM->GetIDPtr().PP ) );

	if( iNewPos <= 0 )
	{
		return;
	}

	if( iNewPos > GetLastBranchPos( pHM->GetIDPtr().PP ) )
	{
		return;
	}

	int iOldPos = pHM->GetPos();

	if( iOldPos != iNewPos )
	{
		CTable *pTab = static_cast<CTable *>( pHM->GetIDPtr().PP );
		ASSERT( pTab );

		if( NULL == pTab )
		{
			return;
		}

		// OldPos circuit will inserted in place of NewPos circuit
		for( IDPTR IDPtr = pTab->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pTab->GetNext( IDPtr.MP ) )
		{
			CDS_HydroMod *pHMcur = static_cast<CDS_HydroMod *>( IDPtr.MP );

			// Skip originate module
			if( pHMcur == pHM )
			{
				continue;
			}

			if( iOldPos < iNewPos )
			{
				if( pHMcur->GetPos() > iOldPos && pHMcur->GetPos() <= iNewPos )
				{
					pHMcur->SetPos( pHMcur->GetPos() - 1 );
				}
			}
			else /*OldPos > NewPos*/
			{
				if( pHMcur->GetPos() < iOldPos && pHMcur->GetPos() >= iNewPos )
				{
					pHMcur->SetPos( pHMcur->GetPos() + 1 );
				}
			}

			// Is automatic name rename it
			if( true == pHMcur->GetHMName().IsEmpty() || _T('*') == pHMcur->GetHMName().GetAt( 0 ) )
			{
				pHMcur->SetHMName( _T("*") );

				if( 0 == pHMcur->GetLevel() )
				{
					CString str;
					ComposeRMName( str, pHMcur, pHMcur->GetPos() );
					pHMcur->SetHMName( (LPCTSTR)str );
				}
				else
				{
					ComposeValveName( IDPtr );
				}
			}
		}
	}

	pHM->SetPos( iNewPos );

	// Is automatic name rename it
	if( true == pHM->GetHMName().IsEmpty() || _T('*') == pHM->GetHMName().GetAt( 0 ) )
	{
		pHM->SetHMName( _T("*") );

		if( 0 == pHM->GetLevel() )
		{
			CString str;
			ComposeRMName( str, pHM, pHM->GetPos() );
			pHM->SetHMName( (LPCTSTR)str );
		}
		else
		{
			ComposeValveName( pHM->GetIDPtr() );
		}
	}
}

////////////////////////////////////////////////////////////////////////////////
// Reindex the modules of pTab if the deleted index generates a hole in the indexing
void CTADatastruct::RemoveIndexHole( CTable *pTab, int iDeletedIndex )
{
	for( IDPTR IDPtr = pTab->GetFirst(); _T('\0') != *IDPtr.ID ; IDPtr = pTab->GetNext() )
	{
		int iIndex = ( static_cast<CDS_HydroMod *>( IDPtr.MP ) )->GetPos();

		if( iIndex > iDeletedIndex )
		{
			( static_cast<CDS_HydroMod *>( IDPtr.MP ) )->SetPos( iIndex - 1 );
		}
	}
}

void CTADatastruct::SetNewIndex( CString strName, SNI_ArgumentType eArgType )
{
	// The aim of this function is to set index for a specific class object to keep the same order as the insert.
	// Typically this method is called in 'CDlgConfSel::OnOK()' after selection has been inserted in CTADatastruct.

	CString strTableID = _T("");

	if( SNI_ArgumentType::SNI_ClassName == eArgType )
	{
		if( strName == CLASS( CDS_SSelBv ) )
		{
			strTableID = _T("REGVALV_TAB");
		}
		else if( strName == CLASS( CDS_SSelDpC ) )
		{
			strTableID = _T("DPCONTR_TAB");
		}
		else if( strName == CLASS( CDS_SSelDpReliefValve ) )
		{
			strTableID = _T("DPCONTR_TAB");
		}
		else if( strName == CLASS( CDS_SSelBCv ) )
		{
			strTableID = _T("CTRLVALVE_TAB");
		}
		else if( strName == CLASS( CDS_SSelCv ) )
		{
			strTableID = _T("CTRLVALVE_TAB");
		}
		else if( strName == CLASS( CDS_SSelPICv ) )
		{
			strTableID = _T("CTRLVALVE_TAB");
		}
		else if( strName == CLASS( CDS_SSelRadSet ) )
		{
			strTableID = _T("RADSET_TAB");
		}
		else if( strName == CLASS( CDS_SSelAirVentSeparator ) )
		{
			strTableID = _T("AIRVENTSEP_TAB");
		}
		else if( strName == CLASS( CDS_SSelPMaint ) )
		{
			strTableID = _T("PRESSMAINT_TAB");
		}
		else if( strName == CLASS( CDS_SSelDpCBCV ) )
		{
			strTableID = _T("DPCBCVALVE_TAB");
		}
		else if( strName == CLASS( CDS_SSelSv ) )
		{
			strTableID = _T("SHUTOFF_TAB");
		}
		else if( strName == CLASS( CDS_SSelSafetyValve ) )
		{
			strTableID = _T("SAFETYVALVE_TAB");
		}
		else if( strName == CLASS( CDS_SSel6WayValve ) )
		{
			strTableID = _T("6WAYCTRLVALV_TAB");
		}
		else if( strName == CLASS( CDS_SSelFloorHeatingManifold ) )
		{
			strTableID = _T("FLOORHCTRL_TAB");
		}
		else if( strName == CLASS( CDS_SSelFloorHeatingController ) )
		{
			strTableID = _T("FLOORHCTRL_TAB");
		}
		else if( strName == CLASS( CDS_SSelTapWaterControl ) )
		{
			strTableID = _T("TAPWATERCTRL_TAB");
		}
		else if( strName == CLASS( CDS_SSelSmartControlValve ) )
		{
			strTableID = _T("SMARTCONTROLVALVE_TAB");
		}
		else if( strName == CLASS( CDS_SSelSmartDpC ) )
		{
			strTableID = _T("SMARTDPC_TAB");
		}
		// HYS-2007: Add CDS_SSelDpSensor for TA Link selected alone.
		else if( strName == CLASS( CDS_SSelDpSensor ) )
		{
			strTableID = _T("DPCONTR_TAB");
		}
	}
	else
	{
		strTableID = strName;
	}

	CTable *pTab = dynamic_cast<CTable *>( Get( strTableID ).MP );

	if( NULL != pTab )
	{
		// Search for last index.
		int iIndex = 0;
		IDPTR IDPtr = _NULL_IDPTR;

		for( IDPtr = pTab->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pTab->GetNext() )
		{
			CDS_SelProd *pclSelProd = dynamic_cast<CDS_SelProd *>( IDPtr.MP );
			CDS_SSelPMaint *pclSSelPMaint = dynamic_cast<CDS_SSelPMaint *>( IDPtr.MP );

			if( NULL != pclSelProd )
			{
				if( NULL == pclSelProd->GetpSelectedInfos() )
				{
					continue;
				}

				if( pclSelProd->GetpSelectedInfos()->GetRowIndex() > iIndex )
				{
					iIndex = pclSelProd->GetpSelectedInfos()->GetRowIndex();
				}
			}
			else if( NULL != pclSSelPMaint )
			{
				if( NULL == pclSSelPMaint->GetpSelectedInfos() )
				{
					continue;
				}

				if( pclSSelPMaint->GetpSelectedInfos()->GetRowIndex() > iIndex )
				{
					iIndex = pclSSelPMaint->GetpSelectedInfos()->GetRowIndex();
				}
			}
		}

		// New index.
		iIndex++;

		for( IDPtr = pTab->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pTab->GetNext() )
		{
			CDS_SelProd *pclSelProd = dynamic_cast<CDS_SelProd *>( IDPtr.MP );
			CDS_SSelPMaint *pclSSelPMaint = dynamic_cast<CDS_SSelPMaint *>( IDPtr.MP );

			if( NULL != pclSelProd )
			{
				if( NULL == pclSelProd->GetpSelectedInfos() )
				{
					continue;
				}

				if( 0 == pclSelProd->GetpSelectedInfos()->GetRowIndex() )
				{
					pclSelProd->GetpSelectedInfos()->SetRowIndex( iIndex++ );
				}
			}
			else if( NULL != pclSSelPMaint )
			{
				if( NULL == pclSSelPMaint->GetpSelectedInfos() )
				{
					continue;
				}

				if( 0 == pclSSelPMaint->GetpSelectedInfos()->GetRowIndex() )
				{
					pclSSelPMaint->GetpSelectedInfos()->SetRowIndex( iIndex++ );
				}
			}
		}
	}
}

void CTADatastruct::SetIndex( CString strTabID )
{
	if( true == strTabID.IsEmpty() )
	{
		return;
	}

	CTable *pTab = static_cast<CTable *>( Get( (LPCTSTR)strTabID ).MP );
	ASSERT( NULL != pTab );

	int iIndex = 0;				// Search for minus index
	iIndex++;					// New index

	for( IDPTR IDPtrDS = pTab->GetFirst(); _T('\0') != *IDPtrDS.ID; IDPtrDS = pTab->GetNext() )
	{
		( static_cast<CDS_SelThing *>( IDPtrDS.MP ) )->SetRowIndex( iIndex++ );
	}

}

// Move a hydromod to another position in the installation, connect it to a PV if necessary.
unsigned short CTADatastruct::MoveHydroMod( CDS_HydroMod *pHMFrom, CTable *pHMTo, bool bKeepUid )
{
	try
	{
		int iNewPos = GetLastBranchPos( pHMTo ) + 1;

		CDlgPasteHM	dlg;

		if( true == pHMFrom->IsaModule() )
		{
			if( true == pHMTo->IsClass( CLASS( CTableHM ) ) || true == static_cast<CDS_HydroMod *>( pHMTo )->IsaModule() )
			{
				if( IDOK != dlg.Display( pHMFrom, &pHMTo, &iNewPos ) )
				{
					return 0;
				}
			}
		}

		// At the end of CDlgPasteHM, NewPos is updated and
		// if the user connects the copied module to an existing valve,
		// pHMTo is updated with this existing valve

		// Connect the module to an existing valve; this valve becomes a partner valve...
		if( false == pHMTo->IsClass( CLASS( CTableHM ) ) && false == ( static_cast<CDS_HydroMod *>( pHMTo ) )->IsaModule() )
		{
			// Move each children of pHMFrom to the new PV.
			for( IDPTR IDPtr = pHMFrom->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pHMFrom->GetNext() )
			{
				pHMFrom->Remove( IDPtr );		// disconnect child
				pHMTo->Insert( IDPtr );			// insert it into the new Pv
			}

			// Delete the old parent module.
			int iHMFromIndex = pHMFrom->GetPos();	// Keep the index before deleting pHMFrom
			IDPTR IDPtrFrom = pHMFrom->GetIDPtr();
			CTable *pPTab = static_cast<CTable *>( IDPtrFrom.PP );
			( IDPtrFrom.PP )->Remove( IDPtrFrom );
			DeleteObject( IDPtrFrom );

			// Reindex the modules of pPTab if the deletion of pHM has created a hole in the indexing.
			if( iHMFromIndex > 0 )
			{
				RemoveIndexHole( pPTab, iHMFromIndex );
			}

			// Change UID.
			if( false == bKeepUid )
			{
				SetHMUid( pHMTo );
			}

			// Reset Level to a correct value.
			SetHMLevel( pHMTo, ( static_cast<CDS_HydroMod *>( pHMTo ) )->GetLevel() );

			// The new PV becomes a module.
			// Remark: we need to do that after the module has it's good level set.
			( static_cast<CDS_HydroMod *>( pHMTo ) )->SetFlagModule( true );
		}
		else
		{
			// Just Move the branch to the new position.
			int iHMFromIndex = pHMFrom->GetPos();	// Keep the index before deleting pHMFrom
			IDPTR IDPtrFrom = pHMFrom->GetIDPtr();
			CTable *pPTab = static_cast<CTable *>( IDPtrFrom.PP );
			( IDPtrFrom.PP )->Remove( IDPtrFrom );
			pHMTo->Insert( IDPtrFrom );

			// Verify if the new index is free, if not shift up.
			VerifyNewPos( pHMTo, iNewPos );
			pHMFrom->SetPos( iNewPos );

			// Reindex the modules of pPTab if the deletion of pHM has created a hole in the indexing
			RemoveIndexHole( pPTab, iHMFromIndex );

			// Change UID.
			if( false == bKeepUid )
			{
				SetHMUid( static_cast<CTable *>( pHMFrom ) );
			}

			// Reset Level to a correct value.
			if( true == pHMTo->IsClass( CLASS( CTableHM ) ) )		// Drop on the Hydraulic network
			{
				SetHMLevel( pHMFrom, 0 );
			}
			else
			{
				SetHMLevel( pHMFrom, ( static_cast<CDS_HydroMod *>( pHMTo ) )->GetLevel() + 1 );
			}
		}

		// Resize all the installation.
		// Do compute only if we are in the hydronic circuit calculation mode and the project is not frozen.
		CDS_ProjectParams *pPrjParam = GetpProjectParams();
		ASSERT( NULL != pPrjParam );

		if( eb3True == IsHMCalcMode() && true == pMainFrame->IsHMCalcChecked() && false == pPrjParam->IsFreezed() )
		{
			ComputeAllInstallation();
		}

		return ( static_cast<CDS_HydroMod *>( pHMTo ) )->GetUid();
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CTADatastruct::MoveHydroMod'."), __LINE__, __FILE__ );
		throw;
	}
}

// return true if we are in HMCalcMode
eBool3 CTADatastruct::IsHMCalcMode( CTable *pTab, bool bAtLeastOne )
{
	if( NULL == pTab )
	{
		pTab = GetpHydroModTable();

		// At least one entry
		if( NULL == pTab->GetFirst().MP )
		{
			return eb3Undef;
		}
	}

	ASSERT( NULL != pTab );

	if( NULL == pTab )
	{
		return eb3Undef;
	}

	// Only one is needed to return true
	if( bAtLeastOne )
	{
		for( IDPTR IDPtr = pTab->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pTab->GetNext( IDPtr.MP ) )
		{
			CDS_HydroMod *pHM = static_cast<CDS_HydroMod *>( IDPtr.MP );

			if( true == pHM->IsHMCalcMode() )
			{
				return eb3True;
			}

			if( true == pHM->IsaModule() )
			{
				if( IsHMCalcMode( pHM, bAtLeastOne ) )
				{
					return eb3True;
				}
			}
		}

		return eb3False;
	}
	// All must be in HMCalc to return true
	else
	{
		for( IDPTR IDPtr = pTab->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pTab->GetNext( IDPtr.MP ) )
		{
			CDS_HydroMod *pHM = static_cast<CDS_HydroMod *>( IDPtr.MP );

			if( false == pHM->IsHMCalcMode() )
			{
				return eb3False;
			}

			if( true == pHM->IsaModule() )
			{
				if( false == IsHMCalcMode( pHM, bAtLeastOne ) )
				{
					return eb3False;
				}
			}
		}

		return eb3True;
	}

	return eb3Undef;
}

void CTADatastruct::SetUserForcedHMCalcModeFlag( bool bUserForcedHMCalcMode )
{
	CDS_ProjectParams *pProjectParams = GetpProjectParams();
	ASSERT( NULL != pProjectParams );

	if( NULL != pProjectParams )
	{
		pProjectParams->SetUserForcedHMCalcModeFlag( bUserForcedHMCalcMode );
	}
}

bool CTADatastruct::GetUserForcedHMCalcModeFlag()
{
	bool bFlag = false;
	CDS_ProjectParams *pProjectParams = GetpProjectParams();
	ASSERT( NULL != pProjectParams );

	if( NULL != pProjectParams )
	{
		bFlag = pProjectParams->GetUserForcedHMCalcModeFlag();
	}

	return bFlag;
}

bool CTADatastruct::IsOldProject()
{
	bool bFlag = false;
	CDS_ProjectParams *pProjectParams = GetpProjectParams();
	ASSERT( NULL != pProjectParams );

	if( NULL != pProjectParams )
	{
		bFlag = pProjectParams->IsOldProject();
	}

	return bFlag;
}

// Do a loop on all module and define the module to be compatible in HydroCalc Mode
void CTADatastruct::CompleteProjForHydroCalcMode( CTable *pTab, bool bLock )
{
	if( NULL == pTab )
	{
		pTab = GetpHydroModTable();
	}

	ASSERT( NULL != pTab );

	if( NULL == pTab )
	{
		return;
	}

	for( IDPTR IDPtr = pTab->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pTab->GetNext( IDPtr.MP ) )
	{
		CDS_HydroMod *pHM = static_cast<CDS_HydroMod *>( IDPtr.MP );

		if( NULL != pHM )
		{
			pHM->CompleteHMForHydroCalcMode( pTab, bLock );

			if( true == pHM->IsaModule() )
			{
				CompleteProjForHydroCalcMode( pHM, bLock );
			}
		}
	}
}

// Do a loop on all modules and lock all valves in it
void CTADatastruct::SetHMValvesLock( bool bLock, CTable *pTab )
{
	if( NULL == pTab )
	{
		pTab = GetpHydroModTable();
	}

	ASSERT( NULL != pTab );

	if( NULL == pTab )
	{
		return;
	}

	for( IDPTR IDPtr = pTab->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pTab->GetNext( IDPtr.MP ) )
	{
		CDS_HydroMod *pHM = static_cast<CDS_HydroMod *>( IDPtr.MP );
		pHM->SetLock( CDS_HydroMod::eHMObj::eBVprim, bLock );
		pHM->SetLock( CDS_HydroMod::eHMObj::eBVbyp, bLock );
		pHM->SetLock( CDS_HydroMod::eHMObj::eBVsec, bLock );
		pHM->SetLock( CDS_HydroMod::eHMObj::eDpC, bLock );
		pHM->SetLock( CDS_HydroMod::eHMObj::eCV, bLock );
		pHM->SetLock( CDS_HydroMod::eHMObj::eShutoffValveSupply, bLock );
		pHM->SetLock( CDS_HydroMod::eHMObj::eShutoffValveReturn, bLock );

		if( true == pHM->IsaModule() )
		{
			SetHMValvesLock( bLock, pHM );
		}
	}
}

// Do a loop on all module and verify if one Bv is partially define
bool CTADatastruct::IsOneValveNotDefine( CTable *pTab )
{
	if( NULL == pTab )
	{
		pTab = GetpHydroModTable();
	}

	ASSERT( NULL != pTab );

	if( NULL == pTab )
	{
		return false;
	}

	for( IDPTR IDPtr = pTab->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pTab->GetNext( IDPtr.MP ) )
	{
		// Define the HydroMod
		CDS_HydroMod *pHM = static_cast<CDS_HydroMod *>( IDPtr.MP );

		// Do a test to verify if the valve is define by its Kv
		if( pHM->GetKvCv() != 0.0 )
		{
			return true;
		}

		// Do a test to verify the valve is not define by the CBI
		if( pHM->GetVDescrType() == enum_VDescriptionType::edt_CBISizeInchValve
				|| pHM->GetVDescrType() == enum_VDescriptionType::edt_CBISizeValve )
		{
			return true;
		}

		if( true == pHM->IsaModule() )
		{
			if( true == IsOneValveNotDefine( pHM ) )
			{
				return true;
			}
		}
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////
// Compute Each root module
bool CTADatastruct::ComputeAllInstallation()
{
	//Main table
	CDS_ProjectParams *pPrjParam = GetpProjectParams();
	ASSERT( NULL != pPrjParam );

	CDlgHMCompilationOutput::CHMInterface clOutputInterface;

	if( true == pPrjParam->GetHNAutomaticCheck() )
	{
		SetCheckAllModules( true );
		clOutputInterface.ClearOutput();
		clOutputInterface.BlockOutput();
	}
	else
	{
		SetCheckAllModules( false );
	}

	CTable *pTab = GetpHydroModTable();
	ASSERT( NULL != pTab );

	for( IDPTR IDPtr = pTab->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pTab->GetNext( IDPtr.MP ) )
	{
		CDS_HydroMod *pHM = static_cast<CDS_HydroMod *>( IDPtr.MP );

		if( NULL != pHM && true == pHM->IsHMCalcMode() )
		{
			( static_cast<CDS_HydroMod *>( IDPtr.MP ) )->ComputeAll( true );
		}
		else
		{
			SetCheckAllModules( false );
			return false;
		}
	}

	SetCheckAllModules( false );
	clOutputInterface.ReleaseOutput();

	return true;
}

void CTADatastruct::VerifyAllRootModules()
{
	//Main table
	SetCheckAllModules( true );
	CDlgHMCompilationOutput::CHMInterface clOutputInterface;
	clOutputInterface.ClearOutput();
	clOutputInterface.BlockOutput();

	CTable *pTab = GetpHydroModTable();
	ASSERT( NULL != pTab );

	for( IDPTR IDPtr = pTab->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pTab->GetNext( IDPtr.MP ) )
	{
		CDS_HydroMod *pHM = static_cast<CDS_HydroMod *>( IDPtr.MP );

		if( NULL != pHM && true == pHM->IsHMCalcMode() )
		{
			clOutputInterface.FillAndSendMessage( IDS_INFOMSG_HM_ANALYZESTARTED, CDlgHMCompilationOutput::Comment, NULL, _T(""), pHM->GetHMName() );
			VerifyInstallation( pHM );
			clOutputInterface.FillAndSendMessage( IDS_INFOMSG_HM_ANALYZEFINISHED, CDlgHMCompilationOutput::Comment, NULL, _T(""), pHM->GetHMName() );
		}
	}

	SetCheckAllModules( false );
	clOutputInterface.ReleaseOutput();
}

void CTADatastruct::_SendValidityHMErrMessage( CDS_HydroMod *pHM, CDB_TAProduct *pTAP, int iValidityFlag )
{
	CDlgHMCompilationOutput::CHMInterface clOutputInterface;

	if( CDS_HydroMod::eValidityFlags::evfTempTooHigh == (iValidityFlag & CDS_HydroMod::eValidityFlags::evfTempTooHigh ) )
	{
		clOutputInterface.FillAndSendMessage( IDS_ERRMSG_HM_FLUIDTEMPNOTMATCH, CDlgHMCompilationOutput::Error, pHM, L"", pTAP->GetName() );
	}

	if( CDS_HydroMod::eValidityFlags::evfDpTooHigh == ( iValidityFlag & CDS_HydroMod::eValidityFlags::evfDpTooHigh ) )
	{
		clOutputInterface.FillAndSendMessage( IDS_WARNMSG_HM_DIFFPRESSTOOHIGH, CDlgHMCompilationOutput::Error, pHM, L"", pTAP->GetName() );
	}

	if( CDS_HydroMod::eValidityFlags::evfMaxDpTooHigh == ( iValidityFlag & CDS_HydroMod::eValidityFlags::evfMaxDpTooHigh ) )
	{
		clOutputInterface.FillAndSendMessage( IDS_WARNMSG_HM_MAXDIFFPRESSTOOHIGH, CDlgHMCompilationOutput::Error, pHM, L"", pTAP->GetName() );
	}

	if( CDS_HydroMod::eValidityFlags::evfDpTooLow == ( iValidityFlag & CDS_HydroMod::eValidityFlags::evfDpTooLow ) )
	{
		clOutputInterface.FillAndSendMessage( IDS_WARNMSG_HM_DIFFPRESSTOOLOW, CDlgHMCompilationOutput::Warning, pHM, L"", pTAP->GetName() );
	}

	if( CDS_HydroMod::eValidityFlags::evfDpSignalTooHigh == ( iValidityFlag & CDS_HydroMod::eValidityFlags::evfDpSignalTooHigh ) )
	{
		clOutputInterface.FillAndSendMessage( IDS_WARNMSG_HM_DPSIGNALTOOHIGH, CDlgHMCompilationOutput::Error, pHM, L"", pTAP->GetName() );
	}

	if( CDS_HydroMod::eValidityFlags::evfDpSignalTooLow == ( iValidityFlag & CDS_HydroMod::eValidityFlags::evfDpSignalTooLow ) )
	{
		clOutputInterface.FillAndSendMessage( IDS_WARNMSG_HM_DPSIGNALTOOLOWER, CDlgHMCompilationOutput::Warning, pHM, L"", pTAP->GetName() );
	}

	if( CDS_HydroMod::eValidityFlags::evfFlowTooHigh == ( iValidityFlag & CDS_HydroMod::eValidityFlags::evfFlowTooHigh ) )
	{
		clOutputInterface.FillAndSendMessage( IDS_ERRMSG_HM_FLOWTOOHIGH, CDlgHMCompilationOutput::Error, pHM, L"", pTAP->GetName() );
	}

	if( CDS_HydroMod::eValidityFlags::evfFlowTooLow == ( iValidityFlag & CDS_HydroMod::eValidityFlags::evfFlowTooLow ) )
	{
		clOutputInterface.FillAndSendMessage( IDS_ERRMSG_HM_FLOWTOOLOW, CDlgHMCompilationOutput::Error, pHM, L"", pTAP->GetName() );
	}
}

void CTADatastruct::RefreshAllSecondaryWCForHMCalc( CTable *pclTable )
{
	if( NULL == pclTable )
	{
		pclTable = GetpHydroModTable();
		ASSERT( NULL != pclTable );	
		
		// For each root module.
		for( IDPTR IDPtrTab = pclTable->GetFirst(); _T('\0') != *IDPtrTab.ID; IDPtrTab = pclTable->GetNext( IDPtrTab.MP ) )
		{
			CDS_HydroMod *pHM = static_cast<CDS_HydroMod *>( IDPtrTab.MP );

			if( NULL == pHM )
			{
				continue;
			}
			
			// Scan all children, go deeper into HM struct.
			for( IDPTR IDPtr = pHM->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pHM->GetNext( IDPtr.MP ) )
			{
				CDS_HydroMod *pChildHM = dynamic_cast<CDS_HydroMod *>( IDPtr.MP );

				if( true == pChildHM->IsaModule() )
				{
					// It's a module, go deeper
					RefreshAllSecondaryWCForHMCalc( pChildHM );
				}
				else
				{
					CDS_HmInj *pcHM = dynamic_cast<CDS_HmInj *>( IDPtr.MP );
					
					if( NULL == pcHM )
					{
						continue;
					}
					
					pcHM->UpdateTUTemperaturesForInjectionCircuit();
				}
			}

			CDS_HmInj *pHMInj = dynamic_cast<CDS_HmInj *>( pHM );
					
			if( NULL == pHMInj )
			{
				continue;
			}
					
			pHMInj->UpdateTUTemperaturesForInjectionCircuit();
		}
	}
	else
	{
		CDS_HydroMod *pHM = dynamic_cast<CDS_HydroMod *>( pclTable );
		
		// Update parent before children.
		if( NULL != dynamic_cast<CDS_HmInj *>( pHM ) )
		{
			( dynamic_cast<CDS_HmInj *>( pHM ) )->UpdateTUTemperaturesForInjectionCircuit();
		}
		
		// Scan all children, go deeper into HM struct.
		for( IDPTR IDPtr = pHM->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pHM->GetNext( IDPtr.MP ) )
		{
			CDS_HydroMod *pParentHM = dynamic_cast<CDS_HydroMod *>( IDPtr.MP );
			
			if( true == pParentHM->IsaModule() )
			{
				// It's a module, go deeper.
				RefreshAllSecondaryWCForHMCalc( pParentHM );
			}
			else
			{
				CDS_HmInj *pcHM = dynamic_cast<CDS_HmInj *>( IDPtr.MP );
				
				if( NULL == pcHM )
				{
					continue;
				}
				
				pcHM->UpdateTUTemperaturesForInjectionCircuit();
			}
		}
	}
}

void CTADatastruct::VerifyInstallation( CTable *pTab, bool bAddCurrentHM )
{
	CDlgHMCompilationOutput::CHMInterface clOutputInterface;
	CDS_TechnicalParameter *pTech = GetpTechParams();
	CDS_ProjectParams *pProjectParams = GetpProjectParams();
	CPrjParams *pPrjParams = pProjectParams->GetpHmCalcParams();

	if( NULL == pTab )
	{
		pTab = GetpHydroModTable();
	}

	ASSERT( NULL != pTab );
	std::map<int, CTable *> mapHM;
	std::map<int, CTable *>::iterator It;

	// Order HM by position
	for( IDPTR IDPtr = pTab->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pTab->GetNext( IDPtr.MP ) )
	{
		CDS_HydroMod *pHM = static_cast<CDS_HydroMod *>( IDPtr.MP );

		if( NULL != pHM && true == pHM->IsHMCalcMode() )
		{
			mapHM[pHM->GetPos()] = pHM;
		}
	}

	if( true == bAddCurrentHM && NULL != dynamic_cast<CDS_HydroMod *>( pTab ) )
	{
		mapHM[0] = pTab;
	}

	for( It = mapHM.begin(); It != mapHM.end(); ++It )
	{
		CDS_HydroMod *pHM = static_cast<CDS_HydroMod *>( It->second );
		
		// To force a refresh of error messsages (Only for smart control valve and smart differential pressure controller for the moment).
		pHM->CheckValidity();

		///////////////////////// HM itself
		if( NULL != pHM->GetpSchcat() && true == pHM->GetpSchcat()->IsStraight() )
		{
			clOutputInterface.FillAndSendMessage( IDS_WARNMSG_HM_MISSINGPV, CDlgHMCompilationOutput::Warning, pHM );
		}

		if( pHM->GetpTermUnit() && pHM->GetpTermUnit()->GetQ() <= 0 )
		{
			clOutputInterface.FillAndSendMessage( IDS_ERROR_HM_FLOWNULL, CDlgHMCompilationOutput::Error, pHM );
		}

		if( NULL != pHM->GetpPump() )
		{
			CDS_HydroMod::CBV *pBV = NULL;

			if( NULL != pHM->GetpSchcat() && true == pHM->GetpSchcat()->IsPump() )
			{
				pBV = pHM->GetpBv();
			}
			else
			{
				pBV = pHM->GetpSecBv();
			}

			if( NULL == pBV )
			{
				clOutputInterface.FillAndSendMessage( IDS_WARNMSG_HM_MISSINGPV, CDlgHMCompilationOutput::Warning, pHM );
			}

			// Test HAvailable
			if( pHM->GetpPump()->GetHpump() > 0 )
			{
				if( pHM->GetpPump()->GetHpump() < pHM->GetpPump()->GetHmin() )
				{
					CString str = WriteCUDouble( _U_DIFFPRESS, pHM->GetpPump()->GetHpump() ) + CString( _T(" < ") );
					str += WriteCUDouble( _U_DIFFPRESS, pHM->GetpPump()->GetHmin(), true );
					clOutputInterface.FillAndSendMessage( IDS_WARNMSG_HM_HPUMPTOLOW, CDlgHMCompilationOutput::Warning, pHM, L"", str );
				}
			}

			// Verification of secondary temperatures for injection circuit.
			if( NULL != pHM->GetpSchcat() && true == pHM->GetpSchcat()->IsInjection() )
			{
				int iErrors = 0;
				std::vector<CString> vecStrErrors;

				if( false == pHM->CheckIfTempAreValid( &iErrors, &vecStrErrors ) )
				{
					for( auto &iter : vecStrErrors )
					{
						clOutputInterface.FillAndSendMessage( iter, CDlgHMCompilationOutput::Error, pHM );
					}
				}
			}
		}

		///////////////////////// Pipes
		std::vector<CPipes *> vpPipes;
		vpPipes.push_back( pHM->GetpCircuitPrimaryPipe() );
		vpPipes.push_back( pHM->GetpCircuitSecondaryPipe() );
		vpPipes.push_back( pHM->GetpDistrSupplyPipe() );
		vpPipes.push_back( pHM->GetpDistrReturnPipe() );
		double dMinLinDp = pTech->GetPipeMinDp();
		double dMaxLinDp = pTech->GetPipeMaxDp();
		double dMinV = pTech->GetPipeMinVel();
		double dMaxV = pTech->GetPipeMaxVel();

		for( unsigned int i = 0; i < vpPipes.size(); i++ )
		{
			CPipes *pPipe = vpPipes[i];

			if( NULL != pPipe )
			{
				CString strPipeLocation;

				if( pPipe->GetLength() <= 0 )
				{
					continue;
				}

				switch( pPipe->GetLocate() )
				{
					case CDS_HydroMod::eCircuitPrimaryPipe:
						strPipeLocation = TASApp.LoadLocalizedString( IDS_MSG_HM_PRIMARYCIRCUITPIPE );
						break;

					case CDS_HydroMod::eCircuitSecondaryPipe:
						strPipeLocation = TASApp.LoadLocalizedString( IDS_MSG_HM_SECONDARYCIRCUITPIPE );
						break;

					case CDS_HydroMod::eDistributionReturnPipe:
						strPipeLocation = TASApp.LoadLocalizedString( IDS_MSG_HM_DISTRIBUTIONRETURNPIPE );
						break;

					case CDS_HydroMod::eDistributionSupplyPipe:
					{
						if( NULL != pHM->GetpDistrReturnPipe() )
						{
							strPipeLocation = TASApp.LoadLocalizedString( IDS_MSG_HM_DISTRIBUTIONSUPPLYPIPE );
						}
						else
						{
							strPipeLocation = TASApp.LoadLocalizedString( IDS_MSG_HM_DISTRIBUTIONPIPE );
						}
					}
					break;
				}

				double dLinDp = pPipe->GetLinDp();

				if( dLinDp > dMaxLinDp || dLinDp < dMinLinDp )
				{
					CString str1 = WriteCUDouble( _U_LINPRESSDROP, dLinDp, true );
					CString str2 = CString( _T("[") ) + WriteCUDouble( _U_LINPRESSDROP, dMinLinDp );
					str2 += CString( _T(" - ") ) + WriteCUDouble( _U_LINPRESSDROP, dMaxLinDp, true );
					str2 += CString( _T("]") );
					// Specific test to elevate Warning to error when dLinDp > 4*dMaxLinDp
					CDlgHMCompilationOutput::MessageType MsgType = CDlgHMCompilationOutput::Warning;

					if( dLinDp > ( 4 * dMaxLinDp ) )
					{
						MsgType = CDlgHMCompilationOutput::Error;
					}

					clOutputInterface.FillAndSendMessage( IDS_WARNMSG_HM_PIPELINDP, MsgType, pHM, L"", strPipeLocation, str1, str2 );
				}

				double dVel = pPipe->GetVelocity();

				// HYS-1878: 2- Show a message in output window.
				if( dVel > dMaxV || dVel < dMinV )
				{
					CString str1 = WriteCUDouble( _U_VELOCITY, dVel, true );
					CString str2 = CString( _T("[") ) + WriteCUDouble( _U_VELOCITY, dMinV );
					str2 += CString( _T(" - ") ) + WriteCUDouble( _U_VELOCITY, dMaxV, true );
					str2 += CString( _T("]") );
					clOutputInterface.FillAndSendMessage( IDS_WARNMSG_HM_PIPEV, CDlgHMCompilationOutput::Warning, pHM, L"", strPipeLocation, str1, str2 );
				}
			}
		}

		///////////////////////// Regulating valves
		std::vector<CDS_HydroMod::CBV *> vpBV;
		vpBV.push_back( pHM->GetpBv() );
		vpBV.push_back( pHM->GetpSecBv() );
		vpBV.push_back( pHM->GetpBypBv() );

		for( unsigned int i = 0; i < vpBV.size(); i++ )
		{
			CDS_HydroMod::CBV *pBV = vpBV[i];

			if( NULL != pBV )
			{
				// CBV * exist but no object was found
				if( NULL == pBV->GetIDPtr().MP )
				{
					// No valve found
					if( pBV->GetHMObjectType() == CDS_HydroMod::eBVprim )
					{
						clOutputInterface.FillAndSendMessage( IDS_ERRMSG_HM_MISSINGPRIMARYBV, CDlgHMCompilationOutput::Error, pHM );
					}

					if( pBV->GetHMObjectType() == CDS_HydroMod::eBVsec )
					{
						clOutputInterface.FillAndSendMessage( IDS_ERRMSG_HM_MISSINGSECONDARYBV, CDlgHMCompilationOutput::Error, pHM );
					}
				}
				else
				{
					// Valve exist test technical parameters
					// CDS_HydroMod::eValidityFlags
					int ValidityFlag = pBV->CheckValidity();
					CDB_TAProduct *pTAP = static_cast<CDB_TAProduct *>( pBV->GetIDPtr().MP );
					_SendValidityHMErrMessage( pHM, pTAP, ValidityFlag );

					// Verify presetting.
					if( NULL != pTAP->GetValveCharacteristic() )
					{
						double dMinRecommendedSetting = pTAP->GetValveCharacteristic()->GetMinRecSetting();

						if( pBV->GetSetting() < dMinRecommendedSetting )
						{
							CString str2 = pTAP->GetValveCharacteristic()->GetSettingString( pBV->GetSetting() );
							str2 += _T(" < ") + pTAP->GetValveCharacteristic()->GetSettingString( dMinRecommendedSetting );

							if( CDS_HydroMod::eBVprim == pBV->GetHMObjectType() )
							{
								clOutputInterface.FillAndSendMessage( IDS_WARNMSG_HM_SETTING, CDlgHMCompilationOutput::Warning, pHM, L"", TASApp.LoadLocalizedString( IDS_MSG_HM_PRIMARYBV ), str2 );
							}

							if( CDS_HydroMod::eBVsec == pBV->GetHMObjectType() )
							{
								clOutputInterface.FillAndSendMessage( IDS_WARNMSG_HM_SETTING, CDlgHMCompilationOutput::Warning, pHM, L"", TASApp.LoadLocalizedString( IDS_MSG_HM_SECONDARYBV ), str2 );
							}
						}
					}
				}
			}
		}

		///////////////////////// DpC
		if( NULL != pHM->GetpDpC() )
		{
			// Missing Dp Controller, HySelect doesn't found a valid DpC for current data
			if( NULL == pHM->GetpDpC()->GetIDPtr().MP )
			{
				clOutputInterface.FillAndSendMessage( IDS_ERRMSG_HM_MISSINGDPC, CDlgHMCompilationOutput::Error, pHM );
			}
			else
			{
				CDB_DpController *pDpC = static_cast< CDB_DpController * >( pHM->GetpDpC()->GetIDPtr().MP );

				// Valve exist test technical parameters
				// CDS_HydroMod::eValidityFlags
				int iValidityFlag = pHM->GetpDpC()->CheckValidity();

				_SendValidityHMErrMessage( pHM, pDpC, iValidityFlag );

				if( -1.0 != pHM->GetpDpC()->GetDpmin() && pHM->GetpDpC()->GetDpmin() < pTech->GetDpCMinDp() )
				{
					CString str2 = WriteCUDouble( _U_DIFFPRESS, pHM->GetpDpC()->GetDpmin() );
					str2 += CString( _T(" < ") ) + WriteCUDouble( _U_DIFFPRESS, pTech->GetDpCMinDp(), true );
					clOutputInterface.FillAndSendMessage( IDS_WARNMSG_HM_DPMIN, CDlgHMCompilationOutput::Warning, pHM, L"", str2 );
				}

				if( -1.0 != pDpC->GetDplmax() && -1.0 != pDpC->GetDplmin()
						&& ( pHM->GetpDpC()->GetDpToStab() > pDpC->GetDplmax() || pHM->GetpDpC()->GetDpToStab() < pDpC->GetDplmin() ) )
				{
					CString str1 = WriteCUDouble( _U_DIFFPRESS, pHM->GetpDpC()->GetDpToStab(), true );
					CString str2 = pDpC->GetFormatedDplRange( true ).c_str();
					clOutputInterface.FillAndSendMessage( IDS_ERRMSG_HM_DPLRANGE, CDlgHMCompilationOutput::Error, pHM, L"", str1, str2 );
				}
			}
		}

		///////////////////////// CV
		if( NULL != pHM->GetpCV() )
		{
			// Missing Dp Controller, HySelect doesn't found a valid DpC for current data
			if( NULL == pHM->GetpCV()->GetCvIDPtr().MP && true == pHM->GetpCV()->IsTaCV() )
			{
				if( eb3True == pHM->GetpCV()->IsPICV() )
				{
					clOutputInterface.FillAndSendMessage( IDS_ERRMSG_HM_MISSINGPICV, CDlgHMCompilationOutput::Error, pHM );
				}
				else if( eb3True == pHM->GetpCV()->IsDpCBCV() )
				{
					clOutputInterface.FillAndSendMessage( IDS_ERRMSG_HM_MISSINGDPCBCV, CDlgHMCompilationOutput::Error, pHM );
				}
				else
				{
					clOutputInterface.FillAndSendMessage( IDS_ERRMSG_HM_MISSINGCV, CDlgHMCompilationOutput::Error, pHM );
				}
			}
			else
			{
				// Valve exist test technical parameters.
				// CDS_HydroMod::eValidityFlags
				if( true == pHM->GetpCV()->IsTaCV() )
				{
					int iValidityFlag = pHM->GetpCV()->CheckValidity();
					CDB_TAProduct *pTAP = static_cast<CDB_TAProduct *>( pHM->GetpCV()->GetCvIDPtr().MP );
					_SendValidityHMErrMessage( pHM, pTAP, iValidityFlag );

					// Verify actuator.
					if( true == pPrjParams->GetActuatorAutomaticallySelect() )
					{
						CDB_ElectroActuator *pActr = dynamic_cast<CDB_ElectroActuator *>( pHM->GetpCV()->GetActrIDPtr().MP );

						if( NULL != pActr )
						{
							bool bActuatorMatch = true;

							// Check package.
							eBool3 eActSelectedAsaPackage = ( true == pPrjParams->GetActuatorSelectedByPackage() ) ? eb3True : eb3False;

							if( true == bActuatorMatch && eActSelectedAsaPackage != pHM->GetpCV()->GetActrSelectedAsaPackage() )
							{
								bActuatorMatch = false;
							}

							// Check fail safe function.
							// HYS-1458 : If fail-safe checkbox is checked we have to get a fail-safe type. If the checkbox is not checked we have to get No fail-safe. 
							// if these conditions are not satisfied, bActuatorMatch is false.
							if( true == bActuatorMatch 
								&& ( ( pActr->GetFailSafe() >= CDB_ElectroActuator::FailSafeType::eFSTypeElectronic 
								&& pActr->GetFailSafe() < CDB_ElectroActuator::FailSafeType::eFSTypeLast && pPrjParams->GetActuatorFailSafeFct() != 1 )
								|| ( (int)pActr->GetFailSafe() == 0 && pPrjParams->GetActuatorFailSafeFct() != 0 ) ) )
							{
								bActuatorMatch = false;
							}

							// Check the power supply.
							if( true == bActuatorMatch && true != pActr->IsPowerSupplyAvailable( pPrjParams->GetPrjParamIDPtr( CPrjParams::ActuatorPowerSupplyID ) ) )
							{
								bActuatorMatch = false;
							}

							// Check input signal.
							if( true == bActuatorMatch && true != pActr->IsInputSignalAvailable( pPrjParams->GetPrjParamIDPtr( CPrjParams::ActuatorInputSignalID ) ) )
							{
								bActuatorMatch = false;
							}

							if( false == bActuatorMatch )
							{
								CString str = pActr->GetName();
								clOutputInterface.FillAndSendMessage( IDS_WARNMSG_HM_SELECTEDACTRDOESNTMATCH, CDlgHMCompilationOutput::Warning, pHM, L"", str );
							}

							// HYS-1759: Do not check the close-of Dp for PIBCV.
							CDB_ControlValve* pCVDB = dynamic_cast<CDB_ControlValve*>(pTAP);
							ASSERT( NULL != pCVDB );
							CDB_CloseOffChar* pCloseOffChar = static_cast<CDB_CloseOffChar*>(pCVDB->GetCloseOffCharIDPtr().MP);
							if( eb3True == pHM->GetpCV()->IsPICV() && NULL != pCloseOffChar && pCloseOffChar->GetLimitType() == CDB_CloseOffChar::CloseOffDp )
							{
								// Do not test closeoffDp because the control part never go above Dp max
							}
							// Test close-off Dp.
							else if( false == pHM->GetpCV()->IsActuatorStrongEnough() )
							{
								int iIDMsg = IDS_WARNMSG_HM_SELECTEDACTRTOOWEAK;

								// CASE of KTM.
								if( NULL == pCloseOffChar )
								{
									// KTM512
									// CloseOff char doesn't exist, HySelect is unable to correctly size actuator
									iIDMsg = IDS_WARNMSG_HM_UNABLETOSIZEACTR;
								}
								// HYS-1685: Do not show actuator if max. inlet pressure is below 5 bar (Eric Bernadou 31-08-2015)
								else if( ( NULL != pCloseOffChar && pCloseOffChar->GetLimitType() == CDB_CloseOffChar::InletPressure )
											&& ( pCloseOffChar->GetMaxInletPressure( pActr->GetMaxForceTorque() ) >= 500000 ) )
								{
									iIDMsg = -1;
								}
	
								if( -1 != iIDMsg )
								{
									CString str = pActr->GetName();
									clOutputInterface.FillAndSendMessage( iIDMsg, CDlgHMCompilationOutput::Error, pHM, L"", str );
								}
							}	
						}
						else
						{
							// Missing actuator ?

						}
					}

				}

				// Verify Authority
				if( false == pHM->GetpCV()->IsOn_Off() )
				{
					CDS_HydroMod *pPressInt = pHM->GetpPressIntHM();
					double dMinAuth = pTech->GetCVMinAuthor();
					bool bConstantFlow = pPressInt->IsConstantFlow();

					if( eb3False == pHM->GetpCV()->IsCVLocInPrimary() )
					{
						if( false == pHM->IsaModule() )
						{
							bConstantFlow = true;
						}
						else
						{
							bConstantFlow = pHM->IsConstantFlow();
						}
					}

					if( true == bConstantFlow  )
					{
						dMinAuth = pTech->GetCVMinAuthCstFlow();
					}

					CString str1, str2;

					str1 = WriteDouble( pHM->GetpCV()->GetAuth(), 2, 1 );
					str2 = WriteDouble( dMinAuth, 2, 1 );

					if( pHM->GetpCV()->GetAuth() < ( dMinAuth * 0.99 ) )
					{
						clOutputInterface.FillAndSendMessage( IDS_WARNMSG_HM_AUTHORITY, CDlgHMCompilationOutput::Warning, pHM, L"", str1, str2 );
					}
				}
			}
		}

		///////////////////////// Shutoff valve on supply.
		if( NULL != pHM->GetpShutoffValve( CDS_HydroMod::eShutoffValveSupply ) )
		{
			// Missing shutoff valve, HySelect doesn't found a valid shutoff valve for current data.
			if( NULL == pHM->GetpShutoffValve( CDS_HydroMod::eShutoffValveSupply )->GetIDPtr().MP )
			{
				clOutputInterface.FillAndSendMessage( IDS_ERRMSG_HM_MISSINGSV, CDlgHMCompilationOutput::Error, pHM );
			}
			else
			{
				CDB_ShutoffValve *pclShutoffValve = static_cast< CDB_ShutoffValve * >( pHM->GetpShutoffValve( CDS_HydroMod::eShutoffValveSupply )->GetIDPtr().MP );

				// Valve exist test technical parameters.
				// CDS_HydroMod::eValidityFlags
				int ValidityFlag = pHM->GetpShutoffValve( CDS_HydroMod::eShutoffValveSupply )->CheckValidity();

				_SendValidityHMErrMessage( pHM, pclShutoffValve, ValidityFlag );
			}
		}

		///////////////////////// Shutoff valve on return.
		if( NULL != pHM->GetpShutoffValve( CDS_HydroMod::eHMObj::eShutoffValveReturn ) )
		{
			// Missing shutoff valve, HySelect doesn't found a valid shutoff valve for current data.
			if( NULL == pHM->GetpShutoffValve( CDS_HydroMod::eShutoffValveReturn )->GetIDPtr().MP )
			{
				clOutputInterface.FillAndSendMessage( IDS_ERRMSG_HM_MISSINGSV, CDlgHMCompilationOutput::Error, pHM );
			}
			else
			{
				CDB_ShutoffValve *pclShutoffValve = static_cast< CDB_ShutoffValve * >( pHM->GetpShutoffValve( CDS_HydroMod::eShutoffValveReturn )->GetIDPtr().MP );

				// Valve exist test technical parameters.
				// CDS_HydroMod::eValidityFlags
				int ValidityFlag = pHM->GetpShutoffValve( CDS_HydroMod::eShutoffValveReturn )->CheckValidity();

				_SendValidityHMErrMessage( pHM, pclShutoffValve, ValidityFlag );
			}
		}

		///////////////////////// Smart control valve.
		if( NULL != pHM->GetpSmartControlValve() )
		{
			// Missing smart control valve, HySelect doesn't found a valid smart control valve for current data.
			if( NULL == pHM->GetpSmartControlValve()->GetIDPtr().MP )
			{
				clOutputInterface.FillAndSendMessage( IDS_ERRMSG_HM_MISSINGSMARTCONTROLVALVE, CDlgHMCompilationOutput::Error, pHM );
			}
			else
			{
				std::vector<CString> vecAllErrors = pHM->GetpSmartControlValve()->GetErrorMessageList( CDS_HydroMod::ErrorWarningMessageFlags::EWMF_All );

				for( auto &iter : vecAllErrors )
				{
					clOutputInterface.FillAndSendMessage( iter, CDlgHMCompilationOutput::Error, pHM );
				}
			}
		}

		///////////////////////// Smart differential pressure controller.
		if( NULL != pHM->GetpSmartDpC() )
		{
			// Missing smart differential pressure controller, HySelect doesn't found a valid smart differential pressure controller for current data.
			if( NULL == pHM->GetpSmartDpC()->GetIDPtr().MP )
			{
				clOutputInterface.FillAndSendMessage( IDS_ERRMSG_HM_MISSINGSMARTDPC, CDlgHMCompilationOutput::Error, pHM );
			}
			else
			{
				std::vector<CString> vecAllErrors = pHM->GetpSmartDpC()->GetErrorMessageList( 
						CDS_HydroMod::CSmartDpC::eErrorMessageObject_SmartDpC, CDS_HydroMod::ErrorWarningMessageFlags::EWMF_All );

				for( auto &iter : vecAllErrors )
				{
					clOutputInterface.FillAndSendMessage( iter, CDlgHMCompilationOutput::Error, pHM );
				}

				vecAllErrors = pHM->GetpSmartDpC()->GetErrorMessageList( 
						CDS_HydroMod::CSmartDpC::eErrorMessageObject_DpSensor, CDS_HydroMod::ErrorWarningMessageFlags::EWMF_All );

				for( auto &iter : vecAllErrors )
				{
					clOutputInterface.FillAndSendMessage( iter, CDlgHMCompilationOutput::Error, pHM );
				}
			}
		}

		if( true == pHM->IsaModule() && pHM != pTab )
		{
			VerifyInstallation( pHM, false );
		}
	}
}

bool CTADatastruct::SaveToTADataStructX( CTADataStructX *pTADSX )
{
	try
	{
		if( NULL == pTADSX )
		{
			HYSELECT_THROW( _T("Internal error: 'pTADSX' argument can't be NULL.") );
		}

		// Project UID; PC is the master for UID.
		pTADSX->SetUID( GetUID() );

		// Copy plant information.
		// Plan reference.
		CDS_PlantX *pPlant = dynamic_cast<CDS_PlantX *>( pTADSX->Get( _T("PLANT_INFO") ).MP );

		if( NULL == pPlant )
		{
			HYSELECT_THROW( _T("Internal error: The 'PLANT_INFO' is not a 'CDS_PlantX' object.") );
		}

		// Plant Name; Description; UID
		CDS_ProjectRef *pPrjRef = TASApp.GetpTADS()->GetpProjectRef();

		if( NULL == pPrjRef )
		{
			HYSELECT_THROW( _T("Internal error: The 'CDS_ProjectRef' can't be NULL.") );
		}

		pPlant->SetString( CDS_PlantX::ePlant::Name, pPrjRef->GetString( CDS_ProjectRef::Name ) );
		pPlant->SetString( CDS_PlantX::ePlant::Description, pPrjRef->GetString( CDS_ProjectRef::Comment ) );
		pPlant->SetString( CDS_PlantX::ePlant::ProjectUID, GetUID() );

		// Water characteristics.
		CTable *pWCTab = dynamic_cast<CTable *>( pTADSX->Get( _T("WC_TAB") ).MP );

		if( NULL == pWCTab )
		{
			HYSELECT_THROW( _T("Internal error: The 'WC_TAB' can't be NULL.") );
		}

		// Current water characteristic.
		CDS_WaterCharacteristic *pTADSWC = TASApp.GetpTADS()->GetpWCForProject();
		ASSERT( NULL != pTADSWC );

		CDS_WaterCharacteristic *pWC = dynamic_cast<CDS_WaterCharacteristic *>( pTADSX->Get( L"PARAM_HMXWC" ).MP ); //FindWC(pTADSWC->GetpWCData() );

		if( NULL != pWC )
		{
			// Already Exist into the Water Char Table keep it
		}
		else
		{
			IDPTR WCIDptr;
			pTADSX->CreateObject( WCIDptr, CLASS( CDS_WaterCharacteristic ), L"PARAM_HMXWC" );
			pWCTab->Insert( WCIDptr );

			pWC = dynamic_cast<CDS_WaterCharacteristic *>( WCIDptr.MP );
		}

		*pWC->GetpWCData() = *pTADSWC->GetpWCData();

		// Copy PIPING_TAB Content.
		CTableHM *pTabSrc = dynamic_cast<CTableHM *>( TASApp.GetpTADS()->GetpHydroModTable() );
		CTable *pTabTrg = dynamic_cast<CTable *>( pTADSX->Get( _T("PIPING_TAB") ).MP );
		
		if( NULL == pTabSrc )
		{
			HYSELECT_THROW( _T("Internal error: The 'pTabSrc' can't be NULL.") );
		}
		else if( NULL == pTabTrg )
		{
			HYSELECT_THROW( _T("Internal error: The 'pTabTrg' can't be NULL.") );
		}

		return pTabSrc->SaveToHMXTable( pTabSrc, pTabTrg, pWC );
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CTADatastruct::SaveToTADataStructX'."), __LINE__, __FILE__ );
		throw;
	}
}

void CTADatastruct::WriteAllDataInRegistry()
{
	// HYS-1590: Start to centralyze the writing in the registry in one place.
	// For the moment, only the technical parameters are written here.
	// In a next Jira card (HYS-1631) we will extend this method to all data to write in the registry.

	CDS_TechnicalParameter *pTech = GetpTechParams();

	if( NULL == pTech )
	{
		return;
	}

	// Default pipe series.
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_PIPESERIES, _T("Default Pipe Series"), pTech->GetDefaultPipeSerieID() );

	TechParam_struct *pTechParamStruct = pTech->GetTechParamStructure();
	::AfxGetApp()->WriteProfileInt( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("ProjectType"), pTechParamStruct->m_eProjectType );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultPrjCoolingTps"), WriteDouble( pTechParamStruct->m_dDefaultPrjCoolingTps, 14, 0 ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultPrjHeatingTps"), WriteDouble( pTechParamStruct->m_dDefaultPrjHeatingTps, 14, 0 ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultPrjCoolingDT"), WriteDouble( pTechParamStruct->m_dDefaultPrjCoolingDT, 14, 0 ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultPrjHeatingDT"), WriteDouble( pTechParamStruct->m_dDefaultPrjHeatingDT, 14, 0 ) );
	
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultPrjCoolingAdditID"), pTechParamStruct->m_strDefaultPrjCoolingAdditID.c_str() );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultPrjHeatingAdditID"), pTechParamStruct->m_strDefaultPrjHeatingAdditID.c_str() );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultPrjCoolingPcWeight"), WriteDouble( pTechParamStruct->m_dDefaultPrjCoolingPcWeight, 14, 0 ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultPrjHeatingPcWeight"), WriteDouble( pTechParamStruct->m_dDefaultPrjHeatingPcWeight, 14, 0 ) );

	::AfxGetApp()->WriteProfileInt( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("ApplicationType"), pTechParamStruct->m_eProductSelectionApplicationType );
	
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// For product selection in heating.
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISHeatingTps"), WriteDouble( pTech->GetDefaultISHeatingTps(), 14, 0 ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISHeatingDT"), WriteDouble( pTech->GetDefaultISHeatingDT(), 14, 0 ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISHeatingAdditID"), pTech->GetDefaultISHeatingAdditID() );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISHeatingPcWeight"), WriteDouble( pTech->GetDefaultISHeatingPcWeight(), 14, 0 ) );

	// HYS-1230: Write density only if user was on 'Other fluid'.
	CString str = ( 0 == wcscmp( pTech->GetDefaultISHeatingAdditID(), _T("OTHER_FLUID") ) ) ? WriteDouble( pTech->GetDefaultISHeatingWC()->GetDens(), 14, 0 ) : _T("");
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISHeatingDensity"), str );
	
	// HYS-1230: Write kinematic viscosity only if user was on 'Other fluid'.
	str = ( 0 == wcscmp( pTech->GetDefaultISHeatingAdditID(), _T("OTHER_FLUID") ) ) ? WriteDouble( pTech->GetDefaultISHeatingWC()->GetKinVisc(), 14, 0 ) : _T("");
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISHeatingKinematicViscosity"), str );

	// HYS-1230: Write specific heat only if user was on 'Other fluid' and choose to put a value.
	::AfxGetApp()->WriteProfileInt( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISHeatingCheckSpecificHeat"), ( true == pTech->GetDefaultISHeatingWC()->GetCheckSpecifHeat() ) ? 1 : 0 );
	str = _T("");

	if( 0 == wcscmp( pTech->GetDefaultISHeatingAdditID(), _T("OTHER_FLUID") ) && true == pTech->GetDefaultISHeatingWC()->GetCheckSpecifHeat() )
	{
		str = WriteDouble( pTech->GetDefaultISHeatingWC()->GetSpecifHeat(), 14, 0 );
	}

	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISHeatingSpecificHeat"), str );
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// For product selection in cooling.
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISCoolingTps"), WriteDouble( pTech->GetDefaultISCoolingTps(), 14, 0 ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISCoolingDT"), WriteDouble( pTech->GetDefaultISCoolingDT(), 14, 0 ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISCoolingAdditID"), pTech->GetDefaultISCoolingAdditID() );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISCoolingPcWeight"), WriteDouble( pTech->GetDefaultISCoolingPcWeight(), 14, 0 ) );

	// HYS-1230: Write density only if user was on 'Other fluid'.
	str = ( 0 == wcscmp( pTech->GetDefaultISCoolingAdditID(), _T("OTHER_FLUID") ) ) ? WriteDouble( pTech->GetDefaultISCoolingWC()->GetDens(), 14, 0 ) : _T("");
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISCoolingDensity"), str );
	
	// HYS-1230: Write kinematic viscosity only if user was on 'Other fluid'.
	str = ( 0 == wcscmp( pTech->GetDefaultISCoolingAdditID(), _T("OTHER_FLUID") ) ) ? WriteDouble( pTech->GetDefaultISCoolingWC()->GetKinVisc(), 14, 0 ) : _T("");
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISCoolingKinematicViscosity"), str );

	// HYS-1230: Write specific heat only if user was on 'Other fluid' and choose to put a value.
	::AfxGetApp()->WriteProfileInt( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISCoolingCheckSpecificHeat"), ( true == pTech->GetDefaultISCoolingWC()->GetCheckSpecifHeat() ) ? 1 : 0 );
	str = _T("");

	if( 0 == wcscmp( pTech->GetDefaultISCoolingAdditID(), _T("OTHER_FLUID") ) && true == pTech->GetDefaultISCoolingWC()->GetCheckSpecifHeat() )
	{
		str = WriteDouble( pTech->GetDefaultISCoolingWC()->GetSpecifHeat(), 14, 0 );
	}

	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISCoolingSpecificHeat"), str );
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// For product selection in solar.
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISSolarTps"), WriteDouble( pTech->GetDefaultISSolarTps(), 14, 0 ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISSolarDT"), WriteDouble( pTech->GetDefaultISSolarDT(), 14, 0 ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISSolarAdditID"), pTech->GetDefaultISSolarAdditID() );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISSolarPcWeight"), WriteDouble( pTech->GetDefaultISSolarPcWeight(), 14, 0 ) );

	// HYS-1230: Write density only if user was on 'Other fluid'.
	str = ( 0 == wcscmp( pTech->GetDefaultISSolarAdditID(), _T("OTHER_FLUID") ) ) ? WriteDouble( pTech->GetDefaultISSolarWC()->GetDens(), 14, 0 ) : _T("");
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISSolarDensity"), str );
	
	// HYS-1230: Write kinematic viscosity only if user was on 'Other fluid'.
	str = ( 0 == wcscmp( pTech->GetDefaultISSolarAdditID(), _T("OTHER_FLUID") ) ) ? WriteDouble( pTech->GetDefaultISSolarWC()->GetKinVisc(), 14, 0 ) : _T("");
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISSolarKinematicViscosity"), str );

	// HYS-1230: Write specific heat only if user was on 'Other fluid' and choose to put a value.
	::AfxGetApp()->WriteProfileInt( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISSolarCheckSpecificHeat"), ( true == pTech->GetDefaultISSolarWC()->GetCheckSpecifHeat() ) ? 1 : 0 );
	str = _T("");

	if( 0 == wcscmp( pTech->GetDefaultISSolarAdditID(), _T("OTHER_FLUID") ) && true == pTech->GetDefaultISSolarWC()->GetCheckSpecifHeat() )
	{
		str = WriteDouble( pTech->GetDefaultISSolarWC()->GetSpecifHeat(), 14, 0 );
	}

	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISSolarSpecificHeat"), str );
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// For product selection in change-over for the cooling side.
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISChangeOverCoolingSideTps"), WriteDouble( pTech->GetDefaultISChangeOverTps( SideDefinition::CoolingSide ), 14, 0 ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISChangeOverCoolingSideDT"), WriteDouble( pTech->GetDefaultISChangeOverDT( SideDefinition::CoolingSide ), 14, 0 ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISChangeOverCoolingSideAdditID"), pTech->GetDefaultISChangeOverAdditID( SideDefinition::CoolingSide ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISChangeOverCoolingSidePcWeight"), WriteDouble( pTech->GetDefaultISChangeOverPcWeight( SideDefinition::CoolingSide ), 14, 0 ) );
	
	// HYS-1230: Write density only if user was on 'Other fluid'.
	str = _T("");

	if( 0 == wcscmp( pTech->GetDefaultISChangeOverAdditID( SideDefinition::CoolingSide ), _T("OTHER_FLUID") ) ) 
	{
		str = WriteDouble( pTech->GetDefaultISChangeOverWC( SideDefinition::CoolingSide )->GetDens(), 14, 0 );
	}

	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISChangeOverCoolingSideDensity"), str );
	
	// HYS-1230: Write kinematic viscosity only if user was on 'Other fluid'.
	str = _T("");

	if( 0 == wcscmp( pTech->GetDefaultISChangeOverAdditID( SideDefinition::CoolingSide ), _T("OTHER_FLUID") ) )
	{
		str = WriteDouble( pTech->GetDefaultISChangeOverWC( SideDefinition::CoolingSide )->GetKinVisc(), 14, 0 );
	}
	
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISChangeOverCoolingSideKinematicViscosity"), str );

	// HYS-1230: Write specific heat only if user was on 'Other fluid' and choose to put a value.
	int iChecked = ( true == pTech->GetDefaultISChangeOverWC( SideDefinition::CoolingSide )->GetCheckSpecifHeat() ) ? 1 : 0;
	::AfxGetApp()->WriteProfileInt( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISChangeOverCoolingSideCheckSpecificHeat"), iChecked );
	str = _T("");

	if( 0 == wcscmp( pTech->GetDefaultISChangeOverAdditID( SideDefinition::CoolingSide ), _T("OTHER_FLUID") ) 
			&& true == pTech->GetDefaultISChangeOverWC( SideDefinition::CoolingSide )->GetCheckSpecifHeat() )
	{
		str = WriteDouble( pTech->GetDefaultISChangeOverWC( SideDefinition::CoolingSide )->GetSpecifHeat(), 14, 0 );
	}

	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISChangeOverCoolingSideSpecificHeat"), str );
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// For product selection in change-over for the heating side.
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISChangeOverHeatingSideTps"), WriteDouble( pTech->GetDefaultISChangeOverTps( SideDefinition::HeatingSide ), 14, 0 ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISChangeOverHeatingSideDT"), WriteDouble( pTech->GetDefaultISChangeOverDT( SideDefinition::HeatingSide ), 14, 0 ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISChangeOverHeatingSideAdditID"), pTech->GetDefaultISChangeOverAdditID( SideDefinition::HeatingSide ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISChangeOverHeatingSidePcWeight"), WriteDouble( pTech->GetDefaultISChangeOverPcWeight( SideDefinition::HeatingSide ), 14, 0 ) );
	
	// HYS-1230: Write density only if user was on 'Other fluid'.
	str = _T("");

	if( 0 == wcscmp( pTech->GetDefaultISChangeOverAdditID( SideDefinition::HeatingSide ), _T("OTHER_FLUID") ) ) 
	{
		str = WriteDouble( pTech->GetDefaultISChangeOverWC( SideDefinition::HeatingSide )->GetDens(), 14, 0 );
	}

	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISChangeOverHeatingSideDensity"), str );
	
	// HYS-1230: Write kinematic viscosity only if user was on 'Other fluid'.
	str = _T("");

	if( 0 == wcscmp( pTech->GetDefaultISChangeOverAdditID( SideDefinition::HeatingSide ), _T("OTHER_FLUID") ) )
	{
		str = WriteDouble( pTech->GetDefaultISChangeOverWC( SideDefinition::HeatingSide )->GetKinVisc(), 14, 0 );
	}
	
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISChangeOverHeatingSideKinematicViscosity"), str );

	// HYS-1230: Write specific heat only if user was on 'Other fluid' and choose to put a value.
	iChecked = ( true == pTech->GetDefaultISChangeOverWC( SideDefinition::HeatingSide )->GetCheckSpecifHeat() ) ? 1 : 0;
	::AfxGetApp()->WriteProfileInt( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISChangeOverHeatingSideCheckSpecificHeat"), iChecked );
	str = _T("");

	if( 0 == wcscmp( pTech->GetDefaultISChangeOverAdditID( SideDefinition::HeatingSide ), _T("OTHER_FLUID") ) 
			&& true == pTech->GetDefaultISChangeOverWC( SideDefinition::HeatingSide )->GetCheckSpecifHeat() )
	{
		str = WriteDouble( pTech->GetDefaultISChangeOverWC( SideDefinition::HeatingSide )->GetSpecifHeat(), 14, 0 );
	}

	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DefaultISChangeOverHeatingSideSpecificHeat"), str );
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	CDS_ProjectParams *pPrjParam = GetpProjectParams();
	CPrjParams *pHMGenParam = pPrjParam->GetpHmCalcParams();

	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T( "PipeCircSerieID"), pHMGenParam->GetPrjParamID( CPrjParams::PipeCircSerieID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T( "PipeByPassSerieID"), pHMGenParam->GetPrjParamID( CPrjParams::PipeByPassSerieID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T( "PipeDistSupplySerieID"), pHMGenParam->GetPrjParamID( CPrjParams::PipeDistSupplySerieID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T( "PipeDistReturnSerieID"), pHMGenParam->GetPrjParamID( CPrjParams::PipeDistReturnSerieID ) );

	::AfxGetApp()->WriteProfileInt( REGISTRYSECTIONNAME_DLGTECHPARAM, REGISTRYKEYNAME_VALVEIMAGETYPE, TASApp.GetProdPicType( ) );

	::AfxGetApp()->WriteProfileInt( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("UseVesselPressureVolumeLimit"), pTech->GetUseVesselPressureVolumeLimit() );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("PressureVolumeLimit"), WriteDouble( pTech->GetPressureVolumeLimit(), 14, 0 ) );
	// HYS-1126
	::AfxGetApp()->WriteProfileInt( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("UseSimplyPst"), pTech->GetUseSimplyPst() );
	::AfxGetApp()->WriteProfileInt( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("MaxNumberOfVesselsInParallel"), pTech->GetMaxNumberOfAdditionalVesselsInParallel() );
	::AfxGetApp()->WriteProfileInt( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("MaxNumberOfVentoInParallel"), pTech->GetMaxNumberOfVentoInParallel() );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("VesselSelectionRangePercentage"), WriteDouble( pTech->GetVesselSelectionRangePercentage(), 14, 0 ) );

	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("WaterHardness"), WriteDouble( pTech->GetDefaultWaterHardness( ), 14, 0 ) );

	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("ValvMinDp"), WriteDouble( pTech->GetValvMinDp( ), 14, 0 ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("ValvMaxDp"), WriteDouble( pTech->GetValvMaxDp( ), 14, 0 ) );

	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("CvMinAuthor"), WriteDouble( pTech->GetCVMinAuthor( ), 14, 0 ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("CvMinAuthCstFlow"), WriteDouble( pTech->GetCVMinAuthCstFlow( ), 14, 0 ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("CvMinDpOnOff"), WriteDouble( pTech->GetCVMinDpOnoff( ), 14, 0 ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("CvMinDpProp"), WriteDouble( pTech->GetCVMinDpProp( ), 14, 0 ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("CvMaxDpProp"), WriteDouble( pTech->GetCVMaxDpProp( ), 14, 0 ) );
	::AfxGetApp()->WriteProfileInt( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("CvDefKvReynard"), pTech->GetCVDefKvReynard( ) );
	::AfxGetApp()->WriteProfileInt( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("CvUseDpCPBand"), pTech->GetCVUseDpCBand( ) );

	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("PICvMinDp"), WriteDouble( pTech->GetPICvMinDp( ), 14, 0 ) );
	::AfxGetApp()->WriteProfileInt( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("PICvHide"), pTech->GetPICvHide( ) );

	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DpCMinDp"), WriteDouble( pTech->GetDpCMinDp(), 14, 0 ) );
	::AfxGetApp()->WriteProfileInt( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DpCHide"), pTech->GetDpCHide( ) );
	::AfxGetApp()->WriteProfileInt( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("MvWithSameSize"), pTech->GetDpCMvWithSameSizeOnly() );

	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("FoMinDp"), WriteDouble( pTech->GetFoMinDp(), 14, 0 ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("FoMaxDp"), WriteDouble( pTech->GetFoMaxDp(), 14, 0 ) );

	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("TrvDefDpTot"), WriteDouble( pTech->GetTrvDefDpTot( ), 14, 0 ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("TrvDefRoomT"), WriteDouble( pTech->GetTrvDefRoomT( ), 14, 0 ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("TrvDefSupplyT"), WriteDouble( pTech->GetTrvDefSupplyT( ), 14, 0 ) );

	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("PipeTargDp"), WriteDouble( pTech->GetPipeTargDp(), 14, 0 ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("PipeMaxDp"), WriteDouble( pTech->GetPipeMaxDp(), 14, 0 ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("PipeTargVel"), WriteDouble( pTech->GetPipeTargVel(), 14, 0 ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("PipeMaxVel"), WriteDouble( pTech->GetPipeMaxVel(), 14, 0 ) );
	// HYS-1878: 3- Write pipe min velocity. Because the value can now be changed by user.
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("PipeMinVel"), WriteDouble( pTech->GetPipeMinVel(), 14, 0 ) );
	::AfxGetApp()->WriteProfileInt( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("PipeVtargUsed"), pTech->GetPipeVtargUsed() );

	// HYS-1749: Save into the registry
	::AfxGetApp()->WriteProfileInt( REGISTRYSECTIONNAME_DLGTECHPARAM, _T( "SizeShift" ), pTech->GetSizeShiftBelow() );
	::AfxGetApp()->WriteProfileInt( REGISTRYSECTIONNAME_DLGTECHPARAM, _T( "SizeShiftAbove" ), pTech->GetSizeShiftAbove() );

	::AfxGetApp()->WriteProfileInt( REGISTRYSECTIONNAME_DLGTECHPARAM, _T( "OldProductsAvailableForHC" ), iChecked );

	// HYS-1763: Write in registry
	::AfxGetApp()->WriteProfileInt( REGISTRYSECTIONNAME_DLGTECHPARAM, _T( "DefaultSmartCVLocation" ), pTech->GetDefaultSmartCVLoc() );

	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("SmartValveDpMaxForBestSuggestion"), WriteDouble( pTech->GetSmartValveDpMaxForBestSuggestion( ), 14, 0 ) );

	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("BvAbv50TypeID"), pHMGenParam->GetPrjParamID( CPrjParams::BvAbv50TypeID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("BvBlw65TypeID"), pHMGenParam->GetPrjParamID( CPrjParams::BvBlw65TypeID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("BvAbv50FamilyID"), pHMGenParam->GetPrjParamID( CPrjParams::BvAbv50FamilyID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("BvBlw65FamilyID"), pHMGenParam->GetPrjParamID( CPrjParams::BvBlw65FamilyID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("BvAbv50BdyMatID"), pHMGenParam->GetPrjParamID( CPrjParams::BvAbv50BdyMatID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("BvBlw65BdyMatID"), pHMGenParam->GetPrjParamID( CPrjParams::BvBlw65BdyMatID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("BvAbv50ConnectID"), pHMGenParam->GetPrjParamID( CPrjParams::BvAbv50ConnectID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("BvBlw65ConnectID"), pHMGenParam->GetPrjParamID( CPrjParams::BvBlw65ConnectID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("BvAbv50VersionID"), pHMGenParam->GetPrjParamID( CPrjParams::BvAbv50VersionID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("BvBlw65VersionID"), pHMGenParam->GetPrjParamID( CPrjParams::BvBlw65VersionID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("BvAbv50PNID"), pHMGenParam->GetPrjParamID( CPrjParams::BvAbv50PNID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("BvBlw65PNID"), pHMGenParam->GetPrjParamID( CPrjParams::BvBlw65PNID ) );

	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("CvAbv50TypeID"), pHMGenParam->GetPrjParamID( CPrjParams::CvAbv50TypeID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("CvBlw65TypeID"), pHMGenParam->GetPrjParamID( CPrjParams::CvBlw65TypeID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("CvAbv50FamilyID"), pHMGenParam->GetPrjParamID( CPrjParams::CvAbv50FamilyID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("CvBlw65FamilyID"), pHMGenParam->GetPrjParamID( CPrjParams::CvBlw65FamilyID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("CvAbv50BdyMatID"), pHMGenParam->GetPrjParamID( CPrjParams::CvAbv50BdyMatID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("CvBlw65BdyMatID"), pHMGenParam->GetPrjParamID( CPrjParams::CvBlw65BdyMatID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("CvAbv50ConnectID"), pHMGenParam->GetPrjParamID( CPrjParams::CvAbv50ConnectID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("CvBlw65ConnectID"), pHMGenParam->GetPrjParamID( CPrjParams::CvBlw65ConnectID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("CvAbv50VersionID"), pHMGenParam->GetPrjParamID( CPrjParams::CvAbv50VersionID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("CvBlw65VersionID"), pHMGenParam->GetPrjParamID( CPrjParams::CvBlw65VersionID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("CvAbv50PNID"), pHMGenParam->GetPrjParamID( CPrjParams::CvAbv50PNID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("CvBlw65PNID"), pHMGenParam->GetPrjParamID( CPrjParams::CvBlw65PNID ) );

	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("BCvAbv50TypeID"), pHMGenParam->GetPrjParamID( CPrjParams::BCvAbv50TypeID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("BCvBlw65TypeID"), pHMGenParam->GetPrjParamID( CPrjParams::BCvBlw65TypeID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("BCvAbv50FamilyID"), pHMGenParam->GetPrjParamID( CPrjParams::BCvAbv50FamilyID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("BCvBlw65FamilyID"), pHMGenParam->GetPrjParamID( CPrjParams::BCvBlw65FamilyID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("BCvAbv50BdyMatID"), pHMGenParam->GetPrjParamID( CPrjParams::BCvAbv50BdyMatID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("BCvBlw65BdyMatID"), pHMGenParam->GetPrjParamID( CPrjParams::BCvBlw65BdyMatID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("BCvAbv50ConnectID"), pHMGenParam->GetPrjParamID( CPrjParams::BCvAbv50ConnectID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("BCvBlw65ConnectID"), pHMGenParam->GetPrjParamID( CPrjParams::BCvBlw65ConnectID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("BCvAbv50VersionID"), pHMGenParam->GetPrjParamID( CPrjParams::BCvAbv50VersionID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("BCvBlw65VersionID"), pHMGenParam->GetPrjParamID( CPrjParams::BCvBlw65VersionID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("BCvAbv50PNID"), pHMGenParam->GetPrjParamID( CPrjParams::BCvAbv50PNID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("BCvBlw65PNID"), pHMGenParam->GetPrjParamID( CPrjParams::BCvBlw65PNID ) );

	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("PICvAbv50TypeID"), pHMGenParam->GetPrjParamID( CPrjParams::PICvAbv50TypeID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("PICvBlw65TypeID"), pHMGenParam->GetPrjParamID( CPrjParams::PICvBlw65TypeID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("PICvAbv50FamilyID"), pHMGenParam->GetPrjParamID( CPrjParams::PICvAbv50FamilyID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("PICvBlw65FamilyID"), pHMGenParam->GetPrjParamID( CPrjParams::PICvBlw65FamilyID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("PICvAbv50BdyMatID"), pHMGenParam->GetPrjParamID( CPrjParams::PICvAbv50BdyMatID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("PICvBlw65BdyMatID"), pHMGenParam->GetPrjParamID( CPrjParams::PICvBlw65BdyMatID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("PICvAbv50ConnectID"), pHMGenParam->GetPrjParamID( CPrjParams::PICvAbv50ConnectID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("PICvBlw65ConnectID"), pHMGenParam->GetPrjParamID( CPrjParams::PICvBlw65ConnectID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("PICvAbv50VersionID"), pHMGenParam->GetPrjParamID( CPrjParams::PICvAbv50VersionID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("PICvBlw65VersionID"), pHMGenParam->GetPrjParamID( CPrjParams::PICvBlw65VersionID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("PICvAbv50PNID"), pHMGenParam->GetPrjParamID( CPrjParams::PICvAbv50PNID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("PICvBlw65PNID"), pHMGenParam->GetPrjParamID( CPrjParams::PICvBlw65PNID ) );

	::AfxGetApp()->WriteProfileInt( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("ActuatorAutomaticallySelect"), ( true == pHMGenParam->GetActuatorAutomaticallySelect( ) ) ? 1 : 0 );
	::AfxGetApp()->WriteProfileInt( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("ActuatorSelectedByPackage"), ( true == pHMGenParam->GetActuatorSelectedByPackage( ) ) ? 1 : 0 );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("ActuatorPowerSupplyID"), pHMGenParam->GetPrjParamID( CPrjParams::ActuatorPowerSupplyID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("ActuatorInputSignalID"), pHMGenParam->GetPrjParamID( CPrjParams::ActuatorInputSignalID ) );
	::AfxGetApp()->WriteProfileInt( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("ActuatorFailSafe"), pHMGenParam->GetActuatorFailSafeFct() );
	::AfxGetApp()->WriteProfileInt( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("ActuatorDRP"), (int)pHMGenParam->GetActuatorDRPFct( ) );

	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DpCAbv50TypeID"), pHMGenParam->GetPrjParamID( CPrjParams::DpCAbv50TypeID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DpCBlw65TypeID"), pHMGenParam->GetPrjParamID( CPrjParams::DpCBlw65TypeID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DpCAbv50FamilyID"), pHMGenParam->GetPrjParamID( CPrjParams::DpCAbv50FamilyID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DpCBlw65FamilyID"), pHMGenParam->GetPrjParamID( CPrjParams::DpCBlw65FamilyID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DpCAbv50BdyMatID"), pHMGenParam->GetPrjParamID( CPrjParams::DpCAbv50BdyMatID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DpCBlw65BdyMatID"), pHMGenParam->GetPrjParamID( CPrjParams::DpCBlw65BdyMatID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DpCAbv50ConnectID"), pHMGenParam->GetPrjParamID( CPrjParams::DpCAbv50ConnectID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DpCBlw65ConnectID"), pHMGenParam->GetPrjParamID( CPrjParams::DpCBlw65ConnectID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DpCAbv50VersionID"), pHMGenParam->GetPrjParamID( CPrjParams::DpCAbv50VersionID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DpCBlw65VersionID"), pHMGenParam->GetPrjParamID( CPrjParams::DpCBlw65VersionID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DpCAbv50PNID"), pHMGenParam->GetPrjParamID( CPrjParams::DpCAbv50PNID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DpCBlw65PNID"), pHMGenParam->GetPrjParamID( CPrjParams::DpCBlw65PNID ) );

	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DpCBCValveAbv50TypeID"), pHMGenParam->GetPrjParamID( CPrjParams::DpCBCValveAbv50TypeID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DpCBCValveBlw65TypeID"), pHMGenParam->GetPrjParamID( CPrjParams::DpCBCValveBlw65TypeID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DpCBCValveAbv50FamilyID"), pHMGenParam->GetPrjParamID( CPrjParams::DpCBCValveAbv50FamilyID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DpCBCValveBlw65FamilyID"), pHMGenParam->GetPrjParamID( CPrjParams::DpCBCValveBlw65FamilyID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DpCBCValveAbv50BdyMatID"), pHMGenParam->GetPrjParamID( CPrjParams::DpCBCValveAbv50BdyMatID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DpCBCValveBlw65BdyMatID"), pHMGenParam->GetPrjParamID( CPrjParams::DpCBCValveBlw65BdyMatID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DpCBCValveAbv50ConnectID"), pHMGenParam->GetPrjParamID( CPrjParams::DpCBCValveAbv50ConnectID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DpCBCValveBlw65ConnectID"), pHMGenParam->GetPrjParamID( CPrjParams::DpCBCValveBlw65ConnectID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DpCBCValveAbv50VersionID"), pHMGenParam->GetPrjParamID( CPrjParams::DpCBCValveAbv50VersionID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DpCBCValveBlw65VersionID"), pHMGenParam->GetPrjParamID( CPrjParams::DpCBCValveBlw65VersionID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DpCBCValveAbv50PNID"), pHMGenParam->GetPrjParamID( CPrjParams::DpCBCValveAbv50PNID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("DpCBCValveBlw65PNID"), pHMGenParam->GetPrjParamID( CPrjParams::DpCBCValveBlw65PNID ) );

	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("SmartControlValveAbv50TypeID"), pHMGenParam->GetPrjParamID( CPrjParams::SmartControlValveAbv50TypeID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("SmartControlValveBlw65TypeID"), pHMGenParam->GetPrjParamID( CPrjParams::SmartControlValveBlw65TypeID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("SmartControlValveAbv50FamilyID"), pHMGenParam->GetPrjParamID( CPrjParams::SmartControlValveAbv50FamilyID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("SmartControlValveBlw65FamilyID"), pHMGenParam->GetPrjParamID( CPrjParams::SmartControlValveBlw65FamilyID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("SmartControlValveAbv50BdyMatID"), pHMGenParam->GetPrjParamID( CPrjParams::SmartControlValveAbv50BdyMatID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("SmartControlValveBlw65BdyMatID"), pHMGenParam->GetPrjParamID( CPrjParams::SmartControlValveBlw65BdyMatID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("SmartControlValveAbv50ConnectID"), pHMGenParam->GetPrjParamID( CPrjParams::SmartControlValveAbv50ConnectID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("SmartControlValveBlw65ConnectID"), pHMGenParam->GetPrjParamID( CPrjParams::SmartControlValveBlw65ConnectID) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("SmartControlValveAbv50VersionID"), pHMGenParam->GetPrjParamID( CPrjParams::SmartControlValveAbv50VersionID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("SmartControlValveBlw65VersionID"), pHMGenParam->GetPrjParamID( CPrjParams::SmartControlValveBlw65VersionID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("SmartControlValveAbv50PNID"), pHMGenParam->GetPrjParamID( CPrjParams::SmartControlValveAbv50PNID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("SmartControlValveBlw65PNID"), pHMGenParam->GetPrjParamID( CPrjParams::SmartControlValveBlw65PNID ) );

	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("SmartDpCAbv50TypeID"), pHMGenParam->GetPrjParamID( CPrjParams::SmartDpCAbv50TypeID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("SmartDpCBlw65TypeID"), pHMGenParam->GetPrjParamID( CPrjParams::SmartDpCBlw65TypeID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("SmartDpCAbv50FamilyID"), pHMGenParam->GetPrjParamID( CPrjParams::SmartDpCAbv50FamilyID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("SmartDpCBlw65FamilyID"), pHMGenParam->GetPrjParamID( CPrjParams::SmartDpCBlw65FamilyID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("SmartDpCAbv50BdyMatID"), pHMGenParam->GetPrjParamID( CPrjParams::SmartDpCAbv50BdyMatID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("SmartDpCBlw65BdyMatID"), pHMGenParam->GetPrjParamID( CPrjParams::SmartDpCBlw65BdyMatID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("SmartDpCAbv50ConnectID"), pHMGenParam->GetPrjParamID( CPrjParams::SmartDpCAbv50ConnectID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("SmartDpCBlw65ConnectID"), pHMGenParam->GetPrjParamID( CPrjParams::SmartDpCBlw65ConnectID) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("SmartDpCAbv50VersionID"), pHMGenParam->GetPrjParamID( CPrjParams::SmartDpCAbv50VersionID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("SmartDpCBlw65VersionID"), pHMGenParam->GetPrjParamID( CPrjParams::SmartDpCBlw65VersionID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("SmartDpCAbv50PNID"), pHMGenParam->GetPrjParamID( CPrjParams::SmartDpCAbv50PNID ) );
	::AfxGetApp()->WriteProfileString( REGISTRYSECTIONNAME_DLGTECHPARAM, _T("SmartDpCBlw65PNID"), pHMGenParam->GetPrjParamID( CPrjParams::SmartDpCBlw65PNID ) );
}

bool CTADatastruct::IsAnchorPtExist( CArray<CAnchorPt::eFunc> *paFunc, CAnchorPt::eFunc func )
{
	if( NULL == paFunc )
	{
		return false;
	}

	for( int i = 0; i < paFunc->GetCount(); i++ )
	{
		if( paFunc->GetAt( i ) == func )
		{
			return true;
		}
	}

	return false;
}

void CTADatastruct::UpdatePipeIDPtrs()
{
	// "PIPING_TAB": CDS_HydroMod
	CTable *pclTable = GetpHydroModTable();

	if( NULL == pclTable )
	{
		ASSERT_RETURN;
	}
	
	std::multimap<double, CDS_HydroMod *> mmapAllHMs;
	CollectHMList( pclTable, &mmapAllHMs );

	for( auto &iter : mmapAllHMs )
	{
		if( NULL == iter.second )
		{
			continue;
		}

		iter.second->UpdateAllPipesIDPtr();
	}
}

CDS_HydroMod *CTADatastruct::CreateNewHM( CTable *pInsertIn, CDB_CircuitScheme *pSch, CDB_ControlProperties::CvCtrlType CtrlType, bool bTaCV, bool bTerminalUnit,
		int iReturnType )
{
	try
	{
		// In search & replace for example, it is possible to change from a control valve defined by its Kvs with a IMI control valve.
		// If user has not defined the control type he wants, this one is let by default to 'eLastCvCtrlType'. We have no way to determine
		// the control type only with the circuit schematic. We must just be sure that if the method is called with the 'fTaCV' parameter set to 'true',
		// the 'CtrlType' parameter must not be set to 'eLastCvCtrlType' to avoid problem after in the code.
		if( true == bTaCV && CDB_ControlProperties::eLastCvCtrlType == CtrlType )
		{
			CtrlType = CDB_ControlProperties::eCvNU;
		}

		CTable *pTabCircSchCateg = static_cast<CTable *>( GetpTADB()->Get( _T("CIRCSCHCAT_TAB") ).MP );
		ASSERT( NULL != pTabCircSchCateg );

		IDPTR CircSchCategIDPtr = pTabCircSchCateg->Get( pSch->GetSchemeCategID() );
		ASSERT( _T('\0') != *CircSchCategIDPtr.ID );

		CDS_HydroMod *pHM = NULL;

		// Switch between scheme categories.
		// HYS-1882: Set SchemeIDPtr before setting return type.
		if( 0 == _tcscmp( CircSchCategIDPtr.ID, _T("SCHCATEG_SP") )
				|| 0 == _tcscmp( CircSchCategIDPtr.ID, _T("SCHCATEG_PDG") )
				|| 0 == _tcscmp( CircSchCategIDPtr.ID, _T("SCHCATEG_DC") ) )
		{
			IDPTR IDPtr;
			CreateObject( IDPtr, CLASS( CDS_HydroMod ) );
			pHM = static_cast<CDS_HydroMod *>( IDPtr.MP );
			pHM->SetSchemeIDPtr( pSch->GetIDPtr() );
			pHM->SetReturnType( ( CDS_HydroMod::ReturnType )iReturnType );
			pHM->Init( pSch->GetIDPtr(), pInsertIn, ( pSch->GetBalType() != CDB_CircuitScheme::eBALTYPE::SP ) );
		}
		else if( 0 == _tcscmp( CircSchCategIDPtr.ID, _T("SCHCATEG_PUMP") ) )
		{
			IDPTR IDPtr;
			CreateObject( IDPtr, CLASS( CDS_HydroMod ) );
			pHM = static_cast <CDS_HydroMod *>( IDPtr.MP );
			pHM->SetSchemeIDPtr( pSch->GetIDPtr() );
			pHM->SetReturnType( ( CDS_HydroMod::ReturnType )iReturnType );
			pHM->Init( pSch->GetIDPtr(), pInsertIn, ( pSch->GetBalType() != CDB_CircuitScheme::eBALTYPE::SP ) );
		}
		else if( 0 == _tcscmp( CircSchCategIDPtr.ID, _T("SCHCATEG_2WD") ) )
		{
			IDPTR IDPtr;
			CreateObject( IDPtr, CLASS( CDS_Hm2W ) );
			CDS_Hm2W *pHm2W = static_cast<CDS_Hm2W *>( IDPtr.MP );
			pHm2W->SetSchemeIDPtr( pSch->GetIDPtr() );
			pHm2W->SetReturnType( ( CDS_HydroMod::ReturnType )iReturnType );
			pHm2W->Init( pSch->GetIDPtr(), pInsertIn, bTaCV );
			pHM = dynamic_cast<CDS_Hm2W *>( pHm2W );
		}
		else if( true == pSch->GetpSchCateg()->IsInjection() )
		{
			if( eDpStab::DpStabOnBVBypass == pSch->GetDpStab() )
			{
				// HYS-1930: auto-adapting variable flow decoupling circuit.

				// We work exactly the same way as a 2-way injection.
				IDPTR IDPtr;
				CreateObject( IDPtr, CLASS( CDS_Hm2WInj ) );
				CDS_Hm2WInj *pHm2WInj = static_cast<CDS_Hm2WInj *>( IDPtr.MP );
				pHm2WInj->SetSchemeIDPtr( pSch->GetIDPtr() );
				pHm2WInj->SetReturnType( ( CDS_HydroMod::ReturnType )iReturnType );
				pHm2WInj->Init( pSch->GetIDPtr(), pInsertIn, bTaCV );
				pHM = dynamic_cast<CDS_Hm2WInj *>( pHm2WInj );
			}
			else if( CDB_ControlProperties::CV2W3W::CV2W == pSch->GetpSchCateg()->Get2W3W() )
			{
				IDPTR IDPtr;
				CreateObject( IDPtr, CLASS( CDS_Hm2WInj ) );
				CDS_Hm2WInj *pHm2WInj = static_cast<CDS_Hm2WInj *>( IDPtr.MP );
				pHm2WInj->SetSchemeIDPtr( pSch->GetIDPtr() );
				pHm2WInj->SetReturnType( ( CDS_HydroMod::ReturnType )iReturnType );
				pHm2WInj->Init( pSch->GetIDPtr(), pInsertIn, bTaCV );
				pHM = dynamic_cast<CDS_Hm2WInj *>( pHm2WInj );
			}
			else if( CDB_ControlProperties::CV2W3W::CV3W == pSch->GetpSchCateg()->Get2W3W() )
			{
				IDPTR IDPtr;
				CreateObject( IDPtr, CLASS( CDS_Hm3WInj ) );
				CDS_Hm3WInj *pHm3WInj = static_cast<CDS_Hm3WInj *>( IDPtr.MP );
				pHm3WInj->SetSchemeIDPtr( pSch->GetIDPtr() );
				pHm3WInj->SetReturnType( ( CDS_HydroMod::ReturnType )iReturnType );
				pHm3WInj->Init( pSch->GetIDPtr(), pInsertIn, bTaCV );
				pHM = dynamic_cast<CDS_Hm3WInj *>( pHm3WInj );
			}
		}
		else if( 0 == _tcscmp( CircSchCategIDPtr.ID, _T("SCHCATEG_3WD") ) )
		{
			IDPTR IDPtr;
			CreateObject( IDPtr, CLASS( CDS_Hm3W ) );
			CDS_Hm3W *pHm3W = static_cast<CDS_Hm3W *>( IDPtr.MP );
			pHm3W->SetSchemeIDPtr( pSch->GetIDPtr() );
			pHm3W->SetReturnType( ( CDS_HydroMod::ReturnType )iReturnType );
			pHm3W->Init( pSch->GetIDPtr(), pInsertIn, ( bTaCV ) );
			pHM = dynamic_cast<CDS_Hm3W *>( pHm3W );
		}
		else
		{
			HYSELECT_THROW( _T("Circuit schematic category '%s' unknown."), CircSchCategIDPtr.ID );
		}

		if( NULL != pHM->GetpCV() )
		{
			pHM->GetpCV()->SetCtrlType( CtrlType );
			pHM->GetpCV()->SetTACv( bTaCV );

			if( false == pHM->GetpCV()->IsTaCV() )
			{
				pHM->GetpCV()->SetCvIDPtr( _NULL_IDPTR );
			}
		}

		IDPTR IDPtr = pHM->GetIDPtr();

		// Attach object to his parent.
		pInsertIn->Insert( IDPtr );

		pHM->SetFlagModule( false == bTerminalUnit );

		// Always create a terminal unit.
		// When HM is a module, it's a virtual terminal unit that is used to store total flow and total Dp of children.
		pHM->CreateTermUnit();
		pHM->GetpTermUnit()->SetVirtual( false == bTerminalUnit );
		pHM->SetSchemeID( pSch->GetIDPtr().ID );

		// Define that the module is created in HMCalc mode.
		pHM->SetHMCalcMode( true );
		return pHM;
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CTADatastruct::CreateNewHM'."), __LINE__, __FILE__ );
		throw;
	}
}

void CTADatastruct::CopyCommonHMData( CDS_HydroMod *pHMSrc, CDS_HydroMod *pHMTo )
{
	try
	{
		IDPTR SchIDPtr = pHMTo->GetSchemeIDPtr();

		pHMTo->EnableComputeHM( false );

		// Copy temperature.
		CDS_HmInj *pHMtoInj = dynamic_cast<CDS_HmInj *>( pHMTo );
		CDS_HmInj *pHMSrcInj = dynamic_cast<CDS_HmInj *>( pHMSrc );

		if( NULL != pHMtoInj && NULL != pHMSrcInj )
		{
			if( NULL != pHMtoInj->GetpCV() && NULL != pHMSrcInj->GetpCV() )
			{
				pHMtoInj->GetpCV()->SetCVLocAuto( pHMSrcInj->GetpCV()->IsCVLocAuto() );
			}

			pHMtoInj->SetDesignCircuitSupplySecondaryTemperature( pHMSrcInj->GetDesignCircuitSupplySecondaryTemperature() );
			pHMtoInj->SetDesignCircuitReturnSecondaryTemperature( pHMSrcInj->GetDesignCircuitReturnSecondaryTemperature() );
		}

		// Copy previous HM common parameters into the new created HydroMod.
		// HYS-1753: Do not copy the TU values (flow, Dp ...) when the src HM and the destion HM
		// are not with terminal unit.
		if( ( NULL != pHMTo->GetpTermUnit() && NULL != pHMSrc->GetpTermUnit() )
		  && ( false == pHMTo->IsaModule() && false == pHMSrc->IsaModule() ) )
		{
			pHMSrc->GetpTermUnit()->CopyTo( pHMTo->GetpTermUnit() );

			// HYS-1766: Copy necessary terminal unit values into the valves.
			if( CTermUnit::_QType::Q == pHMSrc->GetpTermUnit()->GetQType() )
			{
				pHMTo->GetpTermUnit()->SetQ( pHMSrc->GetpTermUnit()->GetTerminalUnitData()->m_dQ );
			}
			else if( CTermUnit::_QType::PdT == pHMSrc->GetpTermUnit()->GetQType() )
			{
				pHMTo->GetpTermUnit()->SetPdT( pHMSrc->GetpTermUnit()->GetTerminalUnitData()->m_dP, pHMSrc->GetpTermUnit()->GetTerminalUnitData()->m_dDT );
			}
		}

		if( NULL != pHMTo->GetpCircuitPrimaryPipe() && NULL != pHMSrc->GetpCircuitPrimaryPipe() )
		{
			pHMSrc->GetpCircuitPrimaryPipe()->Copy( pHMTo->GetpCircuitPrimaryPipe() );
		}

		if( NULL != pHMTo->GetpCircuitSecondaryPipe() && NULL != pHMSrc->GetpCircuitSecondaryPipe() )
		{
			pHMSrc->GetpCircuitSecondaryPipe()->Copy( pHMTo->GetpCircuitSecondaryPipe() );
		}

		if( NULL != pHMTo->GetpDistrSupplyPipe() && NULL != pHMSrc->GetpDistrSupplyPipe() )
		{
			pHMSrc->GetpDistrSupplyPipe()->Copy( pHMTo->GetpDistrSupplyPipe() );
		}

		if( NULL != pHMTo->GetpDistrReturnPipe() && NULL != pHMSrc->GetpDistrReturnPipe() )
		{
			pHMSrc->GetpDistrReturnPipe()->Copy( pHMTo->GetpDistrReturnPipe() );
		}

		if( NULL != pHMTo->GetpPump() && NULL != pHMSrc->GetpPump() )
		{
			pHMSrc->GetpPump()->Copy( pHMTo->GetpPump() );
		}


		// Restore scheme.
		pHMTo->SetSchemeIDPtr( SchIDPtr );

		pHMTo->EnableComputeHM( true );

		// If we are editing a module detach leafs and attach it to the new module.
		if( true == pHMSrc->IsaModule() )
		{
			for( IDPTR IDPtr = pHMSrc->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pHMSrc->GetNext() )
			{
				pHMSrc->Remove( IDPtr );
				pHMTo->Insert( IDPtr );
			}
		}

		// Copy circuit position.
		pHMTo->SetPos( pHMSrc->GetPos() );
		pHMTo->SetLevel( pHMSrc->GetLevel() );

		// Keep non automatic name.
		pHMTo->SetHMName( pHMSrc->GetHMName() );
		pHMTo->SetDescription( pHMSrc->GetDescription() );
		pHMTo->SetRemL1( pHMSrc->GetRemL1() );

		// If pipes was locked keep it locked.
		if( false == pHMSrc->IsaModule() || ( NULL != pHMSrc->GetpSchcat() && true == pHMSrc->GetpSchcat()->IsInjection() ) )
		{
			pHMTo->GetpCircuitPrimaryPipe()->SetLock( pHMSrc->GetpCircuitPrimaryPipe()->IsLocked(), false );
		}
		else
		{
			// Circuit pipe doesn't exist for module.
			pHMTo->GetpCircuitPrimaryPipe()->RemoveAllSingularities();
			pHMTo->GetpCircuitPrimaryPipe()->SetLength( 0 );
			pHMTo->GetpCircuitPrimaryPipe()->SetLock( false, false );
		}

		if( false == pHMSrc->IsaModule() && NULL != pHMSrc->GetpSchcat() && NULL != pHMSrc->GetpCircuitSecondaryPipe() && NULL != pHMTo->GetpCircuitSecondaryPipe() )
		{
			pHMTo->GetpCircuitSecondaryPipe()->SetLock( pHMSrc->GetpCircuitSecondaryPipe()->IsLocked(), false );
		}
		else if( true == pHMTo->IsaModule() && NULL != pHMTo->GetpCircuitSecondaryPipe() )
		{
			// Secondary circuit pipe doesn't exist for module.
			pHMTo->GetpCircuitSecondaryPipe()->RemoveAllSingularities();
			pHMTo->GetpCircuitSecondaryPipe()->SetLength( 0 );
			pHMTo->GetpCircuitSecondaryPipe()->SetLock( false, false );
		}

		if( pHMSrc->GetLevel() != 0 )	// Not for the root module
		{
			pHMTo->GetpDistrSupplyPipe()->SetLock( pHMSrc->GetpDistrSupplyPipe()->IsLocked(), false );

			if( NULL != pHMTo->GetpDistrReturnPipe() && NULL != pHMSrc->GetpDistrReturnPipe() )
			{
				pHMTo->GetpDistrReturnPipe()->SetLock( pHMSrc->GetpDistrReturnPipe()->IsLocked(), false );
			}
		}
		else
		{
			// Distribution pipe doesn't exist for root module.
			pHMTo->GetpDistrSupplyPipe()->RemoveAllSingularities();
			pHMTo->GetpDistrSupplyPipe()->SetLength( 0.0 );

			if( NULL != pHMTo->GetpDistrReturnPipe() && NULL != pHMSrc->GetpDistrReturnPipe() )
			{
				pHMTo->GetpDistrReturnPipe()->RemoveAllSingularities();
				pHMTo->GetpDistrReturnPipe()->SetLength( 0.0 );
			}
		}

		// Delete previous selected circuit.
		IDPTR IDPtr = pHMSrc->GetIDPtr();
		IDPtr.PP->Remove( IDPtr );
		DeleteObject( IDPtr );
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CTADatastruct::CopyCommonHMData'."), __LINE__, __FILE__ );
		throw;
	}
}

const IDPTR CTADatastruct::CreateObjectInParentTable( IDPTR &ParentIDPtr, LPCTSTR ptcID, LPCTSTR ptcClassName, LPCTSTR ptcObjectName )
{
	try
	{
		IDPTR ObjIDptr = Get( ptcID );

		if( NULL == ObjIDptr.MP )
		{
			// Create ID for the project table.
			CreateObject( ObjIDptr, ptcClassName, ptcID );

			if( NULL != ptcObjectName )
			{
				static_cast<CTable *>( ObjIDptr.MP )->SetName( ptcObjectName );
			}

			( static_cast<CTable *>( ParentIDPtr.MP ) )->Insert( ObjIDptr );
			return ObjIDptr;
		}
		else
		{
			return ObjIDptr;
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CTADatastruct::CreateObjectInParentTable'."), __LINE__, __FILE__ );
		throw;
	}
}

void CTADatastruct::_RunAllPipesInTheDatastruct( CTADatastruct::pfRunAllPipesFeedBack fOnePipeFeedBack, LPARAM lpFeedBackParam )
{
	// For hydromod, we will retrieve the list of all available CDS_HydroMod objects.
	// And for each one, we need to verify for all pipes defined in a 'CDS_HydroMod':
	//	CDS_HydroMod::CMeasData::CHMXPipe *m_pDistributionPipe
	//	CDS_HydroMod::CMeasData::CHMXPipe *m_pCircuitPipe
	//	CDS_Hydromod::CPipes *m_pCircPipe;
	//	CDS_Hydromod::CPipes *m_pDistrSupplyPipe;
	//	CDS_Hydromod::CPipes *m_pDistrReturnPipe;
	//	CDS_Hydromod::CPipes *m_pSecPipe;

	std::multimap<double, CDS_HydroMod *> mapHydroMod;
	CollectHMList( GetpHydroModTable(), &mapHydroMod );

	for( auto &iterHydroMod : mapHydroMod )
	{
		for( int iLoopMeasData = 0; iLoopMeasData < (int)iterHydroMod.second->GetMeasDataSize(); iLoopMeasData++ )
		{
			CDS_HydroMod::CMeasData *pMeasData = iterHydroMod.second->GetpMeasData( iLoopMeasData );

			if( NULL == pMeasData )
			{
				ASSERT_CONTINUE;
			}

			if( NULL != pMeasData->GetpDistributionPipe() && NULL != pMeasData->GetpDistributionPipe()->GetpPipe() )
			{
				(this->*fOnePipeFeedBack)( (IDPTR &)pMeasData->GetpDistributionPipe()->GetpPipe()->GetIDPtr(), lpFeedBackParam );
			}

			if( NULL != pMeasData->GetpCircuitPipe() && NULL != pMeasData->GetpCircuitPipe()->GetpPipe() )
			{
				(this->*fOnePipeFeedBack)( (IDPTR &)pMeasData->GetpCircuitPipe()->GetpPipe()->GetIDPtr(), lpFeedBackParam );
			}
		}

		if( NULL != iterHydroMod.second->GetpCircuitPrimaryPipe() )
		{
			(this->*fOnePipeFeedBack)( iterHydroMod.second->GetpCircuitPrimaryPipe()->GetIDPtr(), lpFeedBackParam );
			(this->*fOnePipeFeedBack)( iterHydroMod.second->GetpCircuitPrimaryPipe()->GetBestPipeIDPtr(), lpFeedBackParam );
			(this->*fOnePipeFeedBack)( iterHydroMod.second->GetpCircuitPrimaryPipe()->GetDiversityIDPtr(), lpFeedBackParam );

			std::vector<CPipes::CSingularity *> vecSingularities;
			iterHydroMod.second->GetpCircuitPrimaryPipe()->GetSingularityList( &vecSingularities );

			for( auto &iterSingularity : vecSingularities )
			{
				if( CDS_HydroMod::eDpType::Pipelength == iterSingularity->m_eDpType )
				{
					(this->*fOnePipeFeedBack)( iterSingularity->m_IDPtr, lpFeedBackParam );
				}
			}

			iterHydroMod.second->GetpCircuitPrimaryPipe()->ClearSingularityVector( &vecSingularities );
		}

		if( NULL != iterHydroMod.second->GetpCircuitSecondaryPipe() )
		{
			(this->*fOnePipeFeedBack)( iterHydroMod.second->GetpCircuitSecondaryPipe()->GetIDPtr(), lpFeedBackParam );
			(this->*fOnePipeFeedBack)( iterHydroMod.second->GetpCircuitSecondaryPipe()->GetBestPipeIDPtr(), lpFeedBackParam );
			(this->*fOnePipeFeedBack)( iterHydroMod.second->GetpCircuitSecondaryPipe()->GetDiversityIDPtr(), lpFeedBackParam );

			std::vector<CPipes::CSingularity *> vecSingularities;
			iterHydroMod.second->GetpCircuitSecondaryPipe()->GetSingularityList( &vecSingularities );

			for( auto &iterSingularity : vecSingularities )
			{
				if( CDS_HydroMod::eDpType::Pipelength == iterSingularity->m_eDpType )
				{
					(this->*fOnePipeFeedBack)( iterSingularity->m_IDPtr, lpFeedBackParam );
				}
			}

			iterHydroMod.second->GetpCircuitSecondaryPipe()->ClearSingularityVector( &vecSingularities );
		}

		if( NULL != iterHydroMod.second->GetpDistrSupplyPipe() )
		{
			(this->*fOnePipeFeedBack)( iterHydroMod.second->GetpDistrSupplyPipe()->GetIDPtr(), lpFeedBackParam );
			(this->*fOnePipeFeedBack)( iterHydroMod.second->GetpDistrSupplyPipe()->GetBestPipeIDPtr(), lpFeedBackParam );
			(this->*fOnePipeFeedBack)( iterHydroMod.second->GetpDistrSupplyPipe()->GetDiversityIDPtr(), lpFeedBackParam );

			std::vector<CPipes::CSingularity *> vecSingularities;
			iterHydroMod.second->GetpDistrSupplyPipe()->GetSingularityList( &vecSingularities );

			for( auto &iterSingularity : vecSingularities )
			{
				if( CDS_HydroMod::eDpType::Pipelength == iterSingularity->m_eDpType )
				{
					(this->*fOnePipeFeedBack)( iterSingularity->m_IDPtr, lpFeedBackParam );
				}
			}

			iterHydroMod.second->GetpDistrSupplyPipe()->ClearSingularityVector( &vecSingularities );
		}

		if( NULL != iterHydroMod.second->GetpDistrReturnPipe() )
		{
			(this->*fOnePipeFeedBack)( iterHydroMod.second->GetpDistrReturnPipe()->GetIDPtr(), lpFeedBackParam );
			(this->*fOnePipeFeedBack)( iterHydroMod.second->GetpDistrReturnPipe()->GetBestPipeIDPtr(), lpFeedBackParam );
			(this->*fOnePipeFeedBack)( iterHydroMod.second->GetpDistrReturnPipe()->GetDiversityIDPtr(), lpFeedBackParam );

			std::vector<CPipes::CSingularity *> vecSingularities;
			iterHydroMod.second->GetpDistrReturnPipe()->GetSingularityList( &vecSingularities );

			for( auto &iterSingularity : vecSingularities )
			{
				if( CDS_HydroMod::eDpType::Pipelength == iterSingularity->m_eDpType )
				{
					(this->*fOnePipeFeedBack)( iterSingularity->m_IDPtr, lpFeedBackParam );
				}
			}

			iterHydroMod.second->GetpDistrReturnPipe()->ClearSingularityVector( &vecSingularities );
		}
	}

	// For product selection, we will run all the objects in the CTADatastruct and check those that are a 'CDS_SelProd' object.
	if( NULL != GetpDataList() )
	{
		for( IDPTR IDPtr = GetpDataList()->GetFirst(); _NULL_IDPTR != IDPtr; IDPtr = GetpDataList()->GetNext() )
		{
			if( NULL != dynamic_cast<CDS_SelProd *>( (CData *)( IDPtr.MP ) ) )
			{
				CDS_SelProd *pclSelProd = (CDS_SelProd *)( (CData *)( IDPtr.MP ) );

				if( NULL != pclSelProd->GetpSelPipe() && NULL != pclSelProd->GetpSelPipe()->GetpPipe() )
				{
					(this->*fOnePipeFeedBack)( (IDPTR &)pclSelProd->GetpSelPipe()->GetpPipe()->GetIDPtr(), lpFeedBackParam );
				}
			}
		}
	}
}

void CTADatastruct::_CheckIfUserPipeSeriesToAdd( IDPTR &IDPtr, LPARAM lpFeedBackParam )
{
	// HYS-1590: Feedback method for the "AddUsedUserPipesBeforeSavingProject" method.
	
	if( _T('\0') == *IDPtr.ID || NULL == IDPtr.MP )
	{
		return;
	}

	CDB_Pipe *pclPipe = dynamic_cast<CDB_Pipe *>( IDPtr.MP );

	if( NULL == pclPipe )
	{
		ASSERT_RETURN;
	}

	// Feedback method for the "AddUsedUserPipesBeforeSavingProject" method.
	std::vector<CTable *> *pvecUserPipeSeries = (std::vector<CTable *> *)lpFeedBackParam;

	if( NULL != pclPipe )
	{
		if( false == pclPipe->IsFixed() && NULL != pclPipe->GetIDPtr().PP && NULL != dynamic_cast<CTable *>( pclPipe->GetIDPtr().PP ) )
		{
			CTable *pclPipeSeries = (CTable *)( pclPipe->GetIDPtr().PP );
			auto &iter = std::find( pvecUserPipeSeries->begin(), pvecUserPipeSeries->end(), pclPipeSeries );

			if( iter == pvecUserPipeSeries->end() )
			{
				pvecUserPipeSeries->push_back( pclPipeSeries );
			}
		}
	}
}

void CTADatastruct::_UpdateOneOldPipeID( IDPTR &IDPtr, LPARAM lpParam )
{
	// HYS-1590: Feedback method for the "VerifyPipeSeriesWhenOpeningProject" method.

	if( _T('\0') == *IDPtr.ID )
	{
		return;
	}

	std::pair<std::vector<CString> *, std::vector<CString> *> *pPair = (std::pair<std::vector<CString> *, std::vector<CString> *> *)( lpParam );
	std::vector<CString> *pvecPipeSeriesInProjectNotInHySelect = pPair->first;
	std::vector<CString> *pvecPipeSeriesInProjectButDeletedInHySelect = pPair->second;

	if( NULL == pvecPipeSeriesInProjectNotInHySelect || NULL == pvecPipeSeriesInProjectButDeletedInHySelect )
	{
		ASSERT_RETURN;
	}
	
	// Because when reading the "pipes.db" we already converted old pipe series and pipe IDs, we can convert
	// here all the old reference in the project and verify if IDs exist in the user pipe database or it they are deleted.
	CString strNewPipeID = TASApp.GetpPipeDB()->RenameOneOldPipeID( CString( IDPtr.ID ), CPipeUserDatabase::Convert_Pipe );

	if( false == strNewPipeID.IsEmpty() )
	{
		_tcscpy( IDPtr.ID, strNewPipeID );
	}

	// We can in the same time check if pipe series in which the current pipe in the project is or not in HySelect or is or not deleted.

	// Check if we can retrieve the pipe ID in the user pipe database in HySelect.
	IDPTR PipeInHySelectIDPtr = TASApp.GetpPipeDB()->Get( IDPtr.ID );

	if( _NULL_IDPTR == PipeInHySelectIDPtr || true == ( (CDB_Pipe *)( PipeInHySelectIDPtr.MP ) )->IsDeleted() )
	{
		// Pipe is not found in the user pipe database in HySelect or found but this pipe is now deleted in HySelect.

		// At this stage, the current 'IDPtr' variable is the one in the project (A pipe in a 'CDS_HydroMod' object or in a product selection).
		// But 'MP' and 'PP' are not defined. We need thus to retrieve the true 'CDB_Pipe' object in the 'PIPE_TABLE' of the current
		// project to retrieve in which pipe series it belongs.

		CTable *pclPipeSeriesTable = NULL;

		if( _NULL_IDPTR == PipeInHySelectIDPtr )
		{
			// If 'PipeInHySelectIDPtr' is null, it means that this pipe does not exist in HySelect. So, we will search the parent pipe series
			// in the 'PIPE_TAB' of the current tsp project.
			pclPipeSeriesTable = TASApp.GetpPipeDB()->GetPipeTab( this, false );
		}
		else
		{
			// It's the other condition in the 'if' above, thus the pipe is deleted. So, we will search the parent pipe series in the
			// 'PIPE_TAB' of the HySelect database.
			pclPipeSeriesTable = TASApp.GetpPipeDB()->GetPipeTab();
		}

		ASSERT( NULL != pclPipeSeriesTable );

		// Search now in which pipe series belongs the current pipe.
		bool bStop = false;

		for( IDPTR PipeSeriesIDPtr = pclPipeSeriesTable->GetFirst(); _NULL_IDPTR != PipeSeriesIDPtr && false == bStop; PipeSeriesIDPtr = pclPipeSeriesTable->GetNext() )
		{
			CTable *pclPipeSeries = dynamic_cast<CTable *>( PipeSeriesIDPtr.MP );
			ASSERT( NULL != pclPipeSeries );

			// For each pipe series, run all pipes.
			for( IDPTR PipeInSeriesIDPtr = pclPipeSeries->GetFirst(); _NULL_IDPTR != PipeInSeriesIDPtr && false == bStop; PipeInSeriesIDPtr = pclPipeSeries->GetNext() )
			{
				ASSERT( _T('\0') != *PipeInSeriesIDPtr.ID );

				if( 0 == _tcscmp( PipeInSeriesIDPtr.ID, IDPtr.ID ) )
				{
					if( _NULL_IDPTR == PipeInHySelectIDPtr )
					{
						// Put in the not exist in HySelect vector if not yet in it.
						if( pvecPipeSeriesInProjectNotInHySelect->end() == std::find( pvecPipeSeriesInProjectNotInHySelect->begin(), 
								pvecPipeSeriesInProjectNotInHySelect->end(), PipeSeriesIDPtr.ID ) )
						{
							pvecPipeSeriesInProjectNotInHySelect->push_back( PipeSeriesIDPtr.ID );
						}
					}
					else
					{
						// Put in the deleted vector if not yet in it.
						if( pvecPipeSeriesInProjectButDeletedInHySelect->end() == std::find( pvecPipeSeriesInProjectButDeletedInHySelect->begin(), 
								pvecPipeSeriesInProjectButDeletedInHySelect->end(), PipeSeriesIDPtr.ID ) )
						{
							pvecPipeSeriesInProjectButDeletedInHySelect->push_back( PipeSeriesIDPtr.ID );
						}						
					}

					bStop = true;
				}
			}
		}
	}
}

#endif

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_WaterCharacteristic
//
///////////////////////////////////////////////////////////////////////////////////
CWaterChar::CWaterChar()
{
	_tcsncpy_s( m_AdditFamID, SIZEOFINTCHAR( m_AdditFamID ), _T("WATER_ADDIT"), SIZEOFINTCHAR( m_AdditFamID ) - 1 );
	_tcsncpy_s( m_AdditID, SIZEOFINTCHAR( m_AdditID ), _T("WATER"), SIZEOFINTCHAR( m_AdditID ) - 1 );
	m_dTemp = 20.0;
	m_dPcWeight = 0.0;
	m_dDens = 998.2;
	m_dKinVisc = 1.004e-6;
	m_dSpecifHeat = 4182.0;
	m_dTfreez = 0.0;
	m_bSpecifHeat = false;
	m_bIsForChangeOver = false;
	m_pclSecondWaterChar = NULL;
}

CWaterChar::CWaterChar( const CWaterChar &WaterCharCopy )
{
	_tcsncpy_s( m_AdditFamID, SIZEOFINTCHAR( m_AdditFamID ), _T("WATER_ADDIT"), SIZEOFINTCHAR( m_AdditFamID ) - 1 );
	_tcsncpy_s( m_AdditID, SIZEOFINTCHAR( m_AdditID ), _T("WATER"), SIZEOFINTCHAR( m_AdditID ) - 1 );
	m_dTemp = 20.0;
	m_dPcWeight = 0.0;
	m_dDens = 998.2;
	m_dKinVisc = 1.004e-6;
	m_dSpecifHeat = 4182.0;
	m_dTfreez = 0.0;
	m_bSpecifHeat = false;
	m_bIsForChangeOver = false;
	m_pclSecondWaterChar = NULL;
	*this = WaterCharCopy;
}

CWaterChar::~CWaterChar()
{
	if( NULL != m_pclSecondWaterChar ) 
	{
		delete m_pclSecondWaterChar; 
		m_pclSecondWaterChar = NULL;
	}
}

CDB_AdditCharacteristic *CWaterChar::GetpAdditChar()
{
	if( 0 == _tcscmp( GetAdditFamID(), _T("OTHER_ADDIT") ) )
	{
		return NULL;
	}

	CDB_StringID *pStrID = static_cast<CDB_StringID *>( GetpTADB()->Get( GetAdditID() ).MP );

	if( NULL == pStrID )
	{
		return NULL;
	}

	CDB_AdditCharacteristic *pAdditChar = static_cast<CDB_AdditCharacteristic *>( GetpTADB()->Get( pStrID->GetIDstr() ).MP );
	return pAdditChar;
}

bool CWaterChar::SetAdditFamID( LPCTSTR ID )
{
	bool bReturn = false;

	if( 0 != _tcscmp( ID, m_AdditFamID ) )
	{
		_tcsncpy_s( m_AdditFamID, SIZEOFINTCHAR( m_AdditFamID ), ID, SIZEOFINTCHAR( m_AdditFamID ) - 1 );
		bReturn = true;
	}

	return bReturn;
}

bool CWaterChar::SetAdditID( LPCTSTR ID )
{
	bool bReturn = false;

	if( 0 != _tcscmp( ID, m_AdditID ) )
	{
		_tcsncpy_s( m_AdditID, SIZEOFINTCHAR( m_AdditID ), ID, SIZEOFINTCHAR( m_AdditID ) - 1 );
		bReturn = true;
	}

	return bReturn;
}

bool CWaterChar::SetTemp( double dTemperature )
{
	bool bReturn = false;

	if( m_dTemp != dTemperature )
	{
		m_dTemp = dTemperature;
		bReturn = true;
	}

	return bReturn;
}

bool CWaterChar::SetPcWeight( double dPCWeight )
{
	bool bReturn = false;

	if( m_dPcWeight != dPCWeight )
	{
		m_dPcWeight = dPCWeight;
		bReturn = true;
	}

	return bReturn;
}

bool CWaterChar::SetDens( double dDensity )
{
	bool bReturn = false;

	if( m_dDens != dDensity )
	{
		m_dDens = dDensity;
		bReturn = true;
	}

	return bReturn;
}

bool CWaterChar::SetKinVisc( double dKinematicViscosity )
{
	bool bReturn = false;

	if( m_dKinVisc != dKinematicViscosity )
	{
		m_dKinVisc = dKinematicViscosity;
		bReturn = true;
	}

	return bReturn;
}

bool CWaterChar::SetSpecifHeat( double dSpecificHeat )
{
	bool bReturn = false;

	if( m_dSpecifHeat != dSpecificHeat )
	{
		m_dSpecifHeat = dSpecificHeat;
		bReturn = true;
	}

	return bReturn;
}

bool CWaterChar::SetTfreez( double dFrozenTemperature )
{
	bool bReturn = false;

	if( m_dTfreez != dFrozenTemperature )
	{
		m_dTfreez = dFrozenTemperature;
		bReturn = true;
	}

	return bReturn;
}

bool CWaterChar::SetCheckSpecifHeat( bool bSpecificHeat )
{
	bool bReturn = false;

	if( m_bSpecifHeat != bSpecificHeat )
	{
		m_bSpecifHeat = bSpecificHeat;
		bReturn = true;
	}

	return bReturn;
}

void CWaterChar::SetIsForChangeOver( bool bForChangeOver )
{
	// Change the boolean and create the second water char if it doesn't exist only if bForChangeOver = true
	m_bIsForChangeOver = bForChangeOver;

	if( NULL == m_pclSecondWaterChar )
	{
		InitChangeOverData();
	}
	else if( false == bForChangeOver )
	{
		delete m_pclSecondWaterChar;
		m_pclSecondWaterChar = NULL;
	}
}

void CWaterChar::BuildWaterStrings( _string &str1, _string &str2, const TCHAR *ptcWaterChar, const TCHAR *ptcFluid, const TCHAR *ptcFluidWeight,
		const TCHAR *ptcSupplyTemperature, bool bfull )
{
	// *** String strTsp.
	BuildWaterNameString( str1, ptcWaterChar, ptcFluid, ptcFluidWeight, bfull );

	// *** String strTss.
	str2 = ptcSupplyTemperature;
	str2 = str2 + _T(": ") + WriteCUDouble( _U_TEMPERATURE, m_dTemp, true );
}

void CWaterChar::BuildWaterNameString( _string &str1, const TCHAR *ptcWaterChar, const TCHAR *ptcFluid, const TCHAR *ptcFluidWeight, bool bfull )
{
	_string tmp;
	CTADatabase *pTADB = GetpTADB();

	// Get the pointer on the additive characteristics.
	_string AdditCharID = ( static_cast<CDB_StringID *>( pTADB->Get( m_AdditID ).MP ) )->GetIDstr();
	CDB_AdditCharacteristic *pAdditChar = static_cast<CDB_AdditCharacteristic *>( pTADB->Get( AdditCharID.c_str() ).MP );
	ASSERT( NULL != pAdditChar );

	// Compose the name of the fluid
	if( 0 == _tcscmp( m_AdditFamID, _T("WATER_ADDIT") ) )		// Water
	{
		str1 = ptcWaterChar;
	}
	else if( 0 == _tcscmp( m_AdditFamID, _T("OTHER_ADDIT") ) )	// Any other fluid
	{
		str1 = ptcFluid;
		str1 = str1 + _T(": " ) + WriteCUDouble( _U_DENSITY, m_dDens, true ) + _T( ", ");
		str1 = str1 + WriteCUDouble( _U_KINVISCOSITY, m_dKinVisc, true );
	}
	else if( true == pAdditChar->IsaDilutedAddit() )							// Diluted additives
	{
		tmp = ptcFluidWeight;

		if( true == bfull )
		{
			str1 = ptcWaterChar + _string( _T("/") );
		}

		str1 = str1 + ( static_cast<CDB_StringID *>( pTADB->Get( m_AdditID ).MP ) )->GetString();
		str1 = str1 + _T(" - ") + WriteDouble( m_dPcWeight, 2, 1, true ) + tmp ;
	}
	else										// Ready-to-use fluids
	{
		str1 = ( static_cast<CDB_StringID *>( pTADB->Get( m_AdditID ).MP ) )->GetString();
	}
}

#ifndef TACBX
void CWaterChar::BuildWaterStrings( CString &str1, CString &str2 )
{
	_string s1, s2;
	BuildWaterStrings( s1, s2, TASApp.LoadLocalizedString( IDS_WATERCHAR_WATER ), TASApp.LoadLocalizedString( IDS_WATERCHAR_FLUID )
		   , TASApp.LoadLocalizedString( IDS_WATERCHAR_PCWEIGHT ), TASApp.LoadLocalizedString( IDS_WATERCHAR_TEMP ) );
	str1 = s1.c_str();
	str2 = s2.c_str();
}

void CWaterChar::BuildWaterStringsRibbonBar( CString &str1, CString &str2, CString &str3 )
{
	// Variables
	CString tmp;
	CString sWaterChar = TASApp.LoadLocalizedString( IDS_WATERCHAR_WATER );
	CString sFluid = TASApp.LoadLocalizedString( IDS_WATERCHAR_FLUID );
	CString sFluidWeight = TASApp.LoadLocalizedString( IDS_WATERCHAR_PCWEIGHT );
	CString sTemp = TASApp.LoadLocalizedString( IDS_WATERCHAR_TEMP );

	CTADatabase *pTADB = GetpTADB();
	// Get the pointer on the additive characteristics
	_string AdditCharID = ( static_cast<CDB_StringID *>( pTADB->Get( m_AdditID ).MP ) )->GetIDstr();
	CDB_AdditCharacteristic *pAdditChar = static_cast<CDB_AdditCharacteristic *>( pTADB->Get( AdditCharID.c_str() ).MP );
	ASSERT( pAdditChar );

	str1.Empty();
	str2.Empty();
	str3.Empty();

	// *** String strTsp and strTss
	// Compose the name of the fluid
	if( 0 == _tcscmp( m_AdditFamID, _T("WATER_ADDIT") ) )	// Water
	{
		str1 = sWaterChar;
		str2 = _T("");
	}
	else if( 0 == _tcscmp( m_AdditFamID, _T("OTHER_ADDIT") ) )	// Any other fluid
	{
		str1 = sFluid;
		str2 = WriteCUDouble( _U_DENSITY, m_dDens, true );
		str2 = str2 +  _T(", ");
		str2 = str2 + WriteCUDouble( _U_KINVISCOSITY, m_dKinVisc, true );
	}
	else if( true == pAdditChar->IsaDilutedAddit() )	// Diluted additives
	{
		tmp = sFluidWeight;
		str1 = sWaterChar + _T("/");
		str1 = str1 + ( static_cast<CDB_StringID *>( pTADB->Get( m_AdditID ).MP ) )->GetString();
		str2 = WriteDouble( m_dPcWeight, 2, 1, true ) + tmp ;
	}
	else	// Ready-to-use fluids
	{
		str1 = ( static_cast<CDB_StringID *>( pTADB->Get( m_AdditID ).MP ) )->GetString();
	}

	// *** String strTrs
	str3 = WriteCUDouble( _U_TEMPERATURE, m_dTemp, true );
}

void CWaterChar::BuildWaterNameString( CString &str1, bool bFull )
{
	_string s1;

	BuildWaterNameString( s1, TASApp.LoadLocalizedString( IDS_WATERCHAR_WATER ), TASApp.LoadLocalizedString( IDS_WATERCHAR_FLUID ), 
			TASApp.LoadLocalizedString( IDS_WATERCHAR_PCWEIGHT ), bFull );

	str1 = s1.c_str();
}

void CWaterChar::BuildTempChangeOverStringsRibbonBar( CString &str1, CString &str2 )
{
	// *** Temperature Cooling temp / Heating temp.
	str1 = WriteCUDouble( _U_TEMPERATURE, m_dTemp, true );

	if( NULL != m_pclSecondWaterChar )
	{
		str1 += _T(" / ");
		str1 += WriteCUDouble( _U_TEMPERATURE, m_pclSecondWaterChar->GetTemp(), true );
	}

	// *** DT Cooling / DT Heating.
	CDS_TechnicalParameter *pTechP = TASApp.GetpTADS()->GetpTechParams();

	str2 = WriteCUDouble( _U_DIFFTEMP, pTechP->GetDefaultISChangeOverDT( CoolingSide ), true );

	if( NULL != m_pclSecondWaterChar )
	{
		str2 += _T(" / ");
		str2 += WriteCUDouble( _U_DIFFTEMP, pTechP->GetDefaultISChangeOverDT( HeatingSide ), true );
	}
}
#endif

bool CWaterChar::IsDensityDefined()
{
	bool bIsDefined = false;

	if( 0 == wcscmp( m_AdditFamID, _T("OTHER_ADDIT") ) 
			|| ( NULL != GetpAdditChar() && true == GetpAdditChar()->IsDensityDefined() ) )
	{
		bIsDefined = true;
	}

	return bIsDefined;
}

bool CWaterChar::IsKinematicViscosityDefined()
{
	bool bIsDefined = false;

	if( 0 == wcscmp( m_AdditFamID, _T("OTHER_ADDIT") ) 
			|| ( NULL != GetpAdditChar() && true == GetpAdditChar()->IsKinematicViscosityDefined() ) )
	{
		bIsDefined = true;
	}

	return bIsDefined;
}

bool CWaterChar::IsSpecificHeatDefined()
{
	bool bIsDefined = false;

	if( ( 0 == wcscmp( m_AdditFamID, _T("OTHER_ADDIT") ) && true == m_bSpecifHeat )
			|| ( NULL != GetpAdditChar() && true == GetpAdditChar()->IsSpecificHeatDefined() ) )
	{
		bIsDefined = true;
	}

	return bIsDefined;
}

bool CWaterChar::IsVaporPressureDefined()
{
	bool bIsDefined = false;

	if( NULL != GetpAdditChar() && true == GetpAdditChar()->IsVaporPressureDefined() )
	{
		bIsDefined = true;
	}

	return bIsDefined;
}

CWaterChar &CWaterChar::operator=( const CWaterChar &wc )
{
	_tcsncpy_s( m_AdditFamID, SIZEOFINTCHAR( m_AdditFamID ), wc.m_AdditFamID, SIZEOFINTCHAR( m_AdditFamID ) - 1 );
	_tcsncpy_s( m_AdditID, SIZEOFINTCHAR( m_AdditID ), wc.m_AdditID, SIZEOFINTCHAR( m_AdditID ) - 1 );
	m_dTemp = wc.m_dTemp;
	m_dPcWeight = wc.m_dPcWeight;
	m_dDens = wc.m_dDens;
	m_dKinVisc = wc.m_dKinVisc;
	m_dSpecifHeat = wc.m_dSpecifHeat;
	m_dTfreez = wc.m_dTfreez;
	m_bSpecifHeat = wc.m_bSpecifHeat;
	m_bIsForChangeOver = wc.m_bIsForChangeOver;

	if( NULL != m_pclSecondWaterChar )
	{
		delete m_pclSecondWaterChar;
		m_pclSecondWaterChar = NULL;
	}
	
	if( NULL != wc.m_pclSecondWaterChar )
	{
		m_pclSecondWaterChar = new CWaterChar();
		*m_pclSecondWaterChar = *( wc.m_pclSecondWaterChar );
	}
	
	return *this;
}

bool CWaterChar::operator==( CWaterChar &wc )
{
	bool bRet = true;
	_string str = m_AdditFamID;
	_string str1 = wc.m_AdditFamID;
	bRet = ( str == str1 );
	str = m_AdditID;
	str1 = wc.m_AdditID;
	bRet &= ( str == str1 );
	bRet &= ( m_dTemp == wc.m_dTemp );
	bRet &= ( m_dPcWeight == wc.m_dPcWeight );
	bRet &= ( m_dDens == wc.m_dDens );
	bRet &= ( m_dKinVisc == wc.m_dKinVisc );
	bRet &= ( m_dSpecifHeat == wc.m_dSpecifHeat );
	bRet &= ( m_dTfreez == wc.m_dTfreez );
	bRet &= ( m_bSpecifHeat == wc.m_bSpecifHeat );

	// For changeOver.
	bRet &= ( m_bIsForChangeOver == wc.m_bIsForChangeOver );

	if( NULL != m_pclSecondWaterChar && NULL != wc.m_pclSecondWaterChar )
	{
		bRet &= ( *m_pclSecondWaterChar == *( wc.m_pclSecondWaterChar ) );
	}
	else if( NULL != m_pclSecondWaterChar || NULL != wc.m_pclSecondWaterChar )
	{
		bRet &= false;
	}

	return bRet;
}

bool CWaterChar::operator!=( CWaterChar &wc )
{
	return !( *this == wc );
}

bool CWaterChar::Compare( CWaterChar &wc, bool bWithTemp )
{
	if( true == bWithTemp )
	{
		return ( *this == wc );
	}

	m_dTemp = wc.m_dTemp;
	bool bRet = ( *this == wc );
	wc.m_dTemp = m_dTemp;
	return bRet;
}

CWaterChar::eFluidRetCode CWaterChar::CheckFluidData( double &dTemp, double *pdPCWeight )
{
	if( 0 == wcscmp( GetAdditFamID(), _T("OTHER_ADDIT") ) )
	{
		return CWaterChar::efrcFluidUnknown;
	}

	double dPCWeight = m_dPcWeight;

	if( NULL != pdPCWeight )
	{
		dPCWeight = *pdPCWeight;
	}

	// Get the freezing temperature of the mixture.
	double dTempfreez = GetTfreez( );

	// Check if the phase is liquid or solid and update accordingly.
	if( dTemp < dTempfreez )
	{
		dTemp = dTempfreez;
		return CWaterChar::efrcTemperatureTooLow;
	}
	else
	{
		double dDensity = GetDens();
		double dKinVisc = GetKinVisc();
		double dSpecifHeat = 0;
		double dVaporPressure = 0;
		
		// Liquid phase.
		enum SurfValReturn_enum SVReturn = GetpAdditChar()->GetAdditProp( dPCWeight, dTemp, &dDensity, &dKinVisc, &dSpecifHeat, &dVaporPressure );

		switch( SVReturn )
		{
			case SV_OK:
				return CWaterChar::efrcFluidOk;

			case SV_OUTOFXRANGE: // Additive percentage above max. value
				dPCWeight = GetpAdditChar()->GetMaxPc( );

				if( NULL != pdPCWeight )
				{
					*pdPCWeight = dPCWeight;
				}

				return CWaterChar::efrcAdditiveTooHigh;

			case SV_ABOVEYMAX: // Temperature above max. value
				dTemp = GetpAdditChar()->GetMaxT( dPCWeight );
				return CWaterChar::efrcTempTooHigh;

			// TO avoid warning compilation.
			case SV_OUTOFXYRANGE:
			case SV_OUTOFYRANGE:
			case SV_BELOWYMIN:
			case SV_UNKNOWERROR:
			case SV_LAST:
				break;
		}
	}

	return CWaterChar::efrcFluidUnknown;
}

bool CWaterChar::UpdateFluidData( CDB_AdditCharacteristic *pAdditChar, double dTemp, double dPcWeight )
{
	if( NULL == pAdditChar )
	{
		return false;
	}

	SetTemp( dTemp );

	if( -1.0 != dPcWeight )
	{
		SetPcWeight( dPcWeight );
	}

	if( false == wcscmp( pAdditChar->GetIDPtr().ID, _T("OTHER_ADDIT") ) )
	{
		return false;
	}

	// Variables
	double dDens = 0.0;
	double dKinVisc = 0.0;
	double dSpecifHeat = 0.0;
	double dVaporPressure = 0.0;
	dPcWeight = GetPcWeight();

	pAdditChar->GetAdditProp( dPcWeight, dTemp, &dDens, &dKinVisc, &dSpecifHeat, &dVaporPressure );
	SetDens( dDens );
	SetKinVisc( dKinVisc );
	SetSpecifHeat( dSpecifHeat );
	SetTfreez( pAdditChar->GetTfreez( dPcWeight ) );

	return true;
}

bool CWaterChar::UpdateFluidData( double dTemp, double dPcWeight )
{
	SetTemp( dTemp );

	if( -1.0 != dPcWeight )
	{
		SetPcWeight( dPcWeight );
	}

	if( 0 == wcscmp( GetAdditFamID(), _T("OTHER_ADDIT") ) )
	{
		return false;
	}

	CDB_AdditCharacteristic *pAdditChar = GetpAdditChar();

	if( NULL != pAdditChar )
	{
		return UpdateFluidData( pAdditChar, dTemp, dPcWeight );
	}

	return false;
}

void CWaterChar::InitChangeOverData()
{
	if( true == m_bIsForChangeOver && NULL == m_pclSecondWaterChar )
	{
		m_pclSecondWaterChar = new CWaterChar();
		m_pclSecondWaterChar->m_bIsForChangeOver = false;
		m_pclSecondWaterChar->m_pclSecondWaterChar = NULL;
		_tcsncpy_s( m_pclSecondWaterChar->m_AdditFamID, SIZEOFINTCHAR( m_pclSecondWaterChar->m_AdditFamID ), m_AdditFamID, SIZEOFINTCHAR( m_AdditFamID ) - 1 );
		_tcsncpy_s( m_pclSecondWaterChar->m_AdditID, SIZEOFINTCHAR( m_pclSecondWaterChar->m_AdditID ), m_AdditID, SIZEOFINTCHAR( m_AdditID ) - 1 );
		m_pclSecondWaterChar->m_dTemp = m_dTemp;
		m_pclSecondWaterChar->m_dPcWeight = m_dPcWeight;
		m_pclSecondWaterChar->m_dDens = m_dDens;
		m_pclSecondWaterChar->m_dKinVisc = m_dKinVisc;
		m_pclSecondWaterChar->m_dSpecifHeat = m_dSpecifHeat;
		m_pclSecondWaterChar->m_dTfreez = m_dTfreez;
		m_pclSecondWaterChar->m_bSpecifHeat = m_bSpecifHeat;
	}
}

#define CWATERCHAR_VERSION	2
// Version : 2019-11-20 : Add m_pclSecondWaterChar
void CWaterChar::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CWATERCHAR_VERSION;
	WriteData<>( outf, Version );

	// Info.
	WriteString( outf, m_AdditFamID );
	WriteString( outf, m_AdditID );
	WriteDouble( outf, m_dTemp );
	WriteDouble( outf, m_dPcWeight );
	WriteDouble( outf, m_dDens );
	WriteDouble( outf, m_dKinVisc );
	WriteDouble( outf, m_dSpecifHeat );
	WriteDouble( outf, m_dTfreez );
	WriteData<>( outf, m_bSpecifHeat );
	
	// Version 2.
	WriteData<>( outf, m_bIsForChangeOver );

	if ( NULL!= m_pclSecondWaterChar )
	{
		m_pclSecondWaterChar->Write( outf );
	}
}

bool CWaterChar::Read( INPSTREAM  inpf, bool bOldFile )
{
	// Version.
	// HYS-1867
	BYTE Version = 1;

	if( false == bOldFile )
	{
		inpf.read( (char *)&Version, sizeof( Version ) );

		if( Version < 1 || Version > CWATERCHAR_VERSION )
		{
			return false;
		}
	}

	// Info.
	if( false == ReadString( inpf, m_AdditFamID, sizeof( m_AdditFamID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_AdditID, sizeof( m_AdditID ) ) )
	{
		return false;
	}

	m_dTemp = ReadDouble( inpf );
	m_dPcWeight = ReadDouble( inpf );
	m_dDens = ReadDouble( inpf );
	m_dKinVisc = ReadDouble( inpf );
	m_dSpecifHeat = ReadDouble( inpf );
	m_dTfreez = ReadDouble( inpf );
	inpf.read( (char *)&m_bSpecifHeat, sizeof( m_bSpecifHeat ) );

#ifndef TACBX
	// Test if AdditFamID and AdditID exist in TADB.
	// If not, reset AdditFamID and AdditID to 'Any Other Fluid'.
	// This treatment is to enable tsp file compatibility
	// while adding new fluid in TADB
	CTADatabase *pTADB = TASApp.GetpTADB();

	// HYS-1465 : If the binary DB is reading we don't look if ID exists. Only if project opening in this case we read via TADatastruct.
	// We don't look ID when reading binary DB because all IDs are already verified in the readDBtxt and objects are readed randomly.

	if( ( CDataBase::TADatastruct == pTADB->GetDatabaseType() )
		&&( NULL == pTADB->Get( m_AdditID ).MP || NULL == pTADB->Get( m_AdditFamID ).MP ) )
	{
		_tcsncpy_s( m_AdditFamID, SIZEOFINTCHAR( m_AdditFamID ), _T("OTHER_ADDIT"), SIZEOFINTCHAR( m_AdditFamID ) - 1 );
		_tcsncpy_s( m_AdditID, SIZEOFINTCHAR( m_AdditID ), _T("OTHER_FLUID"), SIZEOFINTCHAR( m_AdditID ) - 1 );
	}
#endif

	UpdateFluidData( m_dTemp );

	if( Version < 2 )
	{
		return true;
	}
	
	// Version 2.
	inpf.read( (char*)&m_bIsForChangeOver, sizeof( m_bIsForChangeOver ) );
	SetIsForChangeOver( m_bIsForChangeOver );

	if( NULL != m_pclSecondWaterChar )
	{
		if( false == m_pclSecondWaterChar->Read( inpf, bOldFile ) )
		{
			return false;
		}
	}

	return true;
}

double CWaterChar::GetDens( double dTemperature )
{
	// HYS-1065: If OTHER ADDIT family return the value in WC dialog.
	if( !wcscmp( GetAdditFamID(), _T("OTHER_ADDIT") ) )
	{
		return m_dDens;
	}
	
	CDB_AdditCharacteristic *pAdditChar = GetpAdditChar();
	ASSERT( NULL != pAdditChar );

	double dRho = 0.0;
	double dKinVisc = 0.0;
	double dSpecifHeat = 0.0;
	double dVaporPressure = 0.0;

	if( SV_OK != pAdditChar->GetAdditProp( m_dPcWeight, dTemperature, &dRho, &dKinVisc, &dSpecifHeat, &dVaporPressure ) )
	{
		return 0.0;
	}

	return dRho;
}

double CWaterChar::GetKinVisc( double dTemperature )
{
	// HYS-1065: If OTHER ADDIT family return the value in WC dialogs.
	if( 0 == wcscmp( GetAdditFamID(), _T("OTHER_ADDIT") ) )
	{
		return m_dKinVisc;
	}
	
	CDB_AdditCharacteristic *pAdditChar = GetpAdditChar();
	ASSERT( NULL != pAdditChar );

	double dRho = 0.0;
	double dKinVisc = 0.0;
	double dSpecifHeat = 0.0;
	double dVaporPressure = 0.0;

	if( SV_OK != pAdditChar->GetAdditProp( m_dPcWeight, dTemperature, &dRho, &dKinVisc, &dSpecifHeat, &dVaporPressure ) )
	{
		return 0.0;
	}

	return dKinVisc;
}

double CWaterChar::GetSpecifHeat( double dTemperature )
{
	// HYS-1065: If OTHER ADDIT family return the value in WC dialog.
	if( 0 == wcscmp( GetAdditFamID(), _T("OTHER_ADDIT") ) )
	{
		return m_dSpecifHeat;
	}
	
	CDB_AdditCharacteristic *pAdditChar = GetpAdditChar();
	ASSERT( NULL != pAdditChar );

	double dRho = 0.0;
	double dKinVisc = 0.0;
	double dSpecifHeat = 0.0;
	double dVaporPressure = 0.0;

	if( SV_OK != pAdditChar->GetAdditProp( m_dPcWeight, dTemperature, &dRho, &dKinVisc, &dSpecifHeat, &dVaporPressure ) )
	{
		return 0.0;
	}

	return dSpecifHeat;
}

double CWaterChar::GetExpansionCoeff( double dT1, double dT2 )
{
	// HYS-1065: If OTHER ADDIT family we don't need the expansion coeff. Pressurisation mode is excluded .
	if( 0 == wcscmp( GetAdditFamID(), _T("OTHER_ADDIT") ) )
	{
		return 0.0;
	}
	
	// Variable
	CDB_AdditCharacteristic *pAdditChar = GetpAdditChar();

	if( NULL == pAdditChar )
	{
		return false;
	}

	// Variables
	double de;
	double dRhoT1 = 0.0;
	double dRhoT2 = 0.0;
	double dKinVisc = 0.0;
	double dSpecifHeat = 0.0;
	double dPcWeight = GetPcWeight();

	double dVaporPressure = 0;

	if( SV_OK != pAdditChar->GetAdditProp( dPcWeight, dT1, &dRhoT1, &dKinVisc, &dSpecifHeat, &dVaporPressure ) )
	{
		return 0;
	}

	if( SV_OK != pAdditChar->GetAdditProp( dPcWeight, dT2, &dRhoT2, &dKinVisc, &dSpecifHeat, &dVaporPressure ) )
	{
		return 0;
	}

	if( 0 == dRhoT2 || 0 == dRhoT1 )
	{
		return 0;
	}

	// e->m3/kg
	if( dT1 < dT2 )
	{
		// Ex: Water -> Rho 0Â°C = 999.8999999 Kg/m3 & Rho 75Â°C = 974.8125 Kg/m3
		//
		// What is the difference in m3/kg between both? (a) 1/974.8125 - 1/999.8999 = 0.00002574 m3/Kg.
		// (There is thus an increase of 0.00002574 m3 by kilo of water).
		//
		// What is the expansion factor between 0Â°C and 75Â°C? 1/999.8999 * x = 0.00002574 -> x = 999.8999 * 0.00002574
		//
		// Transformed in equation:
		//
		//   x = RhoT1 * (   1   -   1  )
		//                 -----   -----
		//                 RhoT2   RhoT1
		//
		// , with (RhoT1 for '999.8999' and ( 1/RhoT2 â 1/RhoT1 ) for '0.00002574'.
		//
		// Multiply first division by RhoT1 and the second one by RhoT2:
		//
		//   x = RhoT1 * (   RhoT1         RhoT2   )
		//                ----------- - -----------
		//                RhoT2*RhoT1   RhoT1*RhoT2
		//
		// We can thus simplify:
		//
		//   x = RhoT1 * ( RhoT1 - RhoT2 )
		//                ---------------
		//                  RhoT1*RhoT2
		//
		// And finally:
		//
		//  x = RhoT1 - RhoT2
		//      -------------
		//          RhoT2

		de = ( dRhoT1 - dRhoT2 ) / dRhoT2;
	}
	else
	{
		de = ( dRhoT2 - dRhoT1 ) / dRhoT1;
	}

	return de;
}

double CWaterChar::GetVaporPressure( double dT1 )
{
	// Return ( max( 1e5 * ( 0.0001*dT1*dT1 - 0.0014*dT1 + 0.0164 - 1e5 ), 0 ) );
	if( dT1 < 100 )
	{
		return 0.0;
	}

	CDB_AdditCharacteristic *pAdditChar = GetpAdditChar();

	if( NULL == pAdditChar )
	{
		return 0.0;
	}

	// Variables
	double dRhoT1 = 0.0;
	double dRhoT2 = 0.0;
	double dKinVisc = 0.0;
	double dSpecifHeat = 0.0;
	double dPcWeight = GetPcWeight();

	double dVaporPressure1 = 0;
	double dVaporPressure2 = 0;

	pAdditChar->GetAdditProp( dPcWeight, dT1, &dRhoT1, &dKinVisc, &dSpecifHeat, &dVaporPressure1 );
	pAdditChar->GetAdditProp( dPcWeight, 100, &dRhoT2, &dKinVisc, &dSpecifHeat, &dVaporPressure2 );

	double dRetVp = dVaporPressure1 - dVaporPressure2;
	return dRetVp;
}

IMPLEMENT_DATA( CDS_WaterCharacteristic )

CDS_WaterCharacteristic::CDS_WaterCharacteristic( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
}

void CDS_WaterCharacteristic::OnDatabaseDestroy()
{
	CData::OnDatabaseDestroy();
}

void CDS_WaterCharacteristic::Copy( CData *pclDestination )
{
	CData::Copy( pclDestination );
	CDS_WaterCharacteristic *pWater = (CDS_WaterCharacteristic *)pclDestination;
	*pWater->GetpWCData() = m_WC;
}

#define CDS_WATERCHARACTERISTIC_VERSION	2
void CDS_WaterCharacteristic::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_WATERCHARACTERISTIC_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CData::Write( outf );

	// Info.
	m_WC.Write( outf );
}

bool CDS_WaterCharacteristic::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_WATERCHARACTERISTIC_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_WATERCHARACTERISTIC_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Info.
	m_WC.Read( inpf, ( Version == 1 ) );
	return true;
}

CDB_AdditCharacteristic *CDS_WaterCharacteristic::GetpAdditChar()
{
	CWaterChar *pWC = GetpWCData();

	if( NULL != pWC )
	{
		return pWC->GetpAdditChar();
	}

	return ( NULL );
}

bool CDS_WaterCharacteristic::UpdateFluidData( double dTemp, double dPcWeight/*= -1.0*/ )
{
	CWaterChar *pWC = GetpWCData();

	if( NULL != pWC )
	{
		return pWC->UpdateFluidData( dTemp, dPcWeight );
	}

	return false;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_TechnicalParameter
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_TechnicalParameter )

CDS_TechnicalParameter::CDS_TechnicalParameter( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
	Init();
}

void CDS_TechnicalParameter::Init()
{
	m_rTechParamData.m_dValveMinDp = 3000.0;						// Min. DP in valves
	m_rTechParamData.m_dValveMin2Dp = 6000.0;					// Max. min. DP in valves
	m_rTechParamData.m_dValveMaxDp = 200000.0;					// Max. DP in valves
	m_rTechParamData.m_dFixedOrificeMinDp = 2000.0;				// Min. DP in FO
	m_rTechParamData.m_dFixedOrificeMaxDp = 6000.0;				// Max. DP in FO
	m_rTechParamData.m_dVenturiMinDp = 2000.0;					// Min. DP in Venturi
	m_rTechParamData.m_dVenturiMaxDp = 10000.0;					// Max. DP in Venturi
	m_rTechParamData.m_iSizeShiftBelow = -2;						// Shift between pipe and device sizes
	m_rTechParamData.m_iSizeShiftAbove = 0;						// Shift between pipe and device sizes
	m_rTechParamData.m_iMaxSizeShift = 4;						// Maximum size shift above and below the pipe size
	m_rTechParamData.m_dPipeMinDp = 10.0;						// Min. DP in pipes
	m_rTechParamData.m_dPipeMaxDp = 200.0;						// Max. DP in pipes
	m_rTechParamData.m_dPipeMinVelocity = 0.3;					// Min. velocity in pipes
	m_rTechParamData.m_dPipeMaxVelocity = 2.0;					// Max. velocity in pipes
	m_rTechParamData.m_dPipeTargetDp = 150.0;					// Target DP in pipes
	m_rTechParamData.m_dPipeTargetVelocity = 1.0;				// Target velocity in pipes
	m_rTechParamData.m_iPipeTargetVelosityUsed = 0;				// 0/1: 1 if TargVel is used to determine the best pipe
	m_rTechParamData.m_dTrvMinDpRatio = 0.25;					// Min. Dp ratio to be takne in Trv
	m_rTechParamData.m_dTrvDefDpTotal = 10000.0;					// Default available diff. press. on rad. circuits
	m_rTechParamData.m_dTrvDefRoomTemperature = 20.0;			// Default room temperature for radiator sizing
	m_rTechParamData.m_dTrvDefSupplyTemperature = 80.0;			// Default supply temperature for radiator sizing
	m_rTechParamData.m_dTrvMaxDp = 30000.0;						// Max. DP in Trv's
	m_rTechParamData.m_dCVMinAuthor = 0.25;						// Min. authority of control valves
	m_rTechParamData.m_dCVMinAuthCstFlow = 0.5;					// Min. authority of control valves for cst flow systems
	m_rTechParamData.m_dCVMinDpOnoff = 2000.0;					// Min. DP in on-off control valves
	m_rTechParamData.m_dCVMinDpProp = 10000.0;					// Min. Dp in proportional control valves
	m_rTechParamData.m_iCVDefKvReynard = 1;						// 0/1: 1 if Kvs values of control valves are by default selected from Reynard series
	m_rTechParamData.m_iCVUseDpCPBand = 0;
	m_rTechParamData.m_dPICvMinDp = 1000.0;						// Min. Dp in Dp control part
	m_rTechParamData.m_iPICvHide = 1;							// 0/1: 1 to hide PICv that do not satisfy the Min. Dp limit
	m_rTechParamData.m_dDpCMinDp = 5000.0;						// Min. Dp in DpC
	m_rTechParamData.m_iDpCHide = 0;								// 0/1: 1 to hide DpC that do not satisfy the Min. Dp limit
	m_rTechParamData.m_iDpCMvLocation = 0;						// Default measuring valve location 0/1: MV in primary/MV in secondary
	m_rTechParamData.m_iDpCMvWithSameSizeOnly = 0;				// Suggest measuring valves with the same size as Dp controller only
	m_rTechParamData.m_iDpCHminFullyOpenMv = 0;					// 0/1: 1 if Hmin must be computed with fully open Mv
	m_rTechParamData.m_dFlowDeviationPlus = 0.1;
	m_rTechParamData.m_dFlowDeviationMinus = -0.1;
	m_rTechParamData.m_strCurrencyID = _T("CURRENCY_EUR");
	m_rTechParamData.m_strDefaultPipeSerieID = _T("STEEL_GEN");
	m_rTechParamData.m_dCVMaxDispDp = 200000;					// Max Dp in control valves
	m_rTechParamData.m_dCVMaxDpProp = 65000.0;					// Max. Dp in proportional control valves
	m_rTechParamData.m_dDpCBCVDpcmin = 3000.0;					// Minimum Dp that a control part of a DpC BCV valve must have to correctly work.
	m_rTechParamData.m_dDpCBCVDplmin = 5000.0;					// Minimum Dp that a DpC BCV valve can stabilize.
	m_rTechParamData.m_dVesselSelectionRangePercentage = 0.0;	// Propose vessels below nominal volume by x%

	m_rTechParamData.m_dMinPressureMargin = 3e+4;
	m_rTechParamData.m_iMaxNumberOfAdditionalVesselsInParallel = 2;
	m_rTechParamData.m_fUseVesselPressureVolumeLimit = false;
	m_rTechParamData.m_dPressureVolumeLimit = 3e+5;				// SWKI HE301-01 (3000bars.liter -> in m3.pascal = 300000)
	m_rTechParamData.m_bCanChangePressureVolumeLimit = false;	// 0/1: 0 in some country (Switzerland) the value is fixed. Some other countries can change.
	m_rTechParamData.m_dPSetupCompresso = 1e+4;
	m_rTechParamData.m_dPSetupTransfero = 2e+4;
	m_rTechParamData.m_dDefaultFillTemperature = 15;
	m_rTechParamData.m_fUseDefaultFreezingPointAsMinTemperature = false;
	m_rTechParamData.m_iMaxNumberOfVentoInParallel = 2;
	m_rTechParamData.m_dDefaultWaterMakeUpTemp = 15;
	m_rTechParamData.m_dDefaultMaxTempInCooling = 45;
	m_rTechParamData.m_dDefaultMinTempInHeating = 5.0;			// We set it to the minimum temperature for a vessel.
	m_rTechParamData.m_dDefaultMinTempInSolar = 5.0;
	m_rTechParamData.m_dDefaultSafetyPressureResponseValve = 3e+5;
	m_rTechParamData.m_dDefaultTAZ = 90;
	m_rTechParamData.m_sDefaultCalculationNorm = _T("PM_NORM_EN12828");
	m_rTechParamData.m_bBreakTankRequiredForWaterMakeUp = true;
	m_rTechParamData.m_dDefaultStaticPressureOfWaterNetwork = 4e+5;
	m_rTechParamData.m_iAvailablePMPanels = Heating + Cooling + Solar;
	m_rTechParamData.m_dDefaultWaterHardness = 1.78324958;		// ( = 10 Â°dH )
	m_rTechParamData.m_dDegassingWaterReserveForVessel = 2e-3;		// in m3.

	// Help to select best PICV(Best one = Smallest Dpmin amongst valves with smallest DN), with a threshold of AcceptedExtraDp if a larger valve has a lower Dpmin).
	m_rTechParamData.m_dPICVExtraThresholdDp = 15000;

	// Default supply temperature, DT, additive ID and PC weight for HM calc.
	m_rTechParamData.m_eProjectType = Cooling;
	m_rTechParamData.m_dDefaultPrjCoolingTps = 6;
	m_rTechParamData.m_dDefaultPrjHeatingTps = 70;
	m_rTechParamData.m_dDefaultPrjCoolingDT = 6;
	m_rTechParamData.m_dDefaultPrjHeatingDT = 20;
	m_rTechParamData.m_eProductSelectionApplicationType = Cooling;
	m_rTechParamData.m_strDefaultPrjCoolingAdditID = _T("WATER");
	m_rTechParamData.m_strDefaultPrjHeatingAdditID = _T("WATER");
	m_rTechParamData.m_dDefaultPrjCoolingPcWeight = 0.0;
	m_rTechParamData.m_dDefaultPrjHeatingPcWeight = 0.0;
	m_rTechParamData.m_dDefaultPrjHeatingPcWeight = 0.0;

	// HYS-1230: Complete review of the water characteristic for product selection.
	// Default water characteristic for product selection.
	m_rTechParamData.m_mapPSDefaultWaterCharByProject.clear();
	m_rTechParamData.m_mmapPSDefaultDTByProject.clear();

	// Heating.
	CWaterChar clWaterChar;
	clWaterChar.SetAdditFamID( _T("WATER_ADDIT") );
	clWaterChar.SetAdditID( _T("WATER") );
	clWaterChar.SetPcWeight( 0.0 );
	clWaterChar.UpdateFluidData( 70.0 );
	m_rTechParamData.m_mapPSDefaultWaterCharByProject.insert( std::pair<ProjectType, CWaterChar>( Heating, clWaterChar ) );
	m_rTechParamData.m_mmapPSDefaultDTByProject.insert( std::pair<ProjectType, double>( Heating, 20.0 ) );

	// Cooling.
	clWaterChar.UpdateFluidData( 6.0 );
	m_rTechParamData.m_mapPSDefaultWaterCharByProject.insert( std::pair<ProjectType, CWaterChar>( Cooling, clWaterChar ) );
	m_rTechParamData.m_mmapPSDefaultDTByProject.insert( std::pair<ProjectType, double>( Cooling, 6.0 ) );

	// Solar.
	clWaterChar.UpdateFluidData( 70.0 );
	m_rTechParamData.m_mapPSDefaultWaterCharByProject.insert( std::pair<ProjectType, CWaterChar>( Solar, clWaterChar ) );
	m_rTechParamData.m_mmapPSDefaultDTByProject.insert( std::pair<ProjectType, double>( Solar, 20.0 ) );

	// Change-over - cooling.
	// PS: in this case, the cooling part is saved in the 'clWaterChar' and for heating it's in the 'CWaterChar::m_pclSecondWaterChar'.
	clWaterChar.SetIsForChangeOver( true );
	clWaterChar.UpdateFluidData( 6.0 );
	m_rTechParamData.m_mmapPSDefaultDTByProject.insert( std::pair<ProjectType, double>( ChangeOver, 6.0 ) );
	
	// Change-over - heating.
	//clWaterChar.InitChangeOverData();
	ASSERT( NULL != clWaterChar.GetSecondWaterChar() );
	
	clWaterChar.GetSecondWaterChar()->UpdateFluidData( 70.0 );
	m_rTechParamData.m_mapPSDefaultWaterCharByProject.insert( std::pair<ProjectType, CWaterChar>( ChangeOver, clWaterChar ) );
	m_rTechParamData.m_mmapPSDefaultDTByProject.insert( std::pair<ProjectType, double>( ChangeOver, 20.0 ) );

	m_rTechParamData.m_iMaxSafetyValveInParallel = 3;
	m_rTechParamData.m_dInitialPressureMargin = 3e4;					// HYS-1022: 0.3 bar margin for initial pressure (EN 12828-2014).
	m_rTechParamData.m_dSafetyTempLimiterLimitEN12953 = 110.0;			// HYS-1104: safety temperature limiter limit from which we need to pass to the EN 12953 norm.
	m_rTechParamData.m_dFluidTempLimitEN12953 = 105.0;					// HYS-1104: supply/return temperature limit from which we need to pass to the EN 12953 norm.
	m_rTechParamData.m_bUseSimplyPst = false;							// HYS-1126: Use simplified calculation pf static pressure.
	m_rTechParamData.m_dDpRefForBest6Way = 3;							// HYS-1151: 3 kPa, the reference value used to determine the best 6-way valve at a flow given.
	m_rTechParamData.m_iDefaultSmartCVLoc = 1;							// HYS-1763: Smart control valve default location in hydronic circuit calculation: 1 Supply side / 0 Return side.
	m_rTechParamData.m_dSmartValveDpMaxForBestSuggestion = 20000.0;		// Dp max for "best" suggestion.
	m_rTechParamData.m_dDefaultSecondaryPumpHMin = 25000.0;				// HYS-1930: New hydronic circuit: auto-adapting variable flow decoupling circuit: add default secondary pump Hmin.
}

double CDS_TechnicalParameter::GetValvMinDp( _string strValveTypeID )
{
	if( 0 == strValveTypeID.compare( L"RVTYPE_VV" ) )
	{
		return GetVtriMinDp();
	}

	if( 0 == strValveTypeID.compare( L"RVTYPE_FO" ) )
	{
		return GetFoMinDp();
	}

	return  GetValvMinDp();
}

double CDS_TechnicalParameter::VerifyValvMaxDp( CDB_TAProduct *pTap )
{
	double dMaxDp = -1.0;

	if( NULL != pTap )
	{
		dMaxDp = pTap->GetDpmax();

		if( dMaxDp <= 0.0 )
		{
			dMaxDp = _GetValvMaxDp( pTap->GetTypeID() );
		}
	}
	else
	{
		dMaxDp = GetValvMaxDp();
	}

	return dMaxDp;
}

#ifndef TACBX
IDPTR CDS_TechnicalParameter::GetDefaultPipeSerieIDPtr()
{
	CTable *pTab = TASApp.GetpPipeDB()->GetPipeTab();
	ASSERT( NULL != pTab );

	IDPTR idptr = _NULL_IDPTR;
	CString str = GetDefaultPipeSerieID();

	if( false == str.IsEmpty() )
	{
		idptr = pTab->Get( str );

		if( idptr.MP && idptr.MP->IsHidden() )
		{
			// a default pipe series is never hidden
			idptr.MP->SetHidden( false );

			for( IDPTR IDPtr = ( static_cast<CTable *>( idptr.MP ) )->GetFirst(); NULL != IDPtr.MP; IDPtr = ( static_cast<CTable *>( idptr.MP ) )->GetNext() )
			{
				IDPtr.MP->SetHidden( false );
			}
		}
	}

	return idptr;
}

CDB_Currency *CDS_TechnicalParameter::GetCurrentCurrencyDB()
{
	CTable *pTab = (CTable *)( TASApp.GetpTADB()->Get( _T("CURRENCY_TAB") ).MP );
	ASSERT( NULL != pTab );

	return (CDB_Currency *)( pTab->Get( m_rTechParamData.m_strCurrencyID.c_str() ).MP );
}

_string CDS_TechnicalParameter::GetCurrentCurrencyISO()
{
	_string strResult = _T("");
	CDB_Currency *pclCurrency = GetCurrentCurrencyDB();

	if( NULL != pclCurrency )
	{
		strResult = pclCurrency->GetISO();
	}

	return strResult;
}

double CDS_TechnicalParameter::GetDefaultPrjTpr()
{
	double dReturnTemperature = 0.0; 

	if( ProjectType::Cooling == GetProjectApplicationType() )
	{
		dReturnTemperature = GetDefaultPrjTps() + GetDefaultPrjDT();
	}
	else
	{
		dReturnTemperature = GetDefaultPrjTps() - GetDefaultPrjDT();
	}

	return dReturnTemperature;
}

double CDS_TechnicalParameter::GetDefaultPrjHeatingTpr()
{
	return GetDefaultPrjHeatingTps() - GetDefaultPrjHeatingDT();
}

double CDS_TechnicalParameter::GetDefaultPrjCoolingTpr()
{
	return GetDefaultPrjCoolingTps() + GetDefaultPrjCoolingDT();
}

int CDS_TechnicalParameter::GetProductSelectionApplicationTypeIDS( ProjectType eAppType )
{
	if( Heating == eAppType )
	{
		return IDS_RBN_APPLITYPE_HEATING;
	}

	if( Cooling == eAppType )
	{
		return IDS_RBN_APPLITYPE_COOLING;
	}

	if( Solar == eAppType )
	{
		return IDS_RBN_APPLITYPE_SOLAR;
	}

	if( ChangeOver == eAppType )
	{
		return IDS_RBN_APPLITYPE_CHANGEOVER;
	}

	return 0;
}
#endif

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Start of methods to get default supply temperature for product selection.
double CDS_TechnicalParameter::GetDefaultISTps( SideDefinition eSideDefinition )
{ 
	return GetDefaultISTps( m_rTechParamData.m_eProductSelectionApplicationType, eSideDefinition );
}

double CDS_TechnicalParameter::GetDefaultISTps( ProjectType eApplicationType, SideDefinition eSideDefinition )
{
	double dTps = DBL_MAX;

	switch( eApplicationType )
	{
		case Heating:
			dTps = GetDefaultISHeatingTps();
			break;

		case Cooling:
			dTps = GetDefaultISCoolingTps();
			break;

		case Solar:
			dTps = GetDefaultISSolarTps();
			break;

		case ChangeOver:
			dTps = GetDefaultISChangeOverTps( eSideDefinition );
			break;

		case InvalidProjectType:
		default:
			break;
	}

	return dTps;
}

double CDS_TechnicalParameter::GetDefaultISHeatingTps()
{ 
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( Heating ) );
	return m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( Heating ).GetTemp();
}

double CDS_TechnicalParameter::GetDefaultISCoolingTps()
{ 
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( Cooling ) );
	return m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( Cooling ).GetTemp();
}

double CDS_TechnicalParameter::GetDefaultISSolarTps()
{ 
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( Solar ) );
	return m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( Solar ).GetTemp();
}

double CDS_TechnicalParameter::GetDefaultISChangeOverTps( SideDefinition eSideDefinition )
{
	ASSERT( CoolingSide == eSideDefinition || HeatingSide == eSideDefinition );
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( ChangeOver ) );
	
	double dTps = DBL_MAX;	
	CWaterChar &clWaterChar = m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( ChangeOver );

	if( CoolingSide == eSideDefinition )
	{
		dTps = clWaterChar.GetTemp();
	}
	else if( HeatingSide == eSideDefinition )
	{
		ASSERT( NULL != clWaterChar.GetSecondWaterChar() );
		dTps = clWaterChar.GetSecondWaterChar()->GetTemp();
	}

	return dTps;
}
// End of methods to get default supply temperature for product selection.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Start of methods to get default DT for product selection.
double CDS_TechnicalParameter::GetDefaultISDT( SideDefinition eSideDefinition )
{
	return GetDefaultISDT( m_rTechParamData.m_eProductSelectionApplicationType, eSideDefinition );
}

double CDS_TechnicalParameter::GetDefaultISDT( ProjectType eApplicationType, SideDefinition eSideDefinition )
{
	double dDT = DBL_MAX;

	switch( eApplicationType )
	{
		case Heating:
			dDT = GetDefaultISHeatingDT();
			break;

		case Cooling:
			dDT = GetDefaultISCoolingDT();
			break;

		case Solar:
			dDT = GetDefaultISSolarDT();
			break;

		case ChangeOver:
			dDT = GetDefaultISChangeOverDT( eSideDefinition );
			break;

		case InvalidProjectType:
		default:
			break;
	}

	return dDT;
}

double CDS_TechnicalParameter::GetDefaultISHeatingDT()
{ 
	ASSERT( 1 == m_rTechParamData.m_mmapPSDefaultDTByProject.count( Heating ) );
	
	std::pair<multimap<ProjectType, double>::iterator, multimap<ProjectType, double>::iterator> iter;
	iter = m_rTechParamData.m_mmapPSDefaultDTByProject.equal_range( Heating );
	
	return iter.first->second;
}
	
double CDS_TechnicalParameter::GetDefaultISCoolingDT()
{ 
	ASSERT( 1 == m_rTechParamData.m_mmapPSDefaultDTByProject.count( Cooling ) );

	std::pair<multimap<ProjectType, double>::iterator, multimap<ProjectType, double>::iterator> iter;
	iter = m_rTechParamData.m_mmapPSDefaultDTByProject.equal_range( Cooling );
	
	return iter.first->second;
}

double CDS_TechnicalParameter::GetDefaultISSolarDT()
{ 
	ASSERT( 1 == m_rTechParamData.m_mmapPSDefaultDTByProject.count( Solar ) );

	std::pair<multimap<ProjectType, double>::iterator, multimap<ProjectType, double>::iterator> iter;
	iter = m_rTechParamData.m_mmapPSDefaultDTByProject.equal_range( Solar );
	
	return iter.first->second;
}

double CDS_TechnicalParameter::GetDefaultISChangeOverDT( SideDefinition eSideDefinition )
{
	ASSERT( CoolingSide == eSideDefinition || HeatingSide == eSideDefinition );
	ASSERT( 2 == m_rTechParamData.m_mmapPSDefaultDTByProject.count( ChangeOver ) );

	std::pair<multimap<ProjectType, double>::iterator, multimap<ProjectType, double>::iterator> mapPair;
	mapPair = m_rTechParamData.m_mmapPSDefaultDTByProject.equal_range( ChangeOver );

	double dDT = mapPair.first->second;

	if( HeatingSide == eSideDefinition )
	{
		mapPair.first++;
		dDT = mapPair.first->second;
	}

	return dDT;
}
// End of methods to get default DT for product selection.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Start of methods to get default return temperature for product selection.
double CDS_TechnicalParameter::GetDefaultISTpr( SideDefinition eSideDefinition )
{
	return GetDefaultISTpr( m_rTechParamData.m_eProductSelectionApplicationType, eSideDefinition );
}

double CDS_TechnicalParameter::GetDefaultISTpr( ProjectType eApplicationType, SideDefinition eSideDefinition )
{
	double dTpr = 0.0;

	switch( eApplicationType )
	{
		case Heating:
			dTpr = GetDefaultISHeatingTpr();
			break;

		case Cooling:
			dTpr = GetDefaultISCoolingTpr();
			break;

		case Solar:
			dTpr = GetDefaultISSolarTpr();
			break;

		case ChangeOver:
			dTpr = GetDefaultISChangeOverTpr( eSideDefinition );
			break;

		case InvalidProjectType:
		default:
			break;
	}

	return dTpr;
}

double CDS_TechnicalParameter::GetDefaultISHeatingTpr()
{
	double dTpr = DBL_MAX;
	double dTps = GetDefaultISHeatingTps();
	double dDT = GetDefaultISHeatingDT();

	if( dTps != DBL_MAX && dDT != DBL_MAX )
	{
		dTpr = dTps - dDT;
	}

	return dTpr;
}

double CDS_TechnicalParameter::GetDefaultISCoolingTpr()
{
	double dTpr = DBL_MAX;
	double dTps = GetDefaultISCoolingTps();
	double dDT = GetDefaultISCoolingDT();

	if( dTps != DBL_MAX && dDT != DBL_MAX )
	{
		dTpr = dTps + dDT;
	}

	return dTpr;
}

double CDS_TechnicalParameter::GetDefaultISSolarTpr()
{
	double dTpr = DBL_MAX;
	double dTps = GetDefaultISSolarTps();
	double dDT = GetDefaultISSolarDT();

	if( dTps != DBL_MAX && dDT != DBL_MAX )
	{
		dTpr = dTps - dDT;
	}

	return dTpr;
}

double CDS_TechnicalParameter::GetDefaultISChangeOverTpr( SideDefinition eSideDefinition )
{
	ASSERT( CoolingSide == eSideDefinition || HeatingSide == eSideDefinition );

	double dTpr = DBL_MAX;
	double dTps = GetDefaultISChangeOverTps( eSideDefinition );
	double dDT = GetDefaultISChangeOverDT( eSideDefinition );

	if( dTps != DBL_MAX && dDT != DBL_MAX )
	{
		if( CoolingSide == eSideDefinition )
		{
			dTpr = dTps + dDT;
		}
		else if( HeatingSide == eSideDefinition )
		{
			dTpr = dTps - dDT;
		}
	}

	return dTpr;
}
// End of methods to get default return temperature for product selection.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Start of methods to get default additive ID for product selection.
LPCTSTR CDS_TechnicalParameter::GetDefaultISAdditID( SideDefinition eSideDefinition )
{ 
	return GetDefaultISAdditID( m_rTechParamData.m_eProductSelectionApplicationType, eSideDefinition );
}

LPCTSTR CDS_TechnicalParameter::GetDefaultISAdditID( ProjectType eApplicationType, SideDefinition eSideDefinition )
{ 
	LPCTSTR lpAdditID = NULL;

	switch( eApplicationType ) 
	{
		case Heating:
			lpAdditID = GetDefaultISHeatingAdditID();
			break;

		case Cooling:
			lpAdditID = GetDefaultISCoolingAdditID();
			break;

		case Solar:
			lpAdditID = GetDefaultISSolarAdditID();
			break;

		case ChangeOver:
			lpAdditID = GetDefaultISChangeOverAdditID( eSideDefinition );
			break;

		case InvalidProjectType:
		default:
			break;
	}

	return lpAdditID;
}

LPCTSTR CDS_TechnicalParameter::GetDefaultISHeatingAdditID()
{
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( Heating ) );
	return m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( Heating ).GetAdditID();
}

LPCTSTR CDS_TechnicalParameter::GetDefaultISCoolingAdditID()
{
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( Cooling ) );
	return m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( Cooling ).GetAdditID();
}

LPCTSTR CDS_TechnicalParameter::GetDefaultISSolarAdditID()
{
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( Solar ) );
	return m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( Solar ).GetAdditID();
}

LPCTSTR CDS_TechnicalParameter::GetDefaultISChangeOverAdditID( SideDefinition eSideDefinition )
{
	ASSERT( CoolingSide == eSideDefinition || HeatingSide == eSideDefinition );
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( ChangeOver ) );
	
	LPCTSTR lpAdditID = NULL;
	CWaterChar &clWaterChar = m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( ChangeOver );

	if( CoolingSide == eSideDefinition )
	{
		lpAdditID = clWaterChar.GetAdditID();
	}
	else if( HeatingSide == eSideDefinition )
	{
		ASSERT( NULL != clWaterChar.GetSecondWaterChar() );
		lpAdditID = clWaterChar.GetSecondWaterChar()->GetAdditID();
	}

	return lpAdditID;
}
// End of methods to get default additive ID for product selection.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Start of methods to get default weight of the additive for product selection.
double CDS_TechnicalParameter::GetDefaultISPcWeight( SideDefinition eSideDefinition )
{
	return GetDefaultISPcWeight( m_rTechParamData.m_eProductSelectionApplicationType, eSideDefinition );
}

double CDS_TechnicalParameter::GetDefaultISPcWeight( ProjectType eApplicationType, SideDefinition eSideDefinition )
{ 
	double dPcWeight = 0.0;

	switch( eApplicationType ) 
	{
		case Heating:
			dPcWeight = GetDefaultISHeatingPcWeight();
			break;

		case Cooling:
			dPcWeight = GetDefaultISCoolingPcWeight();
			break;

		case Solar:
			dPcWeight = GetDefaultISSolarPcWeight();
			break;

		case ChangeOver:
			dPcWeight = GetDefaultISChangeOverPcWeight( eSideDefinition );
			break;

		case InvalidProjectType:
		default:
			break;
	}

	return dPcWeight;
}

double CDS_TechnicalParameter::GetDefaultISHeatingPcWeight()
{
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( Heating ) );
	return m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( Heating ).GetPcWeight();
}

double CDS_TechnicalParameter::GetDefaultISCoolingPcWeight()
{
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( Cooling ) );
	return m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( Cooling ).GetPcWeight();
}

double CDS_TechnicalParameter::GetDefaultISSolarPcWeight()
{
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( Solar ) );
	return m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( Solar ).GetPcWeight();
}

double CDS_TechnicalParameter::GetDefaultISChangeOverPcWeight( SideDefinition eSideDefinition )
{
	ASSERT( CoolingSide == eSideDefinition || HeatingSide == eSideDefinition );
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( ChangeOver ) );
	
	double dPCWeight = DBL_MAX;	
	CWaterChar &clWaterChar = m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( ChangeOver );

	if( CoolingSide == eSideDefinition )
	{
		dPCWeight = clWaterChar.GetPcWeight();
	}
	else if( HeatingSide == eSideDefinition )
	{
		ASSERT( NULL != clWaterChar.GetSecondWaterChar() );
		dPCWeight = clWaterChar.GetSecondWaterChar()->GetPcWeight();
	}

	return dPCWeight;
}
// End of methods to get default weight of the additive for product selection.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Start of methods to get default water characteristic for product selection.
CWaterChar *CDS_TechnicalParameter::GetDefaultISWC( SideDefinition eSideDefinition )
{ 
	return GetDefaultISWC( m_rTechParamData.m_eProductSelectionApplicationType, eSideDefinition );
}

CWaterChar *CDS_TechnicalParameter::GetDefaultISWC( ProjectType eApplicationType, SideDefinition eSideDefinition )
{ 
	CWaterChar *pclWaterChar = NULL;

	switch( eApplicationType ) 
	{
		case Heating:
			pclWaterChar = GetDefaultISHeatingWC();
			break;

		case Cooling:
			pclWaterChar = GetDefaultISCoolingWC();
			break;

		case Solar:
			pclWaterChar = GetDefaultISSolarWC();
			break;

		case ChangeOver:
			pclWaterChar = GetDefaultISChangeOverWC( eSideDefinition );
			break;

		case InvalidProjectType:
		default:
			break;
	}

	return pclWaterChar;
}

CWaterChar *CDS_TechnicalParameter::GetDefaultISHeatingWC()
{
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( Heating ) );
	return &m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( Heating );
}

CWaterChar *CDS_TechnicalParameter::GetDefaultISCoolingWC()
{
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( Cooling ) );
	return &m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( Cooling );
}

CWaterChar *CDS_TechnicalParameter::GetDefaultISSolarWC()
{
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( Solar ) );
	return &m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( Solar );
}

CWaterChar *CDS_TechnicalParameter::GetDefaultISChangeOverWC( SideDefinition eSideDefinition )
{
	ASSERT( CoolingSide == eSideDefinition || HeatingSide == eSideDefinition );
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( ChangeOver ) );
	
	CWaterChar *pclWaterChar = &m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( ChangeOver );
	ASSERT( NULL != pclWaterChar );

	if( HeatingSide == eSideDefinition )
	{
		ASSERT( NULL != pclWaterChar->GetSecondWaterChar() );
		pclWaterChar = pclWaterChar->GetSecondWaterChar();
	}

	return pclWaterChar;
}
// End of methods to get default water characteristic for product selection.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef TACBX
int CDS_TechnicalParameter::GetPressurONIDS( PressurON PressOn )
{
	if( poPumpDischarge == PressOn )
	{
		return IDS_PRESSONPUMPDISCHARGE;
	}

	if( poPumpSuction == PressOn )
	{
		return IDS_PRESSONPUMPSUCTION;
	}

	return 0;
}
#endif

_string CDS_TechnicalParameter::GetPressureVolumeLimitCU() const
{
	CUnitDatabase *pUnitDB = CDimValue::AccessUDB();
	_string strUnit = pUnitDB->GetNameOfDefaultUnit( _U_PRESSURE );
	strUnit += _T(".");
	strUnit += pUnitDB->GetNameOfDefaultUnit( _U_VOLUME );
	double dPressVolLimitCUP = CDimValue::SItoCU( _U_PRESSURE, GetPressureVolumeLimit() );
	double dPressVolLimitCUPV = CDimValue::SItoCU( _U_VOLUME, dPressVolLimitCUP );
	_string strPV = WriteCUDouble( _U_NODIM, dPressVolLimitCUPV );
	strPV += _T(" ");
	strPV += strUnit;
	return strPV;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Start of methods to set default supply temperature for product selection.
void CDS_TechnicalParameter::SetDefaultISTps( double dDefaultISDT, SideDefinition eSideDefinition )
{
	SetDefaultISTps( dDefaultISDT, m_rTechParamData.m_eProductSelectionApplicationType, eSideDefinition );
}

void CDS_TechnicalParameter::SetDefaultISTps( double dDefaultISTps, ProjectType eApplicationType, SideDefinition eSideDefinition )
{ 
	switch( eApplicationType )
	{
		case Heating:
			SetDefaultISHeatingTps( dDefaultISTps );
			break;

		case Cooling:
			SetDefaultISCoolingTps( dDefaultISTps );
			break;

		case Solar:
			SetDefaultISSolarTps( dDefaultISTps );
			break;

		case ChangeOver:
			SetDefaultISChangeOverTps( dDefaultISTps, eSideDefinition );
			break;

		case InvalidProjectType:
		default:
			break;
	}
}

void CDS_TechnicalParameter::SetDefaultISHeatingTps( double dDefaultISHeatingTps )
{
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( Heating ) );
	m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( Heating ).SetTemp( dDefaultISHeatingTps );
}

void CDS_TechnicalParameter::SetDefaultISCoolingTps( double dDefaultISCoolingTps )
{
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( Cooling ) );
	m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( Cooling ).SetTemp( dDefaultISCoolingTps );
}
	
void CDS_TechnicalParameter::SetDefaultISSolarTps( double dDefaultISSolarTps )
{
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( Solar ) );
	m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( Solar ).SetTemp( dDefaultISSolarTps );
}
	
void CDS_TechnicalParameter::SetDefaultISChangeOverTps( double dDefaultISChangeOverTps, SideDefinition eSideDefinition )
{
	ASSERT( CoolingSide == eSideDefinition || HeatingSide == eSideDefinition );
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( ChangeOver ) );

	CWaterChar &clWaterChar = m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( ChangeOver );

	if( CoolingSide == eSideDefinition )
	{
		clWaterChar.SetTemp( dDefaultISChangeOverTps );
	}
	else if( HeatingSide == eSideDefinition )
	{
		ASSERT( NULL != clWaterChar.GetSecondWaterChar() );
		clWaterChar.GetSecondWaterChar()->SetTemp( dDefaultISChangeOverTps );
	}
}
// End of methods to set default supply temperature for product selection.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Start of methods to set default DT for product selection.
void CDS_TechnicalParameter::SetDefaultISDT( double dDefaultISDT, SideDefinition eSideDefinition )
{
	SetDefaultISDT( dDefaultISDT, m_rTechParamData.m_eProductSelectionApplicationType, eSideDefinition );
}

void CDS_TechnicalParameter::SetDefaultISDT( double dDefaultISDT, ProjectType eApplicationType, SideDefinition eSideDefinition )
{
	switch( eApplicationType )
	{
		case Heating:
			SetDefaultISHeatingDT( dDefaultISDT );
			break;

		case Cooling:
			SetDefaultISCoolingDT( dDefaultISDT );
			break;

		case Solar:
			SetDefaultISSolarDT( dDefaultISDT );
			break;

		case ChangeOver:
			SetDefaultISChangeOverDT( dDefaultISDT, eSideDefinition );
			break;

		case InvalidProjectType:
		default:
			break;
	}
}

void CDS_TechnicalParameter::SetDefaultISHeatingDT( double dDefaultISHeatingDT )
{
	ASSERT( 1 == m_rTechParamData.m_mmapPSDefaultDTByProject.count( Heating ) );

	std::pair<multimap<ProjectType, double>::iterator, multimap<ProjectType, double>::iterator> iter;
	iter = m_rTechParamData.m_mmapPSDefaultDTByProject.equal_range( Heating );

	iter.first->second = dDefaultISHeatingDT;
}

void CDS_TechnicalParameter::SetDefaultISCoolingDT( double dDefaultISCoolingDT )
{
	ASSERT( 1 == m_rTechParamData.m_mmapPSDefaultDTByProject.count( Cooling ) );
	
	std::pair<multimap<ProjectType, double>::iterator, multimap<ProjectType, double>::iterator> iter;
	iter = m_rTechParamData.m_mmapPSDefaultDTByProject.equal_range( Cooling );
	
	iter.first->second = dDefaultISCoolingDT;
}

void CDS_TechnicalParameter::SetDefaultISSolarDT( double dDefaultISSolarDT )
{
	ASSERT( 1 == m_rTechParamData.m_mmapPSDefaultDTByProject.count( Solar ) );

	std::pair<multimap<ProjectType, double>::iterator, multimap<ProjectType, double>::iterator> iter;
	iter = m_rTechParamData.m_mmapPSDefaultDTByProject.equal_range( Solar );

	iter.first->second = dDefaultISSolarDT;
}

void CDS_TechnicalParameter::SetDefaultISChangeOverDT( double dDefaultISChangeOverDT, SideDefinition eSideDefinition )
{
	ASSERT( CoolingSide == eSideDefinition || HeatingSide == eSideDefinition );
	ASSERT( 2 == m_rTechParamData.m_mmapPSDefaultDTByProject.count( ChangeOver ) );

	std::pair<multimap<ProjectType, double>::iterator, multimap<ProjectType, double>::iterator> mapPair;
	mapPair = m_rTechParamData.m_mmapPSDefaultDTByProject.equal_range( ChangeOver );

	if( HeatingSide == eSideDefinition )
	{
		mapPair.first++;
	}

	mapPair.first->second = dDefaultISChangeOverDT;
}
// End of methods to set default DT for product selection.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Start of methods to set default additive ID for product selection.
void CDS_TechnicalParameter::SetDefaultISAdditID( _string strDefaultISAdditID, SideDefinition eSideDefinition )
{
	SetDefaultISAdditID( strDefaultISAdditID, m_rTechParamData.m_eProductSelectionApplicationType, eSideDefinition );
}

void CDS_TechnicalParameter::SetDefaultISAdditID( _string strDefaultISAdditID, ProjectType eApplicationType, SideDefinition eSideDefinition )
{ 
	switch( eApplicationType )
	{
		case Heating:
			SetDefaultISHeatingAdditID( strDefaultISAdditID );
			break;

		case Cooling:
			SetDefaultISCoolingAdditID( strDefaultISAdditID );
			break;

		case Solar:
			SetDefaultISSolarAdditID( strDefaultISAdditID );
			break;

		case ChangeOver:
			SetDefaultISChangeOverAdditID( strDefaultISAdditID, eSideDefinition );
			break;

		case InvalidProjectType:
		default:
			break;
	}
}

void CDS_TechnicalParameter::SetDefaultISHeatingAdditID( _string strDefaultISHeatingAdditID )
{
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( Heating ) );
	m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( Heating ).SetAdditID( strDefaultISHeatingAdditID.c_str() );
}
	
void CDS_TechnicalParameter::SetDefaultISCoolingAdditID( _string strDefaultISCoolingAdditID )
{
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( Cooling ) );
	m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( Cooling ).SetAdditID( strDefaultISCoolingAdditID.c_str() );
}
	
void CDS_TechnicalParameter::SetDefaultISSolarAdditID( _string strDefaultISSolarAdditID )
{
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( Solar ) );
	m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( Solar ).SetAdditID( strDefaultISSolarAdditID.c_str() );
}

void CDS_TechnicalParameter::SetDefaultISChangeOverAdditID( _string strDefaultISChangeOverAdditID, SideDefinition eSideDefinition )
{
	ASSERT( CoolingSide == eSideDefinition || HeatingSide == eSideDefinition );
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( ChangeOver ) );

	CWaterChar &clWaterChar = m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( ChangeOver );

	if( CoolingSide == eSideDefinition )
	{
		clWaterChar.SetAdditID( strDefaultISChangeOverAdditID.c_str() );
	}
	else if( HeatingSide == eSideDefinition )
	{
		ASSERT( NULL != clWaterChar.GetSecondWaterChar() );
		clWaterChar.GetSecondWaterChar()->SetAdditID( strDefaultISChangeOverAdditID.c_str() );
	}
}
// End of methods to set default additive ID for product selection.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Start of methods to set default weight of the additive for product selection.
void CDS_TechnicalParameter::SetDefaultISPcWeight( double dDefaultISPcWeight, SideDefinition eSideDefinition )
{
	SetDefaultISPcWeight( dDefaultISPcWeight, m_rTechParamData.m_eProductSelectionApplicationType, eSideDefinition );
}

void CDS_TechnicalParameter::SetDefaultISPcWeight( double dDefaultISPcWeight, ProjectType eApplicationType, SideDefinition eSideDefinition )
{
	switch( eApplicationType )
	{
		case Heating:
			SetDefaultISHeatingPcWeight( dDefaultISPcWeight );
			break;

		case Cooling:
			SetDefaultISCoolingPcWeight( dDefaultISPcWeight );
			break;

		case Solar:
			SetDefaultISSolarPcWeight( dDefaultISPcWeight );
			break;

		case ChangeOver:
			SetDefaultISChangeOverPcWeight( dDefaultISPcWeight, eSideDefinition );
			break;

		case InvalidProjectType:
		default:
			break;
	}
}

void CDS_TechnicalParameter::SetDefaultISHeatingPcWeight( double dDefaultISHeatingPcWeight )
{
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( Heating ) );
	m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( Heating ).SetPcWeight( dDefaultISHeatingPcWeight );
}

void CDS_TechnicalParameter::SetDefaultISCoolingPcWeight( double dDefaultISCoolingPcWeight )
{
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( Cooling ) );
	m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( Cooling ).SetPcWeight( dDefaultISCoolingPcWeight );
}

void CDS_TechnicalParameter::SetDefaultISSolarPcWeight( double dDefaultISSolarPcWeight )
{
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( Solar ) );
	m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( Solar ).SetPcWeight( dDefaultISSolarPcWeight );
}

void CDS_TechnicalParameter::SetDefaultISChangeOverPcWeight( double dDefaultISChangeOverPcWeight, SideDefinition eSideDefinition )
{
	ASSERT( CoolingSide == eSideDefinition || HeatingSide == eSideDefinition );
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( ChangeOver ) );

	CWaterChar &clWaterChar = m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( ChangeOver );

	if( CoolingSide == eSideDefinition )
	{
		clWaterChar.SetPcWeight( dDefaultISChangeOverPcWeight );
	}
	else if( HeatingSide == eSideDefinition )
	{
		ASSERT( NULL != clWaterChar.GetSecondWaterChar() );
		clWaterChar.GetSecondWaterChar()->SetPcWeight( dDefaultISChangeOverPcWeight );
	}
}
// End of methods to set default weight of the additive for product selection.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Start of methods to set default water characteristic for product selection.
void CDS_TechnicalParameter::SetDefaultISWC( CWaterChar &clWaterChar, SideDefinition eSideDefinition )
{
	SetDefaultISWC( clWaterChar, m_rTechParamData.m_eProductSelectionApplicationType, eSideDefinition );
}

void CDS_TechnicalParameter::SetDefaultISWC( CWaterChar &clWaterChar, ProjectType eApplicationType, SideDefinition eSideDefinition )
{
	switch( eApplicationType )
	{
		case Heating:
			SetDefaultISHeatingWC( clWaterChar );
			break;

		case Cooling:
			SetDefaultISCoolingWC( clWaterChar );
			break;

		case Solar:
			SetDefaultISSolarWC( clWaterChar );
			break;

		case ChangeOver:
			SetDefaultISChangeOverWC( clWaterChar, eSideDefinition );
			break;

		case InvalidProjectType:
		default:
			break;
	}
}

void CDS_TechnicalParameter::SetDefaultISHeatingWC( CWaterChar &clWaterChar )
{
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( Heating ) );
	m_rTechParamData.m_mapPSDefaultWaterCharByProject[Heating] = clWaterChar;
}

void CDS_TechnicalParameter::SetDefaultISCoolingWC( CWaterChar &clWaterChar )
{
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( Cooling ) );
	m_rTechParamData.m_mapPSDefaultWaterCharByProject[Cooling] = clWaterChar;
}

void CDS_TechnicalParameter::SetDefaultISSolarWC( CWaterChar &clWaterChar )
{
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( Solar ) );
	m_rTechParamData.m_mapPSDefaultWaterCharByProject[Solar] = clWaterChar;
}

void CDS_TechnicalParameter::SetDefaultISChangeOverWC( CWaterChar &clWaterChar, SideDefinition eSideDefinition )
{
	ASSERT( CoolingSide == eSideDefinition || HeatingSide == eSideDefinition );
	ASSERT( 0 != m_rTechParamData.m_mapPSDefaultWaterCharByProject.count( ChangeOver ) );

	CWaterChar &clWaterCharToSave = m_rTechParamData.m_mapPSDefaultWaterCharByProject.at( ChangeOver );

	if( CoolingSide == eSideDefinition )
	{
		clWaterCharToSave = clWaterChar;
	}
	else if( HeatingSide == eSideDefinition )
	{
		ASSERT( NULL != clWaterCharToSave.GetSecondWaterChar() );
		*clWaterCharToSave.GetSecondWaterChar() = clWaterChar;
	}
}
// End of methods to set default weight of the additive for product selection.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void CDS_TechnicalParameter::Copy( CData *pclDestination )
{
	CDS_TechnicalParameter *pDestinationTechnicalParameters = static_cast<CDS_TechnicalParameter *>( pclDestination );

	if( NULL == pDestinationTechnicalParameters )
	{
		return;
	}

	pDestinationTechnicalParameters->SetValvMinDp( m_rTechParamData.m_dValveMinDp );
	pDestinationTechnicalParameters->SetValvMaxDp( m_rTechParamData.m_dValveMaxDp );
	pDestinationTechnicalParameters->SetValvMin2Dp( m_rTechParamData.m_dValveMin2Dp );
	pDestinationTechnicalParameters->SetFoMinDp( m_rTechParamData.m_dFixedOrificeMinDp );
	pDestinationTechnicalParameters->SetFoMaxDp( m_rTechParamData.m_dFixedOrificeMaxDp );
	pDestinationTechnicalParameters->SetVtriMinDp( m_rTechParamData.m_dVenturiMinDp );
	pDestinationTechnicalParameters->SetVtriMaxDp( m_rTechParamData.m_dVenturiMaxDp );
	pDestinationTechnicalParameters->SetSizeShiftBelow( m_rTechParamData.m_iSizeShiftBelow );
	pDestinationTechnicalParameters->SetSizeShiftAbove( m_rTechParamData.m_iSizeShiftAbove );
	pDestinationTechnicalParameters->SetMaxSizeShift( m_rTechParamData.m_iMaxSizeShift );
	pDestinationTechnicalParameters->SetPipeMinDp( m_rTechParamData.m_dPipeMinDp );
	pDestinationTechnicalParameters->SetPipeMaxDp( m_rTechParamData.m_dPipeMaxDp );
	pDestinationTechnicalParameters->SetPipeMinVel( m_rTechParamData.m_dPipeMinVelocity );
	pDestinationTechnicalParameters->SetPipeMaxVel( m_rTechParamData.m_dPipeMaxVelocity );
	pDestinationTechnicalParameters->SetPipeTargDp( m_rTechParamData.m_dPipeTargetDp );
	pDestinationTechnicalParameters->SetPipeTargVel( m_rTechParamData.m_dPipeTargetVelocity );
	pDestinationTechnicalParameters->SetPipeVtargUsed( m_rTechParamData.m_iPipeTargetVelosityUsed );
	pDestinationTechnicalParameters->SetTrvMinDpRatio( m_rTechParamData.m_dTrvMinDpRatio );
	pDestinationTechnicalParameters->SetTrvDefDpTot( m_rTechParamData.m_dTrvDefDpTotal );
	pDestinationTechnicalParameters->SetTrvDefRoomT( m_rTechParamData.m_dTrvDefRoomTemperature );
	pDestinationTechnicalParameters->SetTrvDefSupplyT( m_rTechParamData.m_dTrvDefSupplyTemperature );
	pDestinationTechnicalParameters->SetTrvMaxDp( m_rTechParamData.m_dTrvMaxDp );
	pDestinationTechnicalParameters->SetCVMinAuthor( m_rTechParamData.m_dCVMinAuthor );
	pDestinationTechnicalParameters->SetCVMinAuthCstFlow( m_rTechParamData.m_dCVMinAuthCstFlow );
	pDestinationTechnicalParameters->SetCVMinDpOnoff( m_rTechParamData.m_dCVMinDpOnoff );
	pDestinationTechnicalParameters->SetCVMinDpProp( m_rTechParamData.m_dCVMinDpProp );
	pDestinationTechnicalParameters->SetCVDefKvReynard( m_rTechParamData.m_iCVDefKvReynard );
	pDestinationTechnicalParameters->SetCVUseDpCBand( m_rTechParamData.m_iCVUseDpCPBand );
	pDestinationTechnicalParameters->SetPICvMinDp( m_rTechParamData.m_dPICvMinDp );
	pDestinationTechnicalParameters->SetPICvHide( m_rTechParamData.m_iPICvHide );
	pDestinationTechnicalParameters->SetDpCMinDp( m_rTechParamData.m_dDpCMinDp );
	pDestinationTechnicalParameters->SetDpCHide( m_rTechParamData.m_iDpCHide );
	pDestinationTechnicalParameters->SetDpCMvLoc( m_rTechParamData.m_iDpCMvLocation );
	pDestinationTechnicalParameters->SetDpCfDpCMvWithSameSizeOnly( m_rTechParamData.m_iDpCMvWithSameSizeOnly );
	pDestinationTechnicalParameters->SetDpCHminFullyOpenMv( m_rTechParamData.m_iDpCHminFullyOpenMv );
	pDestinationTechnicalParameters->SetFlowDeviationPlus( m_rTechParamData.m_dFlowDeviationPlus );
	pDestinationTechnicalParameters->SetFlowDeviationMinus( m_rTechParamData.m_dFlowDeviationMinus );
	pDestinationTechnicalParameters->SetCurrencyID( m_rTechParamData.m_strCurrencyID );
	pDestinationTechnicalParameters->SetDefaultPipeSerieID( m_rTechParamData.m_strDefaultPipeSerieID );
	pDestinationTechnicalParameters->SetCVMaxDispDp( m_rTechParamData.m_dCVMaxDispDp );
	pDestinationTechnicalParameters->SetCVMaxDpProp( m_rTechParamData.m_dCVMaxDpProp );
	pDestinationTechnicalParameters->SetDpCBCVDpcmin( m_rTechParamData.m_dDpCBCVDpcmin );
	pDestinationTechnicalParameters->SetDpCBCVDpcmin( m_rTechParamData.m_dDpCBCVDplmin );
	pDestinationTechnicalParameters->SetMinPressureMargin( m_rTechParamData.m_dMinPressureMargin );
	pDestinationTechnicalParameters->SetMaxNumberOfAdditionalVesselsInParallel( m_rTechParamData.m_iMaxNumberOfAdditionalVesselsInParallel );
	pDestinationTechnicalParameters->SetUseVesselPressureVolumeLimit( m_rTechParamData.m_fUseVesselPressureVolumeLimit );
	pDestinationTechnicalParameters->SetPressureVolumeLimit( m_rTechParamData.m_dPressureVolumeLimit );
	
	// HYS-1126.
	pDestinationTechnicalParameters->SetUseSimplyPst( m_rTechParamData.m_bUseSimplyPst );

	pDestinationTechnicalParameters->SetCanChangePressureVolumeLimit( m_rTechParamData.m_bCanChangePressureVolumeLimit );
	pDestinationTechnicalParameters->SetMaxNumberOfVentoInParallel( m_rTechParamData.m_iMaxNumberOfVentoInParallel );
	pDestinationTechnicalParameters->SetPSetupCompresso( m_rTechParamData.m_dPSetupCompresso );
	pDestinationTechnicalParameters->SetPSetupTransfero( m_rTechParamData.m_dPSetupTransfero );
	pDestinationTechnicalParameters->SetDefaultFillTemperature( m_rTechParamData.m_dDefaultFillTemperature );
	pDestinationTechnicalParameters->SetUseDefaultFreezingPointAsMinTemperature( m_rTechParamData.m_fUseDefaultFreezingPointAsMinTemperature );
	pDestinationTechnicalParameters->SetVesselSelectionRangePercentage( m_rTechParamData.m_dVesselSelectionRangePercentage );

	pDestinationTechnicalParameters->SetDefaultWaterMakeUpTemp( m_rTechParamData.m_dDefaultWaterMakeUpTemp );
	pDestinationTechnicalParameters->SetDefaultMaxTempInCooling( m_rTechParamData.m_dDefaultMaxTempInCooling );
	pDestinationTechnicalParameters->SetDefaultMinTempInHeating( m_rTechParamData.m_dDefaultMinTempInHeating );
	pDestinationTechnicalParameters->SetDefaultMinTempInSolar( m_rTechParamData.m_dDefaultMinTempInSolar );
	pDestinationTechnicalParameters->SetDefaultSafetyPressureResponseValve( m_rTechParamData.m_dDefaultSafetyPressureResponseValve );
	pDestinationTechnicalParameters->SetDefaultTAZ( m_rTechParamData.m_dDefaultTAZ );
	pDestinationTechnicalParameters->SetDefaultCalculationNorm( m_rTechParamData.m_sDefaultCalculationNorm );
	pDestinationTechnicalParameters->SetBreakTankRequiredForWaterMakeUp( m_rTechParamData.m_bBreakTankRequiredForWaterMakeUp );
	pDestinationTechnicalParameters->SetDefaultStaticPressureOfWaterNetwork( m_rTechParamData.m_dDefaultStaticPressureOfWaterNetwork );
	pDestinationTechnicalParameters->SetAvailablePMPanels( m_rTechParamData.m_iAvailablePMPanels );
	pDestinationTechnicalParameters->SetDefaultWaterHardness( m_rTechParamData.m_dDefaultWaterHardness );
	pDestinationTechnicalParameters->SetDegassingWaterReserveForVessel( m_rTechParamData.m_dDegassingWaterReserveForVessel );

	pDestinationTechnicalParameters->SetProjectApplicationType( Cooling );
	pDestinationTechnicalParameters->SetDefaultPrjTps( m_rTechParamData.m_dDefaultPrjCoolingTps );
	pDestinationTechnicalParameters->SetDefaultPrjDT( m_rTechParamData.m_dDefaultPrjCoolingDT );
	pDestinationTechnicalParameters->SetDefaultPrjAddit( m_rTechParamData.m_strDefaultPrjCoolingAdditID );
	pDestinationTechnicalParameters->SetDefaultPrjPcWeight( m_rTechParamData.m_dDefaultPrjCoolingPcWeight );

	pDestinationTechnicalParameters->SetProjectApplicationType( Heating );
	pDestinationTechnicalParameters->SetDefaultPrjTps( m_rTechParamData.m_dDefaultPrjHeatingTps );
	pDestinationTechnicalParameters->SetDefaultPrjDT( m_rTechParamData.m_dDefaultPrjHeatingDT );
	pDestinationTechnicalParameters->SetDefaultPrjAddit( m_rTechParamData.m_strDefaultPrjHeatingAdditID );
	pDestinationTechnicalParameters->SetDefaultPrjPcWeight( m_rTechParamData.m_dDefaultPrjHeatingPcWeight );

	pDestinationTechnicalParameters->SetProjectApplicationType( m_rTechParamData.m_eProjectType );

	pDestinationTechnicalParameters->SetProductSelectionApplicationType( m_rTechParamData.m_eProductSelectionApplicationType );

	// HYS-1230: Complete review of the water characteristic for product selection.
	// Copy default water characteristic for heating for product selection.
	pDestinationTechnicalParameters->SetDefaultISHeatingWC( *GetDefaultISHeatingWC() );
	pDestinationTechnicalParameters->SetDefaultISHeatingDT( GetDefaultISHeatingDT() );

	// Copy default water characteristic for cooling for product selection.
	pDestinationTechnicalParameters->SetDefaultISCoolingWC( *GetDefaultISCoolingWC() );
	pDestinationTechnicalParameters->SetDefaultISCoolingDT( GetDefaultISCoolingDT() );

	// Copy default water characteristic for solar for product selection.
	pDestinationTechnicalParameters->SetDefaultISSolarWC( *GetDefaultISSolarWC() );
	pDestinationTechnicalParameters->SetDefaultISSolarDT( GetDefaultISSolarDT() );

	// Copy default water characteristic for change-over - cooling side for product selection.
	pDestinationTechnicalParameters->SetDefaultISChangeOverWC( *GetDefaultISChangeOverWC( CoolingSide ), CoolingSide );
	pDestinationTechnicalParameters->SetDefaultISChangeOverDT( GetDefaultISChangeOverDT( CoolingSide ), CoolingSide );

	// Copy default water characteristic for change-over - heating side for product selection.
	pDestinationTechnicalParameters->SetDefaultISChangeOverWC( *GetDefaultISChangeOverWC( HeatingSide ), HeatingSide );
	pDestinationTechnicalParameters->SetDefaultISChangeOverDT( GetDefaultISChangeOverDT( HeatingSide ), HeatingSide );

	pDestinationTechnicalParameters->SetPICVExtraThresholdDp( m_rTechParamData.m_dPICVExtraThresholdDp );

	pDestinationTechnicalParameters->SetMaxSafetyValveInParallel( m_rTechParamData.m_iMaxSafetyValveInParallel );

	// HYS-1022: 0.3 bar margin for initial pressure (EN 12828-2014).
	pDestinationTechnicalParameters->SetInitialPressureMargin( m_rTechParamData.m_dInitialPressureMargin );

	// HYS-1104: safety temperature limiter limit from which we need to pass to the EN 12953 norm.
	pDestinationTechnicalParameters->SetSafetyTempLimiterLimitEN12953( m_rTechParamData.m_dSafetyTempLimiterLimitEN12953 );
	
	// HYS-1104: supply/return temperature limit from which we need to pass to the EN 12953 norm.
	pDestinationTechnicalParameters->SetFluidTempLimitEN12953( m_rTechParamData.m_dFluidTempLimitEN12953 );

	// HYS-1151: The reference value used to determine the best 6-way valve at a flow given.
	pDestinationTechnicalParameters->SetDpRefForBest6Way( m_rTechParamData.m_dDpRefForBest6Way );

	// HYS-1763: Smart control valve default location in hydronic circuit calculation: 1 Supply side / 0 Return side.
	pDestinationTechnicalParameters->SetDefaultSmartCVLoc( m_rTechParamData.m_iDefaultSmartCVLoc );

	pDestinationTechnicalParameters->SetSmartValveDpMaxForBestSuggestion( m_rTechParamData.m_dSmartValveDpMaxForBestSuggestion );

	// Version 39: HYS-1930: New hydronic circuit: auto-adapting variable flow decoupling circuit: add default secondary pump Hmin.
	pDestinationTechnicalParameters->SetDefaultSecondaryPumpHMin( m_rTechParamData.m_dDefaultSecondaryPumpHMin );

	pDestinationTechnicalParameters->Modified();
}

int CDS_TechnicalParameter::Compare( CData *pDataToCompare )
{
	if( NULL == pDataToCompare || NULL == dynamic_cast<CDS_TechnicalParameter *>( pDataToCompare ) )
	{
		return -1;
	}

	CDS_TechnicalParameter *pclTechParamToCompare = dynamic_cast<CDS_TechnicalParameter *>( pDataToCompare );
	TechParam_struct *pTechParamStructToCompare = pclTechParamToCompare->GetTechParamStructure();

	if( pTechParamStructToCompare->m_dValveMinDp != m_rTechParamData.m_dValveMinDp )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dValveMaxDp != m_rTechParamData.m_dValveMaxDp )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dValveMin2Dp != m_rTechParamData.m_dValveMin2Dp )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dFixedOrificeMinDp != m_rTechParamData.m_dFixedOrificeMinDp )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dFixedOrificeMaxDp != m_rTechParamData.m_dFixedOrificeMaxDp )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dVenturiMinDp != m_rTechParamData.m_dVenturiMinDp )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dVenturiMaxDp != m_rTechParamData.m_dVenturiMaxDp )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_iSizeShiftBelow != m_rTechParamData.m_iSizeShiftBelow )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_iSizeShiftAbove != m_rTechParamData.m_iSizeShiftAbove )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_iMaxSizeShift != m_rTechParamData.m_iMaxSizeShift )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dPipeMinDp != m_rTechParamData.m_dPipeMinDp )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dPipeMaxDp != m_rTechParamData.m_dPipeMaxDp )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dPipeMinVelocity != m_rTechParamData.m_dPipeMinVelocity )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dPipeMaxVelocity != m_rTechParamData.m_dPipeMaxVelocity )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dPipeTargetDp != m_rTechParamData.m_dPipeTargetDp )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dPipeTargetVelocity != m_rTechParamData.m_dPipeTargetVelocity )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_iPipeTargetVelosityUsed != m_rTechParamData.m_iPipeTargetVelosityUsed )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dTrvMinDpRatio != m_rTechParamData.m_dTrvMinDpRatio )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dTrvDefDpTotal != m_rTechParamData.m_dTrvDefDpTotal )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dTrvDefRoomTemperature != m_rTechParamData.m_dTrvDefRoomTemperature )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dTrvDefSupplyTemperature != m_rTechParamData.m_dTrvDefSupplyTemperature )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dTrvMaxDp != m_rTechParamData.m_dTrvMaxDp )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dCVMinAuthor != m_rTechParamData.m_dCVMinAuthor )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dCVMinAuthCstFlow != m_rTechParamData.m_dCVMinAuthCstFlow )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dCVMinDpOnoff != m_rTechParamData.m_dCVMinDpOnoff )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dCVMinDpProp != m_rTechParamData.m_dCVMinDpProp )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_iCVDefKvReynard != m_rTechParamData.m_iCVDefKvReynard )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_iCVUseDpCPBand != m_rTechParamData.m_iCVUseDpCPBand )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dPICvMinDp != m_rTechParamData.m_dPICvMinDp )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_iPICvHide != m_rTechParamData.m_iPICvHide )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dDpCMinDp != m_rTechParamData.m_dDpCMinDp )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_iDpCHide != m_rTechParamData.m_iDpCHide )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_iDpCMvLocation != m_rTechParamData.m_iDpCMvLocation )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_iDpCMvWithSameSizeOnly != m_rTechParamData.m_iDpCMvWithSameSizeOnly )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_iDpCHminFullyOpenMv != m_rTechParamData.m_iDpCHminFullyOpenMv )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dFlowDeviationPlus != m_rTechParamData.m_dFlowDeviationPlus )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dFlowDeviationMinus != m_rTechParamData.m_dFlowDeviationMinus )
	{
		return -1;
	}

	if( 0 != pTechParamStructToCompare->m_strCurrencyID.compare( m_rTechParamData.m_strCurrencyID ) )
	{
		return -1;
	}

	if( 0 != pTechParamStructToCompare->m_strDefaultPipeSerieID.compare( m_rTechParamData.m_strDefaultPipeSerieID ) )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dCVMaxDispDp != m_rTechParamData.m_dCVMaxDispDp )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dCVMaxDpProp != m_rTechParamData.m_dCVMaxDpProp )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dDpCBCVDpcmin != m_rTechParamData.m_dDpCBCVDpcmin )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dDpCBCVDplmin != m_rTechParamData.m_dDpCBCVDplmin )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dVesselSelectionRangePercentage != m_rTechParamData.m_dVesselSelectionRangePercentage )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dMinPressureMargin != m_rTechParamData.m_dMinPressureMargin )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_iMaxNumberOfAdditionalVesselsInParallel != m_rTechParamData.m_iMaxNumberOfAdditionalVesselsInParallel )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_fUseVesselPressureVolumeLimit != m_rTechParamData.m_fUseVesselPressureVolumeLimit )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dPressureVolumeLimit != m_rTechParamData.m_dPressureVolumeLimit )
	{
		return -1;
	}

	// HYS-1126.
	if( pTechParamStructToCompare->m_bUseSimplyPst != m_rTechParamData.m_bUseSimplyPst )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_bCanChangePressureVolumeLimit != m_rTechParamData.m_bCanChangePressureVolumeLimit )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_iMaxNumberOfVentoInParallel != m_rTechParamData.m_iMaxNumberOfVentoInParallel )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dPSetupCompresso != m_rTechParamData.m_dPSetupCompresso )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dPSetupTransfero != m_rTechParamData.m_dPSetupTransfero )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dDefaultFillTemperature != m_rTechParamData.m_dDefaultFillTemperature )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_fUseDefaultFreezingPointAsMinTemperature != m_rTechParamData.m_fUseDefaultFreezingPointAsMinTemperature )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dDefaultWaterMakeUpTemp != m_rTechParamData.m_dDefaultWaterMakeUpTemp )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dDefaultMaxTempInCooling != m_rTechParamData.m_dDefaultMaxTempInCooling )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dDefaultMinTempInHeating != m_rTechParamData.m_dDefaultMinTempInHeating )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dDefaultMinTempInSolar != m_rTechParamData.m_dDefaultMinTempInSolar )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dDefaultSafetyPressureResponseValve != m_rTechParamData.m_dDefaultSafetyPressureResponseValve )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dDefaultTAZ != m_rTechParamData.m_dDefaultTAZ )
	{
		return -1;
	}

	if( 0 != pTechParamStructToCompare->m_sDefaultCalculationNorm.compare( m_rTechParamData.m_sDefaultCalculationNorm ) )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_bBreakTankRequiredForWaterMakeUp != m_rTechParamData.m_bBreakTankRequiredForWaterMakeUp )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dDefaultStaticPressureOfWaterNetwork != m_rTechParamData.m_dDefaultStaticPressureOfWaterNetwork )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_iAvailablePMPanels != m_rTechParamData.m_iAvailablePMPanels )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dDefaultWaterHardness != m_rTechParamData.m_dDefaultWaterHardness )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dDegassingWaterReserveForVessel != m_rTechParamData.m_dDegassingWaterReserveForVessel )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_eProjectType != m_rTechParamData.m_eProjectType )
	{
		return -1;
	}

	// Compare water characteristic in heating and cooling for HM calc.
	if( pTechParamStructToCompare->m_dDefaultPrjCoolingTps != m_rTechParamData.m_dDefaultPrjCoolingTps )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dDefaultPrjHeatingTps != m_rTechParamData.m_dDefaultPrjHeatingTps )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dDefaultPrjCoolingDT != m_rTechParamData.m_dDefaultPrjCoolingDT )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dDefaultPrjHeatingDT != m_rTechParamData.m_dDefaultPrjHeatingDT )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_eProductSelectionApplicationType != m_rTechParamData.m_eProductSelectionApplicationType )
	{
		return -1;
	}

	if( 0 != pTechParamStructToCompare->m_strDefaultPrjHeatingAdditID.compare( m_rTechParamData.m_strDefaultPrjHeatingAdditID ) )
	{
		return -1;
	}

	if( 0 != pTechParamStructToCompare->m_strDefaultPrjCoolingAdditID.compare( m_rTechParamData.m_strDefaultPrjCoolingAdditID ) )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dDefaultPrjHeatingPcWeight != m_rTechParamData.m_dDefaultPrjHeatingPcWeight )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dDefaultPrjCoolingPcWeight != m_rTechParamData.m_dDefaultPrjCoolingPcWeight )
	{
		return -1;
	}

	// HYS-1230: Complete review of the water characteristic for product selection.
	// Compare water characteristic in heating, cooling, solar and change-over for product selection.
	if( *pclTechParamToCompare->GetDefaultISHeatingWC() != *GetDefaultISHeatingWC() )
	{
		return -1;
	}

	if( *pclTechParamToCompare->GetDefaultISCoolingWC() != *GetDefaultISCoolingWC() )
	{
		return -1;
	}

	if( *pclTechParamToCompare->GetDefaultISSolarWC() != *GetDefaultISSolarWC() )
	{
		return -1;
	}

	if( *pclTechParamToCompare->GetDefaultISChangeOverWC( CoolingSide ) != *GetDefaultISChangeOverWC( CoolingSide ) )
	{
		return -1;
	}

	if( *pclTechParamToCompare->GetDefaultISChangeOverWC( HeatingSide ) != *GetDefaultISChangeOverWC( HeatingSide ) )
	{
		return -1;
	}

	if( pclTechParamToCompare->GetDefaultISHeatingDT() != GetDefaultISHeatingDT() )
	{
		return -1;
	}

	if( pclTechParamToCompare->GetDefaultISCoolingDT() != GetDefaultISCoolingDT() )
	{
		return -1;
	}

	if( pclTechParamToCompare->GetDefaultISSolarDT() != GetDefaultISSolarDT() )
	{
		return -1;
	}

	if( pclTechParamToCompare->GetDefaultISChangeOverDT( CoolingSide ) != GetDefaultISChangeOverDT( CoolingSide ) )
	{
		return -1;
	}

	if( pclTechParamToCompare->GetDefaultISChangeOverDT( HeatingSide ) != GetDefaultISChangeOverDT(  HeatingSide  ) )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_iMaxSafetyValveInParallel != m_rTechParamData.m_iMaxSafetyValveInParallel )
	{
		return -1;
	}

	// HYS-1022: 0.3 bar margin for initial pressure (EN 12828-2014).
	if( pTechParamStructToCompare->m_dInitialPressureMargin != m_rTechParamData.m_dInitialPressureMargin )
	{
		return -1;
	}

	// HYS-1104: safety temperature limiter limit from which we need to pass to the EN 12953 norm.
	if( pTechParamStructToCompare->m_dSafetyTempLimiterLimitEN12953 != m_rTechParamData.m_dSafetyTempLimiterLimitEN12953 )
	{
		return -1;
	}
	
	// HYS-1104: supply/return temperature limit from which we need to pass to the EN 12953 norm.
	if( pTechParamStructToCompare->m_dFluidTempLimitEN12953 != m_rTechParamData.m_dFluidTempLimitEN12953 )
	{
		return -1;
	}

	// HYS-1151: The reference value used to determine the best 6-way valve at a flow given.
	if( pTechParamStructToCompare->m_dDpRefForBest6Way != m_rTechParamData.m_dDpRefForBest6Way )
	{
		return -1;
	}
	
	// HYS-1763: Smart control valve default location in hydronic circuit calculation: 1 Supply side / 0 Return side.
	if( pTechParamStructToCompare->m_iDefaultSmartCVLoc != m_rTechParamData.m_iDefaultSmartCVLoc )
	{
		return -1;
	}

	if( pTechParamStructToCompare->m_dSmartValveDpMaxForBestSuggestion != m_rTechParamData.m_dSmartValveDpMaxForBestSuggestion )
	{
		return -1;
	}

	// Version 39: HYS-1930: New hydronic circuit: auto-adapting variable flow decoupling circuit: add default secondary pump Hmin.
	if( pTechParamStructToCompare->m_dDefaultSecondaryPumpHMin != m_rTechParamData.m_dDefaultSecondaryPumpHMin )
	{
		return -1;
	}

	return 0;
}

#ifndef TACBX
void CDS_TechnicalParameter::ExportTechParams( std::map<CString, CString> *pmapExportedData )
{
	if( NULL == pmapExportedData )
	{
		return;
	}

	CString strValue;
	strValue.Format( _T("%.13g"), m_rTechParamData.m_dValveMinDp );
	pmapExportedData->insert( std::pair<CString, CString>( _T("ValveMinDp"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dValveMin2Dp );
	pmapExportedData->insert( std::pair<CString, CString>( _T("ValveMin2Dp"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dValveMaxDp );
	pmapExportedData->insert( std::pair<CString, CString>( _T("ValveMaxDp"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dFixedOrificeMinDp );
	pmapExportedData->insert( std::pair<CString, CString>( _T("FixedOrificeMinDp"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dFixedOrificeMaxDp );
	pmapExportedData->insert( std::pair<CString, CString>( _T("FixedOrificeMaxDp"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dVenturiMinDp );
	pmapExportedData->insert( std::pair<CString, CString>( _T("VenturiMinDp"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dVenturiMaxDp );
	pmapExportedData->insert( std::pair<CString, CString>( _T("VenturiMaxDp"), strValue ) );

	strValue.Format( _T("%i"), m_rTechParamData.m_iSizeShiftAbove );
	pmapExportedData->insert( std::pair<CString, CString>( _T("SizeShiftAbove"), strValue ) );

	strValue.Format( _T("%i"), m_rTechParamData.m_iSizeShiftBelow );
	pmapExportedData->insert( std::pair<CString, CString>( _T("SizeShiftBelow"), strValue ) );

	strValue.Format( _T("%i"), m_rTechParamData.m_iMaxSizeShift );
	pmapExportedData->insert( std::pair<CString, CString>( _T("MaxSizeShift"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dPipeMinDp );
	pmapExportedData->insert( std::pair<CString, CString>( _T("PipeMinDp"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dPipeMaxDp );
	pmapExportedData->insert( std::pair<CString, CString>( _T("PipeMaxDp"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dPipeMinVelocity );
	pmapExportedData->insert( std::pair<CString, CString>( _T("PipeMinVelocity"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dPipeMaxVelocity );
	pmapExportedData->insert( std::pair<CString, CString>( _T("PipeMaxVelocity"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dPipeTargetDp );
	pmapExportedData->insert( std::pair<CString, CString>( _T("PipeTargetDp"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dPipeTargetVelocity );
	pmapExportedData->insert( std::pair<CString, CString>( _T("PipeTargetVelocity"), strValue ) );

	strValue.Format( _T("%i"), m_rTechParamData.m_iPipeTargetVelosityUsed );
	pmapExportedData->insert( std::pair<CString, CString>( _T("PipeTargetVelosityUsed"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dTrvMinDpRatio );
	pmapExportedData->insert( std::pair<CString, CString>( _T("TrvMinDpRatio"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dTrvDefDpTotal );
	pmapExportedData->insert( std::pair<CString, CString>( _T("TrvDefDpTotal"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dTrvDefRoomTemperature );
	pmapExportedData->insert( std::pair<CString, CString>( _T("TrvDefRoomTemperature"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dTrvDefSupplyTemperature );
	pmapExportedData->insert( std::pair<CString, CString>( _T("TrvDefSupplyTemperature"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dTrvMaxDp );
	pmapExportedData->insert( std::pair<CString, CString>( _T("TrvMaxDp"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dCVMinAuthor );
	pmapExportedData->insert( std::pair<CString, CString>( _T("CVMinAuthor"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dCVMinAuthCstFlow );
	pmapExportedData->insert( std::pair<CString, CString>( _T("CVMinAuthCstFlow"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dCVMinDpOnoff );
	pmapExportedData->insert( std::pair<CString, CString>( _T("CVMinDpOnoff"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dCVMinDpProp );
	pmapExportedData->insert( std::pair<CString, CString>( _T("CVMinDpProp"), strValue ) );

	strValue.Format( _T("%i"), m_rTechParamData.m_iCVDefKvReynard );
	pmapExportedData->insert( std::pair<CString, CString>( _T("CVDefKvReynard"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dDpCMinDp );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DpCMinDp"), strValue ) );

	strValue.Format( _T("%i"), m_rTechParamData.m_iDpCHide );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DpCHide"), strValue ) );

	strValue.Format( _T("%i"), m_rTechParamData.m_iDpCMvLocation );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DpCMvLocation"), strValue ) );

	strValue.Format( _T("%i"), m_rTechParamData.m_iDpCHminFullyOpenMv );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DpCHminFullyOpenMv"), strValue ) );

	pmapExportedData->insert( std::pair<CString, CString>( _T("CurrencyID"), m_rTechParamData.m_strCurrencyID.c_str() ) );

	pmapExportedData->insert( std::pair<CString, CString>( _T("DefaultPipeSerieID"), m_rTechParamData.m_strDefaultPipeSerieID.c_str() ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dCVMaxDispDp );
	pmapExportedData->insert( std::pair<CString, CString>( _T("CVMaxDispDp"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dCVMaxDpProp );
	pmapExportedData->insert( std::pair<CString, CString>( _T("CVMaxDpProp"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dPICvMinDp );
	pmapExportedData->insert( std::pair<CString, CString>( _T("PICvMinDp"), strValue ) );

	strValue.Format( _T("%i"), m_rTechParamData.m_iPICvHide );
	pmapExportedData->insert( std::pair<CString, CString>( _T("PICvHide"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dFlowDeviationPlus );
	pmapExportedData->insert( std::pair<CString, CString>( _T("FlowDeviationPlus"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dFlowDeviationMinus );
	pmapExportedData->insert( std::pair<CString, CString>( _T("FlowDeviationMinus"), strValue ) );

	strValue.Format( _T("%i"), m_rTechParamData.m_iDpCMvWithSameSizeOnly );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DpCMvWithSameSizeOnly"), strValue ) );

	strValue.Format( _T("%i"), (int)m_rTechParamData.m_eProjectType );
	pmapExportedData->insert( std::pair<CString, CString>( _T("ProjectType"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dDefaultPrjCoolingDT );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DefaultPrjCoolingDT"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dDefaultPrjHeatingDT );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DefaultPrjHeatingDT"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dDefaultPrjCoolingTps );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DefaultCoolingTps"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dDefaultPrjHeatingTps );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DefaultHeatingTps"), strValue ) );

	strValue.Format( _T("%i"), m_rTechParamData.m_iCVUseDpCPBand );
	pmapExportedData->insert( std::pair<CString, CString>( _T("CVUseDpCPBand"), strValue ) );

	strValue.Format( _T("%i"), (int)m_rTechParamData.m_eProductSelectionApplicationType );
	pmapExportedData->insert( std::pair<CString, CString>( _T("ApplicationType"), strValue ) );

	// HYS-1022: Change the name of variable and methods to be synchronized with HyTools.
	// 0.2 bar margin over static height as per EN 12828-2014.
	strValue.Format( _T("%.13g"), m_rTechParamData.m_dMinPressureMargin );
	pmapExportedData->insert( std::pair<CString, CString>( _T("MinPressureMargin"), strValue ) );

	strValue.Format( _T("%i"), (int)m_rTechParamData.m_iMaxNumberOfAdditionalVesselsInParallel );
	pmapExportedData->insert( std::pair<CString, CString>( _T("MaxNumberOfAdditionalVesselsInParallel"), strValue ) );

	strValue.Format( _T("%i"), (int)m_rTechParamData.m_fUseVesselPressureVolumeLimit );
	pmapExportedData->insert( std::pair<CString, CString>( _T("UseVesselPressureVolumeLimit"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dPressureVolumeLimit );
	pmapExportedData->insert( std::pair<CString, CString>( _T("PressureVolumeLimit"), strValue ) );

	strValue.Format( _T("%i"), (int)m_rTechParamData.m_bCanChangePressureVolumeLimit );
	pmapExportedData->insert( std::pair<CString, CString>( _T("CanChangePressureVolumeLimit"), strValue ) );

	// HYS-1126.
	strValue.Format( _T("%i"), (int)m_rTechParamData.m_bUseSimplyPst );
	pmapExportedData->insert( std::pair<CString, CString>( _T("UseSimplyPst"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dPSetupCompresso );
	pmapExportedData->insert( std::pair<CString, CString>( _T("PSetupCompresso"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dPSetupTransfero );
	pmapExportedData->insert( std::pair<CString, CString>( _T("PSetupTransfero"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dDefaultFillTemperature );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DefaultFillTemperature"), strValue ) );

	strValue.Format( _T("%i"), (int)m_rTechParamData.m_fUseDefaultFreezingPointAsMinTemperature );
	pmapExportedData->insert( std::pair<CString, CString>( _T("UseDefaultFreezingPointAsMinTemperature"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dDefaultWaterMakeUpTemp );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DefaultWaterMakeUpTemp"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dDefaultMaxTempInCooling );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DefaultMaxTempInCooling"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dDefaultMinTempInHeating );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DefaultMinTempInHeating"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dDefaultMinTempInSolar );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DefaultMinTempInSolar"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dDefaultSafetyPressureResponseValve );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DefaultSafetyPressureResponseValve"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dDefaultTAZ );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DefaultTAZ"), strValue ) );

	pmapExportedData->insert( std::pair<CString, CString>( _T("DefaultCalculationNorm"), m_rTechParamData.m_sDefaultCalculationNorm.c_str() ) );

	strValue.Format( _T("%i"), (int)m_rTechParamData.m_bBreakTankRequiredForWaterMakeUp );
	pmapExportedData->insert( std::pair<CString, CString>( _T("BreakTankRequiredForWaterMakeUp"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dDefaultStaticPressureOfWaterNetwork );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DefaultStaticPressureOfWaterNetwork"), strValue ) );

	strValue.Format( _T("%i"), (int)m_rTechParamData.m_iAvailablePMPanels );
	pmapExportedData->insert( std::pair<CString, CString>( _T("AvailablePMPanels"), strValue ) );

	strValue.Format( _T("%i"), (int)m_rTechParamData.m_iMaxNumberOfVentoInParallel );
	pmapExportedData->insert( std::pair<CString, CString>( _T("MaxNumberOfVentoInParallel"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dDefaultWaterHardness );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DefaultWaterHardness"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dDegassingWaterReserveForVessel );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DegassingWaterReserveForVessel"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dDpCBCVDpcmin );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DpCBCVDpcmin"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dDpCBCVDplmin );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DpCBCVDplmin"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dVesselSelectionRangePercentage );
	pmapExportedData->insert( std::pair<CString, CString>( _T("VesselSelectionRangePercentage"), strValue ) );

	pmapExportedData->insert( std::pair<CString, CString>( _T("DefaultPrjCoolingAdditID"), m_rTechParamData.m_strDefaultPrjCoolingAdditID.c_str() ) );

	pmapExportedData->insert( std::pair<CString, CString>( _T("DefaultPrjHeatingAdditID"), m_rTechParamData.m_strDefaultPrjHeatingAdditID.c_str() ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dDefaultPrjCoolingPcWeight );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DefaultPrjCoolingPcWeight"), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dDefaultPrjHeatingPcWeight );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DefaultPrjHeatingPcWeight"), strValue ) );

	strValue.Format( _T("%i"), m_rTechParamData.m_iMaxSafetyValveInParallel );
	pmapExportedData->insert( std::pair<CString, CString>( _T("MaxSafetyValveInParallel"), strValue ) );

	// HYS-1022: 0.3 bar margin for initial pressure (EN 12828-2014).
	strValue.Format( _T("%.13g"), m_rTechParamData.m_dInitialPressureMargin );
	pmapExportedData->insert( std::pair<CString, CString>( _T("InitialPressureMargin"), strValue ) );

	// HYS-1104: safety temperature limiter limit from which we need to pass to the EN 12953 norm.
	strValue.Format( _T("%.13g"), m_rTechParamData.m_dSafetyTempLimiterLimitEN12953 );
	pmapExportedData->insert( std::pair<CString, CString>( _T("SafetyTempLimiterLimitEN12953"), strValue ) );
	
	// HYS-1104: supply/return temperature limit from which we need to pass to the EN 12953 norm.
	strValue.Format( _T("%.13g"), m_rTechParamData.m_dFluidTempLimitEN12953 );
	pmapExportedData->insert( std::pair<CString, CString>( _T("FluidTempLimitEN12953"), strValue ) );

	// HYS-1151: The reference value used to determine the best 6-way valve at a flow given.
	strValue.Format( _T("%.13g"), m_rTechParamData.m_dDpRefForBest6Way );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DpRefForBest6Way"), strValue ) );

	// HYS-1230: Complete review of the water characteristic for product selection.
	// Export water characteristic for heating.
	CWaterChar clWaterChar = *GetDefaultISHeatingWC();
	_ExportTechParamsHelper( pmapExportedData, clWaterChar, ProjectType::Heating );

	strValue.Format( _T("%.13g"), GetDefaultISHeatingDT() );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DefaultISHeatingDT"), strValue ) );

	// Export water characteristic for cooling.
	clWaterChar = *GetDefaultISCoolingWC();
	_ExportTechParamsHelper( pmapExportedData, clWaterChar, ProjectType::Cooling );

	strValue.Format( _T("%.13g"), GetDefaultISCoolingDT() );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DefaultISCoolingDT"), strValue ) );

	// Export water characteristic for solar.
	clWaterChar = *GetDefaultISSolarWC();
	_ExportTechParamsHelper( pmapExportedData, clWaterChar, ProjectType::Solar );

	strValue.Format( _T("%.13g"), GetDefaultISSolarDT() );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DefaultISSolarDT"), strValue ) );

	// Export water characteristic for change-over - cooling side.
	clWaterChar = *GetDefaultISChangeOverWC( CoolingSide );
	_ExportTechParamsHelper( pmapExportedData, clWaterChar, ProjectType::ChangeOver, CoolingSide );

	strValue.Format( _T("%.13g"), GetDefaultISChangeOverDT( CoolingSide ) );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DefaultISChangeOverCoolingSideDT"), strValue ) );

	// Export water characteristic for change-over - heating side.
	clWaterChar = *GetDefaultISChangeOverWC( HeatingSide );
	_ExportTechParamsHelper( pmapExportedData, clWaterChar, ProjectType::ChangeOver, HeatingSide );

	strValue.Format( _T("%.13g"), GetDefaultISChangeOverDT( HeatingSide ) );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DefaultISChangeOverHeatingSideDT"), strValue ) );

	// HYS-1763: Smart control valve default location
	strValue.Format( _T( "%i" ), m_rTechParamData.m_iDefaultSmartCVLoc );
	pmapExportedData->insert( std::pair<CString, CString>( _T( "DefaultSmartCVLocation" ), strValue ) );

	strValue.Format( _T("%.13g"), m_rTechParamData.m_dSmartValveDpMaxForBestSuggestion );
	pmapExportedData->insert( std::pair<CString, CString>( _T("SmartValveDpMaxForBestSuggestion"), strValue ) );

	// Version 39: HYS-1930: New hydronic circuit: auto-adapting variable flow decoupling circuit: add default secondary pump Hmin.
	strValue.Format( _T("%.13g"), m_rTechParamData.m_dDefaultSecondaryPumpHMin );
	pmapExportedData->insert( std::pair<CString, CString>( _T("DefaultSecondaryPumpHMin"), strValue ) );
}

void CDS_TechnicalParameter::ImportTechParams( std::map<CString, CString> *pmapExportedData )
{
	if( NULL == pmapExportedData )
	{
		return;
	}

	if( 0 != pmapExportedData->count( _T("valvemindp") ) )
	{
		m_rTechParamData.m_dValveMinDp = _ttof( pmapExportedData->at( _T("valvemindp") ) );
	}

	if( 0 != pmapExportedData->count( _T("valvemin2dp") ) )
	{
		m_rTechParamData.m_dValveMin2Dp = _ttof( pmapExportedData->at( _T("valvemin2dp") ) );
	}

	if( 0 != pmapExportedData->count( _T("valvemaxdp") ) )
	{
		m_rTechParamData.m_dValveMaxDp = _ttof( pmapExportedData->at( _T("valvemaxdp") ) );
	}

	if( 0 != pmapExportedData->count( _T("fixedorificemindp") ) )
	{
		m_rTechParamData.m_dFixedOrificeMinDp = _ttof( pmapExportedData->at( _T("fixedorificemindp") ) );
	}

	if( 0 != pmapExportedData->count( _T("fixedorificemaxdp") ) )
	{
		m_rTechParamData.m_dFixedOrificeMaxDp = _ttof( pmapExportedData->at( _T("fixedorificemaxdp") ) );
	}

	if( 0 != pmapExportedData->count( _T("venturimindp") ) )
	{
		m_rTechParamData.m_dVenturiMinDp = _ttof( pmapExportedData->at( _T("venturimindp") ) );
	}

	if( 0 != pmapExportedData->count( _T("venturimaxdp") ) )
	{
		m_rTechParamData.m_dVenturiMaxDp = _ttof( pmapExportedData->at( _T("venturimaxdp") ) );
	}

	if( 0 != pmapExportedData->count( _T("sizeshiftabove") ) )
	{
		m_rTechParamData.m_iSizeShiftAbove = _wtoi( pmapExportedData->at( _T("sizeshiftabove") ) );
	}

	if( 0 != pmapExportedData->count( _T("sizeshiftbelow") ) )
	{
		m_rTechParamData.m_iSizeShiftBelow = _wtoi( pmapExportedData->at( _T("sizeshiftbelow") ) );
	}

	if( 0 != pmapExportedData->count( _T("maxsizeshift") ) )
	{
		m_rTechParamData.m_iMaxSizeShift = _wtoi( pmapExportedData->at( _T("maxsizeshift") ) );
	}

	if( 0 != pmapExportedData->count( _T("pipemindp") ) )
	{
		m_rTechParamData.m_dPipeMinDp = _ttof( pmapExportedData->at( _T("pipemindp") ) );
	}

	if( 0 != pmapExportedData->count( _T("pipemaxdp") ) )
	{
		m_rTechParamData.m_dPipeMaxDp = _ttof( pmapExportedData->at( _T("pipemaxdp") ) );
	}

	if( 0 != pmapExportedData->count( _T("pipeminvelocity") ) )
	{
		m_rTechParamData.m_dPipeMinVelocity = _ttof( pmapExportedData->at( _T("pipeminvelocity") ) );
	}

	if( 0 != pmapExportedData->count( _T("pipemaxvelocity") ) )
	{
		m_rTechParamData.m_dPipeMaxVelocity = _ttof( pmapExportedData->at( _T("pipemaxvelocity") ) );
	}

	if( 0 != pmapExportedData->count( _T("pipetargetdp") ) )
	{
		m_rTechParamData.m_dPipeTargetDp = _ttof( pmapExportedData->at( _T("pipetargetdp") ) );
	}

	if( 0 != pmapExportedData->count( _T("pipetargetvelocity") ) )
	{
		m_rTechParamData.m_dPipeTargetVelocity = _ttof( pmapExportedData->at( _T("pipetargetvelocity") ) );
	}

	if( 0 != pmapExportedData->count( _T("pipetargetvelosityused") ) )
	{
		m_rTechParamData.m_iPipeTargetVelosityUsed = _wtoi( pmapExportedData->at( _T("pipetargetvelosityused") ) );
	}

	if( 0 != pmapExportedData->count( _T("trvmindpratio") ) )
	{
		m_rTechParamData.m_dTrvMinDpRatio = _ttof( pmapExportedData->at( _T("trvmindpratio") ) );
	}

	if( 0 != pmapExportedData->count( _T("trvdefdptotal") ) )
	{
		m_rTechParamData.m_dTrvDefDpTotal = _ttof( pmapExportedData->at( _T("trvdefdptotal") ) );
	}

	if( 0 != pmapExportedData->count( _T("trvdefroomtemperature") ) )
	{
		m_rTechParamData.m_dTrvDefRoomTemperature = _ttof( pmapExportedData->at( _T("trvdefroomtemperature") ) );
	}

	if( 0 != pmapExportedData->count( _T("trvdefsupplytemperature") ) )
	{
		m_rTechParamData.m_dTrvDefSupplyTemperature = _ttof( pmapExportedData->at( _T("trvdefsupplytemperature") ) );
	}

	if( 0 != pmapExportedData->count( _T("trvmaxdp") ) )
	{
		m_rTechParamData.m_dTrvMaxDp = _ttof( pmapExportedData->at( _T("trvmaxdp") ) );
	}

	if( 0 != pmapExportedData->count( _T("cvminauthor") ) )
	{
		m_rTechParamData.m_dCVMinAuthor = _ttof( pmapExportedData->at( _T("cvminauthor") ) );
	}

	if( 0 != pmapExportedData->count( _T("cvminauthcstflow") ) )
	{
		m_rTechParamData.m_dCVMinAuthCstFlow = _ttof( pmapExportedData->at( _T("cvminauthcstflow") ) );
	}

	if( 0 != pmapExportedData->count( _T("cvmindponoff") ) )
	{
		m_rTechParamData.m_dCVMinDpOnoff = _ttof( pmapExportedData->at( _T("cvmindponoff") ) );
	}

	if( 0 != pmapExportedData->count( _T("cvmindpprop") ) )
	{
		m_rTechParamData.m_dCVMinDpProp = _ttof( pmapExportedData->at( _T("cvmindpprop") ) );
	}

	if( 0 != pmapExportedData->count( _T("cvdefkvreynard") ) )
	{
		m_rTechParamData.m_iCVDefKvReynard = _wtoi( pmapExportedData->at( _T("cvdefkvreynard") ) );
	}

	if( 0 != pmapExportedData->count( _T("dpcmindp") ) )
	{
		m_rTechParamData.m_dDpCMinDp = _ttof( pmapExportedData->at( _T("dpcmindp") ) );
	}

	if( 0 != pmapExportedData->count( _T("dpchide") ) )
	{
		m_rTechParamData.m_iDpCHide = _wtoi( pmapExportedData->at( _T("dpchide") ) );
	}

	if( 0 != pmapExportedData->count( _T("dpcmvlocation") ) )
	{
		m_rTechParamData.m_iDpCMvLocation = _wtoi( pmapExportedData->at( _T("dpcmvlocation") ) );
	}

	if( 0 != pmapExportedData->count( _T("dpchminfullyopenmv") ) )
	{
		m_rTechParamData.m_iDpCHminFullyOpenMv = _wtoi( pmapExportedData->at( _T("dpchminfullyopenmv") ) );
	}

	if( 0 != pmapExportedData->count( _T("currencyid") ) )
	{
		m_rTechParamData.m_strCurrencyID = pmapExportedData->at( _T("currencyid") ).MakeUpper();
	}

	if( 0 != pmapExportedData->count( _T("defaultpipeserieid") ) )
	{
		m_rTechParamData.m_strDefaultPipeSerieID = pmapExportedData->at( _T("defaultpipeserieid") ).MakeUpper();
	}

	if( 0 != pmapExportedData->count( _T("cvmaxdispdp") ) )
	{
		m_rTechParamData.m_dCVMaxDispDp = _ttof( pmapExportedData->at( _T("cvmaxdispdp") ) );
	}

	if( 0 != pmapExportedData->count( _T("cvmaxdpprop") ) )
	{
		m_rTechParamData.m_dCVMaxDpProp = _ttof( pmapExportedData->at( _T("cvmaxdpprop") ) );
	}

	if( 0 != pmapExportedData->count( _T("picvmindp") ) )
	{
		m_rTechParamData.m_dPICvMinDp = _ttof( pmapExportedData->at( _T("picvmindp") ) );
	}

	if( 0 != pmapExportedData->count( _T("picvhide") ) )
	{
		m_rTechParamData.m_iPICvHide = _wtoi( pmapExportedData->at( _T("picvhide") ) );
	}

	if( 0 != pmapExportedData->count( _T("flowdeviationplus") ) )
	{
		m_rTechParamData.m_dFlowDeviationPlus = _ttof( pmapExportedData->at( _T("flowdeviationplus") ) );
	}

	if( 0 != pmapExportedData->count( _T("flowdeviationminus") ) )
	{
		m_rTechParamData.m_dFlowDeviationMinus = _ttof( pmapExportedData->at( _T("flowdeviationminus") ) );
	}

	if( 0 != pmapExportedData->count( _T("dpcmvwithsamesizeonly") ) )
	{
		m_rTechParamData.m_iDpCMvWithSameSizeOnly = _wtoi( pmapExportedData->at( _T("dpcmvwithsamesizeonly") ) );
	}

	if( 0 != pmapExportedData->count( _T("projecttype") ) )
	{
		m_rTechParamData.m_eProjectType = ( ProjectType )_wtoi( pmapExportedData->at( _T("projecttype") ) );
	}

	if( 0 != pmapExportedData->count( _T("defaultprjcoolingdt") ) )
	{
		m_rTechParamData.m_dDefaultPrjCoolingDT = _ttof( pmapExportedData->at( _T("defaultprjcoolingdt") ) );
	}

	if( 0 != pmapExportedData->count( _T("defaultprjheatingdt") ) )
	{
		m_rTechParamData.m_dDefaultPrjHeatingDT = _ttof( pmapExportedData->at( _T("defaultprjheatingdt") ) );
	}

	if( 0 != pmapExportedData->count( _T("defaultcoolingtps") ) )
	{
		m_rTechParamData.m_dDefaultPrjCoolingTps = _ttof( pmapExportedData->at( _T("defaultcoolingtps") ) );
	}

	if( 0 != pmapExportedData->count( _T("defaultheatingtps") ) )
	{
		m_rTechParamData.m_dDefaultPrjHeatingTps = _ttof( pmapExportedData->at( _T("defaultheatingtps") ) );
	}

	if( 0 != pmapExportedData->count( _T("cvusedpcpband") ) )
	{
		m_rTechParamData.m_iCVUseDpCPBand = _wtoi( pmapExportedData->at( _T("cvusedpcpband") ) );
	}

	if( 0 != pmapExportedData->count( _T("applicationtype") ) )
	{
		m_rTechParamData.m_eProductSelectionApplicationType = (ProjectType)_wtoi( pmapExportedData->at( _T("applicationtype") ) );
	}

	// HYS-1022: Change the name of variable and methods to be synchronized with HyTools.
	// 0.2 bar margin over static height as per EN 12828-2014.
	if( 0 != pmapExportedData->count( _T("minpressuremargin") ) )
	{
		m_rTechParamData.m_dMinPressureMargin = _ttof( pmapExportedData->at( _T("minpressuremargin") ) );
	}

	if( 0 != pmapExportedData->count( _T("maxnumberofadditionalvesselsinparallel") ) )
	{
		m_rTechParamData.m_iMaxNumberOfAdditionalVesselsInParallel = _wtoi( pmapExportedData->at( _T("maxnumberofadditionalvesselsinparallel") ) );
	}

	if( 0 != pmapExportedData->count( _T("usevesselpressurevolumelimit") ) )
	{
		m_rTechParamData.m_fUseVesselPressureVolumeLimit = ( bool )( 0 == _wtoi( pmapExportedData->at( _T("usevesselpressurevolumelimit") ) ) ) ? false : true;
	}

	if( 0 != pmapExportedData->count( _T("pressurevolumelimit") ) )
	{
		m_rTechParamData.m_dPressureVolumeLimit = _ttof( pmapExportedData->at( _T("pressurevolumelimit") ) );
	}

	if( 0 != pmapExportedData->count( _T("canchangepressurevolumelimit") ) )
	{
		m_rTechParamData.m_bCanChangePressureVolumeLimit = ( bool )( 0 == _wtoi( pmapExportedData->at( _T("canchangepressurevolumelimit") ) ) ) ? false : true;
	}

	// HYS-1126.
	if( 0 != pmapExportedData->count( _T("usesimplypst") ) )
	{
		m_rTechParamData.m_bUseSimplyPst = ( bool )( 0 == _wtoi( pmapExportedData->at( _T("usesimplypst") ) ) ) ? false : true;
	}

	if( 0 != pmapExportedData->count( _T("psetupCompresso") ) )
	{
		m_rTechParamData.m_dPSetupCompresso = _ttof( pmapExportedData->at( _T("psetupCompresso") ) );
	}

	if( 0 != pmapExportedData->count( _T("psetupTransfero") ) )
	{
		m_rTechParamData.m_dPSetupTransfero = _ttof( pmapExportedData->at( _T("psetupTransfero") ) );
	}

	if( 0 != pmapExportedData->count( _T("defaultfilltemperature") ) )
	{
		m_rTechParamData.m_dDefaultFillTemperature = _ttof( pmapExportedData->at( _T("defaultfilltemperature") ) );
	}

	if( 0 != pmapExportedData->count( _T("usedefaultfreezingpointasmintemperature") ) )
	{
		m_rTechParamData.m_fUseDefaultFreezingPointAsMinTemperature = ( bool )( 0 == _wtoi( pmapExportedData->at( _T("usedefaultfreezingpointasmintemperature") ) ) )
				? false : true;
	}

	if( 0 != pmapExportedData->count( _T("defaultwatermakeuptemp") ) )
	{
		m_rTechParamData.m_dDefaultWaterMakeUpTemp = _ttof( pmapExportedData->at( _T("defaultwatermakeuptemp") ) );
	}

	if( 0 != pmapExportedData->count( _T("defaultmaxtempincooling") ) )
	{
		m_rTechParamData.m_dDefaultMaxTempInCooling = _ttof( pmapExportedData->at( _T("defaultmaxtempincooling") ) );
	}

	if( 0 != pmapExportedData->count( _T("defaultmintempinheating") ) )
	{
		m_rTechParamData.m_dDefaultMinTempInHeating = _ttof( pmapExportedData->at( _T("defaultmintempinheating") ) );
	}

	if( 0 != pmapExportedData->count( _T("defaultmintempinsolar") ) )
	{
		m_rTechParamData.m_dDefaultMinTempInSolar = _ttof( pmapExportedData->at( _T("defaultmintempinsolar") ) );
	}

	if( 0 != pmapExportedData->count( _T("defaultsafetypressureresponsevalve") ) )
	{
		m_rTechParamData.m_dDefaultSafetyPressureResponseValve = _ttof( pmapExportedData->at( _T("defaultsafetypressureresponsevalve") ) );
	}

	if( 0 != pmapExportedData->count( _T("defaulttaz") ) )
	{
		m_rTechParamData.m_dDefaultTAZ = _ttof( pmapExportedData->at( _T("defaulttaz") ) );
	}

	if( 0 != pmapExportedData->count( _T("defaultcalculationnorm") ) )
	{
		m_rTechParamData.m_sDefaultCalculationNorm = pmapExportedData->at( _T("defaultcalculationnorm") ).MakeUpper();
	}

	if( 0 != pmapExportedData->count( _T("breaktankrequiredforwatermakeup") ) )
	{
		m_rTechParamData.m_bBreakTankRequiredForWaterMakeUp = ( bool )( 0 == _wtoi( pmapExportedData->at( _T("breaktankrequiredforwatermakeup") ) ) ) ? false : true;
	}

	if( 0 != pmapExportedData->count( _T("defaultstaticpressureofwaternetwork") ) )
	{
		m_rTechParamData.m_dDefaultStaticPressureOfWaterNetwork = _ttof( pmapExportedData->at( _T("defaultstaticpressureofwaternetwork") ) );
	}

	if( 0 != pmapExportedData->count( _T("availablepmpanels") ) )
	{
		m_rTechParamData.m_iAvailablePMPanels = _wtoi( pmapExportedData->at( _T("availablepmpanels") ) );
	}

	if( 0 != pmapExportedData->count( _T("maxnumberofventoinparallel") ) )
	{
		m_rTechParamData.m_iMaxNumberOfVentoInParallel = _wtoi( pmapExportedData->at( _T("maxnumberofventoinparallel") ) );
	}

	if( 0 != pmapExportedData->count( _T("defaultwaterhardness") ) )
	{
		m_rTechParamData.m_dDefaultWaterHardness = _ttof( pmapExportedData->at( _T("defaultwaterhardness") ) );
	}

	if( 0 != pmapExportedData->count( _T("degassingwaterreserveforvessel") ) )
	{
		m_rTechParamData.m_dDegassingWaterReserveForVessel = _ttof( pmapExportedData->at( _T("degassingwaterreserveforvessel") ) );
	}

	if( 0 != pmapExportedData->count( _T("dpcbcvdpcmin") ) )
	{
		m_rTechParamData.m_dDpCBCVDpcmin = _ttof( pmapExportedData->at( _T("dpcbcvdpcmin") ) );
	}

	if( 0 != pmapExportedData->count( _T("dpcbcvdplmin") ) )
	{
		m_rTechParamData.m_dDpCBCVDplmin = _ttof( pmapExportedData->at( _T("dpcbcvdplmin") ) );
	}

	if( 0 != pmapExportedData->count( _T("vesselselectionrangepercentage") ) )
	{
		m_rTechParamData.m_dVesselSelectionRangePercentage = _ttof( pmapExportedData->at( _T("vesselselectionrangepercentage") ) );
	}

	if( 0 != pmapExportedData->count( _T("defaultprjcoolingadditid") ) )
	{
		m_rTechParamData.m_strDefaultPrjCoolingAdditID = pmapExportedData->at( _T("defaultprjcoolingadditid") ).MakeUpper();
	}

	if( 0 != pmapExportedData->count( _T("defaultprjheatingadditid") ) )
	{
		m_rTechParamData.m_strDefaultPrjHeatingAdditID = pmapExportedData->at( _T("defaultprjheatingadditid") ).MakeUpper();
	}

	if( 0 != pmapExportedData->count( _T("defaultprjcoolingpcweight") ) )
	{
		m_rTechParamData.m_dDefaultPrjCoolingPcWeight = _ttof( pmapExportedData->at( _T("defaultprjcoolingpcweight") ) );
	}

	if( 0 != pmapExportedData->count( _T("defaultprjheatingpcweight") ) )
	{
		m_rTechParamData.m_dDefaultPrjHeatingPcWeight = _ttof( pmapExportedData->at( _T("defaultprjheatingpcweight") ) );
	}

	if( 0 != pmapExportedData->count( _T("maxsafetyvalveinparallel") ) )
	{
		m_rTechParamData.m_iMaxSafetyValveInParallel = _wtoi( pmapExportedData->at( _T("maxsafetyvalveinparallel") ) );
	}

	// HYS-1022: 0.3 bar margin for initial pressure (EN 12828-2014).
	if( 0 != pmapExportedData->count( _T("initialpressuremargin") ) )
	{
		m_rTechParamData.m_dInitialPressureMargin = _ttof( pmapExportedData->at( _T("initialpressuremargin") ) );
	}

	// HYS-1104: safety temperature limiter limit from which we need to pass to the EN 12953 norm.
	if( 0 != pmapExportedData->count( _T("safetytemplimiterlimiten12953") ) )
	{
		m_rTechParamData.m_dSafetyTempLimiterLimitEN12953 = _ttof( pmapExportedData->at( _T("safetytemplimiterlimiten12953") ) );
	}
	
	// HYS-1104: supply/return temperature limit from which we need to pass to the EN 12953 norm.
	if( 0 != pmapExportedData->count( _T("fluidtemplimiten12953") ) )
	{
		m_rTechParamData.m_dFluidTempLimitEN12953 = _ttof( pmapExportedData->at( _T("fluidtemplimiten12953") ) );
	}

	// HYS-1151: The reference value used to determine the best 6-way valve at a flow given.
	if( 0 != pmapExportedData->count( _T("dprefforbest6way") ) )
	{
		m_rTechParamData.m_dDpRefForBest6Way = _ttof( pmapExportedData->at( _T("dprefforbest6way") ) );
	}

	// HYS-1230: Complete review of the water characteristic for product selection.
	// For heating.
	CWaterChar *pclWaterChar = GetDefaultISHeatingWC();
	ASSERT( NULL != pclWaterChar );

	_ImportTechParamsHelper( pmapExportedData, pclWaterChar, ProjectType::Heating );

	if( 0 != pmapExportedData->count( _T("defaultisheatingdt") ) )
	{
		SetDefaultISHeatingDT( _ttof( pmapExportedData->at( _T("defaultisheatingdt") ).MakeUpper() ) );
	}

	// For cooling.
	pclWaterChar = GetDefaultISCoolingWC();
	ASSERT( NULL != pclWaterChar );

	_ImportTechParamsHelper( pmapExportedData, pclWaterChar, ProjectType::Cooling );

	if( 0 != pmapExportedData->count( _T("defaultiscoolingdt") ) )
	{
		SetDefaultISCoolingDT( _ttof( pmapExportedData->at( _T("defaultiscoolingdt") ).MakeUpper() ) );
	}

	// For solar.
	pclWaterChar = GetDefaultISSolarWC();
	ASSERT( NULL != pclWaterChar );

	_ImportTechParamsHelper( pmapExportedData, pclWaterChar, ProjectType::Solar );

	if( 0 != pmapExportedData->count( _T("defaultissolardt") ) )
	{
		SetDefaultISSolarDT( _ttof( pmapExportedData->at( _T("defaultissolardt") ).MakeUpper() ) );
	}

	// For change-over for cooling side.
	pclWaterChar = GetDefaultISChangeOverWC( CoolingSide );
	ASSERT( NULL != pclWaterChar );

	_ImportTechParamsHelper( pmapExportedData, pclWaterChar, ProjectType::ChangeOver, CoolingSide );

	if( 0 != pmapExportedData->count( _T("defaultischangeovercoolingsidedt") ) )
	{
		SetDefaultISChangeOverDT( _ttof( pmapExportedData->at( _T("defaultischangeovercoolingsidedt") ).MakeUpper() ), CoolingSide );
	}

	// For change-over for heating side.
	pclWaterChar = GetDefaultISChangeOverWC( HeatingSide );
	ASSERT( NULL != pclWaterChar );

	_ImportTechParamsHelper( pmapExportedData, pclWaterChar, ProjectType::ChangeOver, HeatingSide );

	if( 0 != pmapExportedData->count( _T("defaultischangeoverheatingidedt") ) )
	{
		SetDefaultISChangeOverDT( _ttof( pmapExportedData->at( _T("defaultischangeoverheatingidedt") ).MakeUpper() ), HeatingSide );
	}

	// HYS-1763: Default smart control valve location
	if( 0 != pmapExportedData->count( _T("defaultsmartcvlocation") ) )
	{
		m_rTechParamData.m_iDefaultSmartCVLoc = _wtoi( pmapExportedData->at( _T("defaultsmartcvlocation") ) );
	}

	if( 0 != pmapExportedData->count( _T("smartvalvedpmaxforbestsuggestion") ) )
	{
		m_rTechParamData.m_dSmartValveDpMaxForBestSuggestion = _wtoi( pmapExportedData->at( _T( "smartvalvedpmaxforbestsuggestion" ) ) );
	}

	// Version 39: HYS-1930: New hydronic circuit: auto-adapting variable flow decoupling circuit: add default secondary pump Hmin.
	if( 0 != pmapExportedData->count( _T("defaultsecondarypumphmin") ) )
	{
		m_rTechParamData.m_dDefaultSecondaryPumpHMin = _wtoi( pmapExportedData->at( _T( "defaultsecondarypumphmin" ) ) );
	}
}
#endif

#define CDS_TECHNICALPARAMETER_VERSION	39
// Version 39: 2023-01-12: HYS-1930: New hydronic circuit: auto-adapting variable flow decoupling circuit: add default secondary pump Hmin.
// Version 38: 2022-09-05: HYS-1976: Add 'Dp max for "best" suggestion' in technical paramers for electronic balancing valve
// Version 37: 2021-08-24: HYS-1763: Add default smart control valve location
// Version 36: 2019-11-19: HYS-1230: Complete review of the way we use to save water characteristic for product selection.
// Version 35: 2019-10-11: HYS-1151: The reference value used to determine the best 6-way valve at a flow given.
// Version 34: 2019-07-17: HYS-1126: Use simplified calculation for pst checkbox
// Version 33: 2019-06-03: HYS-1104: safety temperature limiter and supply/return limits from which we need to pass to the EN 12953 norm.
// Version 32: 2019-02-18: HYS-1022: 'm_dInitialPressureMargin' added.
// Version 31: 2018-11-27: 'm_iMaxSafetyValveInParallel' added.
// Version 30: 2018-09-11: 'm_dDefaultISSolarTps', 'm_dDefaultISSolarDT', 'm_strDefaultISSolarAdditID' and 'm_dDefaultISSolarPcWeight' added.
// Version 29: 2018-08-16: 'm_dDegassingWaterReserveForVessel' added.
// Version 28: Additive and PC weight characteristics were inverted in the 'read' and 'write' methods.
// Version 27: Add additive characteristics
// Version 26: Add 'm_dVesselSelectionRangePercentage'
// Version 25: 2015-10-09: Add 'm_dDpCBCVDpcmin'.
// Version 24: 2015-08-28: Add 'm_dDefaultWaterHardness'.
// Version 23: Add 'm_iMaxNumberOfVentoInParallel'.
// Version 22:
// Version 21: Pressure maintenance variables added.
// Version 20: m_dDefaultCoolingISTps, m_dDefaultHeatingISTps added
// Version 19: ApplicationType, m_dDefaultISCoolingDT, m_dDefaultISHeatingDT added
// Version 18: CVUseDpCPBand added
// Version 16: No more need of 'ValvMinOpen' -> this value is found in the 'CDB_ValveCharacteristic' for each valve.
void CDS_TechnicalParameter::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_TECHNICALPARAMETER_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CData::Write( outf );

	// Info.
	WriteDouble( outf, m_rTechParamData.m_dValveMinDp );
	WriteDouble( outf, m_rTechParamData.m_dValveMin2Dp );
	WriteDouble( outf, m_rTechParamData.m_dValveMaxDp );
	WriteDouble( outf, m_rTechParamData.m_dFixedOrificeMinDp );
	WriteDouble( outf, m_rTechParamData.m_dFixedOrificeMaxDp );
	WriteDouble( outf, m_rTechParamData.m_dVenturiMinDp );
	WriteDouble( outf, m_rTechParamData.m_dVenturiMaxDp );
	WriteData<>( outf, m_rTechParamData.m_iSizeShiftAbove );
	WriteData<>( outf, m_rTechParamData.m_iSizeShiftBelow );
	WriteData<>( outf, m_rTechParamData.m_iMaxSizeShift );
	WriteDouble( outf, m_rTechParamData.m_dPipeMinDp );
	WriteDouble( outf, m_rTechParamData.m_dPipeMaxDp );
	WriteDouble( outf, m_rTechParamData.m_dPipeMinVelocity );
	WriteDouble( outf, m_rTechParamData.m_dPipeMaxVelocity );
	WriteDouble( outf, m_rTechParamData.m_dPipeTargetDp );
	WriteDouble( outf, m_rTechParamData.m_dPipeTargetVelocity );
	WriteData<>( outf, m_rTechParamData.m_iPipeTargetVelosityUsed );
	WriteDouble( outf, m_rTechParamData.m_dTrvMinDpRatio );
	WriteDouble( outf, m_rTechParamData.m_dTrvDefDpTotal );
	WriteDouble( outf, m_rTechParamData.m_dTrvDefRoomTemperature );
	WriteDouble( outf, m_rTechParamData.m_dTrvDefSupplyTemperature );
	WriteDouble( outf, m_rTechParamData.m_dTrvMaxDp );
	WriteDouble( outf, m_rTechParamData.m_dCVMinAuthor );
	WriteDouble( outf, m_rTechParamData.m_dCVMinAuthCstFlow );
	WriteDouble( outf, m_rTechParamData.m_dCVMinDpOnoff );
	WriteDouble( outf, m_rTechParamData.m_dCVMinDpProp );
	WriteData<>( outf, m_rTechParamData.m_iCVDefKvReynard );
	WriteDouble( outf, m_rTechParamData.m_dDpCMinDp );
	WriteData<>( outf, m_rTechParamData.m_iDpCHide );
	WriteData<>( outf, m_rTechParamData.m_iDpCMvLocation );
	WriteData<>( outf, m_rTechParamData.m_iDpCHminFullyOpenMv );
	WriteString( outf, (LPCTSTR)m_rTechParamData.m_strCurrencyID.c_str() );
	WriteString( outf, (LPCTSTR)m_rTechParamData.m_strDefaultPipeSerieID.c_str() );
	WriteDouble( outf, m_rTechParamData.m_dCVMaxDispDp );
	WriteDouble( outf, m_rTechParamData.m_dCVMaxDpProp );
	WriteDouble( outf, m_rTechParamData.m_dPICvMinDp );
	WriteData<>( outf, m_rTechParamData.m_iPICvHide );
	WriteDouble( outf, m_rTechParamData.m_dFlowDeviationPlus );
	WriteDouble( outf, m_rTechParamData.m_dFlowDeviationMinus );
	WriteData<>( outf, m_rTechParamData.m_iDpCMvWithSameSizeOnly );
	WriteData<>( outf, m_rTechParamData.m_eProjectType );
	WriteData<>( outf, m_rTechParamData.m_dDefaultPrjCoolingDT );
	WriteData<>( outf, m_rTechParamData.m_dDefaultPrjHeatingDT );
	WriteData<>( outf, m_rTechParamData.m_dDefaultPrjCoolingTps );
	WriteData<>( outf, m_rTechParamData.m_dDefaultPrjHeatingTps );
	WriteData<>( outf, m_rTechParamData.m_iCVUseDpCPBand );
	WriteData<>( outf, m_rTechParamData.m_eProductSelectionApplicationType );
	// HYS-1230: Now the water characteristics for product selection are written at the end.

	// Version 21.
	WriteDouble( outf, m_rTechParamData.m_dMinPressureMargin );
	WriteData<>( outf, m_rTechParamData.m_iMaxNumberOfAdditionalVesselsInParallel );
	WriteData<>( outf, m_rTechParamData.m_fUseVesselPressureVolumeLimit );
	WriteDouble( outf, m_rTechParamData.m_dPressureVolumeLimit );
	WriteData<>( outf, m_rTechParamData.m_bCanChangePressureVolumeLimit );
	WriteDouble( outf, m_rTechParamData.m_dPSetupCompresso );
	WriteDouble( outf, m_rTechParamData.m_dPSetupTransfero );
	WriteDouble( outf, m_rTechParamData.m_dDefaultFillTemperature );
	WriteData<>( outf, m_rTechParamData.m_fUseDefaultFreezingPointAsMinTemperature );

	WriteDouble( outf, m_rTechParamData.m_dDefaultWaterMakeUpTemp );
	WriteDouble( outf, m_rTechParamData.m_dDefaultMaxTempInCooling );
	WriteDouble( outf, m_rTechParamData.m_dDefaultMinTempInHeating );
	WriteDouble( outf, m_rTechParamData.m_dDefaultMinTempInSolar );
	WriteDouble( outf, m_rTechParamData.m_dDefaultSafetyPressureResponseValve );
	WriteDouble( outf, m_rTechParamData.m_dDefaultTAZ );
	WriteString( outf, m_rTechParamData.m_sDefaultCalculationNorm.c_str() );
	WriteData<>( outf, m_rTechParamData.m_bBreakTankRequiredForWaterMakeUp );
	WriteDouble( outf, m_rTechParamData.m_dDefaultStaticPressureOfWaterNetwork );
	WriteData<>( outf, m_rTechParamData.m_iAvailablePMPanels );

	// Version 23.
	WriteData<>( outf, m_rTechParamData.m_iMaxNumberOfVentoInParallel );

	// Version 24.
	WriteData<>( outf, m_rTechParamData.m_dDefaultWaterHardness );

	// Version 25.
	WriteData<>( outf, m_rTechParamData.m_dDpCBCVDpcmin );

	// Version 26.
	WriteData<>( outf, m_rTechParamData.m_dVesselSelectionRangePercentage );

	// Version 27.
	WriteString( outf, m_rTechParamData.m_strDefaultPrjCoolingAdditID.c_str() );
	WriteString( outf, m_rTechParamData.m_strDefaultPrjHeatingAdditID.c_str() );
	WriteDouble( outf, m_rTechParamData.m_dDefaultPrjCoolingPcWeight );
	WriteDouble( outf, m_rTechParamData.m_dDefaultPrjHeatingPcWeight );
	// HYS-1230: Now the water characteristics for product selection are written at the end.

	// Version 29.
	WriteDouble( outf, m_rTechParamData.m_dDegassingWaterReserveForVessel );

	// Version 30.
	// HYS-1230: Now the water characteristics for product selection are written at the end.

	// Version 31.
	WriteData<>( outf, m_rTechParamData.m_iMaxSafetyValveInParallel );
	WriteData<>( outf, m_rTechParamData.m_dDpCBCVDplmin );

	// Version 32. HYS-1022: 0.3 bar margin for initial pressure (EN 12828-2014).
	WriteData<>( outf, m_rTechParamData.m_dInitialPressureMargin );

	// Version 33: HYS-1104: safety temperature limiter limit from which we need to pass to the EN 12953 norm.
	WriteData<>( outf, m_rTechParamData.m_dSafetyTempLimiterLimitEN12953 );
	
	// Version 33: HYS-1104: supply/return temperature limit from which we need to pass to the EN 12953 norm.
	WriteData<>( outf, m_rTechParamData.m_dFluidTempLimitEN12953 );

	// Version 34: HYS-1126: Simplify static pressure calculation.
	WriteData<>( outf, m_rTechParamData.m_bUseSimplyPst );

	// Version 35: HYS-1151: The reference value used to determine the best 6-way valve at a flow given.
	WriteData<>( outf, m_rTechParamData.m_dDpRefForBest6Way );

	// Version 36: HYS-1230: Write the water characteristics for product selection.
	// PS: no 'auto' C++11 syntax for iteration because this code is common with the TA-Scope that uses an old g++ version.
	for( std::map<ProjectType, CWaterChar>::iterator iter = m_rTechParamData.m_mapPSDefaultWaterCharByProject.begin(); iter != m_rTechParamData.m_mapPSDefaultWaterCharByProject.end(); iter++ )
	{
		iter->second.Write( outf );
	}

	for( std::multimap<ProjectType, double>::iterator iter = m_rTechParamData.m_mmapPSDefaultDTByProject.begin(); iter != m_rTechParamData.m_mmapPSDefaultDTByProject.end(); iter++ )
	{
		WriteData<>( outf, iter->second );
	}

	// Version 37: HYS-1763: Write the default smart control valve location.
	WriteData<>( outf, m_rTechParamData.m_iDefaultSmartCVLoc );

	// Version 38: HYS-1976: Write the Dp max for "best" suggestion for smart valve.
	WriteData<>( outf, m_rTechParamData.m_dSmartValveDpMaxForBestSuggestion );

	// Version 39: HYS-1930: New hydronic circuit: auto-adapting variable flow decoupling circuit: add default secondary pump Hmin.
	WriteData<>( outf, m_rTechParamData.m_dDefaultSecondaryPumpHMin );
}

bool CDS_TechnicalParameter::Read( INPSTREAM inpf )
{
	// Version.
	m_rTechParamData.m_bVersion = CDS_TECHNICALPARAMETER_VERSION;
	inpf.read( (char *)&m_rTechParamData.m_bVersion, sizeof( m_rTechParamData.m_bVersion ) );

	if( m_rTechParamData.m_bVersion < 1 || m_rTechParamData.m_bVersion > CDS_TECHNICALPARAMETER_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Info.
	m_rTechParamData.m_dValveMinDp = ReadDouble( inpf );

	if( m_rTechParamData.m_bVersion >= 5 )
	{
		m_rTechParamData.m_dValveMin2Dp = ReadDouble( inpf );
	}

	m_rTechParamData.m_dValveMaxDp = ReadDouble( inpf );

	if( m_rTechParamData.m_bVersion < 16 )
	{
		// Before version 16 'ValvMinOpen' was written here.
		ReadDouble( inpf );
	}

	m_rTechParamData.m_dFixedOrificeMinDp = ReadDouble( inpf );
	m_rTechParamData.m_dFixedOrificeMaxDp = ReadDouble( inpf );

	if( m_rTechParamData.m_bVersion >= 4 )
	{
		m_rTechParamData.m_dVenturiMinDp = ReadDouble( inpf );
		m_rTechParamData.m_dVenturiMaxDp = ReadDouble( inpf );
	}

	if( m_rTechParamData.m_bVersion >= 2 )
	{
		inpf.read( (char *)&m_rTechParamData.m_iSizeShiftAbove, sizeof( m_rTechParamData.m_iSizeShiftAbove ) );
	}

	inpf.read( (char *)&m_rTechParamData.m_iSizeShiftBelow, sizeof( m_rTechParamData.m_iSizeShiftBelow ) );

	if( m_rTechParamData.m_bVersion >= 11 )
	{
		inpf.read( (char *)&m_rTechParamData.m_iMaxSizeShift, sizeof( m_rTechParamData.m_iMaxSizeShift ) );
	}

	m_rTechParamData.m_dPipeMinDp = ReadDouble( inpf );
	m_rTechParamData.m_dPipeMaxDp = ReadDouble( inpf );
	m_rTechParamData.m_dPipeMinVelocity = ReadDouble( inpf );
	m_rTechParamData.m_dPipeMaxVelocity = ReadDouble( inpf );

	if( m_rTechParamData.m_bVersion >= 5 )
	{
		m_rTechParamData.m_dPipeTargetDp = ReadDouble( inpf );
		m_rTechParamData.m_dPipeTargetVelocity = ReadDouble( inpf );
		inpf.read( (char *)&m_rTechParamData.m_iPipeTargetVelosityUsed, sizeof( m_rTechParamData.m_iPipeTargetVelosityUsed ) );
	}
	else // for backward tsp file compatibility
	{
		m_rTechParamData.m_dPipeTargetDp = ( m_rTechParamData.m_dPipeMinDp + m_rTechParamData.m_dPipeMaxDp ) / 2.0;	// Compute Targ as average of Min and Max
		m_rTechParamData.m_dPipeTargetVelocity = ( m_rTechParamData.m_dPipeMinVelocity + m_rTechParamData.m_dPipeMaxVelocity ) / 2.0;
	}

	m_rTechParamData.m_dTrvMinDpRatio = ReadDouble( inpf );
	m_rTechParamData.m_dTrvDefDpTotal = ReadDouble( inpf );
	m_rTechParamData.m_dTrvDefRoomTemperature = ReadDouble( inpf );
	m_rTechParamData.m_dTrvDefSupplyTemperature = ReadDouble( inpf );
	m_rTechParamData.m_dTrvMaxDp = ReadDouble( inpf );
	m_rTechParamData.m_dCVMinAuthor = ReadDouble( inpf );

	if( m_rTechParamData.m_bVersion >= 17 )
	{
		m_rTechParamData.m_dCVMinAuthCstFlow = ReadDouble( inpf );
	}

	if( m_rTechParamData.m_bVersion >= 4 )
	{
		m_rTechParamData.m_dCVMinDpOnoff = ReadDouble( inpf );
		m_rTechParamData.m_dCVMinDpProp = ReadDouble( inpf );
		inpf.read( (char *)&m_rTechParamData.m_iCVDefKvReynard, sizeof( m_rTechParamData.m_iCVDefKvReynard ) );
	}

	if( m_rTechParamData.m_bVersion >= 2 )
	{
		m_rTechParamData.m_dDpCMinDp = ReadDouble( inpf );
		inpf.read( (char *)&m_rTechParamData.m_iDpCHide, sizeof( m_rTechParamData.m_iDpCHide ) );
	}

	if( m_rTechParamData.m_bVersion >= 3 )
	{
		inpf.read( (char *)&m_rTechParamData.m_iDpCMvLocation, sizeof( m_rTechParamData.m_iDpCMvLocation ) );
	}

	inpf.read( (char *)&m_rTechParamData.m_iDpCHminFullyOpenMv, sizeof( m_rTechParamData.m_iDpCHminFullyOpenMv ) );

	if( m_rTechParamData.m_bVersion >= 6 )
	{
		if( false == ReadString( inpf, m_rTechParamData.m_strCurrencyID ) )
		{
			return false;
		}
	}

#ifndef TACBX
	CDS_TechnicalParameter *pTADBTech = static_cast<CDS_TechnicalParameter *>( GetpTADB()->Get( _T("PARAM_TECH") ).MP );
	m_rTechParamData.m_strDefaultPipeSerieID = pTADBTech->GetDefaultPipeSerieID();
#endif

	if( m_rTechParamData.m_bVersion >= 7 )
	{
		if( false == ReadString( inpf, m_rTechParamData.m_strDefaultPipeSerieID ) )
		{
			return false;
		}
	}

	if( m_rTechParamData.m_bVersion >= 8 )
	{
		m_rTechParamData.m_dCVMaxDispDp = ReadDouble( inpf );
	}

	if( m_rTechParamData.m_bVersion >= 9 )
	{
		m_rTechParamData.m_dCVMaxDpProp = ReadDouble( inpf );
	}

	if( m_rTechParamData.m_bVersion >= 10 )											// Version 10 and above
	{
		m_rTechParamData.m_dPICvMinDp = ReadDouble( inpf );
		inpf.read( (char *)&m_rTechParamData.m_iPICvHide, sizeof( m_rTechParamData.m_iPICvHide ) );
	}

	if( m_rTechParamData.m_bVersion >= 12 )											// Version 11 and above
	{
		m_rTechParamData.m_dFlowDeviationPlus = ReadDouble( inpf );
		m_rTechParamData.m_dFlowDeviationMinus = ReadDouble( inpf );
	}

	if( m_rTechParamData.m_bVersion >= 13 )
	{
		inpf.read( (char *)&m_rTechParamData.m_iDpCMvWithSameSizeOnly, sizeof( m_rTechParamData.m_iDpCMvWithSameSizeOnly ) );
	}

	if( m_rTechParamData.m_bVersion >= 14 )
	{
		int i;
		inpf.read( (char *)&i, sizeof( int ) );

		if( m_rTechParamData.m_bVersion < 22 )
		{
			if( 0 == i )
			{
				m_rTechParamData.m_eProjectType = Heating;
			}

			if( 1 == i )
			{
				m_rTechParamData.m_eProjectType = Cooling;
			}

			if( 2 == i )
			{
				m_rTechParamData.m_eProjectType = Solar;
			}
		}
		else
		{
			m_rTechParamData.m_eProjectType = ( ProjectType )i;
		}
	}

	if( m_rTechParamData.m_bVersion >= 15 )
	{
		inpf.read( (char *)&m_rTechParamData.m_dDefaultPrjCoolingDT, sizeof( m_rTechParamData.m_dDefaultPrjCoolingDT ) );
		inpf.read( (char *)&m_rTechParamData.m_dDefaultPrjHeatingDT, sizeof( m_rTechParamData.m_dDefaultPrjHeatingDT ) );
		inpf.read( (char *)&m_rTechParamData.m_dDefaultPrjCoolingTps, sizeof( m_rTechParamData.m_dDefaultPrjCoolingTps ) );
		inpf.read( (char *)&m_rTechParamData.m_dDefaultPrjHeatingTps, sizeof( m_rTechParamData.m_dDefaultPrjHeatingTps ) );
	}

	if( m_rTechParamData.m_bVersion >= 18 )
	{
		inpf.read( (char *)&m_rTechParamData.m_iCVUseDpCPBand, sizeof( m_rTechParamData.m_iCVUseDpCPBand ) );
	}

	if( m_rTechParamData.m_bVersion >= 19 )
	{
		int i;
		inpf.read( (char *)&i, sizeof( i ) );

		if( m_rTechParamData.m_bVersion < 22 )
		{
			if( 0 == i )
			{
				m_rTechParamData.m_eProductSelectionApplicationType = Heating;
			}

			if( 1 == i )
			{
				m_rTechParamData.m_eProductSelectionApplicationType = Cooling;
			}

			if( 2 == i )
			{
				m_rTechParamData.m_eProductSelectionApplicationType = Solar;
			}
		}
		else
		{
			m_rTechParamData.m_eProductSelectionApplicationType = ( ProjectType )i;
		}

		// HYS-1230: From version 36, these info are read at the end.
		if( m_rTechParamData.m_bVersion < 36 )
		{
			double dDT;
			inpf.read( (char *)&dDT, sizeof( dDT ) );
			SetDefaultISCoolingDT( dDT );

			inpf.read( (char *)&dDT, sizeof( dDT ) );
			SetDefaultISHeatingDT( dDT );
		}
	}

	// HYS-1230: From version 36, these info are read at the end.
	if( m_rTechParamData.m_bVersion >= 20 && m_rTechParamData.m_bVersion < 36 )
	{
		double dDT = ReadDouble( inpf );
		SetDefaultISCoolingTps( dDT );

		dDT = ReadDouble( inpf );
		SetDefaultISHeatingTps( dDT );
	}

	if( m_rTechParamData.m_bVersion >= 21 )
	{
		m_rTechParamData.m_dMinPressureMargin = ReadDouble( inpf );
		inpf.read( (char *)&m_rTechParamData.m_iMaxNumberOfAdditionalVesselsInParallel, sizeof( m_rTechParamData.m_iMaxNumberOfAdditionalVesselsInParallel ) );
		inpf.read( (char *)&m_rTechParamData.m_fUseVesselPressureVolumeLimit, sizeof( m_rTechParamData.m_fUseVesselPressureVolumeLimit ) );
		m_rTechParamData.m_dPressureVolumeLimit = ReadDouble( inpf );
		inpf.read( (char *)&m_rTechParamData.m_bCanChangePressureVolumeLimit, sizeof( m_rTechParamData.m_bCanChangePressureVolumeLimit ) );
		m_rTechParamData.m_dPSetupCompresso = ReadDouble( inpf );
		m_rTechParamData.m_dPSetupTransfero = ReadDouble( inpf );
		m_rTechParamData.m_dDefaultFillTemperature = ReadDouble( inpf );
		inpf.read( (char *)&m_rTechParamData.m_fUseDefaultFreezingPointAsMinTemperature, sizeof( m_rTechParamData.m_fUseDefaultFreezingPointAsMinTemperature ) );
	}

	if( m_rTechParamData.m_bVersion >= 22 )
	{
		m_rTechParamData.m_dDefaultWaterMakeUpTemp = ReadDouble( inpf );
		m_rTechParamData.m_dDefaultMaxTempInCooling = ReadDouble( inpf );
		m_rTechParamData.m_dDefaultMinTempInHeating = ReadDouble( inpf );
		m_rTechParamData.m_dDefaultMinTempInSolar = ReadDouble( inpf );
		m_rTechParamData.m_dDefaultSafetyPressureResponseValve = ReadDouble( inpf );
		m_rTechParamData.m_dDefaultTAZ = ReadDouble( inpf );

		if( false == ReadString( inpf, m_rTechParamData.m_sDefaultCalculationNorm ) )
		{
			return false;
		}

		inpf.read( (char *)&m_rTechParamData.m_bBreakTankRequiredForWaterMakeUp, sizeof( m_rTechParamData.m_bBreakTankRequiredForWaterMakeUp ) );
		m_rTechParamData.m_dDefaultStaticPressureOfWaterNetwork = ReadDouble( inpf );
		inpf.read( (char *)&m_rTechParamData.m_iAvailablePMPanels, sizeof( m_rTechParamData.m_iAvailablePMPanels ) );
	}

	if( m_rTechParamData.m_bVersion >= 23 )
	{
		inpf.read( (char *)&m_rTechParamData.m_iMaxNumberOfVentoInParallel, sizeof( m_rTechParamData.m_iMaxNumberOfVentoInParallel ) );
	}

	if( m_rTechParamData.m_bVersion >= 24 )
	{
		inpf.read( (char *)&m_rTechParamData.m_dDefaultWaterHardness, sizeof( m_rTechParamData.m_dDefaultWaterHardness ) );
	}

	if( m_rTechParamData.m_bVersion >= 25 )
	{
		inpf.read( (char *)&m_rTechParamData.m_dDpCBCVDpcmin, sizeof( m_rTechParamData.m_dDpCBCVDpcmin ) );
	}

	if( m_rTechParamData.m_bVersion >= 26 )
	{
		inpf.read( (char *)&m_rTechParamData.m_dVesselSelectionRangePercentage, sizeof( m_rTechParamData.m_dVesselSelectionRangePercentage ) );
	}

	if( 27 == m_rTechParamData.m_bVersion )
	{
		// In version 27, characteristics was written in this order: project cooling & heating AdditID, project c./h. PC weight (A)
		// Individual selection c./h. AdditID and IS c./h. PC weight (B).
		// BUT in the 'read' method, it was: IS c./h. (B) followed by Project c./h. (A).
		// Summary: Write: (A) - (B)
		//          Read : (B) - (A)
		// When user saved his project, the 'write' method thus wrote (B) - (A).
		// When user opened again his project, the 'read' method read inverted and then (A) - (B).
		// We don't have thus any idea in which order are the current status in the .prj file.
		// The only thing we can do is to read as before event if it will eventually not good.
		
		// HYS-1230: From version 36, these info are read at the end.
		std::wstring strString;
			
		if( false == ReadString( inpf, strString ) )
		{
			return false;
		}

		SetDefaultISCoolingAdditID( strString );

		if( false == ReadString( inpf, strString ) )
		{
			return false;
		}

		SetDefaultISHeatingAdditID( strString );

		double dPcWeight = ReadDouble( inpf );
		SetDefaultISCoolingPcWeight( dPcWeight );

		dPcWeight = ReadDouble( inpf );
		SetDefaultISHeatingPcWeight( dPcWeight );

		if( false == ReadString( inpf, m_rTechParamData.m_strDefaultPrjCoolingAdditID ) )
		{
			return false;
		}

		if( false == ReadString( inpf, m_rTechParamData.m_strDefaultPrjHeatingAdditID ) )
		{
			return false;
		}

		m_rTechParamData.m_dDefaultPrjCoolingPcWeight = ReadDouble( inpf );
		m_rTechParamData.m_dDefaultPrjHeatingPcWeight = ReadDouble( inpf );
	}

	if( m_rTechParamData.m_bVersion < 28 )
	{
		return true;
	}

	if( false == ReadString( inpf, m_rTechParamData.m_strDefaultPrjCoolingAdditID ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_rTechParamData.m_strDefaultPrjHeatingAdditID ) )
	{
		return false;
	}

	m_rTechParamData.m_dDefaultPrjCoolingPcWeight = ReadDouble( inpf );
	m_rTechParamData.m_dDefaultPrjHeatingPcWeight = ReadDouble( inpf );

	// HYS-1230: From version 36, these info are read at the end.
	if( m_rTechParamData.m_bVersion < 36 )
	{
		std::wstring strString;
			
		if( false == ReadString( inpf, strString ) )
		{
			return false;
		}

		SetDefaultISCoolingAdditID( strString );

		if( false == ReadString( inpf, strString ) )
		{
			return false;
		}

		SetDefaultISHeatingAdditID( strString );

		double dPcWeight = ReadDouble( inpf );
		SetDefaultISCoolingPcWeight( dPcWeight );

		dPcWeight = ReadDouble( inpf );
		SetDefaultISHeatingPcWeight( dPcWeight );
	}

	if( m_rTechParamData.m_bVersion < 29 )
	{
		return true;
	}

	// Version 29.
	m_rTechParamData.m_dDegassingWaterReserveForVessel = ReadDouble( inpf );

	if( m_rTechParamData.m_bVersion < 30 )
	{
		return true;
	}

	// Version 30.
	// HYS-1230: From version 36, these info are read at the end.
	if( m_rTechParamData.m_bVersion < 36 )
	{
		double dTps = ReadDouble( inpf );
		SetDefaultISSolarTps( dTps );

		double dDT;
		inpf.read( (char *)&dDT, sizeof( dDT ) );
		SetDefaultISSolarDT( dDT );

		std::wstring strString;

		if( false == ReadString( inpf, strString ) )
		{
			return false;
		}

		SetDefaultISSolarAdditID( strString );

		double dPcWeight = ReadDouble( inpf );
		SetDefaultISSolarPcWeight( dPcWeight );
	}

	if( m_rTechParamData.m_bVersion < 31 )
	{
		return true;
	}

	inpf.read( (char *)&m_rTechParamData.m_iMaxSafetyValveInParallel, sizeof( m_rTechParamData.m_iMaxSafetyValveInParallel ) );
	inpf.read( (char *)&m_rTechParamData.m_dDpCBCVDplmin, sizeof( m_rTechParamData.m_dDpCBCVDplmin ) );

	if( m_rTechParamData.m_bVersion < 32 )
	{
		return true;
	}

	// Version 32. HYS-1022: 0.3 bar margin for initial pressure (EN 12828-2014).
	inpf.read( (char *)&m_rTechParamData.m_dInitialPressureMargin, sizeof( m_rTechParamData.m_dInitialPressureMargin ) );

	if( m_rTechParamData.m_bVersion < 33 )
	{
		return true;
	}

	// Version 33: HYS-1104: safety temperature limiter limit from which we need to pass to the EN 12953 norm.
	inpf.read( (char *)&m_rTechParamData.m_dSafetyTempLimiterLimitEN12953, sizeof( m_rTechParamData.m_dSafetyTempLimiterLimitEN12953 ) );
	
	// Version 33: HYS-1104: supply/return temperature limit from which we need to pass to the EN 12953 norm.
	inpf.read( (char *)&m_rTechParamData.m_dFluidTempLimitEN12953, sizeof( m_rTechParamData.m_dFluidTempLimitEN12953 ) );

	if( m_rTechParamData.m_bVersion < 34 )
	{
		return true;
	}

	// Version 34: HYS-1126: Simplify the static pressure calculation
	inpf.read( (char*)&m_rTechParamData.m_bUseSimplyPst, sizeof( m_rTechParamData.m_bUseSimplyPst ) );
	
	if( m_rTechParamData.m_bVersion < 35 )
	{
		return true;
	}

	// Version 35: HYS-1151: The reference value used to determine the best 6-way valve at a flow given.
	inpf.read( (char*)&m_rTechParamData.m_dDpRefForBest6Way, sizeof( m_rTechParamData.m_dDpRefForBest6Way ) );

	if( m_rTechParamData.m_bVersion < 36 )
	{
		return true;
	}

	// HYS-1230: Complete review of the getter/setter for water characteristic for product selection.
	for( std::map<ProjectType, CWaterChar>::iterator iter = m_rTechParamData.m_mapPSDefaultWaterCharByProject.begin(); iter != m_rTechParamData.m_mapPSDefaultWaterCharByProject.end(); iter++ )
	{
		iter->second.Read( inpf );
	}

	for( std::multimap<ProjectType, double>::iterator iter = m_rTechParamData.m_mmapPSDefaultDTByProject.begin(); iter != m_rTechParamData.m_mmapPSDefaultDTByProject.end(); iter++ )
	{
		inpf.read( (char*)&iter->second, sizeof( iter->second ) );
	}

	// HYS-1763: Read default smart control valve location
	if( m_rTechParamData.m_bVersion < 37 )
	{
		return true;
	}

	inpf.read( (char*)&m_rTechParamData.m_iDefaultSmartCVLoc, sizeof( m_rTechParamData.m_iDefaultSmartCVLoc ) );

	if( m_rTechParamData.m_bVersion < 38 )
	{
		return true;
	}

	// Version 38: HYS-1976: Read the Dp max for "best" suggestion for smart valve.
	inpf.read( (char*)&m_rTechParamData.m_dSmartValveDpMaxForBestSuggestion, sizeof( m_rTechParamData.m_dSmartValveDpMaxForBestSuggestion ) );

	if( m_rTechParamData.m_bVersion < 39 )
	{
		return true;
	}

	// Version 39: HYS-1930: New hydronic circuit: auto-adapting variable flow decoupling circuit: add default secondary pump Hmin.
	inpf.read( (char*)&m_rTechParamData.m_dDefaultSecondaryPumpHMin, sizeof( m_rTechParamData.m_dDefaultSecondaryPumpHMin ) );
	
	return true;
}

#ifndef TACBX
void CDS_TechnicalParameter::ReadText( INPSTREAM  inpf, unsigned short *pusLineCount )
{
	try
	{
		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Read base.
		CData::ReadText( inpf, pusLineCount );

		ptcLine = ReadTextLine( inpf, pusLineCount );

		TCHAR *ptcEndPtr;
		m_rTechParamData.m_dValveMinDp = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert valve minimum pressure drop value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dValveMin2Dp = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert valve minimum doubled pressure drop value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dValveMaxDp = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert valve maximum pressure drop value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dFixedOrificeMinDp = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert fixed orifice valve minimum pressure drop value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dFixedOrificeMaxDp = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert fixed orifice valve maximum pressure drop value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dVenturiMinDp = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert venturi valve minimum pressure drop value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dVenturiMaxDp = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert venturi valve maximum pressure drop value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_iSizeShiftAbove = ( int )_tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert size shift above value (%s) in int (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_iSizeShiftBelow = ( int )_tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert size shift below value (%s) in int (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_iMaxSizeShift = ( int )_tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert maximum size shift value (%s) in int (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dPipeMinDp = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert pip minimum pressure drop value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dPipeMaxDp = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert pipe maximum pressure drop value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dPipeMinVelocity = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert pipe minimum velocity value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dPipeMaxVelocity = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert pipe maximum velocity value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dPipeTargetDp = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert pipe target pressure drop value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dPipeTargetVelocity = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert pipe target velocity value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_iPipeTargetVelosityUsed = ( int )_tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert pipe target velocity used value (%s) in int (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dTrvMinDpRatio = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert Trv minimum pressure drop ratio value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dTrvDefDpTotal = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert Trv default pressure drop total value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dTrvDefRoomTemperature = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert Trv default room temperature value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dTrvDefSupplyTemperature = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert Trv default supply temperature value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dTrvMaxDp = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert Trv maximum pressure drop value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dCVMinAuthor = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert control valve minimum authority value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dCVMinAuthCstFlow = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert control valve minimum authority value at constant flow (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dCVMinDpOnoff = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert conntrol valve minimum pressure drop value for On/Off control (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dCVMinDpProp = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert conntrol valve minimum pressure drop value for proportionnal control (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dCVMaxDpProp = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert control valve maximum pressure drop value for proportionnal control (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dCVMaxDispDp = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert control valve maximum pressure drop value to display (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_iCVDefKvReynard = ( int )_tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert control valve default Kv use Reynard series value (%s) in int (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dPICvMinDp = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert PIBCV minimum pressure drop value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_iPICvHide = ( int )_tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert PIBCV to hide value (%s) in int (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dDpCMinDp = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert Dp controller minimum pressure drop value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_iDpCHide = ( int )_tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert Dp controller to hide value (%s) in int (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_iDpCMvLocation = ( int )_tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert Dp controller - measuring valve location value (%s) in int (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_iDpCHminFullyOpenMv = ( int )_tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert Dp controller - Hmin computed with measuring valve full opened value (%s) in int (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		int iProjectType = ( int )_tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert HM calc project type value (%s) in int (pos: %i)."), ptcLine, *pusLineCount );
		}

		if( ProjectType::Heating != iProjectType && ProjectType::Cooling != iProjectType && ProjectType::Solar != iProjectType && ProjectType::ChangeOver != iProjectType )
		{
			iProjectType = ProjectType::Heating;
		}

		m_rTechParamData.m_eProjectType = ( ProjectType )iProjectType;

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dDefaultPrjCoolingTps = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert default HM calc supply temperature value for cooling mode (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dDefaultPrjHeatingTps = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert default HM calc supply temperature value for heating mode (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dDefaultPrjCoolingDT = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert default HM calc DT value for cooling mode (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dDefaultPrjHeatingDT = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert default HM calc DT value for heating mode (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		// HYS-1230: All information regarding water characteristic for product selection are now read at the end.

		ptcLine = ReadTextLine( inpf, pusLineCount );
		int iLength = _tcslen( ptcLine );

		if( _T('"') != *ptcLine )
		{
			HYSELECT_THROW( _T("Currency ID (%s) variable must start with \" (pos: %i)."), ptcLine, *pusLineCount );
		}
		else if( _T('"') != ptcLine[iLength - 1] )
		{
			HYSELECT_THROW( _T("Currency ID (%s) variable must end with \" (pos: %i)."), ptcLine, *pusLineCount );
		}
		else if( _tcslen( ptcLine ) > _ID_LENGTH + 2 )
		{
			HYSELECT_THROW( _T("Currency ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), ( _ID_LENGTH + 2 ), *pusLineCount );
		}

		ptcLine[iLength - 1] = _T('\0');
		m_rTechParamData.m_strCurrencyID = ptcLine + 1;

		ptcLine = ReadTextLine( inpf, pusLineCount );
		iLength = _tcslen( ptcLine );

		if( _T('"') != *ptcLine )
		{
			HYSELECT_THROW( _T("Default pipe series ID (%s) variable must start with \" (pos: %i)."), ptcLine, *pusLineCount );
		}
		else if( _T('"') != ptcLine[iLength - 1] )
		{
			HYSELECT_THROW( _T("Default pipe series ID (%s) variable must end with \" (pos: %i)."), ptcLine, *pusLineCount );
		}
		else if( _tcslen( ptcLine ) > _ID_LENGTH + 2 )
		{
			HYSELECT_THROW( _T("Default pipe series ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), ( _ID_LENGTH + 2 ), *pusLineCount );
		}
	
		ptcLine[iLength - 1] = _T('\0');
		m_rTechParamData.m_strDefaultPipeSerieID = ptcLine + 1;

		// Version 21.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dMinPressureMargin = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert minimum pressure margin value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_iMaxNumberOfAdditionalVesselsInParallel = ( int )_tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert maximum number of value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );

		// To avoid compilation warning.
		int iValue = ( int )_tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert use pressure.volume limit value (%s) in int (pos: %i)."), ptcLine, *pusLineCount );
		}
	
		m_rTechParamData.m_fUseVesselPressureVolumeLimit = ( 0 == iValue ) ? false : true;

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dPressureVolumeLimit = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert presure.volume limit value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );

		// To avoid compilation warning.
		iValue = ( int )_tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert 'Can change the pressure.volume limit' value (%s) in int (pos: %i)."), ptcLine, *pusLineCount );
		}
	
		m_rTechParamData.m_bCanChangePressureVolumeLimit = ( 0 == iValue ) ? false : true;

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dPSetupCompresso = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert pressure setup of Compresso value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dPSetupTransfero = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert pressure setup of Transfero value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dDefaultFillTemperature = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert default fill temperature value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );

		// To avoid compilation warning.
		iValue = ( int )_tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert 'Use default freezing point as minimum temperature' value (%s) in int (pos: %i)."), ptcLine, *pusLineCount );
		}
	
		m_rTechParamData.m_fUseDefaultFreezingPointAsMinTemperature = ( 0 == iValue ) ? false : true;

		ReadDoubleFromTextLine( inpf, m_rTechParamData.m_dDefaultWaterMakeUpTemp, pusLineCount );
		ReadDoubleFromTextLine( inpf, m_rTechParamData.m_dDefaultMaxTempInCooling, pusLineCount );
		ReadDoubleFromTextLine( inpf, m_rTechParamData.m_dDefaultMinTempInHeating, pusLineCount );
		ReadDoubleFromTextLine( inpf, m_rTechParamData.m_dDefaultMinTempInSolar, pusLineCount );
		ReadDoubleFromTextLine( inpf, m_rTechParamData.m_dDefaultSafetyPressureResponseValve, pusLineCount );
		ReadDoubleFromTextLine( inpf, m_rTechParamData.m_dDefaultTAZ, pusLineCount );

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_sDefaultCalculationNorm = ptcLine;

		if( _tcslen( ptcLine ) > _ID_LENGTH )
		{
			HYSELECT_THROW( _T("Default calculation norm ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
		}

		if( NULL == GetpTADB()->Get( m_rTechParamData.m_sDefaultCalculationNorm.c_str() ).MP )
		{
			HYSELECT_THROW( _T("Default calculation norm ID (%s) is defined but not found in the database (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
	
		// To avoid compilation warning.
		iValue = ( int )_tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert break tank required value for water make-up (%s) in int (pos: %i)."), ptcLine, *pusLineCount );
		}
	
		m_rTechParamData.m_bBreakTankRequiredForWaterMakeUp = ( 0 == iValue ) ? false : true;

		ReadDoubleFromTextLine( inpf, m_rTechParamData.m_dDefaultStaticPressureOfWaterNetwork, pusLineCount );

		m_rTechParamData.m_iAvailablePMPanels = ReadEnumLine( inpf, pusLineCount );

		if( m_rTechParamData.m_iAvailablePMPanels < Heating || m_rTechParamData.m_iAvailablePMPanels > ( Solar << 1 ) )
		{
			HYSELECT_THROW( _T("Available PM panels value (%i) can be a combination of one of these values: 'Heating', 'Cooling' or 'Solar' (pos: %i)."), m_rTechParamData.m_iAvailablePMPanels, *pusLineCount );
		}

		// Version 23.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_iMaxNumberOfVentoInParallel = ( int )_tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't maximum number of Vento in parallel value (%s) in int (pos: %i)."), ptcLine, *pusLineCount );
		}

		// Version 24.
		ReadDoubleFromTextLine( inpf, m_rTechParamData.m_dDefaultWaterHardness, pusLineCount );

		// Version 25.
		ReadDoubleFromTextLine( inpf, m_rTechParamData.m_dDpCBCVDpcmin, pusLineCount );

		// Version 26.
		ReadDoubleFromTextLine( inpf, m_rTechParamData.m_dVesselSelectionRangePercentage, pusLineCount );

		// Version 27.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_strDefaultPrjCoolingAdditID = ptcLine;

		if( _tcslen( ptcLine ) > _ID_LENGTH )
		{
			HYSELECT_THROW( _T("Default HM calc additive ID for cooling (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
		}
	
		if( NULL == GetpTADB()->Get( m_rTechParamData.m_strDefaultPrjCoolingAdditID.c_str() ).MP )
		{
			HYSELECT_THROW( _T("Default HM calc additive ID for cooling (%s) is defined but not found in the database (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_strDefaultPrjHeatingAdditID = ptcLine;

		if( _tcslen( ptcLine ) > _ID_LENGTH )
		{
			HYSELECT_THROW( _T("Default HM calc additive ID for heating (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
		}

		if( NULL == GetpTADB()->Get( m_rTechParamData.m_strDefaultPrjHeatingAdditID.c_str() ).MP )
		{
			HYSELECT_THROW( _T("Default HM calc additive ID for heating (%s) is defined but not found in the database (pos: %i)."), ptcLine, *pusLineCount );
		}

		ReadDoubleFromTextLine( inpf, m_rTechParamData.m_dDefaultPrjCoolingPcWeight, pusLineCount );
		ReadDoubleFromTextLine( inpf, m_rTechParamData.m_dDefaultPrjHeatingPcWeight, pusLineCount );

		// HYS-1230: All information regarding water characteristic for product selection are now read at the end.

		// Version 29.
		ReadDoubleFromTextLine( inpf, m_rTechParamData.m_dDegassingWaterReserveForVessel, pusLineCount );

		// Version 30.
		// HYS-1230: All information regarding water characteristic for product selection are now read at the end.

		// Version 31.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_iMaxSafetyValveInParallel = (int)_tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert maximum safety valve in parallel value (%s) in int (pos: %i)."), ptcLine, *pusLineCount );
		}

		ReadDoubleFromTextLine( inpf, m_rTechParamData.m_dDpCBCVDplmin, pusLineCount );

		// Version 32. HYS-1022: 0.3 bar margin for initial pressure (EN 12828-2014).
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dInitialPressureMargin = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert initial pressure margin value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		// Version 33: HYS-1104: safety temperature limiter limit from which we need to pass to the EN 12953 norm.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dSafetyTempLimiterLimitEN12953 = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert safety temperature limiter limit value for EN 12953 (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		// Version 33: HYS-1104: supply/return temperature limit from which we need to pass to the EN 12953 norm.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dFluidTempLimitEN12953 = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert supply/return temperature limit value for EN12953 (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}
	
		// Version 34: HYS-1126: Simplify calculation of static pressure checkbox.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		iValue = (int)_tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert simplify calculation of static pressure checkbox value (%s) in int (pos: %i)."), ptcLine, *pusLineCount );
		}
	
		m_rTechParamData.m_bUseSimplyPst = ( 0 == iValue ) ? false : true;

		// Version 35: HYS-1126: The reference value used to determine the best 6-way valve at a given flow.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dDpRefForBest6Way = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert reference value used to determiner the best 6-way valve at a given flow (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		// Version 36: HYS-1230: All information regarding water characteristic for product selection are now read here.

		ptcLine = ReadTextLine( inpf, pusLineCount );
		int iApplicationType = ( int )_tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert application type value for product selection (%s) in int (pos: %i)."), ptcLine, *pusLineCount );
		}

		if( ProjectType::Heating != iApplicationType && ProjectType::Cooling != iApplicationType && ProjectType::Solar != iApplicationType )
		{
			iApplicationType = ProjectType::Heating;
		}

		m_rTechParamData.m_eProductSelectionApplicationType = ( ProjectType )iApplicationType;

		// Info for heating.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		double dValue = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert default product selection supply temperature for heating (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		SetDefaultISHeatingTps( dValue );

		ptcLine = ReadTextLine( inpf, pusLineCount );
		dValue = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert default product selection DT for heating (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		SetDefaultISHeatingDT( dValue );

		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _tcslen( ptcLine ) > _ID_LENGTH )
		{
			HYSELECT_THROW( _T("Default product selection additive ID for heating (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
		}

		SetDefaultISHeatingAdditID( ptcLine );

		if( NULL == GetpTADB()->Get( GetDefaultISHeatingAdditID() ).MP )
		{
			HYSELECT_THROW( _T("Default product selection additive ID for heating (%s) is defined but not found in the database (pos: %i)."), ptcLine, *pusLineCount );
		}

		ReadDoubleFromTextLine( inpf, dValue, pusLineCount );
		SetDefaultISHeatingPcWeight( dValue );

		// Info for cooling.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		dValue = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert default product selection supply temperature for cooling (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		SetDefaultISCoolingTps( dValue );

		ptcLine = ReadTextLine( inpf, pusLineCount );
		dValue = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert default product selection DT for cooling (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		SetDefaultISCoolingDT( dValue );

		ptcLine = ReadTextLine( inpf, pusLineCount );
		SetDefaultISCoolingAdditID( ptcLine );

		if( _tcslen( ptcLine ) > _ID_LENGTH )
		{
			HYSELECT_THROW( _T("Default product selection additive ID for cooling (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
		}

		if( NULL == GetpTADB()->Get( GetDefaultISCoolingAdditID() ).MP )
		{
			HYSELECT_THROW( _T("Default product selection additive ID for cooling (%s) is defined but not found in the database (pos: %i)."), ptcLine, *pusLineCount );
		}

		ReadDoubleFromTextLine( inpf, dValue, pusLineCount );
		SetDefaultISCoolingPcWeight( dValue );

		// Info for solar.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		dValue = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert default product selection supply temperature for solar (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		SetDefaultISSolarTps( dValue );

		ptcLine = ReadTextLine( inpf, pusLineCount );
		dValue = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert default product selection DT for solar (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		SetDefaultISSolarDT( dValue );

		ptcLine = ReadTextLine( inpf, pusLineCount );
		SetDefaultISSolarAdditID( ptcLine );

		if( _tcslen( ptcLine ) > _ID_LENGTH )
		{
			HYSELECT_THROW( _T("Default product selection additive ID for solar (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
		}

		if( NULL == GetpTADB()->Get( GetDefaultISSolarAdditID() ).MP )
		{
			HYSELECT_THROW( _T("Default product selection additive ID for solar (%s) is defined but not found in the database (pos: %i)."), ptcLine, *pusLineCount );
		}

		ReadDoubleFromTextLine( inpf, dValue, pusLineCount );
		SetDefaultISSolarPcWeight( dValue );

		// Info for change-over - cooling side.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		dValue = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert default product selection supply temperature for change-over cooling side (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}
	
		SetDefaultISChangeOverTps( dValue, CoolingSide );

		ptcLine = ReadTextLine( inpf, pusLineCount );
		dValue = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert default product selection DT for change-over cooling side (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		SetDefaultISChangeOverDT( dValue, CoolingSide );

		ptcLine = ReadTextLine( inpf, pusLineCount );
		SetDefaultISChangeOverAdditID( ptcLine, CoolingSide );

		if( _tcslen( ptcLine ) > _ID_LENGTH )
		{
			HYSELECT_THROW( _T("Default product selection additive ID for change-over cooling side (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
		}

		if( NULL == GetpTADB()->Get( GetDefaultISChangeOverAdditID( CoolingSide ) ).MP )
		{
			HYSELECT_THROW( _T("Default product selection additive ID for change-over cooling side (%s) is defined but not found in the database (pos: %i)."), ptcLine, *pusLineCount );
		}

		ReadDoubleFromTextLine( inpf, dValue, pusLineCount );
		SetDefaultISChangeOverPcWeight( dValue, CoolingSide );

		// Info for change-over - heating side.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		dValue = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert default product selection supply temperature for change-over heating side (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		SetDefaultISChangeOverTps( dValue, HeatingSide );

		ptcLine = ReadTextLine( inpf, pusLineCount );
		dValue = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert default product selection DT for change-over heating side (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		SetDefaultISChangeOverDT( dValue, HeatingSide );

		ptcLine = ReadTextLine( inpf, pusLineCount );
		SetDefaultISChangeOverAdditID( ptcLine, HeatingSide );

		if( _tcslen( ptcLine ) > _ID_LENGTH )
		{
			HYSELECT_THROW( _T("Default product selection additive ID for change-over heating side (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
		}

		if( NULL == GetpTADB()->Get( GetDefaultISChangeOverAdditID( HeatingSide ) ).MP )
		{
			HYSELECT_THROW( _T("Default product selection additive ID for change-over heating side (%s) is defined but not found in the database (pos: %i)."), ptcLine, *pusLineCount );
		}

		ReadDoubleFromTextLine( inpf, dValue, pusLineCount );
		SetDefaultISChangeOverPcWeight( dValue, HeatingSide );

		// Version 37: HYS-1763: Smart control valve default location
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_iDefaultSmartCVLoc = (int)_tcstod( ptcLine, &ptcEndPtr );
		
		if( _T( '\0' ) != *ptcEndPtr )
		{
			HYSELECT_THROW( _T( "Can't convert default smart control valve location (%s) in int (pos: %i)." ), ptcLine, *pusLineCount );
		}

		// Version 38: HYS-1976: Dp max for "best" suggestion.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dSmartValveDpMaxForBestSuggestion = (int)_tcstod( ptcLine, &ptcEndPtr );
		
		if( _T( '\0' ) != *ptcEndPtr )
		{
			HYSELECT_THROW( _T( "Can't convert smart valve max dp for 'best' suggestion (%s) in int (pos: %i)." ), ptcLine, *pusLineCount );
		}

		// Version 39: HYS-1930: New hydronic circuit: auto-adapting variable flow decoupling circuit: add default secondary pump Hmin.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_rTechParamData.m_dDefaultSecondaryPumpHMin = (int)_tcstod( ptcLine, &ptcEndPtr );
		
		if( _T( '\0' ) != *ptcEndPtr )
		{
			HYSELECT_THROW( _T( "Can't convert default secondary Hmin value (%s) in int (pos: %i)." ), ptcLine, *pusLineCount );
		}

		// Close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDS_TechnicalParameter::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif

double CDS_TechnicalParameter::_GetValvMaxDp( _string strValveTypeID )
{
	if( 0 == strValveTypeID.compare( _T("RVTYPE_VV") ) )
	{
		return GetVtriMaxDp();
	}

	if( 0 == strValveTypeID.compare( _T("RVTYPE_FO") ) )
	{
		return GetFoMaxDp();
	}

	return GetValvMaxDp();
}

#ifndef TACBX
void CDS_TechnicalParameter::_ExportTechParamsHelper( std::map<CString, CString> *pmapExportedData, CWaterChar &clWaterChar, ProjectType eApplicationType,
		SideDefinition eSideDefinition )
{
	CString strAppType;

	switch( eApplicationType )
	{
		case ProjectType::Heating:
			strAppType = _T("Heating");
			break;

		case ProjectType::Cooling:
			strAppType = _T("Cooling");
			break;

		case ProjectType::Solar:
			strAppType = _T("Solar");
			break;

		case ProjectType::ChangeOver:
			if( CoolingSide == eSideDefinition )
			{
				strAppType = _T("ChangeOverCoolingSide");
			}
			else
			{
				strAppType = _T("ChangeOverHeatingSide");
			}

			break;
	}

	CString strKeyName;
	strKeyName.Format( _T("DefaultIS%sAdditFamilyID"), (LPCTSTR)strAppType );
	pmapExportedData->insert( std::pair<CString, CString>( strKeyName, clWaterChar.GetAdditFamID() ) );

	strKeyName.Format( _T("DefaultIS%sAdditID"), (LPCTSTR)strAppType );
	pmapExportedData->insert( std::pair<CString, CString>( strKeyName, clWaterChar.GetAdditID() ) );
	
	CString strValue;
	strValue.Format( _T("%.13g"), clWaterChar.GetTemp() );
	strKeyName.Format( _T("DefaultIS%sTps"), (LPCTSTR)strAppType );
	pmapExportedData->insert( std::pair<CString, CString>( strKeyName, strValue ) );

	strValue.Format( _T("%.13g"), clWaterChar.GetPcWeight() );
	strKeyName.Format( _T("DefaultIS%sPcWeight"), (LPCTSTR)strAppType );
	pmapExportedData->insert( std::pair<CString, CString>( strKeyName, strValue ) );
}

void CDS_TechnicalParameter::_ImportTechParamsHelper( std::map<CString, CString> *pmapExportedData, CWaterChar *pclWaterChar, ProjectType eApplicationType, 
		SideDefinition eSideDefinition )
{
	ASSERT( NULL != pmapExportedData && NULL != pclWaterChar );

	CString strAppType;

	switch( eApplicationType )
	{
		case ProjectType::Heating:
			strAppType = _T("heating");
			break;

		case ProjectType::Cooling:
			strAppType = _T("cooling");
			break;

		case ProjectType::Solar:
			strAppType = _T("solar");
			break;

		case ProjectType::ChangeOver:
			if( CoolingSide == eSideDefinition )
			{
				strAppType = _T("changeovercoolingside");
			}
			else
			{
				strAppType = _T("changeoverheatingside");
			}

			break;
	}

	CString strKeyName;
	strKeyName.Format( _T("defaultis%sadditfamilyid"), (LPCTSTR)strAppType );

	if( 0 != pmapExportedData->count( strKeyName ) )
	{
		pclWaterChar->SetAdditFamID( pmapExportedData->at( strKeyName ).MakeUpper() );
	}

	strKeyName.Format( _T("defaultis%sadditid"), (LPCTSTR)strAppType );

	if( 0 != pmapExportedData->count( strKeyName ) )
	{
		pclWaterChar->SetAdditID( pmapExportedData->at( strKeyName ).MakeUpper() );
	}

	strKeyName.Format( _T("defaultis%stps"), (LPCTSTR)strAppType );

	if( 0 != pmapExportedData->count( strKeyName ) )
	{
		pclWaterChar->SetTemp( _wtof( pmapExportedData->at( strKeyName ).MakeUpper() ) );
	}

	strKeyName.Format( _T("defaultis%spcweight"), (LPCTSTR)strAppType );

	if( 0 != pmapExportedData->count( strKeyName ) )
	{
		pclWaterChar->SetPcWeight( _wtof( pmapExportedData->at( strKeyName ).MakeUpper() ) );
	}
}
#endif

#ifndef TACBX
///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_PersistData
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_PersistData )

CDS_PersistData::CDS_PersistData( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_MultiString( pDataBase, ID )
{
	SetString( epdOldValvesUsed, _T("false") );
	m_fOldValveUsed = false;
}

void CDS_PersistData::SetOldValveUsed( bool bFlag )
{
	if( true == bFlag )
	{
		SetString( CDS_PersistData::epdOldValvesUsed, _T("true") );
	}
	else
	{
		SetString( CDS_PersistData::epdOldValvesUsed, _T("false") );
	}

	m_fOldValveUsed = bFlag;
}

#define CDS_PERSISTDATA_VERSION	1
void CDS_PersistData::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_PERSISTDATA_VERSION;
	WriteData<>( outf, Version );
	
	// Base class.
	CDB_MultiString::Write( outf );
}

bool CDS_PersistData::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_PERSISTDATA_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_PERSISTDATA_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDB_MultiString::Read( inpf ) )
	{
		return false;
	}

	m_fOldValveUsed = IsStrIndexTrue( epdOldValvesUsed );
	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SelParameterBase
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SelParameterBase )

CDS_SelParameterBase::CDS_SelParameterBase( ParameterType eParameterType, CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
	m_eParameterType = eParameterType;
	m_pclColumnWidthContainer = NULL;
}

CDS_SelParameterBase::~CDS_SelParameterBase()
{
	if( NULL != m_pclColumnWidthContainer )
	{
		delete m_pclColumnWidthContainer;
	}
}

void CDS_SelParameterBase::WriteToRegistry()
{
	// Write all column width.
	if( NULL != m_pclColumnWidthContainer )
	{
		m_pclColumnWidthContainer->WriteRegistry( m_strSectionName );
	}
}

void CDS_SelParameterBase::ReadFromRegistry()
{
	// Read all column width.
	if( NULL != m_pclColumnWidthContainer )
	{
		m_pclColumnWidthContainer->ReadRegistry( m_strSectionName );
	}
}

void CDS_SelParameterBase::CCWSheet::ReadRegistry( CMemFile &clCWSheet )
{
	// Read version.
	clCWSheet.Read( &m_nVersionID, sizeof( m_nVersionID ) );

	// Run all columns.
	short nColumnID;

	do
	{
		clCWSheet.Read( &nColumnID, sizeof( nColumnID ) );

		if( nColumnID != -1 )
		{
			long lWidth;
			clCWSheet.Read( &lWidth, sizeof( lWidth ) );
			m_mapAllColumn[nColumnID] = lWidth;
		}
	}
	while( nColumnID != -1 );
}

void CDS_SelParameterBase::CCWSheet::ReadRegistryOldVersion( CMemFile &clCWBurst )
{
	m_nVersionID = 1;

	// Read number of columns defined.
	int iColumnNumber;
	clCWBurst.Read( &iColumnNumber, sizeof( iColumnNumber ) );

	for( int iLoop = 0; iLoop < iColumnNumber; iLoop++ )
	{
		int iColumnID;
		clCWBurst.Read( &iColumnID, sizeof( iColumnID ) );
		long lColumnWidth;
		clCWBurst.Read( &lColumnWidth, sizeof( lColumnWidth ) );
		m_mapAllColumn[( short )iColumnID] = lColumnWidth;
	}
}

void CDS_SelParameterBase::CCWSheet::WriteRegistry( CMemFile &clCWSheet )
{
	// Write version.
	clCWSheet.Write( &m_nVersionID, sizeof( m_nVersionID ) );

	// Fill with all infos.
	for( mapShortLongIter iter = m_mapAllColumn.begin(); iter != m_mapAllColumn.end(); ++iter )
	{
		clCWSheet.Write( &iter->first, sizeof( short ) );
		clCWSheet.Write( &iter->second, sizeof( long ) );
	}

	// Close.
	short nEnd = -1;
	clCWSheet.Write( &nEnd, sizeof( nEnd ) );
}

void CDS_SelParameterBase::CCWSheet::_Init( void )
{
	m_nSheetID = -1;
	m_nVersionID = -1;
	m_mapAllColumn.clear();
}

CDS_SelParameterBase::CCWWindow::~CCWWindow()
{
	if( m_mapAllSheet.size() > 0 )
	{
		for( mapShortCCWSheetIter iter = m_mapAllSheet.begin(); iter != m_mapAllSheet.end(); ++iter )
		{
			if( NULL != iter->second )
			{
				delete iter->second;
			}
		}

		m_mapAllSheet.clear();
	}
}

CDS_SelParameterBase::CCWSheet *CDS_SelParameterBase::CCWWindow::GetCWSheet( short nSheetID, bool fCreateIfNotExist )
{
	CCWSheet *pclCWSheet = NULL;

	if( m_mapAllSheet.count( nSheetID ) > 0 )
	{
		pclCWSheet = m_mapAllSheet[nSheetID];
	}
	else if( true == fCreateIfNotExist )
	{
		pclCWSheet = CreateNewCWSSheet( nSheetID );

		if( NULL != pclCWSheet )
		{
			m_mapAllSheet[nSheetID] = pclCWSheet;
		}
	}

	return pclCWSheet;
}

void CDS_SelParameterBase::CCWWindow::ReadRegistry( CString strSectionName )
{
	// Try first to get the description.
	BYTE *pbCWWindow = NULL;
	UINT uiCWWindowSize = 0;
	CString strEntryName;
	strEntryName.Format( _T("CW_Window_%X"), m_nWindowID );
	BOOL bReturn = AfxGetApp()->GetProfileBinary( strSectionName, strEntryName, &pbCWWindow, &uiCWWindowSize );

	if( TRUE == bReturn )
	{
		CMemFile clCWWindow;
		clCWWindow.Attach( pbCWWindow, uiCWWindowSize );

		// Run all sheets.
		short nSheetID;

		do
		{
			clCWWindow.Read( &nSheetID, sizeof( nSheetID ) );

			if( nSheetID != -1 )
			{
				if( 0 == m_mapAllSheet.count( nSheetID ) )
				{
					CCWSheet *pclCCWSheet = CreateNewCWSSheet( nSheetID );

					if( NULL != pclCCWSheet )
					{
						m_mapAllSheet[nSheetID] = pclCCWSheet;
						m_mapAllSheet[nSheetID]->ReadRegistry( clCWWindow );
					}
				}
			}
		}
		while( nSheetID != -1 );

		clCWWindow.Detach();
		delete[] pbCWWindow;
	}
}

void CDS_SelParameterBase::CCWWindow::ReadRegistryOldVersion( CMemFile &clCWBurst, int iSheetNumber )
{
	for( int iLoop = 0; iLoop < iSheetNumber; iLoop++ )
	{
		int iSheetID;
		clCWBurst.Read( &iSheetID, sizeof( iSheetID ) );
		CCWSheet *pclCCWSheet = CreateNewCWSSheet( iSheetID );

		if( NULL != pclCCWSheet )
		{
			m_mapAllSheet[( short )iSheetID] = pclCCWSheet;
			m_mapAllSheet[( short )iSheetID]->ReadRegistryOldVersion( clCWBurst );
		}
	}
}

void CDS_SelParameterBase::CCWWindow::WriteRegistry( CString strSectionName )
{
	CMemFile clCWWindow;

	// Fill with all infos.
	for( mapShortCCWSheet::iterator iter = m_mapAllSheet.begin(); iter != m_mapAllSheet.end(); ++iter )
	{
		clCWWindow.Write( &iter->first, sizeof( short ) );
		iter->second->WriteRegistry( clCWWindow );
	}

	// Close and write.
	short nEnd = -1;
	clCWWindow.Write( &nEnd, sizeof( nEnd ) );

	CString strEntryName;
	strEntryName.Format( _T("CW_Window_%X"), m_nWindowID );
	UINT uiLength = ( UINT )clCWWindow.GetLength();
	BYTE *pbBuffer = clCWWindow.Detach();
	::AfxGetApp()->WriteProfileBinary( strSectionName, strEntryName, pbBuffer, uiLength );
	free( pbBuffer );
}

CDS_SelParameterBase::CCWSheet *CDS_SelParameterBase::CCWWindow::CreateNewCWSSheet( short nSheetID )
{
	return new CCWSheet( nSheetID );
}

void CDS_SelParameterBase::CCWWindow::_Init()
{
	m_nWindowID = -1;
	m_mapAllSheet.clear();
}

CDS_SelParameterBase::CCWContainer::~CCWContainer()
{
	_Clear();
}

CDS_SelParameterBase::CCWWindow *CDS_SelParameterBase::CCWContainer::GetCCWindow( short nWindowID, bool fCreateIfNotExist )
{
	CCWWindow *pclCWWindow = NULL;

	if( m_mapAllWindow.count( nWindowID ) > 0 )
	{
		pclCWWindow = m_mapAllWindow[nWindowID];
	}
	else if( true == fCreateIfNotExist )
	{
		pclCWWindow = CreateNewCWSWindow( nWindowID );

		if( NULL != pclCWWindow )
		{
			m_mapAllWindow[nWindowID] = pclCWWindow;
		}
	}

	return pclCWWindow;
}

void CDS_SelParameterBase::CCWContainer::ReadRegistry( CString strSectionName )
{
	_Clear();

	// Try first to get the description.
	BYTE *pbCWDescription = NULL;
	UINT uiCWDescriptionSize = 0;
	BOOL bReturn = AfxGetApp()->GetProfileBinary( strSectionName, _T("CW_Container"), &pbCWDescription, &uiCWDescriptionSize );

	if( FALSE == bReturn )
	{
		// Old version. We have all column width, for all sheets and for all RViewSSelXXX in only one key.
		BYTE *pbCWBurst;
		UINT uiCWBurstSize;

		if( FALSE == AfxGetApp()->GetProfileBinary( strSectionName, _T("ColumnWidth"), &pbCWBurst, &uiCWBurstSize ) )
		{
			return;
		}

		CMemFile clCWBurst;
		clCWBurst.Attach( pbCWBurst, uiCWBurstSize );

		for( int iLoop = CW_WINDOWID_INDSELBCV; iLoop <= CW_WINDOWID_INDSELTRV; iLoop++ )
		{
			int iSheetNumber;
			clCWBurst.Read( &iSheetNumber, sizeof( iSheetNumber ) );

			if( iSheetNumber != -1 )
			{
				CCWWindow *pclCCWWindow = CreateNewCWSWindow( iLoop );

				if( NULL != pclCCWWindow )
				{
					m_mapAllWindow[iLoop] = pclCCWWindow;
					m_mapAllWindow[iLoop]->ReadRegistryOldVersion( clCWBurst, iSheetNumber );
				}
			}
		}

		clCWBurst.Detach();
		delete [] pbCWBurst;
	}
	else
	{
		// New version. We have one key for one window (containing column width for all sheets of this window).
		CMemFile clCWDescription;
		clCWDescription.Attach( pbCWDescription, uiCWDescriptionSize );

		// Run all windows.
		short nWindowID;

		do
		{
			clCWDescription.Read( &nWindowID, sizeof( nWindowID ) );

			if( nWindowID != -1 )
			{
				CCWWindow *pclCCWWindow = CreateNewCWSWindow( nWindowID );

				if( NULL != pclCCWWindow )
				{
					m_mapAllWindow[nWindowID] = pclCCWWindow;
					m_mapAllWindow[nWindowID]->ReadRegistry( strSectionName );
				}
			}
		}
		while( nWindowID != -1 );

		m_bInitialized = true;

		clCWDescription.Detach();
		delete [] pbCWDescription;
	}
}

void CDS_SelParameterBase::CCWContainer::WriteRegistry( CString strSectionName )
{
	CMemFile clCWDescription;

	// Run all windows.
	for( mapShortCCWWindowIter iter = m_mapAllWindow.begin(); iter != m_mapAllWindow.end(); ++iter )
	{
		clCWDescription.Write( &iter->first, sizeof( short ) );
		iter->second->WriteRegistry( strSectionName );
	}

	// Close and write container description.
	short nEnd = -1;
	clCWDescription.Write( &nEnd, sizeof( nEnd ) );
	CString strEntryName;
	strEntryName.Format( _T("CW_Container") );
	UINT uiLength = ( UINT )clCWDescription.GetLength();
	BYTE *pbBuffer = clCWDescription.Detach();
	::AfxGetApp()->WriteProfileBinary( strSectionName, strEntryName, pbBuffer, uiLength );
	free( pbBuffer );
}

CDS_SelParameterBase::CCWWindow *CDS_SelParameterBase::CCWContainer::CreateNewCWSWindow( short nWindowID )
{
	return new CCWWindow( nWindowID );
}

void CDS_SelParameterBase::CCWContainer::_Clear( void )
{
	if( false == m_mapAllWindow.empty() )
	{
		for( mapShortCCWWindowIter iter = m_mapAllWindow.begin(); iter != m_mapAllWindow.end(); ++iter )
		{
			if( NULL != iter->second )
			{
				delete iter->second;
			}
		}

		m_mapAllWindow.clear();
	}

	m_bInitialized = false;
}

CDS_SelParameterBase::CCWWindow *CDS_SelParameterBase::GetWindowColumnWidth( short nWindowID, bool fCreateIfNotExist )
{
	CDS_SelParameterBase::CCWWindow *pclCCWWindow = NULL;

	if( NULL != m_pclColumnWidthContainer )
	{
		pclCCWWindow = m_pclColumnWidthContainer->GetCCWindow( nWindowID, fCreateIfNotExist );
	}

	return pclCCWWindow;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_IndSelParameter
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_IndSelParameter )

CDS_IndSelParameter::CDS_IndSelParameter( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SelParameterBase( ParameterType::IndividualSelection, pDataBase, ID )
{
	m_strSectionName = _T("DlgIndSelection");

	// Initialize parameters common to all selections.
	// Remark: PARAM_TECH not yet initialized when the constructor is called, use STEEL_GEN_PIPES it will be overwritten by calling 'VerifyPipeSeries'.
	_tcsncpy_s( m_strPipeSeriesID, SIZEOFINTCHAR( m_strPipeSeriesID ), _T("STEEL_GEN_PIPES"), SIZEOFINTCHAR( m_strPipeSeriesID ) - 1 );
	_tcsncpy_s( m_strPipeSizeID, SIZEOFINTCHAR( m_strPipeSizeID ), _T(""), SIZEOFINTCHAR( m_strPipeSizeID ) - 1 );

	// Initialize parameters for balancing valves.
	m_iBvRadioFlowPowerDT = 0;									// Version 17.
	m_iBvDpChecked = BST_UNCHECKED;
	_tcsncpy_s( m_strBvTypeID, SIZEOFINTCHAR( m_strBvTypeID ), _T("RVTYPE_BV"), SIZEOFINTCHAR( m_strBvTypeID ) - 1 );
	m_strBvFamilyID[0] = _T('\0');
	m_strBvMaterialID[0] = _T('\0');
	m_strBvConnectID[0] = _T('\0');
	m_strBvVersionID[0] = _T('\0');
	m_strBvPNID[0] = _T('\0');

	// Initialize parameters for Dp controller.
	m_iDpCRadioFlowPowerDT = 0;									// Version 17.
	m_iDpCDpStab = eDpStab::DpStabOnBranch;
	m_iDpCMvLoc = eMvLoc::MvLocPrimary;
	m_iDpCLocation = eDpCLoc::DpCLocDownStream;
	m_iDpCDpChecked = BST_UNCHECKED;
	m_iDpCDpMaxChecked = BST_UNCHECKED;							// Version 19.
	m_strDpCTypeID[0] = _T('\0');
	m_strDpCFamilyID[0] = _T('\0');
	m_strDpCMaterialID[0] = _T('\0');
	m_strDpCConnectID[0] = _T('\0');
	m_strDpCVersionID[0] = _T('\0');
	m_strDpCPNID[0] = _T('\0');
	m_iDpCPackageChecked = BST_UNCHECKED;
	m_iDpCInfoWnd = TRUE;

	// Initialize parameters for thermostatic and return valves.
	m_iTrvRadioFlowPowerDT = 0;
	m_iTrvDpChecked = BST_UNCHECKED;
	m_iTrvActuatorType = ActuatorType::AT_ThermoStatic;
	m_iTrvRadiatorValveType = BST_UNCHECKED;
	m_strTrvSVFamilyID[0] = _T('\0');
	m_strTrvSVVersionID[0] = _T('\0');
	m_strTrvSVConnectID[0] = _T('\0');
	m_strTrvRVFamilyID[0] = _T('\0');
	m_strTrvRVVersionID[0] = _T('\0');
	m_strTrvRVConnectID[0] = _T('\0');
	m_strTrvSVInsertName[0] = '\0';
	m_strTrvSVInsertFamilyID[0] = _T('\0');
	m_strTrvSVInsertTypeID[0] = _T('\0');
	m_bTrvSVInsertInKv = false;
	m_dTrvSVInsertKvValue = 0.0;
	m_strTrvRVInsertFamilyID[0] = _T('\0');
	m_strTrvActuatorTypeID[0] = _T('\0');
	m_strTrvActuatorFamilyID[0] = _T('\0');
	m_strTrvActuatorVersionID[0] = _T('\0');
	m_eTrvRVMode = RRVM_IMI;
	memset( &m_rTrvRadInfos, 0, sizeof( RadInfo_struct ) );

	// Initialize parameters for control valves.
	m_iCvRadioFlowPowerDT = 0;									// Version 17.
	m_eCvCB2W3W = CDB_ControlProperties::CV2W3W::CV2W;
	m_eCvCBCtrlType = CDB_ControlProperties::CvCtrlType::eCvProportional;
	m_iCvCheckDpKvs = BST_UNCHECKED;
	m_iCvRadioKvs = BST_CHECKED;
	m_strCvTypeID[0] = _T('\0');
	m_strCvFamilyID[0] = _T('\0');
	m_strCvMaterialID[0] = _T('\0');
	m_strCvConnectID[0] = _T('\0');
	m_strCvVersionID[0] = _T('\0');
	m_strCvPNID[0] = _T('\0');
	m_strCvActPowerSupplyID[0] = _T('\0');
	m_strCvActInputSignalID[0] = _T('\0');
	m_iCvFailSafeFct = 0;
	m_eCvDRPFct = CDB_ControlValve::DRPFunction::drpfUndefined;
	m_iCvPackageChecked = BST_UNCHECKED;

	// Initialize parameters for pressure independent control valves.
	m_iPICvRadioFlowPowerDT = 0;								// Version 17.
	m_ePICvCBCtrlType = CDB_ControlProperties::CvCtrlType::eCvProportional;
	m_strPICvTypeID[0] = _T('\0');
	m_strPICvFamilyID[0] = _T('\0');
	m_strPICvMaterialID[0] = _T('\0');
	m_strPICvConnectID[0] = _T('\0');
	m_strPICvVersionID[0] = _T('\0');
	m_strPICvPNID[0] = _T('\0');
	m_strPICvActPowerSupplyID[0] = _T('\0');
	m_strPICvActInputSignalID[0] = _T('\0');
	m_iPICvFailSafeFct = 0;
	m_ePICvDRPFct = CDB_ControlValve::DRPFunction::drpfUndefined;
	m_iPICvPackageChecked = BST_UNCHECKED;
	m_iPICvDpMaxChecked = BST_UNCHECKED;						// Version 19.

	// Initialize parameters for balancing and control valves.
	m_iBCVRadioFlowPowerDT = 0;									// Version 17.
	m_iBCVDpChecked	= BST_UNCHECKED;							// Version 17.
	m_eBCV2W3W = CDB_ControlProperties::CV2W3W::CV2W;
	m_eBCVCBCtrlType = CDB_ControlProperties::CvCtrlType::eCvProportional;
	m_strBCVTypeID[0] = _T('\0');
	m_strBCVFamilyID[0] = _T('\0');
	m_strBCVMaterialID[0] = _T('\0');
	m_strBCVConnectID[0] = _T('\0');
	m_strBCVVersionID[0] = _T('\0');
	m_strBCVPNID[0] = _T('\0');
	m_strBCVActPowerSupplyID[0] = _T('\0');
	m_strBCVActInputSignalID[0] = _T('\0');
	m_iBCVFailSafeFct = 0;
	m_eBCVDRPFct = CDB_ControlValve::DRPFunction::drpfUndefined;
	m_iBCVPackageChecked = BST_UNCHECKED;

	// Initialize parameters for separators.
	m_iSepRadioFlowPowerDT = 0;										// Version 17.
	m_strSeparatorTypeID[0] = _T('\0');
	m_strSeparatorFamilyID[0] = _T('\0');
	m_strSeparatorConnectID[0] = _T('\0');
	m_strSeparatorVersionID[0] = _T('\0');

	// Initialize parameters for pressure maintenance.
	m_ePMApplicationType = ProjectType::Heating;					// Version 18.
	m_strPMPressureMaintenanceTypeID[0] = _T('\0');					// Version 18.
	m_strPMWaterMakeUpTypeID[0] = _T('\0');							// Version 20.
	m_iPMDegassingChecked = 0;										// Version 18.
	m_strPMNorm[0] = '\0';											// Version 18.
	m_ePMPressOn = PressurON::poPumpSuction;						// Version 18.

	// Initialize parameters for combined Dp controller and balancing & control valves.
	m_iDpCBCVRadioFlowPowerDT = 0;
	m_eDpCBCVCBCtrlType = CDB_ControlProperties::CvCtrlType::eCvProportional;
	m_strDpCBCVTypeID[0] = _T('\0');
	m_strDpCBCVFamilyID[0] = _T('\0');
	m_strDpCBCVMaterialID[0] = _T('\0');
	m_strDpCBCVConnectID[0] = _T('\0');
	m_strDpCBCVVersionID[0] = _T('\0');
	m_strDpCBCVPNID[0] = _T('\0');
	m_strDpCBCVActPowerSupplyID[0] = _T('\0');
	m_strDpCBCVActInputSignalID[0] = _T('\0');
	m_iDpCBCVFailSafeFct = 0;
	m_eDpCBCVDRPFct = CDB_ControlValve::DRPFunction::drpfUndefined;
	m_iDpCBCVPackageChecked = BST_UNCHECKED;
	m_iDpCBCVDpToStabilizeChecked = BST_UNCHECKED;
	m_iDpCBCVWithSTSChecked = BST_UNCHECKED;
	m_iDpCBCVInfoWnd = TRUE;

	// Initialize parameters for shut-off valves.
	m_iSvRadioFlowPowerDT = 0;
	m_strSvTypeID[0] = _T('\0');
	m_strSvFamilyID[0] = _T('\0');
	m_strSvMaterialID[0] = _T('\0');
	m_strSvConnectID[0] = _T('\0');
	m_strSvVersionID[0] = _T('\0');
	m_strSvPNID[0] = _T('\0');

	// Initialize parameters for safety valves.
	m_eSafetyValveSystemType = ProjectType::Heating;
	m_strSafetyValveSystemHeatGeneratorTypeID[0] = _T('\0');
	m_strSafetyValveNormID[0] = _T('\0');
	m_strSafetyValveFamilyID[0] = _T('\0');
	m_strSafetyValveConnectionID[0] = _T('\0');
	m_dSafetyValveSetPressure = 0.0;

	// Version 25: HYS-1058: we need to save pressurisation maintenance and water quality preferences.
	m_pclPMWQPrefs = new CPMWQPrefs();

	// Initialize for 6-way
	m_e6WValveSelectionMode = e6Way_EQMControl;
	m_i6WValveRadioFlowPowerDT = 0;
	m_str6WValveConnectID[0] = _T('\0');
	m_str6WValveVersionID[0] = _T('\0');
	m_b6WValveCheckFastElectConnection = true;
	// HYS-1877: Version 31: 6-way valve set
	m_b6WValveCheckOnlyForSet = false;
	// PICV.
	m_bIs6WValvePICvDpMaxChecked = false;
	m_e6WValvePICvCBCtrlType = CDB_ControlProperties::CvCtrlType::eCvProportional;
	m_str6WValvePICvTypeID[0] = _T('\0');
	m_str6WValvePICvFamilyID[0] = _T('\0');
	m_str6WValvePICvMaterialID[0] = _T('\0');
	m_str6WValvePICvConnectID[0] = _T('\0');
	m_str6WValvePICvVersionID[0] = _T('\0');
	m_str6WValvePICvPNID[0] = _T('\0');
	m_str6WValvePICvActInputSignalID[0] = _T('\0');
	// BV.
	m_bIs6WValveBvDpChecked = false;
	m_str6WValveBvTypeID[0] = _T('\0');						// Last selected balancing valve type ID.
	m_str6WValveBvFamilyID[0] = _T('\0');					// Last selected balancing valve family ID.
	m_str6WValveBvMaterialID[0] = _T('\0');					// Last selected balancing valve material ID.
	m_str6WValveBvConnectID[0] = _T('\0');					// Last selected balancing valve connection ID.
	m_str6WValveBvVersionID[0] = _T('\0');					// Last selected balancing valve version ID.
	m_str6WValveBvPNID[0] = _T('\0');						// Last selected balancing valve PN ID.

	// Inialize for smart control valve.
	m_iSmartControlValveRadioFlowPowerDT = 0;
	m_strSmartControlValveBodyMaterialID[0] = _T('\0');			// Last selected smart control valve type ID.
	m_strSmartControlValveConnectID[0] = _T('\0');					// Last selected smart control valve family ID.
	m_strSmartControlValveVersionID[0] = _T('\0');					// Last selected smart control valve material ID.
	m_iSmartControlValveDpMaxChecked = 0;					    // HYS-1939: TA-Smart Dp - 06 - Individual selection: create the datastruct object.

	// Init for smart DpC. Version 32
	// HYS-1937: TA-Smart Dp - 04 - Individual selection: left tab.
	m_iSmartDpCRadioFlowPowerDT = 0;
	m_iSmartDpCDpBranchChecked = 0;				
	m_iSmartDpCDpMaxChecked = 0;				               // HYS-1939: TA-Smart Dp - 06 - Individual selection: create the datastruct object.
	m_strSmartDpCBodyMaterialID[0] = _T( '\0' );
	m_strSmartDpCConnectID[0] = _T( '\0' );		
	m_strSmartDpCVersionID[0] = _T( '\0' );
	// HYS-1938: TA-Smart Dp - 05 - Individual selection: right view
	// HYS-1992: Remove set possibility of TA Smart Dp.
	m_bSmartDpCCheckOnlyForSet = false; // No more used

	m_fPMWaterMakeupBreakTank = false;
	m_pclColumnWidthContainer = new CCWContainer();
}

CDS_IndSelParameter::~CDS_IndSelParameter()
{
	if( NULL != m_pclPMWQPrefs )
	{
		delete m_pclPMWQPrefs;
		m_pclPMWQPrefs = NULL;
	}
}

int CDS_IndSelParameter::GetWindowShowAllPrioritiesState( int nWindowID, int iButtonID )
{
	if( 0 == m_mapShowHideAllPrioritiesState.count( nWindowID ) )
	{
		return -1;
	}

	if( 0 == m_mapShowHideAllPrioritiesState[nWindowID].count( iButtonID ) )
	{
		return -1;
	}

	return m_mapShowHideAllPrioritiesState[nWindowID][iButtonID];
}

void CDS_IndSelParameter::Copy( CData *pclDestination )
{
	CData::Copy( pclDestination );
	
	CDS_IndSelParameter *pDestinationIndSelParameter = (CDS_IndSelParameter *)pclDestination;
	pDestinationIndSelParameter->SetPipeSeriesID( m_strPipeSeriesID );
	pDestinationIndSelParameter->SetPipeSizeID( m_strPipeSizeID );
	pDestinationIndSelParameter->SetBvRadioFlowPowerDT( m_iBvRadioFlowPowerDT );
	pDestinationIndSelParameter->SetBvDpCheckBox( m_iBvDpChecked );
	pDestinationIndSelParameter->SetBvTypeID( m_strBvTypeID );
	pDestinationIndSelParameter->SetBvFamilyID( m_strBvFamilyID );
	pDestinationIndSelParameter->SetBvMaterialID( m_strBvMaterialID );
	pDestinationIndSelParameter->SetBvConnectID( m_strBvConnectID );
	pDestinationIndSelParameter->SetBvVersionID( m_strBvVersionID );
	pDestinationIndSelParameter->SetBvPNID( m_strBvPNID );
	pDestinationIndSelParameter->SetDpCRadioFlowPowerDT( m_iDpCRadioFlowPowerDT );
	pDestinationIndSelParameter->SetDpCDpStab( m_iDpCDpStab );
	pDestinationIndSelParameter->SetDpCMvLoc( m_iDpCMvLoc );
	pDestinationIndSelParameter->SetDpCLoc( m_iDpCLocation );
	pDestinationIndSelParameter->SetDpCDpCheckBox( m_iDpCDpChecked );
	pDestinationIndSelParameter->SetDpCDpMaxCheckBox( m_iDpCDpMaxChecked );
	pDestinationIndSelParameter->SetDpCTypeID( m_strDpCTypeID );
	pDestinationIndSelParameter->SetDpCFamilyID( m_strDpCFamilyID );
	pDestinationIndSelParameter->SetDpCMaterialID( m_strDpCMaterialID );
	pDestinationIndSelParameter->SetDpCConnectID( m_strDpCConnectID );
	pDestinationIndSelParameter->SetDpCVersionID( m_strDpCVersionID );
	pDestinationIndSelParameter->SetDpCPNID( m_strDpCPNID );
	pDestinationIndSelParameter->SetDpCPackageChecked( m_iDpCPackageChecked );
	pDestinationIndSelParameter->SetDpCInfoWndChecked( m_iDpCInfoWnd );
	pDestinationIndSelParameter->SetTrvRadioFlowPowerDT( m_iTrvRadioFlowPowerDT );
	pDestinationIndSelParameter->SetTrvDpCheckBox( m_iTrvDpChecked );
	pDestinationIndSelParameter->SetTrvActuatorType( m_iTrvActuatorType );
	pDestinationIndSelParameter->SetTrvRadiatorValveType( m_iTrvRadiatorValveType );
	pDestinationIndSelParameter->SetTrvSVFamilyID( m_strTrvSVFamilyID );
	pDestinationIndSelParameter->SetTrvSVVersionID( m_strTrvSVVersionID );
	pDestinationIndSelParameter->SetTrvSVConnectID( m_strTrvSVConnectID );
	pDestinationIndSelParameter->SetTrvRVFamilyID( m_strTrvRVFamilyID );
	pDestinationIndSelParameter->SetTrvRVVersionID( m_strTrvRVVersionID );
	pDestinationIndSelParameter->SetTrvRVConnectID( m_strTrvRVConnectID );
	pDestinationIndSelParameter->SetTrvSVInsertName( m_strTrvSVInsertName );
	pDestinationIndSelParameter->SetTrvSVInsertFamilyID( m_strTrvSVInsertFamilyID );
	pDestinationIndSelParameter->SetTrvSVInsertTypeID( m_strTrvSVInsertTypeID );
	pDestinationIndSelParameter->SetTrvSVInsertInKv( m_bTrvSVInsertInKv );
	pDestinationIndSelParameter->SetTrvSVInsertKvValue( m_dTrvSVInsertKvValue );
	pDestinationIndSelParameter->SetTrvRVInsertFamilyID( m_strTrvRVInsertFamilyID );
	pDestinationIndSelParameter->SetTrvActuatorTypeID( m_strTrvActuatorTypeID );
	pDestinationIndSelParameter->SetTrvActuatorFamilyID( m_strTrvActuatorFamilyID );
	pDestinationIndSelParameter->SetTrvActuatorVersionID( m_strTrvActuatorVersionID );
	pDestinationIndSelParameter->SetTrvRVMode( m_eTrvRVMode );
	pDestinationIndSelParameter->SetTrvRadInfos(&m_rTrvRadInfos );
	pDestinationIndSelParameter->SetCvRadioFlowPowerDT( m_iCvRadioFlowPowerDT );
	pDestinationIndSelParameter->SetCvCB2W3W( m_eCvCB2W3W );
	pDestinationIndSelParameter->SetCvCBCtrlType( m_eCvCBCtrlType );
	pDestinationIndSelParameter->SetCvCheckDpKvs( m_iCvCheckDpKvs );
	pDestinationIndSelParameter->SetCvRadioKvs( m_iCvRadioKvs );
	pDestinationIndSelParameter->SetCvTypeID( m_strCvTypeID );
	pDestinationIndSelParameter->SetCvFamilyID( m_strCvFamilyID );
	pDestinationIndSelParameter->SetCvMaterialID( m_strCvMaterialID );
	pDestinationIndSelParameter->SetCvConnectID( m_strCvConnectID );
	pDestinationIndSelParameter->SetCvVersionID( m_strCvVersionID );
	pDestinationIndSelParameter->SetCvPNID( m_strCvPNID );
	pDestinationIndSelParameter->SetCvActPowerSupplyID( m_strCvActPowerSupplyID );
	pDestinationIndSelParameter->SetCvActInputSignalID( m_strCvActInputSignalID );
	pDestinationIndSelParameter->SetCvFailSafeFct( m_iCvFailSafeFct );
	pDestinationIndSelParameter->SetCvDRPFct( m_eCvDRPFct );
	pDestinationIndSelParameter->SetCvPackageChecked( m_iCvPackageChecked );
	pDestinationIndSelParameter->SetPICvRadioFlowPowerDT( m_iPICvRadioFlowPowerDT );
	pDestinationIndSelParameter->SetPICvCBCtrlType( m_ePICvCBCtrlType );
	pDestinationIndSelParameter->SetPICvTypeID( m_strPICvTypeID );
	pDestinationIndSelParameter->SetPICvFamilyID( m_strPICvFamilyID );
	pDestinationIndSelParameter->SetPICvMaterialID( m_strPICvMaterialID );
	pDestinationIndSelParameter->SetPICvConnectID( m_strPICvConnectID );
	pDestinationIndSelParameter->SetPICvVersionID( m_strPICvVersionID );
	pDestinationIndSelParameter->SetPICvPNID( m_strPICvPNID );
	pDestinationIndSelParameter->SetPICvActPowerSupplyID( m_strPICvActPowerSupplyID );
	pDestinationIndSelParameter->SetPICvActInputSignalID( m_strPICvActInputSignalID );
	pDestinationIndSelParameter->SetPICvFailSafeFct( m_iPICvFailSafeFct );
	pDestinationIndSelParameter->SetPICvDRPFct( m_ePICvDRPFct );
	pDestinationIndSelParameter->SetPICvPackageChecked( m_iPICvPackageChecked );
	pDestinationIndSelParameter->SetPICvDpMaxCheckBox( m_iPICvDpMaxChecked );
	pDestinationIndSelParameter->SetBCVRadioFlowPowerDT( m_iBCVRadioFlowPowerDT );
	pDestinationIndSelParameter->SetBCVDpCheckBox( m_iBCVDpChecked );
	pDestinationIndSelParameter->SetBCVCB2W3W( m_eBCV2W3W );
	pDestinationIndSelParameter->SetBCVCBCtrlType( m_eBCVCBCtrlType );
	pDestinationIndSelParameter->SetBCVTypeID( m_strBCVTypeID );
	pDestinationIndSelParameter->SetBCVFamilyID( m_strBCVFamilyID );
	pDestinationIndSelParameter->SetBCVMaterialID( m_strBCVMaterialID );
	pDestinationIndSelParameter->SetBCVConnectID( m_strBCVConnectID );
	pDestinationIndSelParameter->SetBCVVersionID( m_strBCVVersionID );
	pDestinationIndSelParameter->SetBCVPNID( m_strBCVPNID );
	pDestinationIndSelParameter->SetBCVActPowerSupplyID( m_strBCVActPowerSupplyID );
	pDestinationIndSelParameter->SetBCVActInputSignalID( m_strBCVActInputSignalID );
	pDestinationIndSelParameter->SetBCVFailSafeFct( m_iBCVFailSafeFct );
	pDestinationIndSelParameter->SetBCVDRPFct( m_eBCVDRPFct );
	pDestinationIndSelParameter->SetBCVPackageChecked( m_iBCVPackageChecked );
	pDestinationIndSelParameter->SetSepRadioFlowPowerDT( m_iSepRadioFlowPowerDT );
	pDestinationIndSelParameter->SetSeparatorTypeID( m_strSeparatorTypeID );
	pDestinationIndSelParameter->SetSeparatorFamilyID( m_strSeparatorFamilyID );
	pDestinationIndSelParameter->SetSeparatorConnectID( m_strSeparatorConnectID );
	pDestinationIndSelParameter->SetSeparatorVersionID( m_strSeparatorVersionID );
	pDestinationIndSelParameter->SetPMApplicationType( m_ePMApplicationType );
	pDestinationIndSelParameter->SetPMPressMaintTypeID( m_strPMPressureMaintenanceTypeID );
	pDestinationIndSelParameter->SetPMWaterMakeUpTypeID( m_strPMWaterMakeUpTypeID );
	pDestinationIndSelParameter->SetPMDegassingChecked( m_iPMDegassingChecked );
	pDestinationIndSelParameter->SetPMNorm( m_strPMNorm );
	pDestinationIndSelParameter->SetPMPressOn( m_ePMPressOn );
	pDestinationIndSelParameter->SetDpCBCVRadioFlowPowerDT( m_iDpCBCVRadioFlowPowerDT );
	pDestinationIndSelParameter->SetDpCBCVCBCtrlType( m_eDpCBCVCBCtrlType );
	pDestinationIndSelParameter->SetDpCBCVTypeID( m_strDpCBCVTypeID );
	pDestinationIndSelParameter->SetDpCBCVFamilyID( m_strDpCBCVFamilyID );
	pDestinationIndSelParameter->SetDpCBCVMaterialID( m_strDpCBCVMaterialID );
	pDestinationIndSelParameter->SetDpCBCVConnectID( m_strDpCBCVConnectID );
	pDestinationIndSelParameter->SetDpCBCVVersionID( m_strDpCBCVVersionID );
	pDestinationIndSelParameter->SetDpCBCVPNID( m_strDpCBCVPNID );
	pDestinationIndSelParameter->SetDpCBCVActPowerSupplyID( m_strDpCBCVActPowerSupplyID );
	pDestinationIndSelParameter->SetDpCBCVActInputSignalID( m_strDpCBCVActInputSignalID );
	pDestinationIndSelParameter->SetDpCBCVFailSafeFct( m_iDpCBCVFailSafeFct );
	pDestinationIndSelParameter->SetDpCBCVDRPFct( m_eDpCBCVDRPFct );
	pDestinationIndSelParameter->SetDpCBCVPackageChecked( m_iDpCBCVPackageChecked );
	pDestinationIndSelParameter->SetDpCBCVDpToStabilizeCheckBox( m_iDpCBCVDpToStabilizeChecked );
	pDestinationIndSelParameter->SetDpCBCVWithSTSCheckBox( m_iDpCBCVWithSTSChecked );
	pDestinationIndSelParameter->SetDpCBCVInfoWndChecked( m_iDpCBCVInfoWnd );
	pDestinationIndSelParameter->SetSvRadioFlowPowerDT( m_iSvRadioFlowPowerDT );
	pDestinationIndSelParameter->SetSvTypeID( m_strSvTypeID );
	pDestinationIndSelParameter->SetSvFamilyID( m_strSvFamilyID );
	pDestinationIndSelParameter->SetSvMaterialID( m_strSvMaterialID );
	pDestinationIndSelParameter->SetSvConnectID( m_strSvConnectID );
	pDestinationIndSelParameter->SetSvVersionID( m_strSvVersionID );
	pDestinationIndSelParameter->SetSvPNID( m_strSvPNID );
	pDestinationIndSelParameter->SetPMWaterMakeupBreakTank( m_fPMWaterMakeupBreakTank );

	// Version 24: safety valves.
	pDestinationIndSelParameter->SetSafetyValveSystemType( m_eSafetyValveSystemType );
	pDestinationIndSelParameter->SetSafetyValveSystemHeatGeneratorTypeID( m_strSafetyValveSystemHeatGeneratorTypeID );
	pDestinationIndSelParameter->SetSafetyValveNormID( m_strSafetyValveNormID );
	pDestinationIndSelParameter->SetSafetyValveFamilyID( m_strSafetyValveFamilyID );
	pDestinationIndSelParameter->SetSafetyValveConnectionID( m_strSafetyValveConnectionID );
	pDestinationIndSelParameter->SetSafetyValveSetPressure( m_dSafetyValveSetPressure );

	// Version 25: HYS-1058: we need to save pressurisation maintenance and water quality preferences.
	pDestinationIndSelParameter->SetPMWQPrefs( m_pclPMWQPrefs );

	// 6-way.
	pDestinationIndSelParameter->Set6WValveSelectionMode( m_e6WValveSelectionMode );
	pDestinationIndSelParameter->Set6WValveRadioFlowPowerDT( m_i6WValveRadioFlowPowerDT );
	pDestinationIndSelParameter->Set6WValveConnectID( m_str6WValveConnectID );
	pDestinationIndSelParameter->Set6WValveVersionID( m_str6WValveVersionID );
	pDestinationIndSelParameter->Set6WValveCheckFastElectConnection( m_b6WValveCheckFastElectConnection );

	// Version 31: HYS-1877 6-way valve set.
	pDestinationIndSelParameter->Set6WValveKitCheckbox( m_b6WValveCheckOnlyForSet );

	// 6-way PICV.
	pDestinationIndSelParameter->Set6WValvePICvDpMaxChecked( m_bIs6WValvePICvDpMaxChecked );
	pDestinationIndSelParameter->Set6WValvePICvCBCtrlType( m_e6WValvePICvCBCtrlType );
	pDestinationIndSelParameter->Set6WValvePICvTypeID( m_str6WValvePICvTypeID );
	pDestinationIndSelParameter->Set6WValvePICvFamilyID( m_str6WValvePICvFamilyID );
	pDestinationIndSelParameter->Set6WValvePICvMaterialID( m_str6WValvePICvMaterialID );
	pDestinationIndSelParameter->Set6WValvePICvConnectID( m_str6WValvePICvConnectID );
	pDestinationIndSelParameter->Set6WValvePICvVersionID( m_str6WValvePICvVersionID );
	pDestinationIndSelParameter->Set6WValvePICvPNID( m_str6WValvePICvPNID );
	pDestinationIndSelParameter->Set6WValvePICvActInputSignalID( m_str6WValvePICvActInputSignalID );
	
	// 6-way BV.
	pDestinationIndSelParameter->Set6WValveBvDpChecked( m_bIs6WValveBvDpChecked );
	pDestinationIndSelParameter->Set6WValveBVTypeID( m_str6WValveBvTypeID );
	pDestinationIndSelParameter->Set6WValveBVFamilyID( m_str6WValveBvFamilyID );
	pDestinationIndSelParameter->Set6WValveBVMaterialID( m_str6WValveBvMaterialID );
	pDestinationIndSelParameter->Set6WValveBVConnectID( m_str6WValveBvConnectID );
	pDestinationIndSelParameter->Set6WValveBVVersionID( m_str6WValveBvVersionID );
	pDestinationIndSelParameter->Set6WValveBVPNID( m_str6WValveBvPNID );

	// Version 29: smart control valve.
	pDestinationIndSelParameter->SetSmartControlValveRadioFlowPowerDT( m_iSmartControlValveRadioFlowPowerDT );
	pDestinationIndSelParameter->SetSmartControlValveBodyMaterialID( m_strSmartControlValveBodyMaterialID );
	pDestinationIndSelParameter->SetSmartControlValveConnectID( m_strSmartControlValveConnectID );
	pDestinationIndSelParameter->SetSmartControlValvePNID( m_strSmartControlValveVersionID );
	pDestinationIndSelParameter->SetSmartControlValveDpMaxCheckBox( m_iSmartControlValveDpMaxChecked );               // Version 32

	// Version 32: smart Dp.
	// HYS-1937: TA-Smart Dp - 04 - Individual selection: left tab.
	pDestinationIndSelParameter->SetSmartDpCRadioFlowPowerDT( m_iSmartDpCRadioFlowPowerDT );
	pDestinationIndSelParameter->SetSmartDpCDpBranchCheckBox( m_iSmartDpCDpBranchChecked );
	pDestinationIndSelParameter->SetSmartDpCDpMaxCheckBox( m_iSmartDpCDpMaxChecked );
	pDestinationIndSelParameter->SetSmartDpCBodyMaterialID( m_strSmartDpCBodyMaterialID );
	pDestinationIndSelParameter->SetSmartDpCConnectID( m_strSmartDpCConnectID );
	pDestinationIndSelParameter->SetSmartDpCPNID( m_strSmartDpCVersionID );
	// HYS-1938: TA-Smart Dp - 05 - Individual selection: right view
	// HYS-1992: Remove set possibility of TA Smart Dp.
	//pDestinationIndSelParameter->SetSmartDpCSetCheckBox( m_bSmartDpCCheckOnlyForSet );

	// HYS-1384: Version 30.
	for( auto &iterWindowID : m_mapShowHideAllPrioritiesState )
	{
		for( auto &iterStates : iterWindowID.second )
		{
			pDestinationIndSelParameter->SetWindowShowAllPrioritiesState( iterWindowID.first, iterStates.first, iterStates.second );
		}
	}
}

void CDS_IndSelParameter::SetWindowShowAllPrioritiesState( int iWindowID, int iButtonID, int iState )
{
	if( 0 == m_mapShowHideAllPrioritiesState.count( iWindowID ) )
	{
		std::map<int, int> mapValue;
		m_mapShowHideAllPrioritiesState.insert( std::pair<int, std::map<int, int>>( iWindowID, mapValue ) );
	}

	if( 0 == m_mapShowHideAllPrioritiesState[iWindowID].count( iButtonID ) )
	{
		m_mapShowHideAllPrioritiesState[iWindowID].insert( std::pair<int, int>( iButtonID, iState ) );
	}
	else
	{
		m_mapShowHideAllPrioritiesState[iWindowID][iButtonID] = iState;
	}
}

#define CDS_INDSELPARAMETER_VERSION	33
// Version 33: 2022-12-05: HYS-1992: Remove CheckBox set.
// Version 32: 2022-07-05: HYS-1937: TA-Smart Dp - 04 - Individual selection: left tab.
//                         HYS-1939: TA-Smart Dp - 06 - Individual selection: create the datastruct object. Add Dp max for smart valves selection.
// Version 31: 2022-06-01: HYS-1877 6-way valve set
// Version 30: 2021-04-01: HYS-1384: save all show/hide all priorities arrow states and 'm_fShowAllPriorities' deleted.
// Version 29: 2021-01-12: Add smart control valve.
// Version 28: 2020-01-27: Add m_iTrvRadioFlowPowerDT.
// Version 27: 2019-10-30: HYS-1146: Add 6-way control valves
// Version 26: Adding actuator's default return position
// Version 25: HYS-1058: we need to save pressurisation maintenance and water quality preferences.
// Version 24: 2018-11-21: Safety valve added.
// Version 23: 2016-09-12: Additional parameters for combined Dp controller, balancing and control valve.
// Version 22: 2016-07-05: Shut-off valve added.
// Version 21: 2015-11-17: Combined Dp controller and balancing & control valve added.
// Version 20: 'm_iPMWaterMakeUpChecked' replaced by 'm_strPMWaterMakeUpTypeID'.
// Version 19: Add 'Dp max' check box for DpC and PICV individual selection.
// Version 18: Pressure maintenance variables.
// Version 17: Add Flow/Power-DT radio state for all individual selection (Except trv) and add Dp checkbox state for BCV.
// Version 16: Separator added.
// Version 15: 'm_iSSelTrvInsertChecked' is replaced by 'm_iSSelTrvRadiatorValveType'.
void CDS_IndSelParameter::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_INDSELPARAMETER_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CData::Write( outf );

	// Write parameters for balancing valves.
	WriteData<>( outf, m_iBvDpChecked );
	WriteString( outf, m_strBvTypeID );
	WriteString( outf, m_strBvFamilyID );
	WriteString( outf, m_strBvMaterialID );
	WriteString( outf, m_strBvConnectID );
	WriteString( outf, m_strBvVersionID );
	WriteString( outf, m_strBvPNID );
	WriteString( outf, m_strPipeSeriesID );
	WriteString( outf, m_strPipeSizeID );

	// Write parameters for Dp controller.
	WriteData<>( outf, m_iDpCDpStab );
	WriteData<>( outf, m_iDpCMvLoc );
	WriteData<>( outf, m_iDpCDpChecked );

	// Write parameters for thermostatic and return valves.
	WriteData<>( outf, m_iTrvRadioFlowPowerDT ); // Version 28
	WriteData<>( outf, m_iTrvDpChecked );
	WriteString( outf, m_strTrvSVFamilyID );
	WriteString( outf, m_strTrvRVFamilyID );
	WriteString( outf, m_strTrvSVVersionID );
	WriteString( outf, m_strTrvRVVersionID );
	WriteString( outf, m_strTrvSVConnectID );
	WriteString( outf, m_strTrvRVConnectID );
	WriteData<>( outf, m_eTrvRVMode );

	// Write additional parameters for Dp controller.
	WriteString( outf,  m_strDpCTypeID );
	WriteString( outf,  m_strDpCConnectID );
	WriteString( outf,  m_strDpCPNID );

	// Write parameters for control valves.
	WriteData<>( outf, m_iCvCheckDpKvs );
	WriteData<>( outf, m_iCvRadioKvs );
	WriteData<>( outf, m_eCvCB2W3W );
	WriteString( outf, m_strCvTypeID );
	WriteData<>( outf, m_eCvCBCtrlType );
	WriteString( outf, m_strCvFamilyID );
	WriteString( outf, m_strCvMaterialID );
	WriteString( outf, m_strCvConnectID );
	WriteString( outf, m_strCvVersionID );
	WriteString( outf, m_strCvPNID );

	// Write additional parameter for thermostatic and return valves.
	// Remark: 'm_iSSelTrvThrmHeadChecked' has been replaced by 'm_iSSelActuatorType' in version 13.
	int iDummy = 0;
	WriteData<>( outf, iDummy );

	// Write parameters for pressure independent control valves.
	WriteString( outf, m_strPICvTypeID );
	WriteData<>( outf, m_ePICvCBCtrlType );
	WriteString( outf, m_strPICvFamilyID );
	WriteString( outf, m_strPICvMaterialID );
	WriteString( outf, m_strPICvConnectID );
	WriteString( outf, m_strPICvVersionID );
	WriteString( outf, m_strPICvPNID );

	// Write parameters for balancing and control valves.
	WriteData<>( outf, m_eBCV2W3W );
	WriteString( outf, m_strBCVTypeID );
	WriteData<>( outf, m_eBCVCBCtrlType );
	WriteString( outf, m_strBCVFamilyID );
	WriteString( outf, m_strBCVMaterialID );
	WriteString( outf, m_strBCVConnectID );
	WriteString( outf, m_strBCVVersionID );
	WriteString( outf, m_strBCVPNID );

	// Write additional parameters for Dp controller.
	WriteString( outf,  m_strDpCFamilyID );
	WriteString( outf,  m_strDpCMaterialID );
	WriteString( outf,  m_strDpCVersionID );
	WriteData<>( outf, m_iDpCPackageChecked );
	WriteData<>( outf, m_iDpCLocation );
	WriteData<>( outf, m_iDpCInfoWnd );

	// Write additional parameter for thermostatic and return valves.
	WriteData<>( outf, m_rTrvRadInfos );

	// Version 13.
	WriteData<>( outf, m_iTrvActuatorType );

	// Since version 15, 'm_iSSelTrvInsertChecked' has been replaced by 'm_iSSelTrvRadiatorValveType'.
	// When reading old project, we reject this value.
	WriteData<>( outf, m_iTrvRadiatorValveType );

	WriteString( outf, m_strTrvSVInsertName );
	WriteString( outf, m_strTrvSVInsertFamilyID );
	WriteString( outf, m_strTrvSVInsertTypeID );
	WriteData<>( outf, m_bTrvSVInsertInKv );
	WriteData<>( outf, m_dTrvSVInsertKvValue );
	WriteString( outf, m_strTrvRVInsertFamilyID );
	WriteString( outf, m_strTrvActuatorTypeID );
	WriteString( outf, m_strTrvActuatorFamilyID );
	WriteString( outf, m_strTrvActuatorVersionID );

	// Version 14. Adding actuators for CV, BCV and PICV.
	WriteString( outf, m_strCvActPowerSupplyID );
	WriteString( outf, m_strCvActInputSignalID );
	WriteData<>( outf, m_iCvFailSafeFct );
	WriteData<>( outf, m_iCvPackageChecked );

	WriteString( outf, m_strBCVActPowerSupplyID );
	WriteString( outf, m_strBCVActInputSignalID );
	WriteData<>( outf, m_iBCVFailSafeFct );
	WriteData<>( outf, m_iBCVPackageChecked );

	WriteString( outf, m_strPICvActPowerSupplyID );
	WriteString( outf, m_strPICvActInputSignalID );
	WriteData<>( outf, m_iPICvFailSafeFct );
	WriteData<>( outf, m_iPICvPackageChecked );

	// Version 16: Write parameters for separators.
	WriteString( outf, m_strSeparatorTypeID );
	WriteString( outf, m_strSeparatorFamilyID );
	WriteString( outf, m_strSeparatorConnectID );
	WriteString( outf, m_strSeparatorVersionID );

	// Version 17: Write all radio flow / Power-DT status.
	WriteData<>( outf, m_iBvRadioFlowPowerDT );
	WriteData<>( outf, m_iDpCRadioFlowPowerDT );
	WriteData<>( outf, m_iCvRadioFlowPowerDT );
	WriteData<>( outf, m_iPICvRadioFlowPowerDT );
	WriteData<>( outf, m_iBCVRadioFlowPowerDT );
	WriteData<>( outf, m_iBCVDpChecked );
	WriteData<>( outf, m_iSepRadioFlowPowerDT );

	// Version 18: Write all parameters for pressure maintenance.
	WriteData<>( outf, m_ePMApplicationType );
	WriteString( outf, m_strPMPressureMaintenanceTypeID );
	WriteData<>( outf, m_iPMDegassingChecked );
	WriteString( outf, m_strPMNorm );
	WriteData<>( outf, m_ePMPressOn );
	WriteData<>( outf, m_fPMWaterMakeupBreakTank );

	// Version 19: Dp max check box state for DpC and PICV individual selection.
	WriteData<>( outf, m_iDpCDpMaxChecked );
	WriteData<>( outf, m_iPICvDpMaxChecked );

	// Version 20: 'm_strPMWaterMakeUpTypeID'.
	WriteString( outf, m_strPMWaterMakeUpTypeID );

	// Version 21: Write parameters for combined Dp controller and balancing & control valves.
	WriteData<>( outf, m_iDpCBCVRadioFlowPowerDT );
	WriteData<>( outf, m_eDpCBCVCBCtrlType );
	WriteString( outf, m_strDpCBCVTypeID );
	WriteString( outf, m_strDpCBCVFamilyID );
	WriteString( outf, m_strDpCBCVMaterialID );
	WriteString( outf, m_strDpCBCVConnectID );
	WriteString( outf, m_strDpCBCVVersionID );
	WriteString( outf, m_strDpCBCVPNID );
	WriteString( outf, m_strDpCBCVActPowerSupplyID );
	WriteString( outf, m_strDpCBCVActInputSignalID );
	WriteData<>( outf, m_iDpCBCVFailSafeFct );
	WriteData<>( outf, m_iDpCBCVPackageChecked );
	WriteData<>( outf, m_iDpCBCVDpToStabilizeChecked );

	// Version 22: Write parameters for shut-off valves.
	WriteData<>( outf, m_iSvRadioFlowPowerDT );
	WriteString( outf, m_strSvTypeID );
	WriteString( outf, m_strSvFamilyID );
	WriteString( outf, m_strSvMaterialID );
	WriteString( outf, m_strSvConnectID );
	WriteString( outf, m_strSvVersionID );
	WriteString( outf, m_strSvPNID );

	// Version 23: Write additional parameters for combined Dp controller and balancing & control valves.
	WriteData<>( outf, m_iDpCBCVWithSTSChecked );
	WriteData<>( outf, m_iDpCBCVInfoWnd );

	// Version 24: Write parameters for safety valves.
	WriteData<>( outf, m_eSafetyValveSystemType );
	WriteString( outf, m_strSafetyValveSystemHeatGeneratorTypeID );
	WriteString( outf, m_strSafetyValveNormID );
	WriteString( outf, m_strSafetyValveFamilyID );
	WriteString( outf, m_strSafetyValveConnectionID );
	WriteData<>( outf, m_dSafetyValveSetPressure );

	// Version 25: HYS-1058: we need to write pressurisation maintenance and water quality preferences.
	m_pclPMWQPrefs->Write( outf );

	// Version 26: Adding actuator's default return position
	WriteData<>( outf, m_eCvDRPFct );
	WriteData<>( outf, m_eBCVDRPFct );
	WriteData<>( outf, m_ePICvDRPFct );
	WriteData<>( outf, m_eDpCBCVDRPFct );

	// Version 27: 6-way valve parameters
	WriteData<>( outf, m_e6WValveSelectionMode );
	WriteData<>( outf, m_i6WValveRadioFlowPowerDT );
	WriteString( outf, m_str6WValveConnectID );
	WriteString( outf, m_str6WValveVersionID );
	WriteData<>( outf, m_b6WValveCheckFastElectConnection );
	
	// PIBCV.
	WriteData<>( outf, m_bIs6WValvePICvDpMaxChecked );
	WriteData<>( outf, m_e6WValvePICvCBCtrlType );
	WriteString( outf, m_str6WValvePICvTypeID );
	WriteString( outf, m_str6WValvePICvFamilyID );
	WriteString( outf, m_str6WValvePICvMaterialID );
	WriteString( outf, m_str6WValvePICvConnectID );
	WriteString( outf, m_str6WValvePICvVersionID );
	WriteString( outf, m_str6WValvePICvPNID );
	WriteString( outf, m_str6WValvePICvActInputSignalID );
	
	// BV.
	WriteData<>( outf, m_bIs6WValveBvDpChecked );
	WriteString( outf, m_str6WValveBvTypeID );
	WriteString( outf, m_str6WValveBvFamilyID );
	WriteString( outf, m_str6WValveBvMaterialID );
	WriteString( outf, m_str6WValveBvConnectID );
	WriteString( outf, m_str6WValveBvVersionID );
	WriteString( outf, m_str6WValveBvPNID );

	// Version 29: smart control valve.
	WriteData<>( outf, m_iSmartControlValveRadioFlowPowerDT );
	WriteString( outf, m_strSmartControlValveBodyMaterialID );
	WriteString( outf, m_strSmartControlValveConnectID );
	WriteString( outf, m_strSmartControlValveVersionID );
	WriteData<>( outf, m_iSmartControlValveDpMaxChecked );      // Version 32

	// HYS-1384: Version 30.
	char cWindowIDNumbers = (char)m_mapShowHideAllPrioritiesState.size();
	WriteData<>( outf, cWindowIDNumbers );

	for( auto &iterWindowID : m_mapShowHideAllPrioritiesState )
	{
		WriteData<>( outf, iterWindowID.first );

		char cStatesNumber = (char)iterWindowID.second.size();
		WriteData<>( outf, cStatesNumber );

		for( auto &iterStates : iterWindowID.second )
		{
			WriteData<>( outf, iterStates.first );
			WriteData<>( outf, iterStates.second );
		}
	}
	// Version 31: HYS-1877
	WriteData<>( outf, m_b6WValveCheckOnlyForSet );

	// Version 32: HYS-1937: TA-Smart Dp - 04 - Individual selection: left tab..
	WriteData<>( outf, m_iSmartDpCRadioFlowPowerDT );
	WriteData<>( outf, m_iSmartDpCDpBranchChecked );
	WriteData<>( outf, m_iSmartDpCDpMaxChecked );            // HYS-1939
	WriteString( outf, m_strSmartDpCBodyMaterialID );
	WriteString( outf, m_strSmartDpCConnectID );
	WriteString( outf, m_strSmartDpCVersionID );
	// HYS-1938: (Version 33) TA-Smart Dp - 05 - Individual selection: right view
	//WriteData<>( outf, m_bSmartDpCCheckOnlyForSet );
}

bool CDS_IndSelParameter::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_INDSELPARAMETER_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_INDSELPARAMETER_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Read parameters for balancing valves.
	TCHAR dummy[_ID_LENGTH + 1];
	inpf.read( (char *)&m_iBvDpChecked, sizeof( m_iBvDpChecked ) );

	if( false == ReadString( inpf, m_strBvTypeID, sizeof( m_strBvTypeID ) ) )
	{
		return false;
	}

	if( Version > 7 )
	{
		if( false == ReadString( inpf, m_strBvFamilyID, sizeof( m_strBvFamilyID ) ) )
		{
			return false;
		}

		if( false == ReadString( inpf, m_strBvMaterialID, sizeof( m_strBvMaterialID ) ) )
		{
			return false;
		}
	}

	if( false == ReadString( inpf, m_strBvConnectID, sizeof( m_strBvConnectID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBvVersionID, sizeof( m_strBvVersionID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBvPNID, sizeof( m_strBvPNID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strPipeSeriesID, sizeof( m_strPipeSeriesID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strPipeSizeID, sizeof( m_strPipeSizeID ) ) )
	{
		return false;
	}

	// Read parameters for Dp controller.
	inpf.read( (char *)&m_iDpCDpStab, sizeof( m_iDpCDpStab ) );
	inpf.read( (char *)&m_iDpCMvLoc, sizeof( m_iDpCMvLoc ) );
	inpf.read( (char *)&m_iDpCDpChecked, sizeof( m_iDpCDpChecked ) );

	if( Version <= 5 )
	{
		for( int i = 0; i < 2; i++ )
		{
			if( false == ReadString( inpf, dummy, sizeof( dummy ) ) )
			{
				return false;
			}
		}
	}

	// Read parameters for thermostatic and return valves.

	if( Version >= 28 )
	{
		inpf.read( (char *)&m_iTrvRadioFlowPowerDT, sizeof( m_iTrvRadioFlowPowerDT ) );
	}

	inpf.read( (char *)&m_iTrvDpChecked, sizeof( m_iTrvDpChecked ) );

	if( Version <= 5 )
	{
		for( int i = 0; i < 2; i++ )
		{
			if( false == ReadString( inpf, dummy, sizeof( dummy ) ) )
			{
				return false;
			}
		}
	}

	if( false == ReadString( inpf, m_strTrvSVFamilyID, sizeof( m_strTrvSVFamilyID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strTrvRVFamilyID, sizeof( m_strTrvRVFamilyID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strTrvSVVersionID, sizeof( m_strTrvSVVersionID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strTrvRVVersionID, sizeof( m_strTrvRVVersionID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strTrvSVConnectID, sizeof( m_strTrvSVConnectID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strTrvRVConnectID, sizeof( m_strTrvRVConnectID ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_eTrvRVMode, sizeof( m_eTrvRVMode ) );

	if( 1 == Version )
	{
		return true;
	}

	// Read additional parameters for Dp controller.
	if( false == ReadString( inpf,  m_strDpCTypeID, sizeof( m_strDpCTypeID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf,  m_strDpCConnectID, sizeof( m_strDpCConnectID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf,  m_strDpCPNID, sizeof( m_strDpCPNID ) ) )
	{
		return false;
	}

	if( 2 == Version )
	{
		return true;
	}

	// Read parameters for control valves.
	inpf.read( (char *)&m_iCvCheckDpKvs, sizeof( m_iCvCheckDpKvs ) );
	inpf.read( (char *)&m_iCvRadioKvs, sizeof( m_iCvRadioKvs ) );
	inpf.read( (char *)&m_eCvCB2W3W, sizeof( m_eCvCB2W3W ) );

	if( false == ReadString( inpf, m_strCvTypeID, sizeof( m_strCvTypeID ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_eCvCBCtrlType, sizeof( m_eCvCBCtrlType ) );

	if( false == ReadString( inpf, m_strCvFamilyID, sizeof( m_strCvFamilyID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strCvMaterialID, sizeof( m_strCvMaterialID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strCvConnectID, sizeof( m_strCvConnectID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strCvVersionID, sizeof( m_strCvVersionID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strCvPNID, sizeof( m_strCvPNID ) ) )
	{
		return false;
	}

	if( Version <= 5 )
	{
		for( int i = 0; i < 2; i++ )
		{
			if( false == ReadString( inpf, dummy, sizeof( dummy ) ) )
			{
				return false;
			}
		}
	}

	if( 3 == Version )
	{
		return true;
	}

	// Read additional parameter for thermostatic and return valves.
	// Remark: 'm_iSSelTrvThrmHeadChecked' has been replaced by 'm_iSSelActuatorType' in version 13.
	//         For previous version, the default value for 'm_iSSelActuatorType' will be thermostatic head.
	int iDummy;
	inpf.read( (char *)&iDummy, sizeof( iDummy ) );

	if( 4 == Version )
	{
		return true;
	}

	// Read parameters for pressure independent control valves.
	if( false == ReadString( inpf, m_strPICvTypeID, sizeof( m_strPICvTypeID ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_ePICvCBCtrlType, sizeof( m_ePICvCBCtrlType ) );

	if( false == ReadString( inpf, m_strPICvFamilyID, sizeof( m_strPICvFamilyID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strPICvMaterialID, sizeof( m_strPICvMaterialID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strPICvConnectID, sizeof( m_strPICvConnectID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strPICvVersionID, sizeof( m_strPICvVersionID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strPICvPNID, sizeof( m_strPICvPNID ) ) )
	{
		return false;
	}

	if( Version <= 5 )
	{
		for( int i = 0; i < 2; i++ )
		{
			if( false == ReadString( inpf, dummy, sizeof( dummy ) ) )
			{
				return false;
			}
		}
	}

	if( 5 == Version )
	{
		return true;
	}

	// Read parameters for balancing and control valves.
	inpf.read( (char *)&m_eBCV2W3W, sizeof( m_eBCV2W3W ) );

	if( false == ReadString( inpf, m_strBCVTypeID, sizeof( m_strBCVTypeID ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_eBCVCBCtrlType, sizeof( m_eBCVCBCtrlType ) );

	if( false == ReadString( inpf, m_strBCVFamilyID, sizeof( m_strBCVFamilyID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBCVMaterialID, sizeof( m_strBCVMaterialID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBCVConnectID, sizeof( m_strBCVConnectID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBCVVersionID, sizeof( m_strBCVVersionID ) ) )
	{
		return false;
	}

	if( 6 == Version )
	{
		return true;
	}

	if( false == ReadString( inpf, m_strBCVPNID, sizeof( m_strBCVPNID ) ) )
	{
		return false;
	}

	// Read parameter common to all selections.

	// HYS-1384: this variable is no more existing.
	if( Version < 30 )
	{
		bool bDummy = false;
		inpf.read( (char *)&bDummy, sizeof( bDummy ) );
	}

	if( Version < 9 )
	{
		return true;
	}

	// Read additional parameters for Dp controller.
	if( false == ReadString( inpf,  m_strDpCFamilyID, sizeof( m_strDpCFamilyID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf,  m_strDpCMaterialID, sizeof( m_strDpCMaterialID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf,  m_strDpCVersionID, sizeof( m_strDpCVersionID ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_iDpCPackageChecked, sizeof( m_iDpCPackageChecked ) );

	if( Version < 11 )
	{
		return true;
	}

	inpf.read( (char *)&m_iDpCLocation, sizeof( m_iDpCLocation ) );
	inpf.read( (char *)&m_iDpCInfoWnd, sizeof( m_iDpCInfoWnd ) );

	if( Version < 12 )
	{
		return true;
	}

	// Read additional parameter for thermostatic and return valves.
	inpf.read( (char *)&m_rTrvRadInfos, sizeof( RadInfo_struct ) );

	if( Version < 13 )
	{
		return true;
	}

	// Read additional parameter for thermostatic and return valves.
	inpf.read( (char *)&m_iTrvActuatorType, sizeof( m_iTrvActuatorType ) );

	// Since version 15, 'm_iTrvInsertChecked' has been replaced by 'm_iTrvRadiatorValveType'. If version is
	// older, we don't care about the value.
	int iValue;
	inpf.read( (char *)&iValue, sizeof( iValue ) );

	if( Version >= 15 )
	{
		m_iTrvRadiatorValveType = iValue;
	}

	if( false == ReadString( inpf, m_strTrvSVInsertName, sizeof( m_strTrvSVInsertName ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strTrvSVInsertFamilyID, sizeof( m_strTrvSVInsertFamilyID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strTrvSVInsertTypeID, sizeof( m_strTrvSVInsertTypeID ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_bTrvSVInsertInKv, sizeof( m_bTrvSVInsertInKv ) );
	inpf.read( (char *)&m_dTrvSVInsertKvValue, sizeof( m_dTrvSVInsertKvValue ) );

	if( false == ReadString( inpf, m_strTrvRVInsertFamilyID, sizeof( m_strTrvRVInsertFamilyID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strTrvActuatorTypeID, sizeof( m_strTrvActuatorTypeID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strTrvActuatorFamilyID, sizeof( m_strTrvActuatorFamilyID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strTrvActuatorVersionID, sizeof( m_strTrvActuatorVersionID ) ) )
	{
		return false;
	}

	if( Version < 14 )
	{
		return true;
	}
	bool isDRPCvReaded = false;
	bool isDRPBCvReaded = false;
	bool isDRPPICvReaded = false;
	bool isDRPDPCBCvReaded = false;
	// Read additional parameter for control valves.
	if( false == ReadString( inpf, m_strCvActPowerSupplyID, sizeof( m_strCvActPowerSupplyID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strCvActInputSignalID, sizeof( m_strCvActInputSignalID ) ) )
	{
		return false;
	}
	if( Version >= 26 )
	{
		inpf.read( (char *)&m_iCvFailSafeFct, sizeof( m_iCvFailSafeFct ) );
	}
	else
	{
		inpf.read( (char *)&m_eCvDRPFct, sizeof( m_eCvDRPFct ) );
		m_iCvFailSafeFct = 0;
		isDRPCvReaded = true;
	}
	inpf.read( (char *)&m_iCvPackageChecked, sizeof( m_iCvPackageChecked ) );

	// Read additional parameter for balancing and control valves.
	if( false == ReadString( inpf, m_strBCVActPowerSupplyID, sizeof( m_strBCVActPowerSupplyID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBCVActInputSignalID, sizeof( m_strBCVActInputSignalID ) ) )
	{
		return false;
	}

	if( Version >= 26 )
	{
		inpf.read( (char *)&m_iBCVFailSafeFct, sizeof( m_iBCVFailSafeFct ) );
	}
	else
	{
		inpf.read( (char *)&m_eBCVDRPFct, sizeof( m_eBCVDRPFct ) );
		isDRPBCvReaded = true;
		m_iBCVFailSafeFct = 0;
	}
	inpf.read( (char *)&m_iBCVPackageChecked, sizeof( m_iBCVPackageChecked ) );

	// Read additional parameter for pressure independent and control valves.
	if( false == ReadString( inpf, m_strPICvActPowerSupplyID, sizeof( m_strPICvActPowerSupplyID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strPICvActInputSignalID, sizeof( m_strPICvActInputSignalID ) ) )
	{
		return false;
	}

	if( Version >= 26 )
	{
		inpf.read( (char *)&m_iPICvFailSafeFct, sizeof( m_iPICvFailSafeFct ) );
	}
	else
	{
		inpf.read( (char *)&m_ePICvDRPFct, sizeof( m_ePICvDRPFct ) );
		isDRPPICvReaded = true;
		m_iPICvFailSafeFct = 0;
	}
	inpf.read( (char *)&m_iPICvPackageChecked, sizeof( m_iPICvPackageChecked ) );

	if( Version < 16 )
	{
		return true;
	}

	// Read additional parameters for separators.
	if( false == ReadString( inpf,  m_strSeparatorTypeID, sizeof( m_strSeparatorTypeID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf,  m_strSeparatorFamilyID, sizeof( m_strSeparatorFamilyID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf,  m_strSeparatorConnectID, sizeof( m_strSeparatorConnectID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf,  m_strSeparatorVersionID, sizeof( m_strSeparatorVersionID ) ) )
	{
		return false;
	}

	if( Version < 17 )
	{
		return true;
	}

	// Version 17: Read all radio flow / Power-DT states and Dp checkbox state for BCV.
	inpf.read( (char *)&m_iBvRadioFlowPowerDT, sizeof( m_iBvRadioFlowPowerDT ) );
	inpf.read( (char *)&m_iDpCRadioFlowPowerDT, sizeof( m_iDpCRadioFlowPowerDT ) );
	inpf.read( (char *)&m_iCvRadioFlowPowerDT, sizeof( m_iCvRadioFlowPowerDT ) );
	inpf.read( (char *)&m_iPICvRadioFlowPowerDT, sizeof( m_iPICvRadioFlowPowerDT ) );
	inpf.read( (char *)&m_iBCVRadioFlowPowerDT, sizeof( m_iBCVRadioFlowPowerDT ) );
	inpf.read( (char *)&m_iBCVDpChecked, sizeof( m_iBCVDpChecked ) );
	inpf.read( (char *)&m_iSepRadioFlowPowerDT, sizeof( m_iSepRadioFlowPowerDT ) );

	if( Version < 18 )
	{
		return true;
	}

	// Version 18: Read all parameters for pressure maintenance.
	inpf.read( (char *)&m_ePMApplicationType, sizeof( m_ePMApplicationType ) );

	if( false == ReadString( inpf,  m_strPMPressureMaintenanceTypeID, sizeof( m_strPMPressureMaintenanceTypeID ) ) )
	{
		return false;
	}

	// Version 20: 'm_iPMWaterMakeUpChecked' has been replaced by 'm_strPMWaterMakeUpTypeID'.
	if( Version < 20 )
	{
		int iDummy = 0;
		inpf.read( (char *)&iDummy, sizeof( iDummy ) );
	}

	inpf.read( (char *)&m_iPMDegassingChecked, sizeof( m_iPMDegassingChecked ) );

	if( false == ReadString( inpf, m_strPMNorm, sizeof( m_strPMNorm ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_ePMPressOn, sizeof( m_ePMPressOn ) );
	inpf.read( (char *)&m_fPMWaterMakeupBreakTank, sizeof( m_fPMWaterMakeupBreakTank ) );

	if( Version < 19 )
	{
		return true;
	}

	// Version 19: Dp max check box state for DpC and PICV individual selection.
	inpf.read( (char *)&m_iDpCDpMaxChecked, sizeof( m_iDpCDpMaxChecked ) );
	inpf.read( (char *)&m_iPICvDpMaxChecked, sizeof( m_iPICvDpMaxChecked ) );

	if( Version < 20 )
	{
		return true;
	}

	// Version 20: 'm_iPMWaterMakeUpChecked' has been replaced by 'm_strPMWaterMakeUpTypeID'.
	if( false == ReadString( inpf,  m_strPMWaterMakeUpTypeID, sizeof( m_strPMWaterMakeUpTypeID ) ) )
	{
		return false;
	}

	if( Version < 21 )
	{
		return true;
	}

	// Read parameters for combined Dp controller and balancing & control valves.
	inpf.read( (char *)&m_iDpCBCVRadioFlowPowerDT, sizeof( m_iDpCBCVRadioFlowPowerDT ) );
	inpf.read( (char *)&m_eDpCBCVCBCtrlType, sizeof( m_eDpCBCVCBCtrlType ) );

	if( false == ReadString( inpf, m_strDpCBCVTypeID, sizeof( m_strDpCBCVTypeID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCBCVFamilyID, sizeof( m_strDpCBCVFamilyID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCBCVMaterialID, sizeof( m_strDpCBCVMaterialID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCBCVConnectID, sizeof( m_strDpCBCVConnectID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCBCVVersionID, sizeof( m_strDpCBCVVersionID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCBCVPNID, sizeof( m_strDpCBCVPNID ) ) )
	{
		return false;
	}

	// Read additional parameter for pressure independent and control valves.
	if( false == ReadString( inpf, m_strDpCBCVActPowerSupplyID, sizeof( m_strDpCBCVActPowerSupplyID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCBCVActInputSignalID, sizeof( m_strDpCBCVActInputSignalID ) ) )
	{
		return false;
	}

	if( Version >= 26 )
	{
		inpf.read( (char *)&m_iDpCBCVFailSafeFct, sizeof( m_iDpCBCVFailSafeFct ) );
	}
	else
	{
		inpf.read( (char *)&m_eDpCBCVDRPFct, sizeof( m_eDpCBCVDRPFct ) );
		isDRPDPCBCvReaded = true;
		m_iDpCBCVFailSafeFct = 0;
	}
	inpf.read( (char *)&m_iDpCBCVPackageChecked, sizeof( m_iDpCBCVPackageChecked ) );
	inpf.read( (char *)&m_iDpCBCVDpToStabilizeChecked, sizeof( m_iDpCBCVDpToStabilizeChecked ) );

	if( Version < 22 )
	{
		return true;
	}

	// Read parameters for shut-off valves.
	inpf.read( (char *)&m_iSvRadioFlowPowerDT, sizeof( m_iSvRadioFlowPowerDT ) );

	if( false == ReadString( inpf, m_strSvTypeID, sizeof( m_strSvTypeID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strSvFamilyID, sizeof( m_strSvFamilyID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strSvMaterialID, sizeof( m_strSvMaterialID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strSvConnectID, sizeof( m_strSvConnectID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strSvVersionID, sizeof( m_strSvVersionID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strSvPNID, sizeof( m_strSvPNID ) ) )
	{
		return false;
	}

	if( Version < 23 )
	{
		return true;
	}

	// Version 23: Read additional parameters for combined Dp controller and balancing & control valves.
	inpf.read( (char *)&m_iDpCBCVWithSTSChecked, sizeof( m_iDpCBCVWithSTSChecked ) );
	inpf.read( (char *)&m_iDpCBCVInfoWnd, sizeof( m_iDpCBCVInfoWnd ) );
	
	if( Version < 24 )
	{
		return true;
	}

	// Version 24: Read parameters for safety valves.
	inpf.read( (char *)&m_eSafetyValveSystemType, sizeof( m_eSafetyValveSystemType ) );

	if( false == ReadString( inpf, m_strSafetyValveSystemHeatGeneratorTypeID, sizeof( m_strSafetyValveSystemHeatGeneratorTypeID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strSafetyValveNormID, sizeof( m_strSafetyValveNormID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strSafetyValveFamilyID, sizeof( m_strSafetyValveFamilyID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strSafetyValveConnectionID, sizeof( m_strSafetyValveConnectionID ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_dSafetyValveSetPressure, sizeof( m_dSafetyValveSetPressure ) );

	if( Version < 25 )
	{
		return true;
	}

	// Version 25: HYS-1058: we need to read pressurisation maintenance and water quality preferences.
	m_pclPMWQPrefs->Read( inpf );

	if( Version < 26 )
	{
		return true;
	}

	// Version 26: Adding actuator's default return position
	if( false == isDRPCvReaded )
	{
		inpf.read( (char *)&m_eCvDRPFct, sizeof( m_eCvDRPFct ) );
	}

	if( false == isDRPBCvReaded )
	{
		inpf.read( (char *)&m_eBCVDRPFct, sizeof( m_eBCVDRPFct ) );
	}

	if( false == isDRPPICvReaded )
	{
		inpf.read( (char *)&m_ePICvDRPFct, sizeof( m_ePICvDRPFct ) );
	}

	if( false == isDRPDPCBCvReaded )
	{
		inpf.read( (char *)&m_eDpCBCVDRPFct, sizeof( m_eDpCBCVDRPFct ) );
	}

	if( Version < 27 )
	{
		return true;
	}

	// Version 27: 6-way.
	inpf.read( (char *)&m_e6WValveSelectionMode, sizeof( m_e6WValveSelectionMode ) );
	inpf.read( (char *)&m_i6WValveRadioFlowPowerDT, sizeof( m_i6WValveRadioFlowPowerDT ) );
	
	if( false == ReadString( inpf, m_str6WValveConnectID, sizeof( m_str6WValveConnectID ) ) )
	{
		return false;
	}
	
	if( false == ReadString( inpf, m_str6WValveVersionID, sizeof( m_str6WValveVersionID ) ) )
	{
		return false;
	}
	
	inpf.read( (char *)&m_b6WValveCheckFastElectConnection, sizeof( m_b6WValveCheckFastElectConnection ) );

	// PIBCV.
	inpf.read( (char *)&m_bIs6WValvePICvDpMaxChecked, sizeof( m_bIs6WValvePICvDpMaxChecked ) );
	inpf.read( (char *)&m_e6WValvePICvCBCtrlType, sizeof( m_e6WValvePICvCBCtrlType ) );
	
	if( false == ReadString( inpf, m_str6WValvePICvTypeID, sizeof( m_str6WValvePICvTypeID ) ) )
	{
		return false;
	}
	
	if( false == ReadString( inpf, m_str6WValvePICvFamilyID, sizeof( m_str6WValvePICvFamilyID ) ) )
	{
		return false;
	}
	
	if( false == ReadString( inpf, m_str6WValvePICvMaterialID, sizeof( m_str6WValvePICvMaterialID ) ) )
	{
		return false;
	}
	
	if( false == ReadString( inpf, m_str6WValvePICvConnectID, sizeof( m_str6WValvePICvConnectID ) ) )
	{
		return false;
	}
	
	if( false == ReadString( inpf, m_str6WValvePICvVersionID, sizeof( m_str6WValvePICvVersionID ) ) )
	{
		return false;
	}
	
	if( false == ReadString( inpf, m_str6WValvePICvPNID, sizeof( m_str6WValvePICvPNID ) ) )
	{
		return false;
	}
	
	if( false == ReadString( inpf, m_str6WValvePICvActInputSignalID, sizeof( m_str6WValvePICvActInputSignalID ) ) )
	{
		return false;
	}
	
	// BV.
	inpf.read( (char *)&m_bIs6WValveBvDpChecked, sizeof( m_bIs6WValveBvDpChecked ) );
	
	if( false == ReadString( inpf, m_str6WValveBvTypeID, sizeof( m_str6WValveBvTypeID ) ) )
	{
		return false;
	}
	
	if( false == ReadString( inpf, m_str6WValveBvFamilyID, sizeof( m_str6WValveBvFamilyID ) ) )
	{
		return false;
	}
	
	if( false == ReadString( inpf, m_str6WValveBvMaterialID, sizeof( m_str6WValveBvMaterialID ) ) )
	{
		return false;
	}
	
	if( false == ReadString( inpf, m_str6WValveBvConnectID, sizeof( m_str6WValveBvConnectID ) ) )
	{
		return false;
	}
	
	if( false == ReadString( inpf, m_str6WValveBvVersionID, sizeof( m_str6WValveBvVersionID ) ) )
	{
		return false;
	}
	
	if( false == ReadString( inpf, m_str6WValveBvPNID, sizeof( m_str6WValveBvPNID ) ) )
	{
		return false;
	}

	if( Version < 29 )
	{
		return true;
	}

	// Version 29: smart control valve.
	inpf.read( (char *)&m_iSmartControlValveRadioFlowPowerDT, sizeof( m_iSmartControlValveRadioFlowPowerDT ) );

	if( false == ReadString( inpf, m_strSmartControlValveBodyMaterialID, sizeof( m_strSmartControlValveBodyMaterialID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strSmartControlValveConnectID, sizeof( m_strSmartControlValveConnectID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strSmartControlValveVersionID, sizeof( m_strSmartControlValveVersionID ) ) )
	{
		return false;
	}

	if( Version < 30 )
	{
		return true;
	}

	// HYS-1939: TA-Smart Dp - 06 - Individual selection: create the datastruct object.
	if( Version >= 32 )
	{
		inpf.read( (char*)&m_iSmartControlValveDpMaxChecked, sizeof( m_iSmartControlValveDpMaxChecked ) );
	}

	// HYS-1384: Version 30.
	m_mapShowHideAllPrioritiesState.clear();

	char cWindowIDNumbers;
	inpf.read( (char *)&cWindowIDNumbers, sizeof( cWindowIDNumbers ) );

	for( char cLoopWindowID = 0; cLoopWindowID < cWindowIDNumbers; cLoopWindowID++ )
	{
		int iWindowID = 0;
		inpf.read( (char *)&iWindowID, sizeof( iWindowID ) );

		char cStateNumbers = 0;
		inpf.read( (char *)&cStateNumbers, sizeof( cStateNumbers ) );

		std::map<int, int> mapRead;

		for( char cLoopState = 0; cLoopState < cStateNumbers; cLoopState++ )
		{
			int iButtonID = 0;
			inpf.read( (char *)&iButtonID, sizeof( iButtonID ) );

			int iState = 0;
			inpf.read( (char *)&iState, sizeof( iState ) );
			mapRead.insert( std::pair<int, int>( iButtonID, iState ) );
		}

		m_mapShowHideAllPrioritiesState.insert( std::pair<int, std::map<int, int>>( iWindowID, mapRead ) );
	}

	// HYS-1877
	if( Version < 31 )
	{
		return true;
	}

	inpf.read( (char*)&m_b6WValveCheckOnlyForSet, sizeof( m_b6WValveCheckOnlyForSet ) );


	if( Version < 32 )
	{
		return true;
	}

	// Version 32: HYS-1937: TA-Smart Dp - 04 - Individual selection: left tab.
	inpf.read( (char*)&m_iSmartDpCRadioFlowPowerDT, sizeof( m_iSmartDpCRadioFlowPowerDT ) );
	inpf.read( (char*)&m_iSmartDpCDpBranchChecked, sizeof( m_iSmartDpCDpBranchChecked ) );
	// HYS-1939: TA-Smart Dp - 06 - Individual selection: create the datastruct object.
	inpf.read( (char*)&m_iSmartDpCDpMaxChecked, sizeof( m_iSmartDpCDpMaxChecked ) );

	if( false == ReadString( inpf, m_strSmartDpCBodyMaterialID, sizeof( m_strSmartDpCBodyMaterialID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strSmartDpCConnectID, sizeof( m_strSmartDpCConnectID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strSmartDpCVersionID, sizeof( m_strSmartDpCVersionID ) ) )
	{
		return false;
	}
	// HYS-1992: Remove checkbox set.
	if( Version == 32 )
	{
		// HYS-1938: TA-Smart Dp - 05 - Individual selection: right view
		inpf.read( (char*)&m_bSmartDpCCheckOnlyForSet, sizeof( m_bSmartDpCCheckOnlyForSet ) );
	}

	return true;
}

void CDS_IndSelParameter::SetPMWQPrefs( CPMWQPrefs *pclPMWQPrefs )
{ 
	m_pclPMWQPrefs->CopyFrom( pclPMWQPrefs );
}

void CDS_IndSelParameter::WriteToRegistry()
{
	CDS_SelParameterBase::WriteToRegistry();

	// Write parameters common to all selections.
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PipeNameID"), m_strPipeSeriesID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PipeSizeID"), m_strPipeSizeID );

	// Write parameters for balancing valves.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("BvRadioFlowPowerDT"), m_iBvRadioFlowPowerDT );					// Version 17.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("BvDpCheckBox"), m_iBvDpChecked );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BvTypeID"), m_strBvTypeID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BvFamilyID"), m_strBvFamilyID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BvMaterialID"), m_strBvMaterialID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BvConnectID"), m_strBvConnectID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BvVersionID"), m_strBvVersionID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BvPNID"), m_strBvPNID );

	// Write parameters for Dp controller.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("DpCRadioFlowPowerDT"), m_iDpCRadioFlowPowerDT );					// Version 17.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("DpCDpStab"), m_iDpCDpStab );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("DpCMvLoc"), m_iDpCMvLoc );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("DpCLoc"), m_iDpCLocation );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("DpCDpChecked"), m_iDpCDpChecked );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("DpCDpMaxChecked"), m_iDpCDpMaxChecked );							// Version 19.
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCTypeID"),  m_strDpCTypeID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCFamilyID"),  m_strDpCFamilyID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCMaterialID"),  m_strDpCMaterialID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCConnectID"),  m_strDpCConnectID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCVersionID"),  m_strDpCVersionID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCPNID"),  m_strDpCPNID );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("DpCPackageChecked"), m_iDpCPackageChecked );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("DpCInfoWnd"), m_iDpCInfoWnd );

	// Write parameters for thermostatic and return valves.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T( "TrvRadioFlowPowerDT" ), m_iTrvRadioFlowPowerDT );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("TrvDpCheckBox"), m_iTrvDpChecked );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("TrvActuatorType"), m_iTrvActuatorType );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("TrvRadiatorValveType"), m_iTrvRadiatorValveType );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("TrvFamilyID"), m_strTrvSVFamilyID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("TrvVersionID"), m_strTrvSVVersionID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("TrvConnectID"), m_strTrvSVConnectID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("TrvRVFamilyID"), m_strTrvRVFamilyID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("TrvRVVersionID"), m_strTrvRVVersionID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("TrvRVConnectID"), m_strTrvRVConnectID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("TrvSVInsertName"), m_strTrvSVInsertName );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("TrvSVInsertFamilyID"), m_strTrvSVInsertFamilyID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("TrvSVInsertTypeID"), m_strTrvSVInsertTypeID );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("TrvSVInsertInKv"), ( true == m_bTrvSVInsertInKv ) ? 1 : 0 );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("TrvSVInsertKvValue"), WriteDouble( m_dTrvSVInsertKvValue, 14, 0 ) );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("TrvRVInsertFamilyID"), m_strTrvRVInsertFamilyID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("TrvActuatorTypeID"), m_strTrvActuatorTypeID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("TrvActuatorFamilyID"), m_strTrvActuatorFamilyID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("TrvActuatorVersionID"), m_strTrvActuatorVersionID );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("TrvRVMode"), m_eTrvRVMode );

	// Write radiator infos.
	CString RadInfosSectionName = m_strSectionName + _T("\\RadInfos");
	::AfxGetApp()->WriteProfileString( RadInfosSectionName, _T("Flow"), WriteDouble( m_rTrvRadInfos.dFlow, 14, 0 ) );
	::AfxGetApp()->WriteProfileInt( RadInfosSectionName, _T("AvailableDpChecked"), m_rTrvRadInfos.bAvailableDpChecked );
	::AfxGetApp()->WriteProfileString( RadInfosSectionName, _T("AvailableDp"), WriteDouble( m_rTrvRadInfos.dAvailableDp, 14, 0 ) );
	::AfxGetApp()->WriteProfileString( RadInfosSectionName, _T("SupplyTemperature"), WriteDouble( m_rTrvRadInfos.dSupplyTemperature, 14, 0 ) );
	::AfxGetApp()->WriteProfileString( RadInfosSectionName, _T("ReturnTemperature"), WriteDouble( m_rTrvRadInfos.dReturnTemperature, 14, 0 ) );
	::AfxGetApp()->WriteProfileString( RadInfosSectionName, _T("RoomTemperature"), WriteDouble( m_rTrvRadInfos.dRoomTemperature, 14, 0 ) );
	::AfxGetApp()->WriteProfileString( RadInfosSectionName, _T("RequiredHeatOutput"), WriteDouble( m_rTrvRadInfos.dRequiredHeatOutput, 14, 0 ) );
	::AfxGetApp()->WriteProfileString( RadInfosSectionName, _T("MinPower"), WriteDouble( m_rTrvRadInfos.dMinPower, 14, 0 ) );
	::AfxGetApp()->WriteProfileString( RadInfosSectionName, _T("RecommendedPower"), WriteDouble( m_rTrvRadInfos.dRecommendedPower, 14, 0 ) );
	::AfxGetApp()->WriteProfileString( RadInfosSectionName, _T("InstalledPower"), WriteDouble( m_rTrvRadInfos.dInstalledPower, 14, 0 ) );
	::AfxGetApp()->WriteProfileString( RadInfosSectionName, _T("MinDT"), WriteDouble( m_rTrvRadInfos.dMinDT, 14, 0 ) );
	::AfxGetApp()->WriteProfileString( RadInfosSectionName, _T("RequiredDT"), WriteDouble( m_rTrvRadInfos.dRequiredDT, 14, 0 ) );
	::AfxGetApp()->WriteProfileString( RadInfosSectionName, _T("NCSupplyT"), WriteDouble( m_rTrvRadInfos.dNCSupplyT, 14, 0 ) );
	::AfxGetApp()->WriteProfileString( RadInfosSectionName, _T("NCReturnT"), WriteDouble( m_rTrvRadInfos.dNCReturnT, 14, 0 ) );
	::AfxGetApp()->WriteProfileString( RadInfosSectionName, _T("NCRoomT"), WriteDouble( m_rTrvRadInfos.dNCRoomT, 14, 0 ) );

	// Write parameters for control valves.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("CvRadioFlowPowerDT"), m_iCvRadioFlowPowerDT );					// Version 17.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("CvCB2W3W"), m_eCvCB2W3W );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("CvCBCtrlType"), m_eCvCBCtrlType );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("CvCheckDpKvs"), m_iCvCheckDpKvs );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("CvRadioKvs"), m_iCvRadioKvs );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("CvCBTypeID"), m_strCvTypeID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("CvFamilyID"), m_strCvFamilyID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("CvMaterialID"), m_strCvMaterialID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("CvConnectID"), m_strCvConnectID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("CvVersionID"), m_strCvVersionID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("CvPNID"), m_strCvPNID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("CvActPowerSupplyID"), m_strCvActPowerSupplyID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("CvActInputSignalID"), m_strCvActInputSignalID );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("CvFailSafeFct"), m_iCvFailSafeFct );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("CvDRPFct"), m_eCvDRPFct );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("CvPackageChecked"), m_iCvPackageChecked );

	// Write parameters for pressure independent control valves.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("PICvRadioFlowPowerDT"), m_iPICvRadioFlowPowerDT );				// Version 17.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("PICvCBCtrlType"), m_ePICvCBCtrlType );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PICvCBTypeID"), m_strPICvTypeID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PICvFamilyID"), m_strPICvFamilyID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PICvMaterialID"), m_strPICvMaterialID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PICvConnectID"), m_strPICvConnectID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PICvVersionID"), m_strPICvVersionID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PICvPNID"), m_strPICvPNID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PICvActPowerSupplyID"), m_strPICvActPowerSupplyID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PICvActInputSignalID"), m_strPICvActInputSignalID );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("PICvFailSafeFct"), m_iPICvFailSafeFct );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("PICvDRPFct"), m_ePICvDRPFct );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("PICvPackageChecked"), m_iPICvPackageChecked );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("PICvDpMaxChecked"), m_iPICvDpMaxChecked );						// Version 19.

	// Write parameters for balancing and control valves.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("BCVRadioFlowPowerDT"), m_iBCVRadioFlowPowerDT );				// Version 17.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("BCVDpChecked"), m_iBCVDpChecked );								// Version 17.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("BCVCB2W3W"), m_eBCV2W3W );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("BCVCBCtrlType"), m_eBCVCBCtrlType );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BCVCBTypeID"), m_strBCVTypeID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BCVCBFamilyID"), m_strBCVFamilyID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BCVCBMaterialID"), m_strBCVMaterialID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BCVCBConnectID"), m_strBCVConnectID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BCVCBVersionID"), m_strBCVVersionID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BCVCBPNID"), m_strBCVPNID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BCVActPowerSupplyID"), m_strBCVActPowerSupplyID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BCVActInputSignalID"), m_strBCVActInputSignalID );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("BCVFailSafeFct"), m_iBCVFailSafeFct );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("BCVDRPFct"), m_eBCVDRPFct );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("BCVPackageChecked"), m_iBCVPackageChecked );

	// Write parameters for separators.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("SepRadioFlowPowerDT"), m_iSepRadioFlowPowerDT );					// Version 17.
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SeparatorTypeID"), m_strSeparatorTypeID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SeparatorFamilyID"), m_strSeparatorFamilyID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SeparatorConnectID"), m_strSeparatorConnectID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SeparatorVersionID"), m_strSeparatorVersionID );

	// Write parameters for for pressure maintenance.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("PMApplicationType"), m_ePMApplicationType );									// Version 18.
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PMPressureMaintenanceTypeID"), m_strPMPressureMaintenanceTypeID );			// Version 18.
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PMWaterMakeUpID"), m_strPMWaterMakeUpTypeID );									// Version 20.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("PMDegassingChecked"), m_iPMDegassingChecked );									// Version 18.
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PMNorm"), m_strPMNorm );														// Version 18.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("PMPressOn"), m_ePMPressOn );													// Version 18.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("PMWaterMakeupBreakTank"), m_fPMWaterMakeupBreakTank );

	// Write parameters for combined Dp controller and balancing & control valves.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("DpCBCVRadioFlowPowerDT"), m_iDpCBCVRadioFlowPowerDT );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("DpCBCVCBCtrlType"), m_eDpCBCVCBCtrlType );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCBCVCBTypeID"), m_strDpCBCVTypeID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCBCVFamilyID"), m_strDpCBCVFamilyID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCBCVMaterialID"), m_strDpCBCVMaterialID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCBCVConnectID"), m_strDpCBCVConnectID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCBCVVersionID"), m_strDpCBCVVersionID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCBCVPNID"), m_strDpCBCVPNID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCBCVActPowerSupplyID"), m_strDpCBCVActPowerSupplyID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCBCVActInputSignalID"), m_strDpCBCVActInputSignalID );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("DpCBCVFailSafeFct"), m_iDpCBCVFailSafeFct );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("DpCBCVDRPFct"), m_eDpCBCVDRPFct );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("DpCBCVPackageChecked"), m_iDpCBCVPackageChecked );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("DpCBCVDpToStabilizeChecked"), m_iDpCBCVDpToStabilizeChecked );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("DpCBCVWithSTSChecked"), m_iDpCBCVWithSTSChecked );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("DpCBCVInfoWnd"), m_iDpCBCVInfoWnd );

	// Write parameters for shut-off valves.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("SvRadioFlowPowerDT"), m_iSvRadioFlowPowerDT );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SvCBTypeID"), m_strSvTypeID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SvFamilyID"), m_strSvFamilyID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SvMaterialID"), m_strSvMaterialID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SvConnectID"), m_strSvConnectID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SvVersionID"), m_strSvVersionID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SvPNID"), m_strSvPNID );

	// Write parameters for safety valves.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("SafetyValveSystemType"), m_eSafetyValveSystemType );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SafetyValveSystemHeatGeneratorTypeID"), m_strSafetyValveSystemHeatGeneratorTypeID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SafetyValveNormID"), m_strSafetyValveNormID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SafetyValveTypeID"), m_strSafetyValveFamilyID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SafetyValveConnectionID"), m_strSafetyValveConnectionID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SafetyValveSetPressure"), WriteDouble( m_dSafetyValveSetPressure, 14, 0 ) );

	// Version 25: HYS-1058: we need to write pressurisation maintenance and water quality preferences in the registry.
	m_pclPMWQPrefs->WriteToRegistry( m_strSectionName );

	// Version 27: 6-way.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("6WSelectionMode"), m_e6WValveSelectionMode );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("6WRadioFlowPowerDT"), m_i6WValveRadioFlowPowerDT );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("6WFamilyID"), m_str6WValveConnectID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("6WVersionID"), m_str6WValveVersionID );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("6WCheckFastElectConnection"), m_b6WValveCheckFastElectConnection );
	// Version 31: HYS-1877
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("6WCheckOnlyForSet"), m_b6WValveCheckOnlyForSet );
	// PIBCV.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("6WPICvDpMaxChecked"), m_bIs6WValvePICvDpMaxChecked );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("6WPICvCBCtrlType"), m_e6WValvePICvCBCtrlType );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("6WPICvTypeID"), m_str6WValvePICvTypeID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("6WPICvFamilyID"), m_str6WValvePICvFamilyID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("6WPICvMaterialID"), m_str6WValvePICvMaterialID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("6WPICvConnectID"), m_str6WValvePICvConnectID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("6WPICvVersionID"), m_str6WValvePICvVersionID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("6WPICvPNID"), m_str6WValvePICvPNID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("6WPICvActInputSignalID"), m_str6WValvePICvActInputSignalID );
	// BV.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("6WBvDpEnabled"), m_bIs6WValveBvDpChecked );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("6WBvTypeID"), m_str6WValveBvTypeID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("6WBvFamilyID"), m_str6WValveBvFamilyID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("6WBvMaterialID"), m_str6WValveBvMaterialID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("6WBvConnectID"), m_str6WValveBvConnectID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("6WBvVersionID"), m_str6WValveBvVersionID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("6WBvPNID"), m_str6WValveBvPNID );

	// Version 29: smart control valve.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("SmartControlValveRadioFlowPowerDT"), m_iSmartControlValveRadioFlowPowerDT );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SmartControlValveBodyMaterialID"), m_strSmartControlValveBodyMaterialID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SmartControlValveConnectID"), m_strSmartControlValveConnectID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SmartControlValveVersionID"), m_strSmartControlValveVersionID );
	// HYS-1939: TA-Smart Dp - 06 - Individual selection: create the datastruct object.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T( "SmartControlValveDpMaxChecked" ), m_iSmartControlValveDpMaxChecked );

	// Version 32: HYS-1937: TA-Smart Dp - 04 - Individual selection: left tab.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T( "SmartDpCRadioFlowPowerDT" ), m_iSmartDpCRadioFlowPowerDT );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T( "SmartDpCDpBranchChecked" ), m_iSmartDpCDpBranchChecked );
	// HYS-1939: TA-Smart Dp - 06 - Individual selection: create the datastruct object.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T( "SmartDpCDpMaxChecked" ), m_iSmartDpCDpMaxChecked );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T( "SmartDpCBodyMaterialID" ), m_strSmartDpCBodyMaterialID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T( "SmartDpCConnectID" ), m_strSmartDpCConnectID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T( "SmartDpCVersionID" ), m_strSmartDpCVersionID );
	// HYS-1938: TA-Smart Dp - 05 - Individual selection: right view
	// HYS-1992: Remove set possibility of TA Smart Dp.
	//::AfxGetApp()->WriteProfileInt( m_strSectionName, _T( "SmartDpCCheckOnlyForSet" ), m_bSmartDpCCheckOnlyForSet );

	// HYS-1384: Version 30.
	CMemFile clMapShowAllStates;
	char cWindowIDNumbers = (char)m_mapShowHideAllPrioritiesState.size();
	clMapShowAllStates.Write( &cWindowIDNumbers, sizeof( cWindowIDNumbers ) );

	for( auto &iterWindowID : m_mapShowHideAllPrioritiesState )
	{
		clMapShowAllStates.Write( &iterWindowID.first, sizeof( iterWindowID.first ) );
		
		char cStatesNumber = (char)iterWindowID.second.size();
		clMapShowAllStates.Write( &cStatesNumber, sizeof( cStatesNumber ) );
		
		for( auto &iterStates : iterWindowID.second )
		{
			clMapShowAllStates.Write( &iterStates.first, sizeof( iterStates.first ) );
			clMapShowAllStates.Write( &iterStates.second, sizeof( iterStates.second ) );
		}
	}

	CString strEntryName( _T("ShowAllPrioritiesStates") );
	UINT uiLength = (UINT)clMapShowAllStates.GetLength();
	BYTE *pbBuffer = clMapShowAllStates.Detach();
	::AfxGetApp()->WriteProfileBinary( m_strSectionName, strEntryName, pbBuffer, uiLength );
	free( pbBuffer );
}

void CDS_IndSelParameter::ReadFromRegistry()
{
	CDS_SelParameterBase::ReadFromRegistry();

	double dValue;
	CString str;

	// Read parameters common to all selections.
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PipeNameID"), m_strPipeSeriesID );
	_tcsncpy_s( m_strPipeSeriesID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PipeSizeID"), m_strPipeSizeID );
	_tcsncpy_s( m_strPipeSizeID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );

	// Read parameters for balancing valves.
	m_iBvRadioFlowPowerDT = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("BvRadioFlowPowerDT"), m_iBvRadioFlowPowerDT );		// Version 17.
	m_iBvDpChecked = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("BvDpCheckBox"), m_iBvDpChecked );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvTypeID"), m_strBvTypeID );
	_tcsncpy_s( m_strBvTypeID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvFamilyID"), m_strBvFamilyID );
	_tcsncpy_s( m_strBvFamilyID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvMaterialID"), m_strBvMaterialID );
	_tcsncpy_s( m_strBvMaterialID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvConnectID"), m_strBvConnectID );
	_tcsncpy_s( m_strBvConnectID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvVersionID"), m_strBvVersionID );
	_tcsncpy_s( m_strBvVersionID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvPNID"), m_strBvPNID );
	_tcsncpy_s( m_strBvPNID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );

	// Read parameters for Dp controller.
	m_iDpCRadioFlowPowerDT = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("DpCRadioFlowPowerDT"), m_iDpCRadioFlowPowerDT );	// Version 17.
	m_iDpCDpStab = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("DpCDpStab"), m_iDpCDpStab );
	m_iDpCMvLoc = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("DpCMvLoc"), m_iDpCMvLoc );
	m_iDpCLocation = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("DpCLoc"), m_iDpCLocation );
	m_iDpCDpChecked = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("DpCDpChecked"), m_iDpCDpChecked );
	m_iDpCDpMaxChecked = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("DpCDpMaxChecked"), m_iDpCDpMaxChecked );	// Version 19.
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCTypeID"),  m_strDpCTypeID );
	_tcsncpy_s( m_strDpCTypeID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCFamilyID"),  m_strDpCFamilyID );
	_tcsncpy_s( m_strDpCFamilyID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCMaterialID"),  m_strDpCMaterialID );
	_tcsncpy_s( m_strDpCMaterialID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCConnectID"),  m_strDpCConnectID );
	_tcsncpy_s( m_strDpCConnectID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCVersionID"),  m_strDpCVersionID );
	_tcsncpy_s( m_strDpCVersionID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCPNID"),  m_strDpCPNID );
	_tcsncpy_s( m_strDpCPNID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	m_iDpCPackageChecked = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("DpCPackageChecked"), m_iDpCPackageChecked );
	m_iDpCInfoWnd = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("DpCInfoWnd"), m_iDpCInfoWnd );

	// Read parameters for thermostatic and return valves.
	m_iTrvRadioFlowPowerDT = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T( "TrvRadioFlowPowerDT" ), m_iTrvRadioFlowPowerDT );
	m_iTrvDpChecked = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("TrvDpCheckBox"), m_iTrvDpChecked );
	m_iTrvActuatorType = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("TrvActuatorType"), m_iTrvActuatorType );
	m_iTrvRadiatorValveType = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("TrvRadiatorValveType"), m_iTrvRadiatorValveType );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("TrvFamilyID"), m_strTrvSVFamilyID );
	_tcsncpy_s( m_strTrvSVFamilyID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("TrvVersionID"), m_strTrvSVVersionID );
	_tcsncpy_s( m_strTrvSVVersionID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("TrvConnectID"), m_strTrvSVConnectID );
	_tcsncpy_s( m_strTrvSVConnectID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("TrvRVFamilyID"), m_strTrvRVFamilyID );
	_tcsncpy_s( m_strTrvRVFamilyID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("TrvRVVersionID"), m_strTrvRVVersionID );
	_tcsncpy_s( m_strTrvRVVersionID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("TrvRVConnectID"), m_strTrvRVConnectID );
	_tcsncpy_s( m_strTrvRVConnectID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("TrvSVInsertName"), m_strTrvSVInsertName );
	_tcsncpy_s( m_strTrvSVInsertName, _COMBO_ITEMNAME_MAX + 1, (LPCTSTR)str, _COMBO_ITEMNAME_MAX );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("TrvSVInsertFamilyID"), m_strTrvSVInsertFamilyID );
	_tcsncpy_s( m_strTrvSVInsertFamilyID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("TrvSVInsertTypeID"), m_strTrvSVInsertTypeID );
	_tcsncpy_s( m_strTrvSVInsertTypeID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	int iValue = 0;
	iValue = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("TrvSVInsertInKv"), iValue );
	m_bTrvSVInsertInKv = ( 1 == iValue ) ? true : false;

	if( ReadDouble( ::AfxGetApp()->GetProfileString( m_strSectionName, _T("TrvSVInsertKvValue") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		m_dTrvSVInsertKvValue = dValue;
	}

	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("TrvRVInsertFamilyID"), m_strTrvRVInsertFamilyID );
	_tcsncpy_s( m_strTrvRVInsertFamilyID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("TrvActuatorTypeID"), m_strTrvActuatorTypeID );
	_tcsncpy_s( m_strTrvActuatorTypeID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("TrvActuatorFamilyID"), m_strTrvActuatorFamilyID );
	_tcsncpy_s( m_strTrvActuatorFamilyID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("TrvActuatorVersionID"), m_strTrvActuatorVersionID );
	_tcsncpy_s( m_strTrvActuatorVersionID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	m_eTrvRVMode = ( RadiatorReturnValveMode )::AfxGetApp()->GetProfileInt( m_strSectionName, _T("TrvRVMode"), m_eTrvRVMode );

	// Read radiator infos.
	CString RadInfosSectionName = m_strSectionName + _T("\\RadInfos");

	if( ReadDouble( ::AfxGetApp()->GetProfileString( RadInfosSectionName, _T("Flow") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		m_rTrvRadInfos.dFlow = dValue;
	}

	m_rTrvRadInfos.bAvailableDpChecked = ( ::AfxGetApp()->GetProfileInt( RadInfosSectionName, _T("AvailableDpChecked"), m_rTrvRadInfos.bAvailableDpChecked ) ) ? true : false;

	if( ReadDouble( ::AfxGetApp()->GetProfileString( RadInfosSectionName, _T("AvailableDp") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		m_rTrvRadInfos.dAvailableDp = dValue;
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( RadInfosSectionName, _T("SupplyTemperature") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		m_rTrvRadInfos.dSupplyTemperature = dValue;
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( RadInfosSectionName, _T("ReturnTemperature") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		m_rTrvRadInfos.dReturnTemperature = dValue;
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( RadInfosSectionName, _T("RoomTemperature") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		m_rTrvRadInfos.dRoomTemperature = dValue;
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( RadInfosSectionName, _T("RequiredHeatOutput") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		m_rTrvRadInfos.dRequiredHeatOutput = dValue;
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( RadInfosSectionName, _T("MinPower") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		m_rTrvRadInfos.dMinPower = dValue;
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( RadInfosSectionName, _T("RecommendedPower") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		m_rTrvRadInfos.dRecommendedPower = dValue;
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( RadInfosSectionName, _T("InstalledPower") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		m_rTrvRadInfos.dInstalledPower = dValue;
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( RadInfosSectionName, _T("MinDT") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		m_rTrvRadInfos.dMinDT = dValue;
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( RadInfosSectionName, _T("RequiredDT") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		m_rTrvRadInfos.dRequiredDT = dValue;
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( RadInfosSectionName, _T("NCSupplyT") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		m_rTrvRadInfos.dNCSupplyT = dValue;
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( RadInfosSectionName, _T("NCReturnT") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		m_rTrvRadInfos.dNCReturnT = dValue;
	}

	if( ReadDouble( ::AfxGetApp()->GetProfileString( RadInfosSectionName, _T("NCRoomT") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		m_rTrvRadInfos.dNCRoomT = dValue;
	}

	// Read parameters for control valves.
	m_iCvRadioFlowPowerDT = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("CvRadioFlowPowerDT"), m_iCvRadioFlowPowerDT );		// Version 17.
	m_eCvCB2W3W = ( CDB_ControlProperties::CV2W3W )::AfxGetApp()->GetProfileInt( m_strSectionName, _T("CvCB2W3W"), m_eCvCB2W3W );
	m_eCvCBCtrlType = ( CDB_ControlProperties::CvCtrlType )::AfxGetApp()->GetProfileInt( m_strSectionName, _T("CvCBCtrlType"), m_eCvCBCtrlType );
	m_iCvCheckDpKvs = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("CvCheckDpKvs"), m_iCvCheckDpKvs );
	m_iCvRadioKvs = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("CvRadioKvs"), m_iCvRadioKvs );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("CvCBTypeID"), m_strCvTypeID );
	_tcsncpy_s( m_strCvTypeID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("CvFamilyID"), m_strCvFamilyID );
	_tcsncpy_s( m_strCvFamilyID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("CvMaterialID"), m_strCvMaterialID );
	_tcsncpy_s( m_strCvMaterialID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("CvConnectID"), m_strCvConnectID );
	_tcsncpy_s( m_strCvConnectID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("CvVersionID"), m_strCvVersionID );
	_tcsncpy_s( m_strCvVersionID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("CvPNID"), m_strCvPNID );
	_tcsncpy_s( m_strCvPNID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("CvActPowerSupplyID"), m_strCvActPowerSupplyID );
	_tcsncpy_s( m_strCvActPowerSupplyID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("CvActInputSignalID"), m_strCvActInputSignalID );
	_tcsncpy_s( m_strCvActInputSignalID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	m_iCvFailSafeFct = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("CvFailSafeFct"), m_iCvFailSafeFct );
	m_eCvDRPFct = ( CDB_ControlValve::DRPFunction )::AfxGetApp()->GetProfileInt( m_strSectionName, _T("CvDRPFct"), m_eCvDRPFct );
	m_iCvPackageChecked = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("CvPackageChecked"), m_iCvPackageChecked );

	// Read parameters for pressure independent control valves.
	m_iPICvRadioFlowPowerDT = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("PICvRadioFlowPowerDT"), m_iPICvRadioFlowPowerDT );		// Version 17.
	m_ePICvCBCtrlType = ( CDB_ControlProperties::CvCtrlType )::AfxGetApp()->GetProfileInt( m_strSectionName, _T("PICvCBCtrlType"), m_ePICvCBCtrlType );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvCBTypeID"), m_strPICvTypeID );
	_tcsncpy_s( m_strPICvTypeID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvFamilyID"), m_strPICvFamilyID );
	_tcsncpy_s( m_strPICvFamilyID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvMaterialID"), m_strPICvMaterialID );
	_tcsncpy_s( m_strPICvMaterialID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvConnectID"), m_strPICvConnectID );
	_tcsncpy_s( m_strPICvConnectID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvVersionID"), m_strPICvVersionID );
	_tcsncpy_s( m_strPICvVersionID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvPNID"), m_strPICvPNID );
	_tcsncpy_s( m_strPICvPNID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvActPowerSupplyID"), m_strPICvActPowerSupplyID );
	_tcsncpy_s( m_strPICvActPowerSupplyID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvActInputSignalID"), m_strPICvActInputSignalID );
	_tcsncpy_s( m_strPICvActInputSignalID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	m_iPICvFailSafeFct = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("PICvFailSafeFct"), m_iPICvFailSafeFct );
	m_ePICvDRPFct = ( CDB_ControlValve::DRPFunction )::AfxGetApp()->GetProfileInt( m_strSectionName, _T("PICvDRPFct"), m_ePICvDRPFct );
	m_iPICvPackageChecked = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("PICvPackageChecked"), m_iPICvPackageChecked );
	m_iPICvDpMaxChecked = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("PICvDpMaxChecked"), m_iPICvDpMaxChecked );		// Version 19.

	// Read parameters for balancing and control valves.
	m_iBCVRadioFlowPowerDT = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("BCVRadioFlowPowerDT"), m_iBCVRadioFlowPowerDT );			// Version 17.
	m_iBCVDpChecked = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("BCVDpChecked"), m_iBCVDpChecked );								// Version 17.
	m_eBCV2W3W = ( CDB_ControlProperties::CV2W3W ) ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("BCVCB2W3W"), m_eBCV2W3W );
	m_eBCVCBCtrlType = ( CDB_ControlProperties::CvCtrlType ) ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("BCVCBCtrlType"), m_eBCVCBCtrlType );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCVCBTypeID"), m_strBCVTypeID );
	_tcsncpy_s( m_strBCVTypeID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCVCBFamilyID"), m_strBCVFamilyID );
	_tcsncpy_s( m_strBCVFamilyID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCVCBMaterialID"), m_strBCVMaterialID );
	_tcsncpy_s( m_strBCVMaterialID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCVCBConnectID"), m_strBCVConnectID );
	_tcsncpy_s( m_strBCVConnectID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCVCBVersionID"), m_strBCVVersionID );
	_tcsncpy_s( m_strBCVVersionID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCVCBPNID"), m_strBCVPNID );
	_tcsncpy_s( m_strBCVPNID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCVActPowerSupplyID"), m_strBCVActPowerSupplyID );
	_tcsncpy_s( m_strBCVActPowerSupplyID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCVActInputSignalID"), m_strBCVActInputSignalID );
	_tcsncpy_s( m_strBCVActInputSignalID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	m_iBCVFailSafeFct = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("BCVFailSafeFct"), m_iBCVFailSafeFct );
	m_eBCVDRPFct = ( CDB_ControlValve::DRPFunction )::AfxGetApp()->GetProfileInt( m_strSectionName, _T("BCVDRPFct"), m_eBCVDRPFct );
	m_iBCVPackageChecked = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("BCVPackageChecked"), m_iBCVPackageChecked );

	// Read parameters for separators.
	m_iSepRadioFlowPowerDT = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("SepRadioFlowPowerDT"), m_iSepRadioFlowPowerDT );			// Version 17.
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SeparatorTypeID"), m_strSeparatorTypeID );
	_tcsncpy_s( m_strSeparatorTypeID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SeparatorFamilyID"), m_strSeparatorFamilyID );
	_tcsncpy_s( m_strSeparatorFamilyID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SeparatorConnectID"), m_strSeparatorConnectID );
	_tcsncpy_s( m_strSeparatorConnectID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SeparatorVersionID"), m_strSeparatorVersionID );
	_tcsncpy_s( m_strSeparatorVersionID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );

	// Read parameters for pressure maintenance.
	m_ePMApplicationType = ( ProjectType )::AfxGetApp()->GetProfileInt( m_strSectionName, _T("PMApplicationType"), m_ePMApplicationType );	// Version 18.

	if( m_ePMApplicationType != Heating && m_ePMApplicationType != Cooling && m_ePMApplicationType != Solar && m_ePMApplicationType != ChangeOver )
	{
		m_ePMApplicationType = Heating;
	}

	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PMPressureMaintenanceTypeID"), m_strPMPressureMaintenanceTypeID );			// Version 18.
	_tcsncpy_s( m_strPMPressureMaintenanceTypeID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PMWaterMakeUpID"), m_strPMWaterMakeUpTypeID );	// Version 20.
	_tcsncpy_s( m_strPMWaterMakeUpTypeID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	m_iPMDegassingChecked = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("PMDegassingChecked"), m_iPMDegassingChecked );				// Version 18.

	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PMNorm"),
										   TASApp.GetpTADS()->GetpTechParams()->GetDefaultCalculationNorm().c_str() );													// Version 18.
	_tcsncpy_s( m_strPMNorm, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );

	m_ePMPressOn = ( PressurON )::AfxGetApp()->GetProfileInt( m_strSectionName, _T("PMPressOn"), m_ePMPressOn );							// Version 18.

	m_fPMWaterMakeupBreakTank = TASApp.GetpTADS()->GetpTechParams()->GetBreakTankRequiredForWaterMakeUp();
	m_fPMWaterMakeupBreakTank = ( 0 != ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("PMWaterMakeupBreakTank"), m_fPMWaterMakeupBreakTank ) ) ? true : false;

	// Read parameters for combined Dp controller and balancing & control valves.
	m_iDpCBCVRadioFlowPowerDT = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("DpCBCVRadioFlowPowerDT"), m_iDpCBCVRadioFlowPowerDT );
	m_eDpCBCVCBCtrlType = ( CDB_ControlProperties::CvCtrlType )::AfxGetApp()->GetProfileInt( m_strSectionName, _T("DpCBCVCBCtrlType"), m_eDpCBCVCBCtrlType );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBCVCBTypeID"), m_strDpCBCVTypeID );
	_tcsncpy_s( m_strDpCBCVTypeID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBCVFamilyID"), m_strDpCBCVFamilyID );
	_tcsncpy_s( m_strDpCBCVFamilyID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBCVMaterialID"), m_strDpCBCVMaterialID );
	_tcsncpy_s( m_strDpCBCVMaterialID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBCVConnectID"), m_strDpCBCVConnectID );
	_tcsncpy_s( m_strDpCBCVConnectID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBCVVersionID"), m_strDpCBCVVersionID );
	_tcsncpy_s( m_strDpCBCVVersionID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBCVPNID"), m_strDpCBCVPNID );
	_tcsncpy_s( m_strDpCBCVPNID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBCVActPowerSupplyID"), m_strDpCBCVActPowerSupplyID );
	_tcsncpy_s( m_strDpCBCVActPowerSupplyID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBCVActInputSignalID"), m_strDpCBCVActInputSignalID );
	_tcsncpy_s( m_strDpCBCVActInputSignalID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	m_iDpCBCVFailSafeFct = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("DpCBCVFailSafeFct"), m_iDpCBCVFailSafeFct );
	m_eDpCBCVDRPFct = ( CDB_ControlValve::DRPFunction )::AfxGetApp()->GetProfileInt( m_strSectionName, _T("DpCBCVDRPFct"), m_eDpCBCVDRPFct );
	m_iDpCBCVPackageChecked = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("DpCBCVPackageChecked"), m_iDpCBCVPackageChecked );
	m_iDpCBCVDpToStabilizeChecked = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("DpCBCVDpToStabilizeChecked"), m_iDpCBCVDpToStabilizeChecked );
	m_iDpCBCVWithSTSChecked = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("DpCBCVWithSTSChecked"), m_iDpCBCVWithSTSChecked );
	m_iDpCBCVInfoWnd = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("DpCBCVInfoWnd"), m_iDpCBCVInfoWnd );

	// Read parameters for shut-off valves.
	m_iSvRadioFlowPowerDT = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("SvRadioFlowPowerDT"), m_iSvRadioFlowPowerDT );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SvCBTypeID"), m_strSvTypeID );
	_tcsncpy_s( m_strSvTypeID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpSvFamilyID"), m_strSvFamilyID );
	_tcsncpy_s( m_strSvFamilyID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SvMaterialID"), m_strSvMaterialID );
	_tcsncpy_s( m_strSvMaterialID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SvConnectID"), m_strSvConnectID );
	_tcsncpy_s( m_strSvConnectID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SvVersionID"), m_strSvVersionID );
	_tcsncpy_s( m_strSvVersionID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SvPNID"), m_strSvPNID );
	_tcsncpy_s( m_strSvPNID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );

	// Version 24: Read parameters for safety valves.
	m_eSafetyValveSystemType = (ProjectType)::AfxGetApp()->GetProfileInt( m_strSectionName, _T("SafetyValveSystemType"), m_eSafetyValveSystemType );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SafetyValveSystemHeatGeneratorTypeID"), m_strSafetyValveSystemHeatGeneratorTypeID );
	_tcsncpy_s( m_strSafetyValveSystemHeatGeneratorTypeID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SafetyValveNormID"), m_strSafetyValveNormID );
	_tcsncpy_s( m_strSafetyValveNormID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SafetyValveTypeID"), m_strSafetyValveFamilyID );
	_tcsncpy_s( m_strSafetyValveFamilyID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SafetyValveConnectionID"), m_strSafetyValveConnectionID );
	_tcsncpy_s( m_strSafetyValveConnectionID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );

	if( ReadDouble( ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SafetyValveSetPressure") ), &dValue ) == RD_OK && dValue != 0.0 )
	{
		m_dSafetyValveSetPressure = dValue;
	}

	// Version 25: HYS-1058: we need to read pressurisation maintenance and water quality preferences from the registry.
	m_pclPMWQPrefs->ReadFromRegistry( m_strSectionName );

	// Version 27: 6-way.
	m_e6WValveSelectionMode = (e6WayValveSelectionMode)::AfxGetApp()->GetProfileInt( m_strSectionName, _T("6WSelectionMode"), m_e6WValveSelectionMode );
	m_i6WValveRadioFlowPowerDT = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("6WRadioFlowPowerDT"), m_i6WValveRadioFlowPowerDT );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("6WFamilyID"), m_str6WValveConnectID );
	_tcsncpy_s( m_str6WValveConnectID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("6WVersionID"), m_str6WValveVersionID );
	_tcsncpy_s( m_str6WValveVersionID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	m_b6WValveCheckFastElectConnection = ( 0 != ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("6WCheckFastElectConnection"), m_b6WValveCheckFastElectConnection ) ) ? true : false;
	// Version 31: HYS-1877
	m_b6WValveCheckOnlyForSet = ( 0 != ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("6WCheckOnlyForSet"), m_b6WValveCheckOnlyForSet ) ) ? true : false;

	// PIBCV.
	m_bIs6WValvePICvDpMaxChecked = ( 0 != ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("6WPICvDpMaxChecked"), m_bIs6WValvePICvDpMaxChecked ) ) ? true : false;
	m_e6WValvePICvCBCtrlType = (CDB_ControlProperties::CvCtrlType)::AfxGetApp()->GetProfileInt( m_strSectionName, _T("6WPICvCBCtrlType"), m_e6WValvePICvCBCtrlType );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("6WPICvTypeID"), m_str6WValvePICvTypeID );
	_tcsncpy_s( m_str6WValvePICvTypeID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("6WPICvFamilyID"), m_str6WValvePICvFamilyID );
	_tcsncpy_s( m_str6WValvePICvFamilyID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("6WPICvMaterialID"), m_str6WValvePICvMaterialID );
	_tcsncpy_s( m_str6WValvePICvMaterialID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("6WPICvConnectID"), m_str6WValvePICvConnectID );
	_tcsncpy_s( m_str6WValvePICvConnectID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("6WPICvVersionID"), m_str6WValvePICvVersionID );
	_tcsncpy_s( m_str6WValvePICvVersionID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("6WPICvPNID"), m_str6WValvePICvPNID );
	_tcsncpy_s( m_str6WValvePICvPNID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("6WPICvActInputSignalID"), m_str6WValvePICvActInputSignalID );
	_tcsncpy_s( m_str6WValvePICvActInputSignalID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	
	// BV.
	m_bIs6WValveBvDpChecked = ( 0 != ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("6WBvDpEnabled"), m_bIs6WValveBvDpChecked ) ) ? true : false;
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("6WBvTypeID"), m_str6WValveBvTypeID );
	_tcsncpy_s( m_str6WValveBvTypeID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("6WBvFamilyID"), m_str6WValveBvFamilyID );
	_tcsncpy_s( m_str6WValveBvFamilyID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("6WBvMaterialID"), m_str6WValveBvMaterialID );
	_tcsncpy_s( m_str6WValveBvMaterialID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("6WBvConnectID"), m_str6WValveBvConnectID );
	_tcsncpy_s( m_str6WValveBvConnectID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("6WBvVersionID"), m_str6WValveBvVersionID );
	_tcsncpy_s( m_str6WValveBvVersionID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("6WBvPNID"), m_str6WValveBvPNID );
	_tcsncpy_s( m_str6WValveBvPNID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );

	// Version 29: smart control valve.
	m_iSmartControlValveRadioFlowPowerDT = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("SmartControlValveRadioFlowPowerDT"), m_iSmartControlValveRadioFlowPowerDT );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartControlValveBodyMaterialID"), m_strSmartControlValveBodyMaterialID );
	_tcsncpy_s( m_strSmartControlValveBodyMaterialID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartControlValveConnectID"), m_strSmartControlValveConnectID );
	_tcsncpy_s( m_strSmartControlValveConnectID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartControlValveVersionID"), m_strSmartControlValveVersionID );
	_tcsncpy_s( m_strSmartControlValveVersionID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	// HYS-1939: TA-Smart Dp - 06 - Individual selection: create the datastruct object.
	m_iSmartControlValveDpMaxChecked = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T( "SmartControlValveDpMaxChecked" ), m_iSmartControlValveDpMaxChecked );

	// Version 32: HYS-1937: TA-Smart Dp - 04 - Individual selection: left tab.
	m_iSmartDpCRadioFlowPowerDT = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T( "SmartDpCRadioFlowPowerDT" ), m_iSmartDpCRadioFlowPowerDT );
	m_iSmartDpCDpBranchChecked = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T( "SmartDpCDpBranchChecked" ), m_iSmartDpCDpBranchChecked );
	// HYS-1939: TA-Smart Dp - 06 - Individual selection: create the datastruct object.
	m_iSmartDpCDpMaxChecked = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T( "SmartDpCDpMaxChecked" ), m_iSmartDpCDpMaxChecked );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T( "SmartDpCBodyMaterialID" ), m_strSmartDpCBodyMaterialID );
	_tcsncpy_s( m_strSmartDpCBodyMaterialID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T( "SmartDpCConnectID" ), m_strSmartDpCConnectID );
	_tcsncpy_s( m_strSmartDpCConnectID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T( "SmartDpCVersionID" ), m_strSmartDpCVersionID );
	_tcsncpy_s( m_strSmartDpCVersionID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	// HYS-1938: TA-Smart Dp - 05 - Individual selection: right view
	// HYS-1992: Remove set possibility of TA Smart Dp.
	//m_bSmartDpCCheckOnlyForSet = (0 != ::AfxGetApp()->GetProfileInt( m_strSectionName, _T( "SmartDpCCheckOnlyForSet" ), m_bSmartDpCCheckOnlyForSet )) ? true : false;

	// HYS-1384: Version 30.
	BYTE *pbCWDescription = NULL;
	UINT uiCWDescriptionSize = 0;
	BOOL bReturn = AfxGetApp()->GetProfileBinary( m_strSectionName, _T("ShowAllPrioritiesStates"), &pbCWDescription, &uiCWDescriptionSize );

	if( TRUE == bReturn )
	{
		CMemFile clMapShowAllStates;
		clMapShowAllStates.Attach( pbCWDescription, uiCWDescriptionSize );

		char cWindowIDNumbers = 0;
		clMapShowAllStates.Read( &cWindowIDNumbers, sizeof( cWindowIDNumbers ) );

		for( char cLoopWindowID = 0; cLoopWindowID < cWindowIDNumbers; cLoopWindowID++ )
		{
			int iWindowID = 0;
			clMapShowAllStates.Read( &iWindowID, sizeof( iWindowID ) );

			char cStateNumbers = 0;
			clMapShowAllStates.Read( &cStateNumbers, sizeof( cStateNumbers ) );

			std::map<int, int> mapRead;

			for( char cLoopState = 0; cLoopState < cStateNumbers; cLoopState++ )
			{
				int iButtonID = 0;
				clMapShowAllStates.Read( &iButtonID, sizeof( iButtonID ) );

				int iState = 0;
				clMapShowAllStates.Read( &iState, sizeof( iState ) );

				mapRead.insert( std::pair<int, int>( iButtonID, iState ) );
			}

			m_mapShowHideAllPrioritiesState.insert( std::pair<int, std::map<int, int>>( iWindowID, mapRead ) );
		}

		clMapShowAllStates.Detach();
		delete [] pbCWDescription;
	}
}

TCHAR *CDS_IndSelParameter::_VerifyPipeSeries( CProductSelelectionParameters *plcProductSelParams )
{
	if( NULL == plcProductSelParams || NULL == plcProductSelParams->m_pTADS || NULL == plcProductSelParams->m_pTADS->GetpTechParams() )
	{
		ASSERTA_RETURN( NULL );
	}

	CTable *pTab = static_cast<CTable *>( TASApp.GetpPipeDB()->Get( m_strPipeSeriesID ).MP );

	// PipeSerie is not available take default pipe series.
	if( !( NULL != pTab && true == pTab->IsSelectable( true ) ) )
	{
		CDS_TechnicalParameter *pTechParam = plcProductSelParams->m_pTADS->GetpTechParams();
		_tcsncpy_s( m_strPipeSeriesID, _ID_LENGTH, (LPCTSTR)pTechParam->GetDefaultPipeSerieID(), _ID_LENGTH );
	}

	return m_strPipeSeriesID;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_BatchSelParameter
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_BatchSelParameter )

CDS_BatchSelParameter::CDS_BatchSelParameter( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SelParameterBase( ParameterType::BatchSelection, pDataBase, ID )
{
	m_strSectionName = _T("DlgBatchSelection");

	// Initialize parameters common to all selections.
	// Remark: PARAM_TECH not yet initialized when the constructor is called, use STEEL_GEN_PIPES it will be overwritten by calling 'VerifyPipeSeries'.
	_tcsncpy_s( m_strPipeSeriesID, SIZEOFINTCHAR( m_strPipeSeriesID ), _T("STEEL_GEN_PIPES"), SIZEOFINTCHAR( m_strPipeSeriesID ) - 1 );
	_tcsncpy_s( m_strPipeSizeID, SIZEOFINTCHAR( m_strPipeSizeID ), _T(""), SIZEOFINTCHAR( m_strPipeSizeID ) - 1 );

	// Initialize parameters for balancing valves.
	m_iBvRadioFlow = 0;
	m_iBvCheckDp = BST_UNCHECKED;
	m_strBvTypeBelow65ID[0] = _T('\0');
	m_strBvFamilyBelow65ID[0] = _T('\0');
	m_strBvMaterialBelow65ID[0] = _T('\0');
	m_strBvConnectBelow65ID[0] = _T('\0');
	m_strBvVersionBelow65ID[0] = _T('\0');
	m_strBvPNBelow65ID[0] = _T('\0');
	m_strBvTypeAbove50ID[0] = _T('\0');
	m_strBvFamilyAbove50ID[0] = _T('\0');
	m_strBvMaterialAbove50ID[0] = _T('\0');
	m_strBvConnectAbove50ID[0] = _T('\0');
	m_strBvVersionAbove50ID[0] = _T('\0');
	m_strBvPNAbove50ID[0] = _T('\0');

	// Initialize parameters for pressure independent control valves.
	m_iPICvRadioFlow = 0;
	m_bPICvCtrlTypeStrictChecked = false;											// Version 7.
	m_ePICvCBCtrlType = CDB_ControlProperties::CvCtrlType::eCvProportional;
	m_strPICvTypeBelow65ID[0] = _T('\0');
	m_strPICvFamilyBelow65ID[0] = _T('\0');
	m_strPICvMaterialBelow65ID[0] = _T('\0');
	m_strPICvConnectBelow65ID[0] = _T('\0');
	m_strPICvVersionBelow65ID[0] = _T('\0');
	m_strPICvPNBelow65ID[0] = _T('\0');
	m_strPICvTypeAbove50ID[0] = _T('\0');
	m_strPICvFamilyAbove50ID[0] = _T('\0');
	m_strPICvMaterialAbove50ID[0] = _T('\0');
	m_strPICvConnectAbove50ID[0] = _T('\0');
	m_strPICvVersionAbove50ID[0] = _T('\0');
	m_strPICvPNAbove50ID[0] = _T('\0');
	m_strPICvActPowerSupplyID[0] = _T('\0');
	m_strPICvActInputSignalID[0] = _T('\0');
	m_iPICvFailSafeFct = 0;
	m_ePICvDRPFct = CDB_ControlValve::DRPFunction::drpfUndefined;					// Version 8.

	// Initialize parameters for balancing & control valves.
	m_iBCvRadioFlow = 0;
	m_iBCvCheckDp = BST_UNCHECKED;
	m_bBCvCtrlTypeStrictChecked = false;											// Version 7.
	m_eBCv2W3W = CDB_ControlProperties::CV2W3W::CV2W;								// Version 6.
	m_eBCvCBCtrlType = CDB_ControlProperties::CvCtrlType::eCvProportional;
	m_strBCvTypeBelow65ID[0] = _T('\0');
	m_strBCvFamilyBelow65ID[0] = _T('\0');
	m_strBCvMaterialBelow65ID[0] = _T('\0');
	m_strBCvConnectBelow65ID[0] = _T('\0');
	m_strBCvVersionBelow65ID[0] = _T('\0');
	m_strBCvPNBelow65ID[0] = _T('\0');
	m_strBCvTypeAbove50ID[0] = _T('\0');
	m_strBCvFamilyAbove50ID[0] = _T('\0');
	m_strBCvMaterialAbove50ID[0] = _T('\0');
	m_strBCvConnectAbove50ID[0] = _T('\0');
	m_strBCvVersionAbove50ID[0] = _T('\0');
	m_strBCvPNAbove50ID[0] = _T('\0');
	m_strBCvActPowerSupplyID[0] = _T('\0');
	m_strBCvActInputSignalID[0] = _T('\0');
	m_iBCvFailSafeFct = 0;
	m_eBCvDRPFct = CDB_ControlValve::DRPFunction::drpfUndefined;					// Version 8.

	// Initialize parameters for separators.
	m_iSepRadioFlow = 0;
	m_strSeparatorTypeID[0] = _T('\0');
	m_strSeparatorFamilyID[0] = _T('\0');
	m_strSeparatorConnectID[0] = _T('\0');
	m_strSeparatorVersionID[0] = _T('\0');

	// Initialize parameters for Dp controller valves.
	m_iDpCRadioFlow = 0;
	m_iDpCCheckDpBranch = BST_UNCHECKED;
	m_iDpCCheckKvs = BST_UNCHECKED;													// HYS-1188: Version 9.
	m_iDpCCheckDpMax = BST_UNCHECKED;
	m_iDpCDpStab = ( int )eDpStab::DpStabOnBranch;
	m_iDpCDpCLocation = ( int )eDpCLoc::DpCLocDownStream;
	m_iDpCMvLocation = ( int )eMvLoc::MvLocPrimary;
	m_strDpCTypeBelow65ID[0] = _T('\0');
	m_strDpCFamilyBelow65ID[0] = _T('\0');
	m_strDpCMaterialBelow65ID[0] = _T('\0');
	m_strDpCConnectBelow65ID[0] = _T('\0');
	m_strDpCVersionBelow65ID[0] = _T('\0');
	m_strDpCPNBelow65ID[0] = _T('\0');
	m_strDpCTypeAbove50ID[0] = _T('\0');
	m_strDpCFamilyAbove50ID[0] = _T('\0');
	m_strDpCMaterialAbove50ID[0] = _T('\0');
	m_strDpCConnectAbove50ID[0] = _T('\0');
	m_strDpCVersionAbove50ID[0] = _T('\0');
	m_strDpCPNAbove50ID[0] = _T('\0');
	
	// For balancing valves selected with Dp controller valves.
	m_strDpCBvTypeBelow65ID[0] = _T('\0');
	m_strDpCBvFamilyBelow65ID[0] = _T('\0');
	m_strDpCBvMaterialBelow65ID[0] = _T('\0');
	m_strDpCBvConnectBelow65ID[0] = _T('\0');
	m_strDpCBvVersionBelow65ID[0] = _T('\0');
	m_strDpCBvPNBelow65ID[0] = _T('\0');
	m_strDpCBvTypeAbove50ID[0] = _T('\0');
	m_strDpCBvFamilyAbove50ID[0] = _T('\0');
	m_strDpCBvMaterialAbove50ID[0] = _T('\0');
	m_strDpCBvConnectAbove50ID[0] = _T('\0');
	m_strDpCBvVersionAbove50ID[0] = _T('\0');
	m_strDpCBvPNAbove50ID[0] = _T('\0');

	// For smart control valve.
	m_iSmartControlValveRadioFlow = 0;
	m_strSmartControlValveMaterialBelow65ID[0] = _T('\0');
	m_strSmartControlValveConnectBelow65ID[0] = _T('\0');
	m_strSmartControlValvePNBelow65ID[0] = _T('\0');
	m_strSmartControlValveMaterialAbove50ID[0] = _T('\0');
	m_strSmartControlValveConnectAbove50ID[0] = _T('\0');
	m_strSmartControlValvePNAbove50ID[0] = _T('\0');

	// For smart differential pressure controller.
	m_iSmartControlValveRadioFlow = 0;
	m_iSmartDpCCheckDpBranch = BST_UNCHECKED;
	m_iSmartDpCCheckDpMax = BST_UNCHECKED;
	m_strSmartDpCMaterialBelow65ID[0] = _T('\0');
	m_strSmartDpCConnectBelow65ID[0] = _T('\0');
	m_strSmartDpCPNBelow65ID[0] = _T('\0');
	m_strSmartDpCMaterialAbove50ID[0] = _T('\0');
	m_strSmartDpCConnectAbove50ID[0] = _T('\0');
	m_strSmartDpCPNAbove50ID[0] = _T('\0');

	m_pclColumnWidthContainer = new CCWBatchSelContainer();
}

CDS_BatchSelParameter::CCWBatchSelSheet::~CCWBatchSelSheet()
{
	m_mapColumnInfo.clear();
}

#define CCWBATCHSELSHEETVERSION		1
void CDS_BatchSelParameter::CCWBatchSelSheet::ReadRegistry( CMemFile &clCWSheet )
{
	// NO INTENTIONALLY CALL TO BASE CLASS!!

	// Read version.
	int iVersion;
	clCWSheet.Read( &iVersion, sizeof( iVersion ) );

	if( iVersion < 1 || iVersion > CCWBATCHSELSHEETVERSION )
	{
		return;
	}

	// Run all columns.
	short nColumnID;

	do
	{
		ColumnInfo rColumnInfo;
		clCWSheet.Read( &nColumnID, sizeof( nColumnID ) );

		if( nColumnID != -1 )
		{
			clCWSheet.Read( &rColumnInfo.m_bIsVisible, sizeof( rColumnInfo.m_bIsVisible ) );
			clCWSheet.Read( &rColumnInfo.m_lWidth, sizeof( rColumnInfo.m_lWidth ) );
			clCWSheet.Read( &rColumnInfo.m_iAfterColumnID, sizeof( rColumnInfo.m_iAfterColumnID ) );

			// To correct on the fly some registry corruption done on previous version
			if( rColumnInfo.m_bIsVisible && rColumnInfo.m_lWidth <= 0 )
			{
				rColumnInfo.m_lWidth = 50;
			}

			m_mapColumnInfo[nColumnID] = rColumnInfo;
		}
	}
	while( nColumnID != -1 );
}

void CDS_BatchSelParameter::CCWBatchSelSheet::WriteRegistry( CMemFile &clCWSheet )
{
	// NO INTENTIONALLY CALL TO BASE CLASS!!

	// Write version.
	int iVersion = CCWBATCHSELSHEETVERSION;
	clCWSheet.Write( &iVersion, sizeof( iVersion ) );

	// Fill with all infos.
	for( mapShortColumnInfoIter iter = m_mapColumnInfo.begin(); iter != m_mapColumnInfo.end(); ++iter )
	{
		clCWSheet.Write( &iter->first, sizeof( short ) );
		clCWSheet.Write( &iter->second.m_bIsVisible, sizeof( iter->second.m_bIsVisible ) );
		clCWSheet.Write( &iter->second.m_lWidth, sizeof( iter->second.m_lWidth ) );
		clCWSheet.Write( &iter->second.m_iAfterColumnID, sizeof( iter->second.m_iAfterColumnID ) );
	}

	// Close.
	short nEnd = -1;
	clCWSheet.Write( &nEnd, sizeof( nEnd ) );
}

CDS_SelParameterBase::CCWSheet *CDS_BatchSelParameter::CCWBatchSelWindow::CreateNewCWSSheet( short nSheetID )
{
	return new CCWBatchSelSheet( nSheetID );
}

CDS_SelParameterBase::CCWWindow *CDS_BatchSelParameter::CCWBatchSelContainer::CreateNewCWSWindow( short nWindowID )
{
	return new CCWBatchSelWindow( nWindowID );
}

void CDS_BatchSelParameter::Copy( CData *pclDestination )
{
	CData::Copy( pclDestination );

	CDS_BatchSelParameter *pclDestinationBatchSelParameter = (CDS_BatchSelParameter *)pclDestination;
	
	pclDestinationBatchSelParameter->SetPipeSeriesID( m_strPipeSeriesID );
	pclDestinationBatchSelParameter->SetPipeSizeID( m_strPipeSizeID );
	
	pclDestinationBatchSelParameter->SetBvFlowRadioState( m_iBvRadioFlow );
	pclDestinationBatchSelParameter->SetBvDpCheckboxState( m_iBvCheckDp );
	pclDestinationBatchSelParameter->SetBvTypeBelow65ID( m_strBvTypeBelow65ID );
	pclDestinationBatchSelParameter->SetBvFamilyBelow65ID( m_strBvFamilyBelow65ID );
	pclDestinationBatchSelParameter->SetBvMaterialBelow65ID( m_strBvMaterialBelow65ID );
	pclDestinationBatchSelParameter->SetBvConnectBelow65ID( m_strBvConnectBelow65ID );
	pclDestinationBatchSelParameter->SetBvVersionBelow65ID( m_strBvVersionBelow65ID );
	pclDestinationBatchSelParameter->SetBvPNBelow65ID( m_strBvPNBelow65ID );
	pclDestinationBatchSelParameter->SetBvTypeAbove50ID( m_strBvTypeAbove50ID );
	pclDestinationBatchSelParameter->SetBvFamilyAbove50ID( m_strBvFamilyAbove50ID );
	pclDestinationBatchSelParameter->SetBvMaterialAbove50ID( m_strBvMaterialAbove50ID );
	pclDestinationBatchSelParameter->SetBvConnectAbove50ID( m_strBvConnectAbove50ID );
	pclDestinationBatchSelParameter->SetBvVersionAbove50ID( m_strBvVersionAbove50ID );
	pclDestinationBatchSelParameter->SetBvPNAbove50ID( m_strBvPNAbove50ID );
	
	pclDestinationBatchSelParameter->SetPICvFlowRadioState( m_iPICvRadioFlow );
	pclDestinationBatchSelParameter->SetPICvCtrlTypeStrictChecked( m_bPICvCtrlTypeStrictChecked );
	pclDestinationBatchSelParameter->SetPICvCBCtrlType( m_ePICvCBCtrlType );
	pclDestinationBatchSelParameter->SetPICvTypeBelow65ID( m_strPICvTypeBelow65ID );
	pclDestinationBatchSelParameter->SetPICvFamilyBelow65ID( m_strPICvFamilyBelow65ID );
	pclDestinationBatchSelParameter->SetPICvMaterialBelow65ID( m_strPICvMaterialBelow65ID );
	pclDestinationBatchSelParameter->SetPICvConnectBelow65ID( m_strPICvConnectBelow65ID );
	pclDestinationBatchSelParameter->SetPICvVersionBelow65ID( m_strPICvVersionBelow65ID );
	pclDestinationBatchSelParameter->SetPICvPNBelow65ID( m_strPICvPNBelow65ID );
	pclDestinationBatchSelParameter->SetPICvTypeAbove50ID( m_strPICvTypeAbove50ID );
	pclDestinationBatchSelParameter->SetPICvFamilyAbove50ID( m_strPICvFamilyAbove50ID );
	pclDestinationBatchSelParameter->SetPICvMaterialAbove50ID( m_strPICvMaterialAbove50ID );
	pclDestinationBatchSelParameter->SetPICvConnectAbove50ID( m_strPICvConnectAbove50ID );
	pclDestinationBatchSelParameter->SetPICvVersionAbove50ID( m_strPICvVersionAbove50ID );
	pclDestinationBatchSelParameter->SetPICvPNAbove50ID( m_strPICvPNAbove50ID );
	pclDestinationBatchSelParameter->SetPICvActPowerSupplyID( m_strPICvActPowerSupplyID );
	pclDestinationBatchSelParameter->SetPICvActInputSignalID( m_strPICvActInputSignalID );
	pclDestinationBatchSelParameter->SetPICvFailSafeFct( m_iPICvFailSafeFct );
	pclDestinationBatchSelParameter->SetPICvDRPFct( m_ePICvDRPFct );
	
	pclDestinationBatchSelParameter->SetBCvFlowRadioState( m_iBCvRadioFlow );
	pclDestinationBatchSelParameter->SetBCvDpCheckboxState( m_iBCvCheckDp );
	pclDestinationBatchSelParameter->SetBCvCtrlTypeStrictChecked( m_bBCvCtrlTypeStrictChecked );
	pclDestinationBatchSelParameter->SetBCVCB2W3W( m_eBCv2W3W );
	pclDestinationBatchSelParameter->SetBCvCBCtrlType( m_eBCvCBCtrlType );
	pclDestinationBatchSelParameter->SetBCvTypeBelow65ID( m_strBCvTypeBelow65ID );
	pclDestinationBatchSelParameter->SetBCvFamilyBelow65ID( m_strBCvFamilyBelow65ID );
	pclDestinationBatchSelParameter->SetBCvMaterialBelow65ID( m_strBCvMaterialBelow65ID );
	pclDestinationBatchSelParameter->SetBCvConnectBelow65ID( m_strBCvConnectBelow65ID );
	pclDestinationBatchSelParameter->SetBCvVersionBelow65ID( m_strBCvVersionBelow65ID );
	pclDestinationBatchSelParameter->SetBCvPNBelow65ID( m_strBCvPNBelow65ID );
	pclDestinationBatchSelParameter->SetBCvTypeAbove50ID( m_strBCvTypeAbove50ID );
	pclDestinationBatchSelParameter->SetBCvFamilyAbove50ID( m_strBCvFamilyAbove50ID );
	pclDestinationBatchSelParameter->SetBCvMaterialAbove50ID( m_strBCvMaterialAbove50ID );
	pclDestinationBatchSelParameter->SetBCvConnectAbove50ID( m_strBCvConnectAbove50ID );
	pclDestinationBatchSelParameter->SetBCvVersionAbove50ID( m_strBCvVersionAbove50ID );
	pclDestinationBatchSelParameter->SetBCvPNAbove50ID( m_strBCvPNAbove50ID );
	pclDestinationBatchSelParameter->SetBCvActPowerSupplyID( m_strBCvActPowerSupplyID );
	pclDestinationBatchSelParameter->SetBCvActInputSignalID( m_strBCvActInputSignalID );
	pclDestinationBatchSelParameter->SetBCvFailSafeFct( m_iBCvFailSafeFct );
	pclDestinationBatchSelParameter->SetBCvDRPFct( m_eBCvDRPFct );
	
	pclDestinationBatchSelParameter->SetSeparatorFlowRadioState( m_iSepRadioFlow );
	pclDestinationBatchSelParameter->SetSeparatorTypeID( m_strSeparatorTypeID );
	pclDestinationBatchSelParameter->SetSeparatorFamilyID( m_strSeparatorFamilyID );
	pclDestinationBatchSelParameter->SetSeparatorConnectID( m_strSeparatorConnectID );
	pclDestinationBatchSelParameter->SetSeparatorVersionID( m_strSeparatorVersionID );
	
	pclDestinationBatchSelParameter->SetDpCFlowRadioState( m_iDpCRadioFlow);
	pclDestinationBatchSelParameter->SetDpCDpBranchCheckboxState( m_iDpCCheckDpBranch );
	pclDestinationBatchSelParameter->SetDpCKvsCheckboxState( m_iDpCCheckKvs );
	pclDestinationBatchSelParameter->SetDpCDpMaxCheckboxState( m_iDpCCheckDpMax );
	pclDestinationBatchSelParameter->SetDpCDpStab( m_iDpCDpStab );
	pclDestinationBatchSelParameter->SetDpCDpCLocation( m_iDpCDpCLocation );
	pclDestinationBatchSelParameter->SetDpCMvLocation( m_iDpCMvLocation );
	pclDestinationBatchSelParameter->SetDpCTypeBelow65ID( m_strDpCTypeBelow65ID );
	pclDestinationBatchSelParameter->SetDpCFamilyBelow65ID( m_strDpCFamilyBelow65ID );
	pclDestinationBatchSelParameter->SetDpCMaterialBelow65ID( m_strDpCMaterialBelow65ID );
	pclDestinationBatchSelParameter->SetDpCConnectBelow65ID( m_strDpCConnectBelow65ID );
	pclDestinationBatchSelParameter->SetDpCVersionBelow65ID( m_strDpCVersionBelow65ID );
	pclDestinationBatchSelParameter->SetDpCPNBelow65ID( m_strDpCPNBelow65ID );
	pclDestinationBatchSelParameter->SetDpCTypeAbove50ID( m_strDpCTypeAbove50ID );
	pclDestinationBatchSelParameter->SetDpCFamilyAbove50ID( m_strDpCFamilyAbove50ID );
	pclDestinationBatchSelParameter->SetDpCMaterialAbove50ID( m_strDpCMaterialAbove50ID );
	pclDestinationBatchSelParameter->SetDpCConnectAbove50ID( m_strDpCConnectAbove50ID );
	pclDestinationBatchSelParameter->SetDpCVersionAbove50ID( m_strDpCVersionAbove50ID );
	pclDestinationBatchSelParameter->SetDpCPNAbove50ID( m_strDpCPNAbove50ID );
	pclDestinationBatchSelParameter->SetDpCBvTypeBelow65ID( m_strDpCBvTypeBelow65ID );
	pclDestinationBatchSelParameter->SetDpCBvFamilyBelow65ID( m_strDpCBvFamilyBelow65ID );
	pclDestinationBatchSelParameter->SetDpCBvMaterialBelow65ID( m_strDpCBvMaterialBelow65ID );
	pclDestinationBatchSelParameter->SetDpCBvConnectBelow65ID( m_strDpCBvConnectBelow65ID );
	pclDestinationBatchSelParameter->SetDpCBvVersionBelow65ID( m_strDpCBvVersionBelow65ID );
	pclDestinationBatchSelParameter->SetDpCBvPNBelow65ID( m_strDpCBvPNBelow65ID );
	pclDestinationBatchSelParameter->SetDpCBvTypeAbove50ID( m_strDpCBvTypeAbove50ID );
	pclDestinationBatchSelParameter->SetDpCBvFamilyAbove50ID( m_strDpCBvFamilyAbove50ID );
	pclDestinationBatchSelParameter->SetDpCBvMaterialAbove50ID( m_strDpCBvMaterialAbove50ID );
	pclDestinationBatchSelParameter->SetDpCBvConnectAbove50ID( m_strDpCBvConnectAbove50ID );
	pclDestinationBatchSelParameter->SetDpCBvVersionAbove50ID( m_strDpCBvVersionAbove50ID );
	pclDestinationBatchSelParameter->SetDpCBvPNAbove50ID( m_strDpCBvPNAbove50ID );

	pclDestinationBatchSelParameter->SetSmartControlValveRadioFlowState( m_iSmartControlValveRadioFlow );
	pclDestinationBatchSelParameter->SetSmartControlValveMaterialBelow65ID( m_strSmartControlValveMaterialBelow65ID );
	pclDestinationBatchSelParameter->SetSmartControlValveConnectBelow65ID( m_strSmartControlValveConnectBelow65ID );
	pclDestinationBatchSelParameter->SetSmartControlValvePNBelow65ID( m_strSmartControlValvePNBelow65ID );
	pclDestinationBatchSelParameter->SetSmartControlValveMaterialAbove50ID( m_strSmartControlValveMaterialAbove50ID );
	pclDestinationBatchSelParameter->SetSmartControlValveConnectAbove50ID( m_strSmartControlValveConnectAbove50ID );
	pclDestinationBatchSelParameter->SetSmartControlValvePNAbove50ID( m_strSmartControlValvePNAbove50ID );

	pclDestinationBatchSelParameter->SetSmartDpCRadioFlowState( m_iSmartDpCRadioFlow );
	pclDestinationBatchSelParameter->SetSmartDpCDpBranchCheckboxState( m_iSmartDpCCheckDpBranch );
	pclDestinationBatchSelParameter->SetSmartDpCDpMaxCheckboxState( m_iSmartDpCCheckDpMax );
	pclDestinationBatchSelParameter->SetSmartDpCMaterialBelow65ID( m_strSmartDpCMaterialBelow65ID );
	pclDestinationBatchSelParameter->SetSmartDpCConnectBelow65ID( m_strSmartDpCConnectBelow65ID );
	pclDestinationBatchSelParameter->SetSmartDpCPNBelow65ID( m_strSmartDpCPNBelow65ID );
	pclDestinationBatchSelParameter->SetSmartDpCMaterialAbove50ID( m_strSmartDpCMaterialAbove50ID );
	pclDestinationBatchSelParameter->SetSmartDpCConnectAbove50ID( m_strSmartDpCConnectAbove50ID );
	pclDestinationBatchSelParameter->SetSmartDpCPNAbove50ID( m_strSmartDpCPNAbove50ID );
}

#define CDS_BATCHSELPARAMETER_VERSION	11
// VErsion 11: 2022-09-05: HYS-1950: Add smart differential pressure controller.
// VErsion 10: 2020-11-04: HYS-1530: Add smart control valve.
// Version 9: 2019-10-08: HYS-1188: We split 'm_iDpCCheckDpKvs' in two variables.
// Version 8: 2019-08-19: 'm_iPICvFailSafeFct' type is now integer and variable 'm_ePICvDRPFct' is added.
// Version 7: 2017-11-14: Strict checkbox added for BCV AND PIBCV.
// Version 6: 2015-11-03: 2w/3w added for BCV, variables for DpC batch selection added (not yet activated).
// Version 5: 2015-07-16: DpC added.
// Version 4: 2014-03-20: Separator added.
// Version 3: 2014-02-21: BCv added.
// Version 2: PICV added.
void CDS_BatchSelParameter::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_BATCHSELPARAMETER_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CData::Write( outf );

	WriteString( outf, m_strPipeSeriesID );
	WriteString( outf, m_strPipeSizeID );

	// Write parameters for balancing valves.
	WriteData<>( outf, m_iBvRadioFlow );
	WriteData<>( outf, m_iBvCheckDp );
	WriteString( outf, m_strBvTypeBelow65ID );
	WriteString( outf, m_strBvFamilyBelow65ID );
	WriteString( outf, m_strBvMaterialBelow65ID );
	WriteString( outf, m_strBvConnectBelow65ID );
	WriteString( outf, m_strBvVersionBelow65ID );
	WriteString( outf, m_strBvPNBelow65ID );
	WriteString( outf, m_strBvTypeAbove50ID );
	WriteString( outf, m_strBvFamilyAbove50ID );
	WriteString( outf, m_strBvMaterialAbove50ID );
	WriteString( outf, m_strBvConnectAbove50ID );
	WriteString( outf, m_strBvVersionAbove50ID );
	WriteString( outf, m_strBvPNAbove50ID );

	// Write parameters for pressure independent control valves.
	WriteData<>( outf, m_iPICvRadioFlow );
	WriteData<>( outf, m_ePICvCBCtrlType );
	WriteString( outf, m_strPICvTypeBelow65ID );
	WriteString( outf, m_strPICvFamilyBelow65ID );
	WriteString( outf, m_strPICvMaterialBelow65ID );
	WriteString( outf, m_strPICvConnectBelow65ID );
	WriteString( outf, m_strPICvVersionBelow65ID );
	WriteString( outf, m_strPICvPNBelow65ID );
	WriteString( outf, m_strPICvTypeAbove50ID );
	WriteString( outf, m_strPICvFamilyAbove50ID );
	WriteString( outf, m_strPICvMaterialAbove50ID );
	WriteString( outf, m_strPICvConnectAbove50ID );
	WriteString( outf, m_strPICvVersionAbove50ID );
	WriteString( outf, m_strPICvPNAbove50ID );
	WriteString( outf, m_strPICvActPowerSupplyID );
	WriteString( outf, m_strPICvActInputSignalID );
	WriteData<>( outf, m_iPICvFailSafeFct );

	// Write parameters for balancing & control valves.
	WriteData<>( outf, m_iBCvRadioFlow );
	WriteData<>( outf, m_iBCvCheckDp );
	WriteData<>( outf, m_eBCvCBCtrlType );
	WriteString( outf, m_strBCvTypeBelow65ID );
	WriteString( outf, m_strBCvFamilyBelow65ID );
	WriteString( outf, m_strBCvMaterialBelow65ID );
	WriteString( outf, m_strBCvConnectBelow65ID );
	WriteString( outf, m_strBCvVersionBelow65ID );
	WriteString( outf, m_strBCvPNBelow65ID );
	WriteString( outf, m_strBCvTypeAbove50ID );
	WriteString( outf, m_strBCvFamilyAbove50ID );
	WriteString( outf, m_strBCvMaterialAbove50ID );
	WriteString( outf, m_strBCvConnectAbove50ID );
	WriteString( outf, m_strBCvVersionAbove50ID );
	WriteString( outf, m_strBCvPNAbove50ID );
	WriteString( outf, m_strBCvActPowerSupplyID );
	WriteString( outf, m_strBCvActInputSignalID );
	WriteData<>( outf, m_iBCvFailSafeFct );

	// Write parameters for separators.
	WriteData<>( outf, m_iSepRadioFlow );
	WriteString( outf, m_strSeparatorTypeID );
	WriteString( outf, m_strSeparatorFamilyID );
	WriteString( outf, m_strSeparatorConnectID );
	WriteString( outf, m_strSeparatorVersionID );

	// Write parameters for Dp controller valves.
	WriteData<>( outf, m_iDpCRadioFlow );
	WriteData<>( outf, m_iDpCCheckDpBranch );
	WriteData<>( outf, m_iDpCCheckDpMax );
	WriteData<>( outf, m_iDpCDpStab );
	WriteData<>( outf, m_iDpCDpCLocation );
	WriteData<>( outf, m_iDpCMvLocation );
	WriteString( outf, m_strDpCTypeBelow65ID );
	WriteString( outf, m_strDpCFamilyBelow65ID );
	WriteString( outf, m_strDpCMaterialBelow65ID );
	WriteString( outf, m_strDpCConnectBelow65ID );
	WriteString( outf, m_strDpCVersionBelow65ID );
	WriteString( outf, m_strDpCPNBelow65ID );
	WriteString( outf, m_strDpCTypeAbove50ID );
	WriteString( outf, m_strDpCFamilyAbove50ID );
	WriteString( outf, m_strDpCMaterialAbove50ID );
	WriteString( outf, m_strDpCConnectAbove50ID );
	WriteString( outf, m_strDpCVersionAbove50ID );
	WriteString( outf, m_strDpCPNAbove50ID );
	
	// For balancing valves selected with Dp controller valves.
	WriteString( outf, m_strDpCBvTypeBelow65ID );
	WriteString( outf, m_strDpCBvFamilyBelow65ID );
	WriteString( outf, m_strDpCBvMaterialBelow65ID );
	WriteString( outf, m_strDpCBvConnectBelow65ID );
	WriteString( outf, m_strDpCBvVersionBelow65ID );
	WriteString( outf, m_strDpCBvPNBelow65ID );
	WriteString( outf, m_strDpCBvTypeAbove50ID );
	WriteString( outf, m_strDpCBvFamilyAbove50ID );
	WriteString( outf, m_strDpCBvMaterialAbove50ID );
	WriteString( outf, m_strDpCBvConnectAbove50ID );
	WriteString( outf, m_strDpCBvVersionAbove50ID );
	WriteString( outf, m_strDpCBvPNAbove50ID );

	// Version 6: Write additional data for balancing & control valves.
	WriteData<>( outf, m_eBCv2W3W );

	// Version 7: Write additional data for balancing & control valves.
	WriteData<>( outf, m_bBCvCtrlTypeStrictChecked );
	WriteData<>( outf, m_bPICvCtrlTypeStrictChecked );

	// Version 8: Write Default return position
	WriteData<>( outf, m_eBCvDRPFct);
	WriteData<>( outf, m_ePICvDRPFct );

	// Version 9: HYS-1188: We split 'm_iDpCCheckDpKvs' in two variables.
	WriteData<>( outf, m_iDpCCheckKvs );

	// Version 10: HYS-1530: Write parameters for smart control valves.
	WriteData<>( outf, m_iSmartControlValveRadioFlow );
	WriteString( outf, m_strSmartControlValveMaterialBelow65ID );
	WriteString( outf, m_strSmartControlValveConnectBelow65ID );
	WriteString( outf, m_strSmartControlValvePNBelow65ID );
	WriteString( outf, m_strSmartControlValveMaterialAbove50ID );
	WriteString( outf, m_strSmartControlValveConnectAbove50ID );
	WriteString( outf, m_strSmartControlValvePNAbove50ID );

	// Version 11: HYS-1950: Write parameters for smart differential pressure controllers.
	WriteData<>( outf, m_iSmartDpCRadioFlow );
	WriteData<>( outf, m_iSmartDpCCheckDpBranch );
	WriteData<>( outf, m_iSmartDpCCheckDpMax );
	WriteString( outf, m_strSmartDpCMaterialBelow65ID );
	WriteString( outf, m_strSmartDpCConnectBelow65ID );
	WriteString( outf, m_strSmartDpCPNBelow65ID );
	WriteString( outf, m_strSmartDpCMaterialAbove50ID );
	WriteString( outf, m_strSmartDpCConnectAbove50ID );
	WriteString( outf, m_strSmartDpCPNAbove50ID );
}

bool CDS_BatchSelParameter::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_BATCHSELPARAMETER_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_BATCHSELPARAMETER_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strPipeSeriesID, sizeof( m_strPipeSeriesID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strPipeSizeID, sizeof( m_strPipeSizeID ) ) )
	{
		return false;
	}

	// Read parameters for balancing valves.
	inpf.read( (char *)&m_iBvRadioFlow, sizeof( m_iBvRadioFlow ) );
	inpf.read( (char *)&m_iBvCheckDp, sizeof( m_iBvCheckDp ) );

	if( false == ReadString( inpf, m_strBvTypeBelow65ID, sizeof( m_strBvTypeBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBvFamilyBelow65ID, sizeof( m_strBvFamilyBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBvMaterialBelow65ID, sizeof( m_strBvMaterialBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBvConnectBelow65ID, sizeof( m_strBvConnectBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBvVersionBelow65ID, sizeof( m_strBvVersionBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBvPNBelow65ID, sizeof( m_strBvPNBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBvTypeAbove50ID, sizeof( m_strBvTypeAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBvFamilyAbove50ID, sizeof( m_strBvFamilyAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBvMaterialAbove50ID, sizeof( m_strBvMaterialAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBvConnectAbove50ID, sizeof( m_strBvConnectAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBvVersionAbove50ID, sizeof( m_strBvVersionAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBvPNAbove50ID, sizeof( m_strBvPNAbove50ID ) ) )
	{
		return false;
	}

	if( Version < 2 )
	{
		return true;
	}

	// Read parameters for pressure independent control valves.
	inpf.read( (char *)&m_iPICvRadioFlow, sizeof( m_iPICvRadioFlow ) );
	inpf.read( (char *)&m_ePICvCBCtrlType, sizeof( m_ePICvCBCtrlType ) );

	if( false == ReadString( inpf, m_strPICvTypeBelow65ID, sizeof( m_strPICvTypeBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strPICvFamilyBelow65ID, sizeof( m_strPICvFamilyBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strPICvMaterialBelow65ID, sizeof( m_strPICvMaterialBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strPICvConnectBelow65ID, sizeof( m_strPICvConnectBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strPICvVersionBelow65ID, sizeof( m_strPICvVersionBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strPICvPNBelow65ID, sizeof( m_strPICvPNBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strPICvTypeAbove50ID, sizeof( m_strPICvTypeAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strPICvFamilyAbove50ID, sizeof( m_strPICvFamilyAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strPICvMaterialAbove50ID, sizeof( m_strPICvMaterialAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strPICvConnectAbove50ID, sizeof( m_strPICvConnectAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strPICvVersionAbove50ID, sizeof( m_strPICvVersionAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strPICvPNAbove50ID, sizeof( m_strPICvPNAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strPICvActPowerSupplyID, sizeof( m_strPICvActPowerSupplyID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strPICvActInputSignalID, sizeof( m_strPICvActInputSignalID ) ) )
	{
		return false;
	}

	bool bIsDRPPICvReaded = false;

	if( Version >= 8 )
	{
		inpf.read( (char *)&m_iPICvFailSafeFct, sizeof( m_iPICvFailSafeFct ) );
	}
	else
	{
		inpf.read( (char *)&m_ePICvDRPFct, sizeof( m_ePICvDRPFct ) );
		bIsDRPPICvReaded = true;
		m_iPICvFailSafeFct = 0;
	}

	if( Version < 3 )
	{
		return true;
	}

	// Read parameters for balancing & control valves.
	inpf.read( (char *)&m_iBCvRadioFlow, sizeof( m_iBCvRadioFlow ) );
	inpf.read( (char *)&m_iBCvCheckDp, sizeof( m_iBCvCheckDp ) );
	inpf.read( (char *)&m_eBCvCBCtrlType, sizeof( m_eBCvCBCtrlType ) );

	if( false == ReadString( inpf, m_strBCvTypeBelow65ID, sizeof( m_strBCvTypeBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBCvFamilyBelow65ID, sizeof( m_strBCvFamilyBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBCvMaterialBelow65ID, sizeof( m_strBCvMaterialBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBCvConnectBelow65ID, sizeof( m_strBCvConnectBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBCvVersionBelow65ID, sizeof( m_strBCvVersionBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBCvPNBelow65ID, sizeof( m_strBCvPNBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBCvTypeAbove50ID, sizeof( m_strBCvTypeAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBCvFamilyAbove50ID, sizeof( m_strBCvFamilyAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBCvMaterialAbove50ID, sizeof( m_strBCvMaterialAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBCvConnectAbove50ID, sizeof( m_strBCvConnectAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBCvVersionAbove50ID, sizeof( m_strBCvVersionAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBCvPNAbove50ID, sizeof( m_strBCvPNAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBCvActPowerSupplyID, sizeof( m_strBCvActPowerSupplyID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strBCvActInputSignalID, sizeof( m_strBCvActInputSignalID ) ) )
	{
		return false;
	}

	bool bIsDRPBCVReaded = false;

	if( Version >= 8 )
	{
		inpf.read( (char *)&m_iBCvFailSafeFct, sizeof( m_iBCvFailSafeFct ) );
	}
	else
	{
		inpf.read( (char *)&m_eBCvDRPFct, sizeof( m_eBCvDRPFct ) );
		bIsDRPBCVReaded = true;
		m_iBCvFailSafeFct = 0;
	}

	if( Version < 4 )
	{
		return true;
	}

	// Read parameters for separators.
	inpf.read( (char *)&m_iSepRadioFlow, sizeof( m_iSepRadioFlow ) );

	if( false == ReadString( inpf, m_strSeparatorTypeID, sizeof( m_strSeparatorTypeID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strSeparatorFamilyID, sizeof( m_strSeparatorFamilyID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strSeparatorConnectID, sizeof( m_strSeparatorConnectID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strSeparatorVersionID, sizeof( m_strSeparatorVersionID ) ) )
	{
		return false;
	}

	if( Version < 5 )
	{
		return true;
	}

	// Read parameters for Dp controller valves.
	inpf.read( (char *)&m_iDpCRadioFlow, sizeof( m_iDpCRadioFlow ) );
	inpf.read( (char *)&m_iDpCCheckDpBranch, sizeof( m_iDpCCheckDpBranch ) );
	inpf.read( (char *)&m_iDpCCheckDpMax, sizeof( m_iDpCCheckDpMax ) );
	inpf.read( (char *)&m_iDpCDpStab, sizeof( m_iDpCDpStab ) );
	inpf.read( (char *)&m_iDpCDpCLocation, sizeof( m_iDpCDpCLocation ) );
	inpf.read( (char *)&m_iDpCMvLocation, sizeof( m_iDpCMvLocation ) );

	if( false == ReadString( inpf, m_strDpCTypeBelow65ID, sizeof( m_strDpCTypeBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCFamilyBelow65ID, sizeof( m_strDpCFamilyBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCMaterialBelow65ID, sizeof( m_strDpCMaterialBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCConnectBelow65ID, sizeof( m_strDpCConnectBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCVersionBelow65ID, sizeof( m_strDpCVersionBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCPNBelow65ID, sizeof( m_strDpCPNBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCTypeAbove50ID, sizeof( m_strDpCTypeAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCFamilyAbove50ID, sizeof( m_strDpCFamilyAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCMaterialAbove50ID, sizeof( m_strDpCMaterialAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCConnectAbove50ID, sizeof( m_strDpCConnectAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCVersionAbove50ID, sizeof( m_strDpCVersionAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCPNAbove50ID, sizeof( m_strDpCPNAbove50ID ) ) )
	{
		return false;
	}

	// For balancing valves selected with Dp controller valves.
	if( false == ReadString( inpf, m_strDpCBvTypeBelow65ID, sizeof( m_strDpCBvTypeBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCBvFamilyBelow65ID, sizeof( m_strDpCBvFamilyBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCBvMaterialBelow65ID, sizeof( m_strDpCBvMaterialBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCBvConnectBelow65ID, sizeof( m_strDpCBvConnectBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCBvVersionBelow65ID, sizeof( m_strDpCBvVersionBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCBvPNBelow65ID, sizeof( m_strDpCBvPNBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCBvTypeAbove50ID, sizeof( m_strDpCBvTypeAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCBvFamilyAbove50ID, sizeof( m_strDpCBvFamilyAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCBvMaterialAbove50ID, sizeof( m_strDpCBvMaterialAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCBvConnectAbove50ID, sizeof( m_strDpCBvConnectAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCBvVersionAbove50ID, sizeof( m_strDpCBvVersionAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strDpCBvPNAbove50ID, sizeof( m_strDpCBvPNAbove50ID ) ) )
	{
		return false;
	}

	if( Version < 6 )
	{
		return true;
	}

	// Version 6: Read additional data for balancing & control valves and PIBCV.
	inpf.read( (char *)&m_eBCv2W3W, sizeof( m_eBCv2W3W ) );

	if( Version < 7 )
	{
		return true;
	}

	// Version 7: Read additional data for balancing & control valves.
	inpf.read( (char *)&m_bBCvCtrlTypeStrictChecked, sizeof( m_bBCvCtrlTypeStrictChecked ) );

	// Read additional data for pressure independent, balancing & control valves.
	inpf.read( (char *)&m_bPICvCtrlTypeStrictChecked, sizeof( m_bPICvCtrlTypeStrictChecked ) );

	if( Version < 8 )
	{
		return true;
	}

	// Version 8: read Default return position
	if( bIsDRPBCVReaded == false )
	{
		inpf.read( (char *)&m_eBCvDRPFct, sizeof( m_eBCvDRPFct ) );
	}

	if( bIsDRPPICvReaded == false )
	{
		inpf.read( (char *)&m_ePICvDRPFct, sizeof( m_ePICvDRPFct ) );
	}

	if( Version < 9 )
	{
		return true;
	}

	// Version 9: HYS-1188: We split 'm_iDpCCheckDpKvs' in two variables.
	inpf.read( (char *)&m_iDpCCheckKvs, sizeof( m_iDpCCheckKvs ) );

	if( Version < 10 )
	{
		return true;
	}

	// Version 10: HYS-1530: Read parameters for smart control valves.
	inpf.read( (char *)&m_iSmartControlValveRadioFlow, sizeof( m_iSmartControlValveRadioFlow ) );

	if( false == ReadString( inpf, m_strSmartControlValveMaterialBelow65ID, sizeof( m_strSmartControlValveMaterialBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strSmartControlValveConnectBelow65ID, sizeof( m_strSmartControlValveConnectBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strSmartControlValvePNBelow65ID, sizeof( m_strSmartControlValvePNBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strSmartControlValveMaterialAbove50ID, sizeof( m_strSmartControlValveMaterialAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strSmartControlValveConnectAbove50ID, sizeof( m_strSmartControlValveConnectAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strSmartControlValvePNAbove50ID, sizeof( m_strSmartControlValvePNAbove50ID ) ) )
	{
		return false;
	}

	if( Version < 11 )
	{
		return true;
	}

	// Version 11: HYS-1950: Write parameters for smart differential pressure controllers.
	inpf.read( (char *)&m_iSmartDpCRadioFlow, sizeof( m_iSmartDpCRadioFlow ) );
	inpf.read( (char *)&m_iSmartDpCCheckDpBranch, sizeof( m_iSmartDpCCheckDpBranch ) );
	inpf.read( (char *)&m_iSmartDpCCheckDpMax, sizeof( m_iSmartDpCCheckDpMax ) );

	if( false == ReadString( inpf, m_strSmartDpCMaterialBelow65ID, sizeof( m_strSmartDpCMaterialBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strSmartDpCConnectBelow65ID, sizeof( m_strSmartDpCConnectBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strSmartDpCPNBelow65ID, sizeof( m_strSmartDpCPNBelow65ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strSmartDpCMaterialAbove50ID, sizeof( m_strSmartDpCMaterialAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strSmartDpCConnectAbove50ID, sizeof( m_strSmartDpCConnectAbove50ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strSmartDpCPNAbove50ID, sizeof( m_strSmartDpCPNAbove50ID ) ) )
	{
		return false;
	}

	return true;
}

void CDS_BatchSelParameter::VerifyIntegrity()
{
	// Called only if opening a project saved with a version of HySelect below to 4.2.3.4.

	CPrjParams *pclPrjParams = new CPrjParams( NULL );

	if( NULL != pclPrjParams )
	{
		pclPrjParams->ResetPrjParams( true );
	}

	CString str;

	// Verify parameters for balancing valves.
	if( true == CString( m_strBvTypeBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvTypeBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvBlw65TypeID ) : m_strBvTypeBelow65ID );

		_tcsncpy_s( m_strBvTypeBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strBvFamilyBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvFamilyBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvBlw65FamilyID ) : m_strBvFamilyBelow65ID );

		_tcsncpy_s( m_strBvFamilyBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strBvMaterialBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvMaterialBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvBlw65BdyMatID ) : m_strBvMaterialBelow65ID );

		_tcsncpy_s( m_strBvMaterialBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strBvConnectBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvConnectBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvBlw65ConnectID ) : m_strBvConnectBelow65ID );

		_tcsncpy_s( m_strBvConnectBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strBvVersionBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvVersionBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvBlw65VersionID ) : m_strBvVersionBelow65ID );

		_tcsncpy_s( m_strBvVersionBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strBvPNBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvPNBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvBlw65PNID ) : m_strBvPNBelow65ID );

		_tcsncpy_s( m_strBvPNBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strBvTypeAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvTypeAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvAbv50TypeID ) : m_strBvTypeAbove50ID );

		_tcsncpy_s( m_strBvTypeAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strBvFamilyAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvFamilyAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvAbv50FamilyID ) : m_strBvFamilyAbove50ID );

		_tcsncpy_s( m_strBvFamilyAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strBvMaterialAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvMaterialAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvAbv50BdyMatID ) : m_strBvMaterialAbove50ID );

		_tcsncpy_s( m_strBvMaterialAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strBvConnectAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvConnectAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvAbv50ConnectID ) : m_strBvConnectAbove50ID );

		_tcsncpy_s( m_strBvConnectAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strBvVersionAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvVersionAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvAbv50VersionID ) : m_strBvVersionAbove50ID );

		_tcsncpy_s( m_strBvVersionAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strBvPNAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvPNAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvAbv50PNID ) : m_strBvPNAbove50ID );

		_tcsncpy_s( m_strBvPNAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	// Read parameters for pressure independent control valves.

	// We set 'eLastCvCtrlType' by default to allow us to detect if key exists or not.
	// If key doesn't exist, we must determine what is the control type to set in regards to other keys (Type, Family ...).
	// It can be the case when HySelect is launched for the first time. In that case, for 'Type', 'Family' and so on, we take values from 'CPrjParams'. But control
	// type is not saved. We need thus to determine control type once these values are read.
	m_ePICvCBCtrlType = ( CDB_ControlProperties::CvCtrlType )::AfxGetApp()->GetProfileInt( m_strSectionName, _T("PICvCBCtrlType"), CDB_ControlProperties::CvCtrlType::eLastCvCtrlType );

	if( true == CString( m_strPICvTypeBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvTypeBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::PICvBlw65TypeID ) : m_strPICvTypeBelow65ID );

		_tcsncpy_s( m_strPICvTypeBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strPICvFamilyBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvFamilyBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::PICvBlw65FamilyID ) : m_strPICvFamilyBelow65ID );

		_tcsncpy_s( m_strPICvFamilyBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strPICvMaterialBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvMaterialBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::PICvBlw65BdyMatID ) : m_strPICvMaterialBelow65ID );

		_tcsncpy_s( m_strPICvMaterialBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strPICvConnectBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvConnectBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::PICvBlw65ConnectID ) : m_strPICvConnectBelow65ID );

		_tcsncpy_s( m_strPICvConnectBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strPICvVersionBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvVersionBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::PICvBlw65VersionID ) : m_strPICvVersionBelow65ID );

		_tcsncpy_s( m_strPICvVersionBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strPICvPNBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvPNBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::PICvBlw65PNID ) : m_strPICvPNBelow65ID );

		_tcsncpy_s( m_strPICvPNBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strPICvTypeAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvTypeAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::PICvAbv50TypeID ) : m_strPICvTypeAbove50ID );

		_tcsncpy_s( m_strPICvTypeAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strPICvFamilyAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvFamilyAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::PICvAbv50FamilyID ) : m_strPICvFamilyAbove50ID );

		_tcsncpy_s( m_strPICvFamilyAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strPICvMaterialAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvMaterialAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::PICvAbv50BdyMatID ) : m_strPICvMaterialAbove50ID );

		_tcsncpy_s( m_strPICvMaterialAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strPICvConnectAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvConnectAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::PICvAbv50ConnectID ) : m_strPICvConnectAbove50ID );

		_tcsncpy_s( m_strPICvConnectAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strPICvVersionAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvVersionAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::PICvAbv50VersionID ) : m_strPICvVersionAbove50ID );

		_tcsncpy_s( m_strPICvVersionAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strPICvPNAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvPNAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::PICvAbv50PNID ) : m_strPICvPNAbove50ID );

		_tcsncpy_s( m_strPICvPNAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strPICvActPowerSupplyID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvActPowerSupplyID"), m_strPICvActPowerSupplyID );
		_tcsncpy_s( m_strPICvActPowerSupplyID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strPICvActInputSignalID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvActInputSignalID"), m_strPICvActInputSignalID );
		_tcsncpy_s( m_strPICvActInputSignalID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	// See remarks just above.
	if( CDB_ControlProperties::CvCtrlType::eLastCvCtrlType == m_ePICvCBCtrlType )
	{
		CRankEx rList;
		TASApp.GetpTADB()->GetTaCVList( &rList, CTADatabase::eForPiCv, false, CDB_ControlProperties::LastCV2W3W, m_strPICvTypeBelow65ID, m_strPICvFamilyBelow65ID,
				m_strPICvMaterialBelow65ID, m_strPICvConnectBelow65ID, m_strPICvVersionBelow65ID, m_strPICvPNBelow65ID, CDB_ControlProperties::LastCVFUNC,
				CDB_ControlProperties::eCvNU, CTADatabase::ForHMCalc );

		_string str;
		CData *pData;

		if( TRUE == rList.GetFirstT<CData *>( str, pData ) )
		{
			CDB_ControlValve *pCV = dynamic_cast<CDB_ControlValve *>( pData );
			ASSERT( NULL != pCV );

			if( NULL != pCV && NULL != pCV->GetCtrlProp() )
			{
				m_ePICvCBCtrlType = pCV->GetCtrlProp()->GetCtrlType();
			}
		}
	}

	// Read parameters for balancing & control valves.

	// We set 'eLastCvCtrlType' by default to allow us to detect if key exists or not.
	// If key doesn't exist, we must determine what is the control type to set in regards to other keys (Type, Family ...).
	// It can be the case when HySelect is launched for the first time. In that case, for 'Type', 'Family' and so on, we take values from 'CPrjParams'. But control
	// type is not saved. We need thus to determine control type once these values are read.
	m_eBCvCBCtrlType = ( CDB_ControlProperties::CvCtrlType )::AfxGetApp()->GetProfileInt( m_strSectionName, _T("BCvCBCtrlType"),
					   CDB_ControlProperties::CvCtrlType::eLastCvCtrlType );

	if( true == CString( m_strBCvTypeBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvTypeBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BCvBlw65TypeID ) : m_strBCvTypeBelow65ID );
		_tcsncpy_s( m_strBCvTypeBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strBCvFamilyBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvFamilyBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BCvBlw65FamilyID ) : m_strBCvFamilyBelow65ID );
		_tcsncpy_s( m_strBCvFamilyBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strBCvMaterialBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvMaterialBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BCvBlw65BdyMatID ) : m_strBCvMaterialBelow65ID );

		_tcsncpy_s( m_strBCvMaterialBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strBCvConnectBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvConnectBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BCvBlw65ConnectID ) : m_strBCvConnectBelow65ID );

		_tcsncpy_s( m_strBCvConnectBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strBCvVersionBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvVersionBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BCvBlw65VersionID ) : m_strBCvVersionBelow65ID );

		_tcsncpy_s( m_strBCvVersionBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strBCvPNBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvPNBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BCvBlw65PNID ) : m_strBCvPNBelow65ID );

		_tcsncpy_s( m_strBCvPNBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strBCvTypeAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvTypeAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BCvAbv50TypeID ) : m_strBCvTypeAbove50ID );

		_tcsncpy_s( m_strBCvTypeAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strBCvFamilyAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvFamilyAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BCvAbv50FamilyID ) : m_strBCvFamilyAbove50ID );

		_tcsncpy_s( m_strBCvFamilyAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strBCvMaterialAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvMaterialAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BCvAbv50BdyMatID ) : m_strBCvMaterialAbove50ID );

		_tcsncpy_s( m_strBCvMaterialAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strBCvConnectAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvConnectAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BCvAbv50ConnectID ) : m_strBCvConnectAbove50ID );

		_tcsncpy_s( m_strBCvConnectAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strBCvVersionAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvVersionAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BCvAbv50VersionID ) : m_strBCvVersionAbove50ID );

		_tcsncpy_s( m_strBCvVersionAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strBCvPNAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvPNAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BCvAbv50PNID ) : m_strBCvPNAbove50ID );

		_tcsncpy_s( m_strBCvPNAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strBCvActPowerSupplyID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvActPowerSupplyID"), m_strBCvActPowerSupplyID );
		_tcsncpy_s( m_strBCvActPowerSupplyID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strBCvActInputSignalID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvActInputSignalID"), m_strBCvActInputSignalID );
		_tcsncpy_s( m_strBCvActInputSignalID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	// See remarks just above.
	if( CDB_ControlProperties::CvCtrlType::eLastCvCtrlType == m_eBCvCBCtrlType )
	{
		CRankEx rList;
		TASApp.GetpTADB()->GetTaCVList( &rList, CTADatabase::eForTechHCBCv, false, CDB_ControlProperties::LastCV2W3W, m_strBCvTypeBelow65ID, m_strBCvFamilyBelow65ID,
				m_strBCvMaterialBelow65ID, m_strBCvConnectBelow65ID, m_strBCvVersionBelow65ID, m_strBCvPNBelow65ID, CDB_ControlProperties::LastCVFUNC,
				CDB_ControlProperties::eCvNU, CTADatabase::ForHMCalc );

		_string str;
		CData *pData = NULL;

		if( TRUE == rList.GetFirstT<CData *>( str, pData ) )
		{
			CDB_ControlValve *pCV = dynamic_cast<CDB_ControlValve *>( pData );
			ASSERT( NULL != pCV );

			if( NULL != pCV && NULL != pCV->GetCtrlProp() )
			{
				m_eBCvCBCtrlType = pCV->GetCtrlProp()->GetCtrlType();
				m_eBCv2W3W = pCV->GetCtrlProp()->GetCv2w3w();
			}
		}
	}

	// Read parameters for separators.
	if( true == CString( m_strSeparatorTypeID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SepTypeID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SeparatorTypeID ) : m_strSeparatorTypeID );

		_tcsncpy_s( m_strSeparatorTypeID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strSeparatorFamilyID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SepFamilyID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SeparatorFamilyID ) : m_strSeparatorFamilyID );

		_tcsncpy_s( m_strSeparatorFamilyID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strSeparatorConnectID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SepConnectID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SeparatorConnectID ) : m_strSeparatorConnectID );

		_tcsncpy_s( m_strSeparatorConnectID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strSeparatorVersionID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SepVersionID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SeparatorVersionID ) : m_strSeparatorVersionID );

		_tcsncpy_s( m_strSeparatorVersionID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	// Read parameters for Dp controller valves.
	if( true == CString( m_strDpCTypeBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCTypeBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCBlw65TypeID ) : m_strDpCTypeBelow65ID );

		_tcsncpy_s( m_strDpCTypeBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strDpCFamilyBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCFamilyBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCBlw65FamilyID ) : m_strDpCFamilyBelow65ID );

		_tcsncpy_s( m_strDpCFamilyBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strDpCMaterialBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCMaterialBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCBlw65BdyMatID ) : m_strDpCMaterialBelow65ID );

		_tcsncpy_s( m_strDpCMaterialBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strDpCConnectBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCConnectBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCBlw65ConnectID ) : m_strDpCConnectBelow65ID );

		_tcsncpy_s( m_strDpCConnectBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strDpCVersionBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCVersionBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCBlw65VersionID ) : m_strDpCVersionBelow65ID );

		_tcsncpy_s( m_strDpCVersionBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strDpCPNBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCPNBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCBlw65PNID ) : m_strDpCPNBelow65ID );

		_tcsncpy_s( m_strDpCPNBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strDpCTypeAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCTypeAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCAbv50TypeID ) : m_strDpCTypeAbove50ID );

		_tcsncpy_s( m_strDpCTypeAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strDpCFamilyAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCFamilyAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCAbv50FamilyID ) : m_strDpCFamilyAbove50ID );

		_tcsncpy_s( m_strDpCFamilyAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strDpCMaterialAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCMaterialAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCAbv50BdyMatID ) : m_strDpCMaterialAbove50ID );

		_tcsncpy_s( m_strDpCMaterialAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strDpCConnectAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCConnectAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCAbv50ConnectID ) : m_strDpCConnectAbove50ID );

		_tcsncpy_s( m_strDpCConnectAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strDpCVersionAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCVersionAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCAbv50VersionID ) : m_strDpCVersionAbove50ID );

		_tcsncpy_s( m_strDpCVersionAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strDpCPNAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCPNAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCAbv50PNID ) : m_strDpCPNAbove50ID );

		_tcsncpy_s( m_strDpCPNAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	// For balancing valves selected with Dp controller valves.
	if( true == CString( m_strDpCBvTypeBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBvTypeBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvBlw65TypeID ) : m_strDpCBvTypeBelow65ID );

		_tcsncpy_s( m_strDpCBvTypeBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strDpCBvFamilyBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBvFamilyBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvBlw65FamilyID ) : m_strDpCBvFamilyBelow65ID );

		_tcsncpy_s( m_strDpCBvFamilyBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strDpCBvMaterialBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBvMaterialBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvBlw65BdyMatID ) : m_strDpCBvMaterialBelow65ID );

		_tcsncpy_s( m_strDpCBvMaterialBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strDpCBvConnectBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBvConnectBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvBlw65ConnectID ) : m_strDpCBvConnectBelow65ID );

		_tcsncpy_s( m_strDpCBvConnectBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strDpCBvVersionBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBvVersionBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvBlw65VersionID ) : m_strDpCBvVersionBelow65ID );

		_tcsncpy_s( m_strDpCBvVersionBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strDpCBvPNBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBvPNBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvBlw65PNID ) : m_strDpCBvPNBelow65ID );

		_tcsncpy_s( m_strDpCBvPNBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strDpCBvTypeAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBvTypeAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvAbv50TypeID ) : m_strDpCBvTypeAbove50ID );

		_tcsncpy_s( m_strDpCBvTypeAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strDpCBvFamilyAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBvFamilyAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvAbv50FamilyID ) : m_strDpCBvFamilyAbove50ID );

		_tcsncpy_s( m_strDpCBvFamilyAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strDpCBvMaterialAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBvMaterialAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvAbv50BdyMatID ) : m_strDpCBvMaterialAbove50ID );

		_tcsncpy_s( m_strDpCBvMaterialAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strDpCBvConnectAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBvConnectAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvAbv50ConnectID ) : m_strDpCBvConnectAbove50ID );

		_tcsncpy_s( m_strDpCBvConnectAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strDpCBvVersionAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBvVersionAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvAbv50VersionID ) : m_strDpCBvVersionAbove50ID );

		_tcsncpy_s( m_strDpCBvVersionAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strDpCBvPNAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBvPNAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvAbv50PNID ) : m_strDpCBvPNAbove50ID );

		_tcsncpy_s( m_strDpCBvPNAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	// Verify parameters for smart control valves.
	if( true == CString( m_strSmartControlValveMaterialBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartControlValveMaterialBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SmartControlValveBlw65BdyMatID ) : m_strSmartControlValveMaterialBelow65ID );

		_tcsncpy_s( m_strSmartControlValveMaterialBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strSmartControlValveConnectBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartControlValveConnectBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SmartControlValveBlw65ConnectID ) : m_strSmartControlValveConnectBelow65ID );

		_tcsncpy_s( m_strSmartControlValveConnectBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strSmartControlValvePNBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartControlValvePNBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SmartControlValveBlw65PNID ) : m_strSmartControlValvePNBelow65ID );

		_tcsncpy_s( m_strSmartControlValvePNBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strSmartControlValveMaterialAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartControlValveMaterialAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SmartControlValveAbv50BdyMatID ) : m_strSmartControlValveMaterialAbove50ID );

		_tcsncpy_s( m_strSmartControlValveMaterialAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strSmartControlValveConnectAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartControlValveConnectAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SmartControlValveAbv50ConnectID ) : m_strSmartControlValveConnectAbove50ID );

		_tcsncpy_s( m_strSmartControlValveConnectAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strSmartControlValvePNAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartControlValvePNAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SmartControlValveAbv50PNID ) : m_strSmartControlValvePNAbove50ID );

		_tcsncpy_s( m_strSmartControlValvePNAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	// Verify parameters for smart differential pressure controllers.
	if( true == CString( m_strSmartDpCMaterialBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartDpCMaterialBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SmartDpCBlw65BdyMatID ) : m_strSmartDpCMaterialBelow65ID );

		_tcsncpy_s( m_strSmartDpCMaterialBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strSmartDpCConnectBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartDpCConnectBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SmartDpCBlw65ConnectID ) : m_strSmartDpCConnectBelow65ID );

		_tcsncpy_s( m_strSmartDpCConnectBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strSmartDpCPNBelow65ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartDpCPNBelow65ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SmartDpCBlw65PNID ) : m_strSmartDpCPNBelow65ID );

		_tcsncpy_s( m_strSmartDpCPNBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strSmartDpCMaterialAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartDpCMaterialAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SmartDpCAbv50BdyMatID ) : m_strSmartDpCMaterialAbove50ID );

		_tcsncpy_s( m_strSmartDpCMaterialAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strSmartDpCConnectAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartDpCConnectAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SmartDpCAbv50ConnectID ) : m_strSmartDpCConnectAbove50ID );

		_tcsncpy_s( m_strSmartDpCConnectAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( true == CString( m_strSmartDpCPNAbove50ID ).IsEmpty() )
	{
		str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartDpCPNAbove50ID"),
				( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SmartDpCAbv50PNID ) : m_strSmartDpCPNAbove50ID );

		_tcsncpy_s( m_strSmartDpCPNAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	}

	if( NULL != pclPrjParams )
	{
		delete pclPrjParams;
	}
}

void CDS_BatchSelParameter::WriteToRegistry()
{
	CDS_SelParameterBase::WriteToRegistry();

	// Write parameters common to all selections.
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PipeSeriesID"), m_strPipeSeriesID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PipeSizeID"), m_strPipeSizeID );

	// Write parameters for balancing valves.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("BvRadioFlow"), m_iBvRadioFlow );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("BvCheckDp"), m_iBvCheckDp );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BvTypeBelow65ID"), m_strBvTypeBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BvFamilyBelow65ID"), m_strBvFamilyBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BvMaterialBelow65ID"), m_strBvMaterialBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BvConnectBelow65ID"), m_strBvConnectBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BvVersionBelow65ID"), m_strBvVersionBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BvPNBelow65ID"), m_strBvPNBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BvTypeAbove50ID"), m_strBvTypeAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BvFamilyAbove50ID"), m_strBvFamilyAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BvMaterialAbove50ID"), m_strBvMaterialAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BvConnectAbove50ID"), m_strBvConnectAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BvVersionAbove50ID"), m_strBvVersionAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BvPNAbove50ID"), m_strBvPNAbove50ID );

	// Write parameters for pressure independent control valves.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("PICvRadioFlow"), m_iPICvRadioFlow );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("PICvCtrlTypeStrictChecked"), ( int )m_bPICvCtrlTypeStrictChecked );	// Version 7.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("PICvCBCtrlType"), m_ePICvCBCtrlType );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PICvTypeBelow65ID"), m_strPICvTypeBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PICvFamilyBelow65ID"), m_strPICvFamilyBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PICvMaterialBelow65ID"), m_strPICvMaterialBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PICvConnectBelow65ID"), m_strPICvConnectBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PICvVersionBelow65ID"), m_strPICvVersionBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PICvPNBelow65ID"), m_strPICvPNBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PICvTypeAbove50ID"), m_strPICvTypeAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PICvFamilyAbove50ID"), m_strPICvFamilyAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PICvMaterialAbove50ID"), m_strPICvMaterialAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PICvConnectAbove50ID"), m_strPICvConnectAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PICvVersionAbove50ID"), m_strPICvVersionAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PICvPNAbove50ID"), m_strPICvPNAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PICvActPowerSupplyID"), m_strPICvActPowerSupplyID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PICvActInputSignalID"), m_strPICvActInputSignalID );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("PICvFailSafeFct"), m_iPICvFailSafeFct );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("PICvDRPFct"), m_ePICvDRPFct );

	// Write parameters for balancing & control valves.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("BCvRadioFlow"), m_iBCvRadioFlow );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("BCvCheckDp"), m_iBCvCheckDp );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("BCvCtrlTypeStrictChecked"), ( int )m_bBCvCtrlTypeStrictChecked );		// Version 7.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("BCvCB2W3W"), m_eBCv2W3W );			// Version 6.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("BCvCBCtrlType"), m_eBCvCBCtrlType );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BCvTypeBelow65ID"), m_strBCvTypeBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BCvFamilyBelow65ID"), m_strBCvFamilyBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BCvMaterialBelow65ID"), m_strBCvMaterialBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BCvConnectBelow65ID"), m_strBCvConnectBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BCvVersionBelow65ID"), m_strBCvVersionBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BCvPNBelow65ID"), m_strBCvPNBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BCvTypeAbove50ID"), m_strBCvTypeAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BCvFamilyAbove50ID"), m_strBCvFamilyAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BCvMaterialAbove50ID"), m_strBCvMaterialAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BCvConnectAbove50ID"), m_strBCvConnectAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BCvVersionAbove50ID"), m_strBCvVersionAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BCvPNAbove50ID"), m_strBCvPNAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BCvActPowerSupplyID"), m_strBCvActPowerSupplyID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("BCvActInputSignalID"), m_strBCvActInputSignalID );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("BCvFailSafeFct"), m_iBCvFailSafeFct );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("BCvDRPFct"), m_eBCvDRPFct );

	// Write parameters for separators.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("SepRadioFlow"), m_iSepRadioFlow );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SepTypeID"), m_strSeparatorTypeID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SepFamilyID"), m_strSeparatorFamilyID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SepConnectID"), m_strSeparatorConnectID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SepVersionID"), m_strSeparatorVersionID );

	// Write parameters for Dp controller valves.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("DpCRadioFlow"), m_iDpCRadioFlow );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("DpCCheckDpBranch"), m_iDpCCheckDpBranch );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("DpCCheckKvs"), m_iDpCCheckKvs );		// Version 9.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("DpCCheckDpMax"), m_iDpCCheckDpMax );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("DpCDpStab"), m_iDpCDpStab );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("DpCDpCLocation"), m_iDpCDpCLocation );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("DpCMvLocation"), m_iDpCMvLocation );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCTypeBelow65ID"), m_strDpCTypeBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCFamilyBelow65ID"), m_strDpCFamilyBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCMaterialBelow65ID"), m_strDpCMaterialBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCConnectBelow65ID"), m_strDpCConnectBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCVersionBelow65ID"), m_strDpCVersionBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCPNBelow65ID"), m_strDpCPNBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCTypeAbove50ID"), m_strDpCTypeAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCFamilyAbove50ID"), m_strDpCFamilyAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCMaterialAbove50ID"), m_strDpCMaterialAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCConnectAbove50ID"), m_strDpCConnectAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCVersionAbove50ID"), m_strDpCVersionAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCPNAbove50ID"), m_strDpCPNAbove50ID );
	
	// For balancing valves selected with Dp controller valves.
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCBvTypeBelow65ID"), m_strDpCBvTypeBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCBvFamilyBelow65ID"), m_strDpCBvFamilyBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCBvMaterialBelow65ID"), m_strDpCBvMaterialBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCBvConnectBelow65ID"), m_strDpCBvConnectBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCBvVersionBelow65ID"), m_strDpCBvVersionBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCBvPNBelow65ID"), m_strDpCBvPNBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCBvTypeAbove50ID"), m_strDpCBvTypeAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCBvFamilyAbove50ID"), m_strDpCBvFamilyAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCBvMaterialAbove50ID"), m_strDpCBvMaterialAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCBvConnectAbove50ID"), m_strDpCBvConnectAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCBvVersionAbove50ID"), m_strDpCBvVersionAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("DpCBvPNAbove50ID"), m_strDpCBvPNAbove50ID );

	// Write parameters for smart control valves.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("SmartControlValveRadioFlow"), m_iSmartControlValveRadioFlow );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SmartControlValveMaterialBelow65ID"), m_strSmartControlValveMaterialBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SmartControlValveConnectBelow65ID"), m_strSmartControlValveConnectBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SmartControlValvePNBelow65ID"), m_strSmartControlValvePNBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SmartControlValveMaterialAbove50ID"), m_strSmartControlValveMaterialAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SmartControlValveConnectAbove50ID"), m_strSmartControlValveConnectAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SmartControlValvePNAbove50ID"), m_strSmartControlValvePNAbove50ID );

	// Write parameters for smart differential pressure controllers.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("SmartDpCRadioFlow"), m_iSmartDpCRadioFlow );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("SmartDpCCheckDpBranch"), m_iSmartDpCCheckDpBranch );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("SmartDpCCheckDpMax"), m_iSmartDpCCheckDpMax );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SmartDpCMaterialBelow65ID"), m_strSmartDpCMaterialBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SmartDpCConnectBelow65ID"), m_strSmartDpCConnectBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SmartDpCPNBelow65ID"), m_strSmartDpCPNBelow65ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SmartDpCMaterialAbove50ID"), m_strSmartDpCMaterialAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SmartDpCConnectAbove50ID"), m_strSmartDpCConnectAbove50ID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("SmartDpCPNAbove50ID"), m_strSmartDpCPNAbove50ID );
}

void CDS_BatchSelParameter::ReadFromRegistry()
{
	CDS_SelParameterBase::ReadFromRegistry();

	CPrjParams *pclPrjParams = new CPrjParams( NULL );

	// HYS-1221 : commented this code because the combos in batchSel are filled by using isSelectable().
	// So it is not possible to have non-selectable products in the combos. it is no more necessary to call ResetPrjParams
	//if( NULL != pclPrjParams )
	//{
	//	pclPrjParams->ResetPrjParams( true );
	//}

	CString str;

	// Read parameters common to all batch selections.
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PipeSeriesID"), m_strPipeSeriesID );
	_tcsncpy_s( m_strPipeSeriesID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PipeSizeID"), m_strPipeSizeID );
	_tcsncpy_s( m_strPipeSizeID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );

	// Read parameters for balancing valves.
	m_iBvRadioFlow = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("BvRadioFlow"), m_iBvRadioFlow );
	m_iBvCheckDp = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("BvCheckDp"), m_iBvCheckDp );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvTypeBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvBlw65TypeID ) : m_strBvTypeBelow65ID );
	_tcsncpy_s( m_strBvTypeBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvFamilyBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvBlw65FamilyID ) : m_strBvFamilyBelow65ID );
	_tcsncpy_s( m_strBvFamilyBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvMaterialBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvBlw65BdyMatID ) : m_strBvMaterialBelow65ID );
	_tcsncpy_s( m_strBvMaterialBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvConnectBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvBlw65ConnectID ) : m_strBvConnectBelow65ID );
	_tcsncpy_s( m_strBvConnectBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvVersionBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvBlw65VersionID ) : m_strBvVersionBelow65ID );
	_tcsncpy_s( m_strBvVersionBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvPNBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvBlw65PNID ) : m_strBvPNBelow65ID );
	_tcsncpy_s( m_strBvPNBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvTypeAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvAbv50TypeID ) : m_strBvTypeAbove50ID );
	_tcsncpy_s( m_strBvTypeAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvFamilyAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvAbv50FamilyID ) : m_strBvFamilyAbove50ID );
	_tcsncpy_s( m_strBvFamilyAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvMaterialAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvAbv50BdyMatID ) : m_strBvMaterialAbove50ID );
	_tcsncpy_s( m_strBvMaterialAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvConnectAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvAbv50ConnectID ) : m_strBvConnectAbove50ID );
	_tcsncpy_s( m_strBvConnectAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvVersionAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvAbv50VersionID ) : m_strBvVersionAbove50ID );
	_tcsncpy_s( m_strBvVersionAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BvPNAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BvAbv50PNID ) : m_strBvPNAbove50ID );
	_tcsncpy_s( m_strBvPNAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );

	// Read parameters for pressure independent control valves.
	m_iPICvRadioFlow = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("PICvRadioFlow"), m_iPICvRadioFlow );

	int iValue = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("PICvCtrlTypeStrictChecked"), m_bPICvCtrlTypeStrictChecked );		// Version 7.
	m_bPICvCtrlTypeStrictChecked = ( 0 == iValue ) ? false : true;

	// We set 'eLastCvCtrlType' by default to allow us to detect if key exists or not.
	// If key doesn't exist, we must determine what is the control type to set in regards to other keys (Type, Family ...).
	// It can be the case when HySelect is launched for the first time. In that case, for 'Type', 'Family' and so on, we take values from 'CPrjParams'. But control
	// type is not saved. We need thus to determine control type once these values are read.
	m_ePICvCBCtrlType = ( CDB_ControlProperties::CvCtrlType )::AfxGetApp()->GetProfileInt( m_strSectionName, _T("PICvCBCtrlType"),
						CDB_ControlProperties::CvCtrlType::eLastCvCtrlType );

	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvTypeBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::PICvBlw65TypeID ) : m_strPICvTypeBelow65ID );
	_tcsncpy_s( m_strPICvTypeBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvFamilyBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::PICvBlw65FamilyID ) : m_strPICvFamilyBelow65ID );
	_tcsncpy_s( m_strPICvFamilyBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvMaterialBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::PICvBlw65BdyMatID ) : m_strPICvMaterialBelow65ID );
	_tcsncpy_s( m_strPICvMaterialBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvConnectBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::PICvBlw65ConnectID ) : m_strPICvConnectBelow65ID );
	_tcsncpy_s( m_strPICvConnectBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvVersionBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::PICvBlw65VersionID ) : m_strPICvVersionBelow65ID );
	_tcsncpy_s( m_strPICvVersionBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvPNBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::PICvBlw65PNID ) : m_strPICvPNBelow65ID );
	_tcsncpy_s( m_strPICvPNBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvTypeAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::PICvAbv50TypeID ) : m_strPICvTypeAbove50ID );
	_tcsncpy_s( m_strPICvTypeAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );

	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvFamilyAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::PICvAbv50FamilyID ) : m_strPICvFamilyAbove50ID );
	_tcsncpy_s( m_strPICvFamilyAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );

	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvMaterialAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::PICvAbv50BdyMatID ) : m_strPICvMaterialAbove50ID );
	_tcsncpy_s( m_strPICvMaterialAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );

	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvConnectAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::PICvAbv50ConnectID ) : m_strPICvConnectAbove50ID );
	_tcsncpy_s( m_strPICvConnectAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );

	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvVersionAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::PICvAbv50VersionID ) : m_strPICvVersionAbove50ID );
	_tcsncpy_s( m_strPICvVersionAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );

	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvPNAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::PICvAbv50PNID ) : m_strPICvPNAbove50ID );
	_tcsncpy_s( m_strPICvPNAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvActPowerSupplyID"), m_strPICvActPowerSupplyID );
	_tcsncpy_s( m_strPICvActPowerSupplyID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PICvActInputSignalID"), m_strPICvActInputSignalID );
	_tcsncpy_s( m_strPICvActInputSignalID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	m_iPICvFailSafeFct = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("PICvFailSafeFct"), m_iPICvFailSafeFct );
	m_ePICvDRPFct = ( CDB_ControlValve::DRPFunction )::AfxGetApp()->GetProfileInt( m_strSectionName, _T("PICvDRPFct"), m_ePICvDRPFct );

	// See remarks just above.
	if( CDB_ControlProperties::CvCtrlType::eLastCvCtrlType == m_ePICvCBCtrlType )
	{
		CRankEx rList;
		TASApp.GetpTADB()->GetTaCVList( &rList, CTADatabase::eForPiCv, false, CDB_ControlProperties::LastCV2W3W, m_strPICvTypeBelow65ID,
										m_strPICvFamilyBelow65ID,
										m_strPICvMaterialBelow65ID, m_strPICvConnectBelow65ID, m_strPICvVersionBelow65ID, m_strPICvPNBelow65ID, CDB_ControlProperties::LastCVFUNC,
										CDB_ControlProperties::eCvNU, CTADatabase::ForHMCalc );
		_string str;
		LPARAM lparam;

		if( TRUE == rList.GetFirst( str, lparam ) )
		{
			CDB_ControlValve *pCV = dynamic_cast<CDB_ControlValve *>( (CData *)lparam );
			ASSERT( NULL != pCV );

			if( NULL != pCV && NULL != pCV->GetCtrlProp() )
			{
				m_ePICvCBCtrlType = pCV->GetCtrlProp()->GetCtrlType();
			}
		}
	}

	// Read parameters for balancing & control valves.
	m_iBCvRadioFlow = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("BCvRadioFlow"), m_iBCvRadioFlow );
	m_iBCvCheckDp = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("BCvCheckDp"), m_iBCvCheckDp );

	iValue = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("BCvCtrlTypeStrictChecked"), m_bBCvCtrlTypeStrictChecked );		// Version 7.
	m_bBCvCtrlTypeStrictChecked = ( 0 == iValue ) ? false : true;

	// We set 'eLastCvCtrlType' by default to allow us to detect if key exists or not.
	// If key doesn't exist, we must determine what is the control type to set in regards to other keys (Type, Family ...).
	// It can be the case when HySelect is launched for the first time. In that case, for 'Type', 'Family' and so on, we take values from 'CPrjParams'. But control
	// type is not saved. We need thus to determine control type once these values are read.
	m_eBCvCBCtrlType = ( CDB_ControlProperties::CvCtrlType )::AfxGetApp()->GetProfileInt( m_strSectionName, _T("BCvCBCtrlType"),
					   CDB_ControlProperties::CvCtrlType::eLastCvCtrlType );

	m_eBCv2W3W = ( CDB_ControlProperties::CV2W3W )::AfxGetApp()->GetProfileInt( m_strSectionName, _T("BCvCB2W3W"),
				 CDB_ControlProperties::CV2W3W::LastCV2W3W );

	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvTypeBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BCvBlw65TypeID ) : m_strBCvTypeBelow65ID );
	_tcsncpy_s( m_strBCvTypeBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvFamilyBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BCvBlw65FamilyID ) : m_strBCvFamilyBelow65ID );
	_tcsncpy_s( m_strBCvFamilyBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvMaterialBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BCvBlw65BdyMatID ) : m_strBCvMaterialBelow65ID );
	_tcsncpy_s( m_strBCvMaterialBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvConnectBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BCvBlw65ConnectID ) : m_strBCvConnectBelow65ID );
	_tcsncpy_s( m_strBCvConnectBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvVersionBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BCvBlw65VersionID ) : m_strBCvVersionBelow65ID );
	_tcsncpy_s( m_strBCvVersionBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvPNBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BCvBlw65PNID ) : m_strBCvPNBelow65ID );
	_tcsncpy_s( m_strBCvPNBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvTypeAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BCvAbv50TypeID ) : m_strBCvTypeAbove50ID );
	_tcsncpy_s( m_strBCvTypeAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvFamilyAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BCvAbv50FamilyID ) : m_strBCvFamilyAbove50ID );
	_tcsncpy_s( m_strBCvFamilyAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvMaterialAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BCvAbv50BdyMatID ) : m_strBCvMaterialAbove50ID );
	_tcsncpy_s( m_strBCvMaterialAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvConnectAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BCvAbv50ConnectID ) : m_strBCvConnectAbove50ID );
	_tcsncpy_s( m_strBCvConnectAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvVersionAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BCvAbv50VersionID ) : m_strBCvVersionAbove50ID );
	_tcsncpy_s( m_strBCvVersionAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvPNAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::BCvAbv50PNID ) : m_strBCvPNAbove50ID );
	_tcsncpy_s( m_strBCvPNAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvActPowerSupplyID"), m_strBCvActPowerSupplyID );
	_tcsncpy_s( m_strBCvActPowerSupplyID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("BCvActInputSignalID"), m_strBCvActInputSignalID );
	_tcsncpy_s( m_strBCvActInputSignalID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	m_iBCvFailSafeFct = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("BCvFailSafeFct"), m_iBCvFailSafeFct );
	m_eBCvDRPFct = ( CDB_ControlValve::DRPFunction )::AfxGetApp()->GetProfileInt( m_strSectionName, _T("BCvDRPFct"), m_eBCvDRPFct );

	// See remarks just above.
	if( CDB_ControlProperties::CvCtrlType::eLastCvCtrlType == m_eBCvCBCtrlType )
	{
		CRankEx rList;
		TASApp.GetpTADB()->GetTaCVList( &rList, CTADatabase::eForTechHCBCv, false, CDB_ControlProperties::LastCV2W3W, m_strBCvTypeBelow65ID,
										m_strBCvFamilyBelow65ID,
										m_strBCvMaterialBelow65ID, m_strBCvConnectBelow65ID, m_strBCvVersionBelow65ID, m_strBCvPNBelow65ID, CDB_ControlProperties::LastCVFUNC,
										CDB_ControlProperties::eCvNU, CTADatabase::ForHMCalc );
		_string str;
		CData *pData = NULL;

		if( TRUE == rList.GetFirstT<CData *>( str, pData ) )
		{
			CDB_ControlValve *pCV = dynamic_cast<CDB_ControlValve *>( pData );
			ASSERT( NULL != pCV );

			if( NULL != pCV && NULL != pCV->GetCtrlProp() )
			{
				m_eBCvCBCtrlType = pCV->GetCtrlProp()->GetCtrlType();
				m_eBCv2W3W = pCV->GetCtrlProp()->GetCv2w3w();
			}
		}
	}

	// Read parameters for separators.
	m_iSepRadioFlow = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("SepRadioFlow"), m_iSepRadioFlow );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SepTypeID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SeparatorTypeID ) : m_strSeparatorTypeID );
	_tcsncpy_s( m_strSeparatorTypeID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SepFamilyID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SeparatorFamilyID ) : m_strSeparatorFamilyID );
	_tcsncpy_s( m_strSeparatorFamilyID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SepConnectID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SeparatorConnectID ) : m_strSeparatorConnectID );
	_tcsncpy_s( m_strSeparatorConnectID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SepVersionID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SeparatorVersionID ) : m_strSeparatorVersionID );
	_tcsncpy_s( m_strSeparatorVersionID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );


	// Read parameters for Dp controller valves.
	m_iDpCRadioFlow = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("DpCRadioFlow"), m_iDpCRadioFlow );
	m_iDpCCheckDpBranch = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("DpCCheckDpBranch"), m_iDpCCheckDpBranch );
	m_iDpCCheckKvs = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("DpCCheckKvs"), m_iDpCCheckKvs );		// Version 9.
	m_iDpCCheckDpMax = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("DpCCheckDpMax"), m_iDpCCheckDpMax );
	m_iDpCDpStab = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("DpCDpStab"), m_iDpCDpStab );
	m_iDpCDpCLocation = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("DpCDpCLocation"), m_iDpCDpCLocation );
	m_iDpCMvLocation = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("DpCMvLocation"), m_iDpCMvLocation );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCTypeBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCBlw65TypeID ) : m_strDpCTypeBelow65ID );
	_tcsncpy_s( m_strDpCTypeBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCFamilyBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCBlw65FamilyID ) : m_strDpCFamilyBelow65ID );
	_tcsncpy_s( m_strDpCFamilyBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCMaterialBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCBlw65BdyMatID ) : m_strDpCMaterialBelow65ID );
	_tcsncpy_s( m_strDpCMaterialBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCConnectBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCBlw65ConnectID ) : m_strDpCConnectBelow65ID );
	_tcsncpy_s( m_strDpCConnectBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCVersionBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCBlw65VersionID ) : m_strDpCVersionBelow65ID );
	_tcsncpy_s( m_strDpCVersionBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCPNBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCBlw65PNID ) : m_strDpCPNBelow65ID );
	_tcsncpy_s( m_strDpCPNBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCTypeAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCAbv50TypeID ) : m_strDpCTypeAbove50ID );
	_tcsncpy_s( m_strDpCTypeAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCFamilyAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCAbv50FamilyID ) : m_strDpCFamilyAbove50ID );
	_tcsncpy_s( m_strDpCFamilyAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCMaterialAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCAbv50BdyMatID ) : m_strDpCMaterialAbove50ID );
	_tcsncpy_s( m_strDpCMaterialAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCConnectAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCAbv50ConnectID ) : m_strDpCConnectAbove50ID );
	_tcsncpy_s( m_strDpCConnectAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCVersionAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCAbv50VersionID ) : m_strDpCVersionAbove50ID );
	_tcsncpy_s( m_strDpCVersionAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCPNAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCAbv50PNID ) : m_strDpCPNAbove50ID );
	_tcsncpy_s( m_strDpCPNAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );

	// For balancing valves selected with Dp controller valves.
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBvTypeBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCBlw65TypeID ) : m_strDpCBvTypeBelow65ID );
	_tcsncpy_s( m_strDpCBvTypeBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBvFamilyBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCBlw65FamilyID ) : m_strDpCBvFamilyBelow65ID );
	_tcsncpy_s( m_strDpCBvFamilyBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBvMaterialBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCBlw65BdyMatID ) : m_strDpCBvMaterialBelow65ID );
	_tcsncpy_s( m_strDpCBvMaterialBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBvConnectBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCBlw65ConnectID ) : m_strDpCBvConnectBelow65ID );
	_tcsncpy_s( m_strDpCBvConnectBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBvVersionBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCBlw65VersionID ) : m_strDpCBvVersionBelow65ID );
	_tcsncpy_s( m_strDpCBvVersionBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBvPNBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCBlw65PNID ) : m_strDpCBvPNBelow65ID );
	_tcsncpy_s( m_strDpCBvPNBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBvTypeAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCAbv50TypeID ) : m_strDpCBvTypeAbove50ID );
	_tcsncpy_s( m_strDpCBvTypeAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBvFamilyAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCAbv50FamilyID ) : m_strDpCBvFamilyAbove50ID );
	_tcsncpy_s( m_strDpCBvFamilyAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBvMaterialAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCAbv50BdyMatID ) : m_strDpCBvMaterialAbove50ID );
	_tcsncpy_s( m_strDpCBvMaterialAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBvConnectAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCAbv50ConnectID ) : m_strDpCBvConnectAbove50ID );
	_tcsncpy_s( m_strDpCBvConnectAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBvVersionAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCAbv50VersionID ) : m_strDpCBvVersionAbove50ID );
	_tcsncpy_s( m_strDpCBvVersionAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("DpCBvPNAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::DpCAbv50PNID ) : m_strDpCBvPNAbove50ID );
	_tcsncpy_s( m_strDpCBvPNAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );

	// Read parameters for smart control valves.
	m_iSmartControlValveRadioFlow = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("SmartControlValveRadioFlow"), m_iSmartControlValveRadioFlow );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartControlValveMaterialBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SmartControlValveBlw65BdyMatID ) : m_strSmartControlValveMaterialBelow65ID );
	_tcsncpy_s( m_strSmartControlValveMaterialBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartControlValveConnectBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SmartControlValveBlw65ConnectID ) : m_strSmartControlValveConnectBelow65ID );
	_tcsncpy_s( m_strSmartControlValveConnectBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartControlValvePNBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SmartControlValveBlw65PNID ) : m_strSmartControlValvePNBelow65ID );
	_tcsncpy_s( m_strSmartControlValvePNBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartControlValveMaterialAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SmartControlValveAbv50BdyMatID ) : m_strSmartControlValveMaterialAbove50ID );
	_tcsncpy_s( m_strSmartControlValveMaterialAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartControlValveConnectAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SmartControlValveAbv50ConnectID ) : m_strSmartControlValveConnectAbove50ID );
	_tcsncpy_s( m_strSmartControlValveConnectAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartControlValvePNAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SmartControlValveAbv50PNID ) : m_strSmartControlValvePNAbove50ID );
	_tcsncpy_s( m_strSmartControlValvePNAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );

	// Read parameters for smart differential pressure controllers.
	m_iSmartDpCRadioFlow = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("SmartDpCRadioFlow"), m_iSmartDpCRadioFlow );
	m_iSmartDpCCheckDpBranch = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("SmartDpCCheckDpBranch"), m_iSmartDpCCheckDpBranch );
	m_iSmartDpCCheckDpMax = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("SmartDpCCheckDpMax"), m_iSmartDpCCheckDpMax );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartDpCMaterialBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SmartDpCBlw65BdyMatID ) : m_strSmartDpCMaterialBelow65ID );
	_tcsncpy_s( m_strSmartDpCMaterialBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartDpCConnectBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SmartDpCBlw65ConnectID ) : m_strSmartDpCConnectBelow65ID );
	_tcsncpy_s( m_strSmartDpCConnectBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartDpCPNBelow65ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SmartDpCBlw65PNID ) : m_strSmartDpCPNBelow65ID );
	_tcsncpy_s( m_strSmartDpCPNBelow65ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartDpCMaterialAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SmartDpCAbv50BdyMatID ) : m_strSmartDpCMaterialAbove50ID );
	_tcsncpy_s( m_strSmartDpCMaterialAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartDpCConnectAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SmartDpCAbv50ConnectID ) : m_strSmartDpCConnectAbove50ID );
	_tcsncpy_s( m_strSmartDpCConnectAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("SmartDpCPNAbove50ID"),
										   ( NULL != pclPrjParams ) ? pclPrjParams->GetPrjParamID( CPrjParams::SmartDpCAbv50PNID ) : m_strSmartDpCPNAbove50ID );
	_tcsncpy_s( m_strSmartDpCPNAbove50ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );

	if( NULL != pclPrjParams )
	{
		delete pclPrjParams;
	}
}

TCHAR *CDS_BatchSelParameter::_VerifyPipeSeries( CProductSelelectionParameters *pclProductSelParams )
{
	if( NULL == pclProductSelParams || NULL == pclProductSelParams->m_pTADS || NULL == pclProductSelParams->m_pTADS->GetpTechParams() )
	{
		ASSERTA_RETURN( NULL );
	}

	CTable *pTab = static_cast<CTable *>( TASApp.GetpPipeDB()->Get( m_strPipeSeriesID ).MP );

	// PipeSerie is not available take default pipe series.
	if( !( NULL != pTab && true == pTab->IsSelectable( true ) ) )
	{
		CDS_TechnicalParameter *pTechParam = pclProductSelParams->m_pTADS->GetpTechParams();
		_tcsncpy_s( m_strPipeSeriesID, _ID_LENGTH, (LPCTSTR)pTechParam->GetDefaultPipeSerieID(), _ID_LENGTH );
	}

	return m_strPipeSeriesID;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_WizardSelParameter
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_WizardSelParameter )

CDS_WizardSelParameter::CDS_WizardSelParameter( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SelParameterBase( ParameterType::WizardSelection, pDataBase, ID )
{
	m_strSectionName = _T("DlgWizardSelection");

	// Initialize parameters common to all selections.
	// Remark: PARAM_TECH not yet initialized when the constructor is called, use STEEL_GEN_PIPES it will be overwritten by calling 'VerifyPipeSeries'.
	_tcsncpy_s( m_strPipeSeriesID, SIZEOFINTCHAR( m_strPipeSeriesID ), _T("STEEL_GEN_PIPES"), SIZEOFINTCHAR( m_strPipeSeriesID ) - 1 );
	_tcsncpy_s( m_strPipeSizeID, SIZEOFINTCHAR( m_strPipeSizeID ), _T(""), SIZEOFINTCHAR( m_strPipeSizeID ) - 1 );

	// Initialize parameters for pressure maintenance.
	m_ePMApplicationType = ProjectType::Heating;
	m_strPMPressureMaintenanceTypeID[0] = _T('\0');
	m_strPMWaterMakeUpTypeID[0] = _T('\0');
	m_iPMDegassingChecked = 0;
	m_strPMNorm[0] = '\0';
	m_ePMPressOn = PressurON::poPumpSuction;

	m_fShowAllPriorities = false;
	m_fPMWaterMakeupBreakTank = false;
}

TCHAR *CDS_WizardSelParameter::_VerifyPipeSeries( CProductSelelectionParameters *pclProductSelParams )
{
	if( NULL == pclProductSelParams || NULL == pclProductSelParams->m_pTADS || NULL == pclProductSelParams->m_pTADS->GetpTechParams() )
	{
		ASSERTA_RETURN( NULL );
	}

	CTable *pTab = static_cast<CTable *>( TASApp.GetpPipeDB()->Get( m_strPipeSeriesID ).MP );

	// PipeSerie is not available take default pipe series.
	if( !( NULL != pTab && true == pTab->IsSelectable( true ) ) )
	{
		CDS_TechnicalParameter *pTechParam = pclProductSelParams->m_pTADS->GetpTechParams();
		_tcsncpy_s( m_strPipeSeriesID, _ID_LENGTH, (LPCTSTR)pTechParam->GetDefaultPipeSerieID(), _ID_LENGTH );
	}

	return m_strPipeSeriesID;
}

void CDS_WizardSelParameter::Copy( CData *pclDestination )
{
	CData::Copy(pclDestination);

	CDS_WizardSelParameter *pclDestinationWizardSelParameter = (CDS_WizardSelParameter*)pclDestination;

	pclDestinationWizardSelParameter->SetPMApplicationType( m_ePMApplicationType);
	pclDestinationWizardSelParameter->SetPMPressMaintType( m_strPMPressureMaintenanceTypeID );
	pclDestinationWizardSelParameter->SetPMWaterMakeUpType( m_strPMWaterMakeUpTypeID );
	pclDestinationWizardSelParameter->SetPMDegassingChecked( m_iPMDegassingChecked);
	pclDestinationWizardSelParameter->SetPMNorm( m_strPMNorm);
	pclDestinationWizardSelParameter->SetPMPressOn( m_ePMPressOn);

	pclDestinationWizardSelParameter->SetPMWaterMakeupBreakTank( m_fPMWaterMakeupBreakTank);
	pclDestinationWizardSelParameter->SetShowAllPriorities( m_fShowAllPriorities);
}

#define CDS_WIZARDSELPARAMETER_VERSION		1
void CDS_WizardSelParameter::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_WIZARDSELPARAMETER_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CData::Write( outf );

	// Write all parameters for pressure maintenance.
	WriteData<>( outf, m_ePMApplicationType );
	WriteString( outf, m_strPMPressureMaintenanceTypeID );
	WriteString( outf, m_strPMWaterMakeUpTypeID );
	WriteData<>( outf, m_iPMDegassingChecked );
	WriteString( outf, m_strPMNorm );
	WriteData<>( outf, m_ePMPressOn );

	WriteData<>( outf, m_fPMWaterMakeupBreakTank );
	WriteData<>( outf, m_fShowAllPriorities );
}

bool CDS_WizardSelParameter::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_WIZARDSELPARAMETER_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_WIZARDSELPARAMETER_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Read parameter for pressurisation selection.
	inpf.read( (char *)&m_ePMApplicationType, sizeof( m_ePMApplicationType ) );

	if( false == ReadString( inpf,  m_strPMPressureMaintenanceTypeID, sizeof( m_strPMPressureMaintenanceTypeID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf,  m_strPMWaterMakeUpTypeID, sizeof( m_strPMWaterMakeUpTypeID ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_iPMDegassingChecked, sizeof( m_iPMDegassingChecked ) );

	if( false == ReadString( inpf, m_strPMNorm, sizeof( m_strPMNorm ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_ePMPressOn, sizeof( m_ePMPressOn ) );

	inpf.read( (char *)&m_fPMWaterMakeupBreakTank, sizeof( m_fPMWaterMakeupBreakTank ) );
	inpf.read( (char *)&m_fShowAllPriorities, sizeof( m_fShowAllPriorities ) );

	return true;
}

void CDS_WizardSelParameter::WriteToRegistry()
{
	CDS_SelParameterBase::WriteToRegistry();

	// Write parameters common to all selections.
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PipeNameID"), m_strPipeSeriesID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PipeSizeID"), m_strPipeSizeID );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("ShowAllPriorities"), m_fShowAllPriorities );

	// Write parameters for for pressure maintenance.
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("PMApplicationType"), m_ePMApplicationType );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PMPressureMaintenanceTypeID"), m_strPMPressureMaintenanceTypeID );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PMWaterMakeUpTypeID"), m_strPMWaterMakeUpTypeID );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("PMDegassingChecked"), m_iPMDegassingChecked );
	::AfxGetApp()->WriteProfileString( m_strSectionName, _T("PMNorm"), m_strPMNorm );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("PMPressOn"), m_ePMPressOn );
	::AfxGetApp()->WriteProfileInt( m_strSectionName, _T("PMWaterMakeupBreakTank"), m_fPMWaterMakeupBreakTank );
}

void CDS_WizardSelParameter::ReadFromRegistry()
{
	CDS_SelParameterBase::ReadFromRegistry();

	CString str;

	// Read parameters common to all selections.
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PipeNameID"), m_strPipeSeriesID );
	_tcsncpy_s( m_strPipeSeriesID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PipeSizeID"), m_strPipeSizeID );
	_tcsncpy_s( m_strPipeSizeID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	m_fShowAllPriorities = ( 0 != ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("ShowAllPriorities"), m_fShowAllPriorities ) ) ? true : false;

	// Read parameters for pressure maintenance.
	m_ePMApplicationType = ( ProjectType )::AfxGetApp()->GetProfileInt( m_strSectionName, _T("PMApplicationType"), m_ePMApplicationType );

	if( m_ePMApplicationType != Heating && m_ePMApplicationType != Cooling && m_ePMApplicationType != Solar )
	{
		m_ePMApplicationType = Heating;
	}

	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PMPressureMaintenanceTypeID"), m_strPMPressureMaintenanceTypeID );
	_tcsncpy_s( m_strPMPressureMaintenanceTypeID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PMWaterMakeUpTypeID"), m_strPMWaterMakeUpTypeID );
	_tcsncpy_s( m_strPMWaterMakeUpTypeID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
	m_iPMDegassingChecked = ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("PMDegassingChecked"), m_iPMDegassingChecked );

	str = ::AfxGetApp()->GetProfileString( m_strSectionName, _T("PMNorm"),
										   TASApp.GetpTADS()->GetpTechParams()->GetDefaultCalculationNorm().c_str() );													// Version 18.
	_tcsncpy_s( m_strPMNorm, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );

	m_ePMPressOn = ( PressurON )::AfxGetApp()->GetProfileInt( m_strSectionName, _T("PMPressOn"), m_ePMPressOn );

	m_fPMWaterMakeupBreakTank = TASApp.GetpTADS()->GetpTechParams()->GetBreakTankRequiredForWaterMakeUp();
	m_fPMWaterMakeupBreakTank = ( 0 != ::AfxGetApp()->GetProfileInt( m_strSectionName, _T("PMWaterMakeupBreakTank"), m_fPMWaterMakeupBreakTank ) ) ? true : false;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SelThing
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SelThing )

CDS_SelThing::CDS_SelThing( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_WaterCharacteristic( pDataBase, ID )
{
	m_ValveIDPtr = _NULL_IDPTR;
	_tcsncpy_s( m_tcHydroModID, SIZEOFINTCHAR( m_tcHydroModID ), _T(""), SIZEOFINTCHAR( m_tcHydroModID ) - 1 );
	_tcsncpy_s( m_tcCBITypeID, SIZEOFINTCHAR( m_tcCBITypeID ), _T(""), SIZEOFINTCHAR( m_tcCBITypeID ) - 1 );
	_tcsncpy_s( m_tcCBISizeID, SIZEOFINTCHAR( m_tcCBISizeID ), _T(""), SIZEOFINTCHAR( m_tcCBISizeID ) - 1 );
	_tcsncpy_s( m_tcCBISizeInchID, SIZEOFINTCHAR( m_tcCBISizeInchID ), _T(""), SIZEOFINTCHAR( m_tcCBISizeInchID ) - 1 );
	_tcsncpy_s( m_tcReference1, SIZEOFINTCHAR( m_tcReference1 ), _T(""), SIZEOFINTCHAR( m_tcReference1 ) - 1 );
	_tcsncpy_s( m_tcReference2, SIZEOFINTCHAR( m_tcReference2 ), _T(""), SIZEOFINTCHAR( m_tcReference2 ) - 1 );
	m_iQuantity = 0;
	m_dPrice = 0.0;
	_tcsncpy_s( m_tcRemark, SIZEOFINTCHAR( m_tcRemark ), _T(""), SIZEOFINTCHAR( m_tcRemark ) - 1 );
	m_iRemarkIndex = 0;
	m_iRowIndex = 0;

	Modified();
}

const IDPTR &CDS_SelThing::GetValveIDPtr()
{
	if( '\0' == *m_ValveIDPtr.ID )
	{
		return _NULL_IDPTR;
	}

	m_ValveIDPtr.DB = GetpTADB();
	Extend( &m_ValveIDPtr );
	return m_ValveIDPtr;
}

LPCTSTR CDS_SelThing::GetID()
{
	return GetValveIDPtr().ID;
}

LPCTSTR CDS_SelThing::GetArtNum()
{
	if( NULL == GetValveIDPtr().MP )
	{
		return _T("");
	}

	return ( static_cast<CDB_TAProduct *>( GetValveIDPtr().MP ) )->GetArtNum();
}

LPCTSTR CDS_SelThing::GetName()
{
	if( NULL == GetValveIDPtr().MP )
	{
		return _T("");
	}

	return ( static_cast<CDB_TAProduct *>( GetValveIDPtr().MP ) )->GetName();
}

LPCTSTR CDS_SelThing::GetVersionID()
{
	if( NULL == GetValveIDPtr().MP )
	{
		return _T("");
	}

	return ( static_cast<CDB_TAProduct *>( GetValveIDPtr().MP ) )->GetVersionID();
}

LPCTSTR CDS_SelThing::GetFamilyID()
{
	if( NULL == GetValveIDPtr().MP )
	{
		return _T("");
	}

	return ( static_cast<CDB_TAProduct *>( GetValveIDPtr().MP ) )->GetFamilyID();
}

LPCTSTR CDS_SelThing::GetTypeID()
{
	if( NULL == GetValveIDPtr().MP )
	{
		return _T("");
	}

	return ( static_cast<CDB_TAProduct *>( GetValveIDPtr().MP ) )->GetTypeID();
}

LPCTSTR CDS_SelThing::GetSizeID()
{
	if( NULL == GetValveIDPtr().MP )
	{
		return _T("");
	}

	return ( static_cast<CDB_TAProduct *>( GetValveIDPtr().MP ) )->GetSizeID();
}

IDPTR CDS_SelThing::GetSizeIDPtr()
{
	if( NULL == GetValveIDPtr().MP )
	{
		return _T("");
	}

	return ( static_cast<CDB_TAProduct *>( GetValveIDPtr().MP ) )->GetSizeIDPtr();
}

int CDS_SelThing::GetSizeKey()
{
	if( NULL == GetValveIDPtr().MP || NULL == dynamic_cast<CDB_TAProduct*>( GetValveIDPtr().MP ) )
	{
		return -1;
	}

	CDB_TAProduct *pclTAProduct = dynamic_cast<CDB_TAProduct*>( GetValveIDPtr().MP );
	return pclTAProduct->GetSizeKey();
}

LPCTSTR CDS_SelThing::GetConnectID()
{
	if( NULL == GetValveIDPtr().MP )
	{
		return _T("");
	}

	return ( static_cast<CDB_TAProduct *>( GetValveIDPtr().MP ) )->GetConnectID();
}

void CDS_SelThing::GetWC( CWaterChar *pWC )
{
	pWC->SetAdditFamID( GetAdditFamID() );
	pWC->SetAdditID( GetAdditID() );
	pWC->SetTemp( GetTemp() );
	pWC->SetPcWeight( GetPcWeight() );
	pWC->SetDens( GetDens() );
	pWC->SetKinVisc( GetKinVisc() );
	pWC->SetSpecifHeat( GetSpecifHeat() );
	pWC->SetTfreez( GetTfreez() );
	pWC->SetCheckSpecifHeat( GetCheckSpecifHeat() );
}

void CDS_SelThing::SetID( LPCTSTR ID )
{
	if( _T('\0') == *ID )
	{
		m_ValveIDPtr = _NULL_IDPTR;
		Modified();
	}
	else if( 0 != _tcscmp( m_ValveIDPtr.ID, ID ) )
	{
		m_ValveIDPtr = _NULL_IDPTR;
		m_ValveIDPtr.SetID( ID );
		m_ValveIDPtr.DB = GetpTADB();
		Modified();
	}
}

void CDS_SelThing::SetWC( CWaterChar *pWC )
{
	SetAdditFamID( pWC->GetAdditFamID() );
	SetAdditID( pWC->GetAdditID() );
	SetTemp( pWC->GetTemp() );
	SetPcWeight( pWC->GetPcWeight() );
	SetDens( pWC->GetDens() );
	SetKinVisc( pWC->GetKinVisc() );
	SetSpecifHeat( pWC->GetSpecifHeat() );
	SetTfreez( pWC->GetTfreez() );
	SetCheckSpecifHeat( pWC->GetCheckSpecifHeat() );
}

void CDS_SelThing::Copy( CData *pclDestination )
{
	CDS_SelThing *pclDestinationSelThing = dynamic_cast<CDS_SelThing *>( pclDestination );
	ASSERT( NULL != pclDestinationSelThing );

	if( NULL == pclDestinationSelThing )
	{
		return;
	}

	// Water Characteristics.
	pclDestinationSelThing->SetWC( GetpWCData() );

	// BV.
	pclDestinationSelThing->SetID( GetID() );
	pclDestinationSelThing->SetRef1( m_tcReference1 );
	pclDestinationSelThing->SetRef2( m_tcReference2 );
	pclDestinationSelThing->SetQuantity( m_iQuantity );
	pclDestinationSelThing->SetPrice( m_dPrice );
	pclDestinationSelThing->SetRemark( m_tcRemark );
	pclDestinationSelThing->SetRemarkIndex( m_iRemarkIndex );
	pclDestinationSelThing->SetRowIndex( 0 );
	pclDestinationSelThing->SetModuleID( GetModuleID() );
	pclDestinationSelThing->SetCBISize( GetCBISize() );
	pclDestinationSelThing->SetCBISizeInch( GetCBISizeInch() );
	pclDestinationSelThing->SetCBIType( GetCBIType() );
}

int CDS_SelThing::CompareSelectionTo( CData *pclSelectionCompareWith, int iKey )
{
	if( NULL == pclSelectionCompareWith )
	{
		return 0;
	}

	CDS_SelThing *pclSelThingCompareWith = dynamic_cast<CDS_SelThing *>( pclSelectionCompareWith );

	if( NULL == pclSelThingCompareWith )
	{
		return CDS_WaterCharacteristic::CompareSelectionTo( pclSelectionCompareWith, iKey );
	}

	int iReturn = 0;

	switch( iKey )
	{
		case PageField_enum::epfFIRSTREF:
			iReturn = StringCompare( m_tcReference1, pclSelThingCompareWith->GetRef1() );
			break;

		case PageField_enum::epfSECONDREF:
			iReturn = StringCompare( m_tcReference2, pclSelThingCompareWith->GetRef2() );
			break;

		case PageField_enum::epfBVINFOPRODUCTNAME:
			iReturn = StringCompare( GetName(), pclSelThingCompareWith->GetName() );
			break;

		case PageField_enum::epfBVINFOPRODUCTSIZE:
		{
			int iSizeToCompare = GetSizeKey();
			int iSizeCompareWith = pclSelThingCompareWith->GetSizeKey();

			if( -1 == iSizeToCompare || -1 == iSizeCompareWith )
			{
				iReturn = 0;
			}
			else if( iSizeToCompare < iSizeCompareWith )
			{
				iReturn = -1;
			}
			else if( iSizeToCompare > iSizeCompareWith )
			{
				iReturn = 1;
			}
		}
		break;

		case PageField_enum::epfARTICLE:

			if( false == TASApp.IsTAArtNumberHidden() )
			{
				iReturn = StringCompare( GetArtNum(), pclSelThingCompareWith->GetArtNum() );
			}
			else
			{
				CDB_TAProduct *pclTAProductToCompare = dynamic_cast<CDB_TAProduct *>( TASApp.GetpTADB()->Get( GetID() ).MP );
				CDB_TAProduct *pclTAProductCompareWith = dynamic_cast<CDB_TAProduct *>( TASApp.GetpTADB()->Get( pclSelThingCompareWith->GetID() ).MP );

				if( NULL != pclTAProductToCompare && NULL != pclTAProductCompareWith )
				{
					CString strLocArtNum1 = LocArtNumTab.GetLocalArticleNumber( pclTAProductToCompare->GetArtNum() );
					CString strLocArtNum2 = LocArtNumTab.GetLocalArticleNumber( pclTAProductCompareWith->GetArtNum() );
					iReturn = StringCompare( strLocArtNum1, strLocArtNum2 );
				}
			}

			break;

		case PageField_enum::epfQUANTITY:

			if( GetQuantity() < pclSelThingCompareWith->GetQuantity() )
			{
				iReturn = -1;
			}
			else if( GetQuantity() > pclSelThingCompareWith->GetQuantity() )
			{
				iReturn = 1;
			}
			else
			{
				iReturn = 0;
			}

			break;

		case PageField_enum::epfSALEUNITPRICE:

			if( GetPrice() < pclSelThingCompareWith->GetPrice() )
			{
				iReturn = -1;
			}
			else if( GetPrice() > pclSelThingCompareWith->GetPrice() )
			{
				iReturn = 1;
			}
			else
			{
				iReturn = 0;
			}

			break;

		default:
			iReturn = CDS_WaterCharacteristic::CompareSelectionTo( pclSelectionCompareWith, iKey );
	}

	return iReturn;
}

#define CDS_SELTHING_VERSION	3
void CDS_SelThing::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SELTHING_VERSION;
	WriteData<>( outf, Version );
	
	// Base class.
	CDS_WaterCharacteristic::Write( outf );
	
	// Info.
	WriteString( outf, m_tcHydroModID );
	WriteString( outf, GetID() );
	WriteString( outf, m_tcReference1 );
	WriteString( outf, m_tcReference2 );
	WriteData<>( outf, m_iQuantity );
	WriteData<>( outf, m_dPrice );
	WriteString( outf, m_tcRemark );
	WriteData<>( outf, m_iRowIndex );
	WriteString( outf, m_tcCBISizeID );
	WriteString( outf, m_tcCBISizeInchID );
	WriteString( outf, m_tcCBITypeID );
}

bool CDS_SelThing::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_SELTHING_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SELTHING_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDS_WaterCharacteristic::Read( inpf ) )
	{
		return false;
	}

	// Info.
	if( Version > 1 )
	{
		if( false == ReadString( inpf, m_tcHydroModID, sizeof( m_tcHydroModID ) ) )
		{
			return false;
		}
	}

	IDPTR idptr;

	if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
	{
		return false;
	}

	SetID( idptr.ID );

	if( Version < 3 )
	{
		if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
		{
			return false;
		}

		if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
		{
			return false;
		}

		if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
		{
			return false;
		}

		if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
		{
			return false;
		}

		if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
		{
			return false;
		}

		if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
		{
			return false;
		}

		if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
		{
			return false;
		}

		if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
		{
			return false;
		}
	}

	if( false == ReadString( inpf, m_tcReference1, sizeof( m_tcReference1 ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_tcReference2, sizeof( m_tcReference2 ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_iQuantity, sizeof( m_iQuantity ) );
	inpf.read( (char *)&m_dPrice, sizeof( m_dPrice ) );

	if( false == ReadString( inpf, m_tcRemark, sizeof( m_tcRemark ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_iRowIndex, sizeof( m_iRowIndex ) );

	if( Version > 1 )
	{
		if( false == ReadString( inpf, m_tcCBISizeID, sizeof( m_tcCBISizeID ) ) )
		{
			return false;
		}

		if( false == ReadString( inpf, m_tcCBISizeInchID, sizeof( m_tcCBISizeInchID ) ) )
		{
			return false;
		}

		if( false == ReadString( inpf, m_tcCBITypeID, sizeof( m_tcCBITypeID ) ) )
		{
			return false;
		}
	}

	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SelHydroThing
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SelHydroThing )

CDS_SelHydroThing::CDS_SelHydroThing( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SelThing( pDataBase, ID )
{
	Flow = 0.0;
	Dp = 0.0;
	Setting = 0.0;			// Setting of the valve
	TFlag = false;			// Temperature validity flag
	PNFlag = false;			// PN (Static pressure) validity flag
	_tcsncpy_s( PipeName, SIZEOFINTCHAR( PipeName ), _T(""), SIZEOFINTCHAR( PipeName ) - 1 );			// Pipe Serie
	_tcsncpy_s( PipeSize, SIZEOFINTCHAR( PipeSize ), _T(""), SIZEOFINTCHAR( PipeSize ) - 1 );			// Pipe Size
	LinDp = 0.0;			// Linear Dp
	LinDpFlag = false;		// Linear Dp validity flag
	U = 0.0;				// Water velocity
	UFlag = false;			// Water velocity validity flag
	TpFlag = false;			// Temperature and pressure validity flag

	Modified();
}

void CDS_SelHydroThing::Copy( CData *pclDestination )
{
	CDS_SelHydroThing *pclDestinationSelHydroThing = dynamic_cast<CDS_SelHydroThing *>( pclDestination );
	ASSERT( pclDestinationSelHydroThing );

	if( !pclDestinationSelHydroThing )
	{
		return;
	}

	CDS_SelThing::Copy( static_cast<CDS_SelThing *>( pclDestinationSelHydroThing ) );
	pclDestinationSelHydroThing->SetFlow( Flow );
	pclDestinationSelHydroThing->SetDp( Dp );
	pclDestinationSelHydroThing->SetSetting( Setting );
	pclDestinationSelHydroThing->SetTFlag( TFlag );
	pclDestinationSelHydroThing->SetPNFlag( PNFlag );
	pclDestinationSelHydroThing->SetPipeName( PipeName );
	pclDestinationSelHydroThing->SetPipeSize( PipeSize );
	pclDestinationSelHydroThing->SetLinDp( LinDp );
	pclDestinationSelHydroThing->SetLinDpFlag( LinDpFlag );
	pclDestinationSelHydroThing->SetU( U );
	pclDestinationSelHydroThing->SetUFlag( UFlag );
	pclDestinationSelHydroThing->SetTpFlag( TpFlag );
}

#define CDS_SELHYDROTHING_VERSION	1
void CDS_SelHydroThing::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SELHYDROTHING_VERSION;
	WriteData<>( outf, Version );
	
	// Base class.
	CDS_SelThing::Write( outf );
	
	// Info.
	WriteData<>( outf, Flow );
	WriteData<>( outf, Dp );
	WriteData<>( outf, Setting );
	WriteData<>( outf, TFlag );
	WriteData<>( outf, PNFlag );
	WriteString( outf, PipeName );
	WriteString( outf, PipeSize );
	WriteData<>( outf, LinDp );
	WriteData<>( outf, LinDpFlag );
	WriteData<>( outf, U );
	WriteData<>( outf, UFlag );
	WriteData<>( outf, TpFlag );
}

bool CDS_SelHydroThing::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_SELHYDROTHING_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SELHYDROTHING_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDS_SelThing::Read( inpf ) )
	{
		return false;
	}

	// Info.
	inpf.read( (char *)&Flow, sizeof( Flow ) );
	inpf.read( (char *)&Dp, sizeof( Dp ) );
	inpf.read( (char *)&Setting, sizeof( Setting ) );
	inpf.read( (char *)&TFlag, sizeof( TFlag ) );
	inpf.read( (char *)&PNFlag, sizeof( PNFlag ) );

	if( false == ReadString( inpf, PipeName, sizeof( PipeName ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, PipeSize, sizeof( PipeSize ) ) )
	{
		return false;
	}

	inpf.read( (char *)&LinDp, sizeof( LinDp ) );
	inpf.read( (char *)&LinDpFlag, sizeof( LinDpFlag ) );
	inpf.read( (char *)&U, sizeof( U ) );
	inpf.read( (char *)&UFlag, sizeof( UFlag ) );
	inpf.read( (char *)&TpFlag, sizeof( TpFlag ) );
	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SelManBv
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SelManBv )

CDS_SelManBv::CDS_SelManBv( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SelHydroThing( pDataBase, ID )
{
	Dp2 = 0.0;
	Dp3 = 0.0;

	Modified();
}

void CDS_SelManBv::Copy( CData *pcldestination )
{
	CDS_SelManBv *pclDestinationSelManBv = dynamic_cast<CDS_SelManBv *>( pcldestination );

	if( NULL == pclDestinationSelManBv )
	{
		ASSERT_RETURN;
	}

	// Water characteristics.
	CDS_SelHydroThing::Copy( static_cast<CDS_SelHydroThing *>( pclDestinationSelManBv ) );
	pclDestinationSelManBv->SetDp2( Dp2 );
	pclDestinationSelManBv->SetDp3( Dp3 );
}

#define CDS_SELMANBV_VERSION	1
void CDS_SelManBv::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SELMANBV_VERSION;
	WriteData<>( outf, Version );
	
	// Base class.
	CDS_SelHydroThing::Write( outf );
	
	// Info.
	WriteData<>( outf, Dp2 );
	WriteData<>( outf, Dp3 );
}

bool CDS_SelManBv::Read( INPSTREAM inpf )
{
	// Versin.
	BYTE Version = CDS_SELMANBV_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SELMANBV_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDS_SelHydroThing::Read( inpf ) )
	{
		return false;
	}

	inpf.read( (char *)&Dp2, sizeof( Dp2 ) );
	inpf.read( (char *)&Dp3, sizeof( Dp3 ) );
	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SelDpC
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SelDpC )

CDS_SelDpC::CDS_SelDpC( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SelManBv( pDataBase, ID )
{
	m_DpCIDPtr = _NULL_IDPTR;
	SchemeIndex = 0;					// Used only for visualisation
	Hmin = 0.0;							// Minimum primary Dp
	Authority = 0.0;					// Authority
	Dpmin = 0.0;						// Minimum Dp of the DpC to get q and DpL
	DpminFlag = false;
	DpL = 0.0;							// Dp load as defined in catalogue
	DpBranch = 0.0;						// Dp branch = Dp of the branch or Dp control valve
	KvCv = 0.0;							// Kv or Cv value of the control valve
	DpStab = 0;							// 0: on branch / 1: on control valve
	MvLoc = 0;							// 0: MV in primary / 1: MV in secondary
	DpCTFlag = false;
	DpCPNFlag = false;
	DpCPrice = 0.0;						// Price of DpC
	DpCSetting = 0.0;					// Setting of DpC
	DpCFlow = 0.0;
	Modified();
}

const IDPTR &CDS_SelDpC::GetDpCIDPtr()
{
	if( _T('\0') == *m_DpCIDPtr.ID )
	{
		return _NULL_IDPTR;
	}

	m_DpCIDPtr.DB = GetpTADB();
	Extend( &m_DpCIDPtr );
	return m_DpCIDPtr;
}

LPCTSTR CDS_SelDpC::GetDpCID()
{
	return GetDpCIDPtr().ID;
}

void CDS_SelDpC::SetDpCID( LPCTSTR ID )
{
	if( _tcscmp( m_DpCIDPtr.ID, ID ) )
	{
		m_DpCIDPtr = _NULL_IDPTR;
		m_DpCIDPtr.DB = GetpTADB();
		m_DpCIDPtr.SetID( ID );
		Modified();
	}
}

LPCTSTR CDS_SelDpC::GetDpCArtNum()
{
	if( NULL == GetDpCIDPtr().MP )
	{
		return _T("");
	}

	return ( static_cast<CDB_TAProduct *>( GetDpCIDPtr().MP ) )->GetArtNum();
}
LPCTSTR CDS_SelDpC::GetDpCName()
{
	if( NULL == GetDpCIDPtr().MP )
	{
		return _T("");
	}

	return ( static_cast<CDB_TAProduct *>( GetDpCIDPtr().MP ) )->GetName();
}

LPCTSTR CDS_SelDpC::GetDpCVersionID()
{
	if( NULL == GetDpCIDPtr().MP )
	{
		return _T("");
	}

	return ( static_cast<CDB_TAProduct *>( GetDpCIDPtr().MP ) )->GetVersionID();
}

LPCTSTR CDS_SelDpC::GetDpCFamilyID()
{
	if( NULL == GetDpCIDPtr().MP )
	{
		return _T("");
	}

	return ( static_cast<CDB_TAProduct *>( GetDpCIDPtr().MP ) )->GetFamilyID();
}

LPCTSTR CDS_SelDpC::GetDpCTypeID()
{
	if( NULL == GetDpCIDPtr().MP )
	{
		return _T("");
	}

	return ( static_cast<CDB_TAProduct *>( GetDpCIDPtr().MP ) )->GetTypeID();
}

LPCTSTR CDS_SelDpC::GetDpCSizeID()
{
	if( NULL == GetDpCIDPtr().MP )
	{
		return _T("");
	}

	return ( static_cast<CDB_TAProduct *>( GetDpCIDPtr().MP ) )->GetSizeID();
}

LPCTSTR CDS_SelDpC::GetDpCConnectID()
{
	if( NULL == GetDpCIDPtr().MP )
	{
		return _T("");
	}

	return ( static_cast<CDB_TAProduct *>( GetDpCIDPtr().MP ) )->GetConnectID();
}

LPCTSTR CDS_SelDpC::GetSchemeName()
{
	SchemeName = GetDpStab() ? _T('1') : _T('0');
	SchemeName += GetMvLoc() ? _T('1') : _T('0');
	CDB_TAProduct *pDpC = dynamic_cast<CDB_TAProduct *>( GetDpCIDPtr().MP );
	CDB_TAProduct *pMV = dynamic_cast<CDB_TAProduct *>( GetValveIDPtr().MP );

	if( NULL != pMV )
	{
		SchemeName += pMV->GetProdPicID();
	}

	if( NULL != pDpC )
	{
		SchemeName += pDpC->GetProdPicID();
	}

	return ( (LPCTSTR)SchemeName );
}

void CDS_SelDpC::Copy( CData *pclDestination )
{
	CDS_SelDpC *pclDestinationSelDpC = dynamic_cast<CDS_SelDpC *>( pclDestination );

	if( NULL == pclDestinationSelDpC )
	{
		ASSERT_RETURN;
	}

	// Copy Mv Params.
	CDS_SelManBv::Copy( static_cast<CDS_SelManBv *>( pclDestinationSelDpC ) );
	
	// Copy Dpc Params.
	pclDestinationSelDpC->SetDpCID( GetDpCID() );
	pclDestinationSelDpC->SetHmin( Hmin );
	pclDestinationSelDpC->SetAuthority( Authority );
	pclDestinationSelDpC->SetDpmin( Dpmin );
	pclDestinationSelDpC->SetDpminFlag( DpminFlag );
	pclDestinationSelDpC->SetDpL( DpL );
	pclDestinationSelDpC->SetDpBranch( DpBranch );
	pclDestinationSelDpC->SetKvCv( KvCv );
	pclDestinationSelDpC->SetDpStab( DpStab );
	pclDestinationSelDpC->SetMvLoc( MvLoc );
	pclDestinationSelDpC->SetDpCTFlag( DpCTFlag );
	pclDestinationSelDpC->SetDpCPNFlag( DpCPNFlag );
	pclDestinationSelDpC->SetDpCPrice( DpCPrice );
	pclDestinationSelDpC->SetSchemeIndex( SchemeIndex );
	pclDestinationSelDpC->SetDpCSetting( DpCSetting );
	pclDestinationSelDpC->SetDpCFlow( DpCFlow );
}

#define CDS_SELDPC_VERSION	3
void CDS_SelDpC::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SELDPC_VERSION;
	WriteData<>( outf, Version );
	
	// Base class.
	CDS_SelManBv::Write( outf );
	
	// Info.
	WriteString( outf, GetDpCID() );
	WriteString( outf, L"" );
	WriteData<>( outf, Hmin );
	WriteData<>( outf, Authority );
	WriteData<>( outf, Dpmin );
	WriteData<>( outf, DpminFlag );
	WriteData<>( outf, DpL );
	WriteData<>( outf, DpBranch );
	WriteData<>( outf, KvCv );
	WriteData<>( outf, DpStab );
	WriteData<>( outf, MvLoc );
	WriteData<>( outf, DpCTFlag );
	WriteData<>( outf, DpCPNFlag );
	WriteData<>( outf, DpCPrice );
	WriteData<>( outf, DpCSetting );
	WriteData<>( outf, DpCFlow );
}

bool CDS_SelDpC::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_SELDPC_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SELDPC_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDS_SelManBv::Read( inpf ) )
	{
		return false;
	}

	// Info.
	IDPTR idptr = _NULL_IDPTR;

	if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
	{
		return false;
	}

	SetDpCID( idptr.ID );

	if( Version < 3 )
	{
		if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
		{
			return false;
		}

		if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
		{
			return false;
		}

		if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
		{
			return false;
		}

		if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
		{
			return false;
		}

		if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
		{
			return false;
		}

		if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
		{
			return false;
		}

		if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
		{
			return false;
		}

		if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
		{
			return false;
		}
	}

	if( false == ReadString( inpf, SchemeName ) )
	{
		return false;    // To take in count of SchemeTab, scheme name is  patched at the function's end
	}

	inpf.read( (char *)&Hmin, sizeof( Hmin ) );
	inpf.read( (char *)&Authority, sizeof( Authority ) );
	inpf.read( (char *)&Dpmin, sizeof( Dpmin ) );
	inpf.read( (char *)&DpminFlag, sizeof( DpminFlag ) );
	inpf.read( (char *)&DpL, sizeof( DpL ) );
	inpf.read( (char *)&DpBranch, sizeof( DpBranch ) );
	inpf.read( (char *)&KvCv, sizeof( KvCv ) );
	inpf.read( (char *)&DpStab, sizeof( DpStab ) );
	inpf.read( (char *)&MvLoc, sizeof( MvLoc ) );
	inpf.read( (char *)&DpCTFlag, sizeof( DpCTFlag ) );
	inpf.read( (char *)&DpCPNFlag, sizeof( DpCPNFlag ) );
	inpf.read( (char *)&DpCPrice, sizeof( DpCPrice ) );
	inpf.read( (char *)&DpCSetting, sizeof( DpCSetting ) );

	if( Version >= 2 )
	{
		inpf.read( (char *)&DpCFlow, sizeof( DpCFlow ) );
	}

	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_DirectSel
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_DirectSel )

CDS_DirectSel::CDS_DirectSel( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SelThing( pDataBase, ID )
{
	fTAProduct = true;		// true when TA products (TADB), false for user product(USERDB)
	_tcsncpy_s( TabID, SIZEOFINTCHAR( TabID ), _T(""), SIZEOFINTCHAR( TabID ) - 1 );	// Store Table ID, it will be used to customize CDlgConfSel
	Comment = _T("");			// User's comment (only for user product)

	Modified();
}

void CDS_DirectSel::Copy( CData *pclDestination )
{
	CDS_SelThing::Copy( pclDestination );
	CDS_DirectSel *pclDestinationDirectSel = dynamic_cast<CDS_DirectSel *>( pclDestination );

	if( NULL !=  pclDestinationDirectSel )
	{
		pclDestinationDirectSel->SetTAProduct( fTAProduct );
		pclDestinationDirectSel->SetTabID( TabID );
		pclDestinationDirectSel->SetComment( (LPCTSTR)Comment );
	}
}

#define CDS_DIRECTSEL_VERSION	1
void CDS_DirectSel::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_DIRECTSEL_VERSION;
	WriteData<>( outf, Version );
	
	// Base class.
	CDS_SelThing::Write( outf );
	
	// Info.
	WriteData<>( outf, fTAProduct );
	WriteString( outf, TabID );
	WriteString( outf, Comment );
}

bool CDS_DirectSel::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_DIRECTSEL_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_DIRECTSEL_VERSION )
	{
		return false;
	}

	// Base class.
	if( !CDS_SelThing::Read( inpf ) )
	{
		return false;
	}

	// Info.
	TCHAR tcBuffer[CSTRING_LINE_SIZE_MAX];
	inpf.read( (char *)&fTAProduct, sizeof( fTAProduct ) );

	if( false == ReadString( inpf, TabID, sizeof( TabID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, tcBuffer, sizeof( tcBuffer ) ) )
	{
		return false;    // Comment
	}

	Comment = CString( tcBuffer );
	return true;
}
///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SelRadSet
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SelRadSet )

CDS_SelRadSet::CDS_SelRadSet( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SelHydroThing( pDataBase, ID )
{
	//_tcsncpy_s(TrvID, SIZEOFINTCHAR(TrvID ), _T(""), SIZEOFINTCHAR(TrvID ) - 1 );				// ID in TADB
	//_tcsncpy_s(TrvArtNum, SIZEOFINTCHAR(TrvArtNum), _T(""), SIZEOFINTCHAR(TrvArtNum)-1);		// Product reference
	//_tcsncpy_s(TrvName, SIZEOFINTCHAR(TrvName), _T(""), SIZEOFINTCHAR(TrvName)-1);			// Product name
	//_tcsncpy_s(TrvVersionID, SIZEOFINTCHAR(TrvVersionID ), _T(""), SIZEOFINTCHAR(TrvVersionID ) - 1 );	// Product version ID
	//_tcsncpy_s(TrvFamilyID, SIZEOFINTCHAR(TrvFamilyID ), _T(""), SIZEOFINTCHAR(TrvFamilyID ) - 1 );	// Product family ID
	//_tcsncpy_s(TrvDocFileID, SIZEOFINTCHAR(TrvDocFileID ), _T(""), SIZEOFINTCHAR(TrvDocFileID ) - 1 );	// Product doc file ID
	//_tcsncpy_s(TrvTypeID, SIZEOFINTCHAR(TrvTypeID ), _T(""), SIZEOFINTCHAR(TrvTypeID ) - 1 );		// Product type ID
	//_tcsncpy_s(TrvSizeID, SIZEOFINTCHAR(TrvSizeID ), _T(""), SIZEOFINTCHAR(TrvSizeID ) - 1 );		// Corresp. valve size ID
	//_tcsncpy_s(TrvConnectID, SIZEOFINTCHAR(TrvConnectID ), _T(""), SIZEOFINTCHAR(TrvConnectID ) - 1 );	// Connection ID

	PresetTrv = false;			// Trv is presetable
	RetVMode = RRVM_IMI;				// Return Valve Mode Nothing, Other, Imi
	DpTrv = 0.0;				// DP of the Trv
	DpTot = 0.0;				// Dp Total
	SettingTrv = 0.0;			// Setting of the Return Valve
	KvRetV = 0.0;				// Kv of the return Valve
	TrvTFlag = false;
	TrvPNFlag = false;
	PReq = 0.0;					// Required Power
	PInst = 0.0;				// Installed Power
	Ti = 0.0;
	Ts = 0.0;
	Tr = 0.0;
	NCTi = 0.0;					// Nominal conditions for Ti,Ts,Tr
	NCTs = 0.0;
	NCTr = 0.0;

	TrvPrice = 0.0;

	m_TrvIDPtr = _NULL_IDPTR;

	Modified();
}

void CDS_SelRadSet::SetTrvID( LPCTSTR ID )
{
	if( _tcscmp( m_TrvIDPtr.ID, ID ) )
	{
		m_TrvIDPtr = _NULL_IDPTR;
		m_TrvIDPtr.SetID( ID );
		m_TrvIDPtr.DB = GetpTADB();
		Modified();
	}
}

const IDPTR &CDS_SelRadSet::GetTrvIDPtr()
{
	if( _T('\0') == m_TrvIDPtr.ID )
	{
		return _NULL_IDPTR;
	}

	m_TrvIDPtr.DB = GetpTADB();
	Extend( &m_TrvIDPtr );
	return m_TrvIDPtr;
}

LPCTSTR CDS_SelRadSet::GetTrvArtNum()
{
	if( _T('\0') == *GetTrvID() )
	{
		return _T("");
	}

	CDB_TAProduct *pTAP = static_cast<CDB_TAProduct *>( GetTrvIDPtr().MP );

	if( NULL == pTAP )
	{
		return _T("");
	}

	return pTAP->GetArtNum();
}

LPCTSTR CDS_SelRadSet::GetTrvName()
{
	if( _T('\0') == *GetTrvID() )
	{
		return _T("");
	}

	CDB_TAProduct *pTAP = static_cast<CDB_TAProduct *>( GetTrvIDPtr().MP );

	if( NULL == pTAP )
	{
		return _T("");
	}

	return pTAP->GetName();
}

LPCTSTR CDS_SelRadSet::GetTrvVersionID()
{
	if( _T('\0') == *GetTrvID() )
	{
		return _T("");
	}

	CDB_TAProduct *pTAP = static_cast<CDB_TAProduct *>( GetTrvIDPtr().MP );

	if( NULL == pTAP )
	{
		return _T("");
	}

	return pTAP->GetVersionID();
}

LPCTSTR CDS_SelRadSet::GetTrvFamilyID()
{
	if( _T('\0') == *GetTrvID() )
	{
		return _T("");
	}

	CDB_TAProduct *pTAP = static_cast<CDB_TAProduct *>( GetTrvIDPtr().MP );

	if( NULL == pTAP )
	{
		return _T("");
	}

	return pTAP->GetFamilyIDPtr().ID;
}

LPCTSTR CDS_SelRadSet::GetTrvTypeID()
{
	if( _T('\0') == *GetTrvID() )
	{
		return _T("");
	}

	CDB_TAProduct *pTAP = static_cast<CDB_TAProduct *>( GetTrvIDPtr().MP );

	if( NULL == pTAP )
	{
		return _T("");
	}

	return pTAP->GetTypeID();
}

LPCTSTR CDS_SelRadSet::GetTrvSizeID()
{
	if( _T('\0') == *GetTrvID() )
	{
		return _T("");
	}

	CDB_TAProduct *pTAP = static_cast<CDB_TAProduct *>( GetTrvIDPtr().MP );

	if( NULL == pTAP )
	{
		return _T("");
	}

	return pTAP->GetSizeID();
}
LPCTSTR CDS_SelRadSet::GetTrvConnectID()
{
	if( _T('\0') == *GetTrvID() )
	{
		return _T("");
	}

	CDB_TAProduct *pTAP = static_cast<CDB_TAProduct *>( GetTrvIDPtr().MP );

	if( NULL == pTAP )
	{
		return _T("");
	}

	return pTAP->GetConnectID();
}

void CDS_SelRadSet::Copy( CData *pclDestination )
{
	CDS_SelRadSet *pclDestinationSelRadSet = dynamic_cast<CDS_SelRadSet *>( pclDestination );
	ASSERT( pclDestinationSelRadSet );

	if( !pclDestinationSelRadSet )
	{
		return;
	}

	CDS_SelHydroThing::Copy( static_cast<CDS_SelHydroThing *>( pclDestinationSelRadSet ) );

	pclDestinationSelRadSet->SetTrvID( GetTrvID() );

	pclDestinationSelRadSet->SetTrvPreset( PresetTrv );
	pclDestinationSelRadSet->SetTrvTFlag( TrvTFlag );
	pclDestinationSelRadSet->SetTrvPNFlag( TrvPNFlag );
	pclDestinationSelRadSet->SetRetVMode( RetVMode );
	pclDestinationSelRadSet->SetTrvDp( DpTrv );
	pclDestinationSelRadSet->SetDpTot( DpTot );
	pclDestinationSelRadSet->SetTrvSetting( SettingTrv );
	pclDestinationSelRadSet->SetKvRetV( KvRetV );
	pclDestinationSelRadSet->SetTrvPrice( TrvPrice );
	pclDestinationSelRadSet->SetPReq( PReq );
	pclDestinationSelRadSet->SetPInst( PInst );
	pclDestinationSelRadSet->SetTi( Ti );
	pclDestinationSelRadSet->SetTs( Ts );
	pclDestinationSelRadSet->SetTr( Tr );
	pclDestinationSelRadSet->SetNCTi( Ti );
	pclDestinationSelRadSet->SetNCTs( Ts );
	pclDestinationSelRadSet->SetNCTr( Tr );
}

#define CDS_SELRADSET_VERSION	2
void CDS_SelRadSet::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SELRADSET_VERSION;
	WriteData<>( outf, Version );
	
	// Base class.
	CDS_SelHydroThing::Write( outf );
	
	// Info.
	WriteString( outf, GetTrvID() );
	WriteData<>( outf, PresetTrv );
	WriteData<>( outf, TrvTFlag );
	WriteData<>( outf, TrvPNFlag );
	WriteData<>( outf, RetVMode );
	WriteData<>( outf, DpTrv );
	WriteData<>( outf, DpTot );
	WriteData<>( outf, SettingTrv );
	WriteData<>( outf, KvRetV );
	WriteData<>( outf, PReq );
	WriteData<>( outf, PInst );
	WriteData<>( outf, Ti );
	WriteData<>( outf, Ts );
	WriteData<>( outf, Tr );
	WriteData<>( outf, TrvPrice );
	WriteData<>( outf, NCTi );
	WriteData<>( outf, NCTs );
	WriteData<>( outf, NCTr );
}

bool CDS_SelRadSet::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_SELRADSET_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SELRADSET_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDS_SelHydroThing::Read( inpf ) )
	{
		return false;
	}

	// Info.
	IDPTR IDPtr = _NULL_IDPTR;

	if( false == ReadString( inpf, IDPtr.ID, sizeof( IDPtr.ID ) ) )
	{
		return false;
	}

	SetTrvID( IDPtr.ID );

	if( 1 == Version )
	{
		if( false == ReadString( inpf, IDPtr.ID, sizeof( IDPtr.ID ) ) )
		{
			return false;
		}

		if( false == ReadString( inpf, IDPtr.ID, sizeof( IDPtr.ID ) ) )
		{
			return false;
		}

		if( false == ReadString( inpf, IDPtr.ID, sizeof( IDPtr.ID ) ) )
		{
			return false;
		}

		if( false == ReadString( inpf, IDPtr.ID, sizeof( IDPtr.ID ) ) )
		{
			return false;
		}

		if( false == ReadString( inpf, IDPtr.ID, sizeof( IDPtr.ID ) ) )
		{
			return false;
		}

		if( false == ReadString( inpf, IDPtr.ID, sizeof( IDPtr.ID ) ) )
		{
			return false;
		}

		if( false == ReadString( inpf, IDPtr.ID, sizeof( IDPtr.ID ) ) )
		{
			return false;
		}

		if( false == ReadString( inpf, IDPtr.ID, sizeof( IDPtr.ID ) ) )
		{
			return false;
		}
	}

	inpf.read( (char *)&PresetTrv, sizeof( PresetTrv ) );
	inpf.read( (char *)&TrvTFlag, sizeof( TrvTFlag ) );
	inpf.read( (char *)&TrvPNFlag, sizeof( TrvPNFlag ) );
	inpf.read( (char *)&RetVMode, sizeof( RetVMode ) );
	inpf.read( (char *)&DpTrv, sizeof( DpTrv ) );
	inpf.read( (char *)&DpTot, sizeof( DpTot ) );
	inpf.read( (char *)&SettingTrv, sizeof( SettingTrv ) );
	inpf.read( (char *)&KvRetV, sizeof( KvRetV ) );
	inpf.read( (char *)&PReq, sizeof( PReq ) );
	inpf.read( (char *)&PInst, sizeof( PInst ) );
	inpf.read( (char *)&Ti, sizeof( Ti ) );
	inpf.read( (char *)&Ts, sizeof( Ts ) );
	inpf.read( (char *)&Tr, sizeof( Tr ) );
	inpf.read( (char *)&TrvPrice, sizeof( TrvPrice ) );
	inpf.read( (char *)&NCTi, sizeof( NCTi ) );
	inpf.read( (char *)&NCTs, sizeof( NCTs ) );
	inpf.read( (char *)&NCTr, sizeof( NCTr ) );
	
	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_ProjectRef
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_ProjectRef )

CDS_ProjectRef::CDS_ProjectRef( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_MultiString( pDataBase, ID )
{
	for( int i = Name; i <= CustFax; i++ )
	{
		CDB_MultiString::SetString( i, _T("") );
	}
}

#define CDS_PRJECTREF_VERSION	1
void CDS_ProjectRef::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_PRJECTREF_VERSION;
	WriteData<>( outf, Version );
	
	// Base class.
	CDB_MultiString::Write( outf );
}

bool CDS_ProjectRef::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_PRJECTREF_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_PRJECTREF_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDB_MultiString::Read( inpf ) )
	{
		return false;
	}

	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_UserRef
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_UserRef )

CDS_UserRef::CDS_UserRef( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_MultiString( pDataBase, ID )
{
	// HYS-1090: the Path field is added after Other field
	for( int i = Name; i <= Path; i++ )
	{
		CDB_MultiString::SetString( i, _T("") );
	}
}

#define CDS_USERREF_VERSION	1
void CDS_UserRef::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_USERREF_VERSION;
	WriteData<>( outf, Version );
	
	// Base class.
	CDB_MultiString::Write( outf );
}

bool CDS_UserRef::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_USERREF_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_USERREF_VERSION )
	{
		return false;
	}

	// Base class.
	if( 0 == CDB_MultiString::Read( inpf ) )
	{
		return false;
	}

	return true;
}
#endif

///////////////////////////////////////////////////////////////////////////////////
//
//								CLog
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CLog )
CLog::CLog( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
}


#ifndef TACBX
///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_LoggedData
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_LoggedData )

CDS_LoggedData::CDS_LoggedData( CDataBase *pDataBase, LPCTSTR ID )
	: CLog( pDataBase, ID )

{
	m_bStartDate = false;
	_tcsncpy_s( Name, SIZEOFINTCHAR( Name ), _T(""), SIZEOFINTCHAR( Name ) - 1 );
	_tcsncpy_s( Site, SIZEOFINTCHAR( Site ), _T(""), SIZEOFINTCHAR( Site ) - 1 );
	_tcsncpy_s( Ref, SIZEOFINTCHAR( Ref ), _T(""), SIZEOFINTCHAR( Ref ) - 1 );
	Valve = 0;
	_tcsncpy_s( Date, SIZEOFINTCHAR( Date ), _T(""), SIZEOFINTCHAR( Date ) - 1 );
	_tcsncpy_s( Time, SIZEOFINTCHAR( Time ), _T(""), SIZEOFINTCHAR( Time ) - 1 );
	Interval = 0;
	Mode = 0;

	for( int i = 0; i < MAXLOGGEDCOLUMN; i++ )
	{
		m_Pos[i] = NULL;
	}

	Modified();
}

CDS_LoggedData::~CDS_LoggedData()
{
	for( int i = 0; i < MAXLOGGEDCOLUMN; i++ )
	{
		DblList[i].RemoveAll();
	}
}

CLog::eChannelType CDS_LoggedData::GetCBIFirstCol()
{
	switch( GetMode() )
	{
		case LOGTYPE_DP:
			return ect_Dp;
			break;

		case LOGTYPE_FLOW:
			return ect_Flow;
			break;

		case LOGTYPE_TEMP:
			return ect_Temp1;
			break;

		case LOGTYPE_DPTEMP:
			return ect_Dp;
			break;

		case LOGTYPE_FLOWTEMP:
			return ect_Flow;
			break;

		default:
			break;
	}

	return ect_LastChannelType;
}

int CDS_LoggedData::GetCBICol( eChannelType Chan )
{
	switch( Chan )
	{
		case ect_Dp:
		{
			if( LOGTYPE_DP == GetMode() )
			{
				return 0;
			}
			else if( LOGTYPE_FLOW == GetMode() )
			{
				return 1;
			}
			else if( LOGTYPE_DPTEMP == GetMode() )
			{
				return 0;
			}
			else if( LOGTYPE_FLOWTEMP == GetMode() )
			{
				return 2;
			}

			break;
		}

		case ect_Temp1:
		{
			if( LOGTYPE_TEMP == GetMode() )
			{
				return 0;
			}
			else if( LOGTYPE_DPTEMP == GetMode() )
			{
				return 1;
			}
			else if( LOGTYPE_FLOWTEMP == GetMode() )
			{
				return 1;
			}

			break;
		}

		case ect_Flow:
		{
			if( LOGTYPE_FLOW == GetMode() )
			{
				return 0;
			}
			else if( LOGTYPE_FLOWTEMP == GetMode() )
			{
				return 0;
			}

			break;
		}

		default:
			break;
	}

	return MAXLOGGEDCOLUMN;
}

bool CDS_LoggedData::InitStartDate()
{
	int iYear, iMonth, iDay, iHour, iMin, iSec;
	_stscanf_s( Date, _T("%d.%d.%d"), &iYear, &iMonth, &iDay );
	_stscanf_s( Time, _T("%d:%d:%d"), &iHour, &iMin, &iSec );

	if( !( iYear >= 1970 && iYear <= 2038 ) )
	{
		return false;
	}

	if( !( iMonth > 0 && iMonth <= 12 ) )
	{
		return false;
	}

	if( !( iDay > 0 && iDay <= 31 ) )
	{
		return false;
	}

	if( !( iHour >= 0 && iHour <= 23 ) )
	{
		return false;
	}

	if( !( iMin >= 0 && iMin <= 59 ) )
	{
		return false;
	}

	if( !( iSec >= 0 && iSec <= 59 ) )
	{
		return false;
	}

	CTime StartDate( iYear, iMonth, iDay, iHour, iMin, iSec );
	m_StartDate = StartDate;
	m_bStartDate = true;
	return true;
}

bool CDS_LoggedData::SetValue( int iColumn, int iRow, double dVal )
{
	if( iColumn >= MAXLOGGEDCOLUMN )
	{
		return false;
	}

	if( DblList[iColumn].GetCount() <= iRow )
	{
		return false;
	}

	DblList[iColumn].SetAt( DblList[iColumn].FindIndex( iRow ), dVal );
	Modified();
	return true;
}

// Check the coherence of logged data
bool CDS_LoggedData::CheckLoggedData()
{
	bool bFlag = true;

	// Check the length of columns
	if( CLog::LogType::LOGTYPE_DPTEMP == Mode || CLog::LogType::LOGTYPE_FLOWTEMP == Mode )
	{
		while( DblList[0].GetCount() < DblList[1].GetCount() )
		{
			bFlag = false;

			if( DblList[1].IsEmpty() )
			{
				break;
			}

			DblList[1].RemoveTail();
		}

		while( DblList[1].GetCount() < DblList[0].GetCount() )
		{
			bFlag = false;

			if( DblList[0].IsEmpty() )
			{
				break;
			}

			DblList[0].RemoveTail();
		}
	}

	return bFlag;
}

bool CDS_LoggedData::AddValue( int iColumn, double dVal )
{
	if( iColumn >= MAXLOGGEDCOLUMN )
	{
		return false;
	}

	DblList[iColumn].AddTail( dVal );
	Modified();
	return true;
}

bool CDS_LoggedData::GetHighestValue( eChannelType chan, double &dVal )
{
	int iColumn = GetCBICol( chan );

	if( iColumn >= MAXLOGGEDCOLUMN )
	{
		return false;
	}

	if( 0 == DblList[iColumn].GetCount() )
	{
		return false;
	}

	double val = -DBL_MAX;
	dVal = val;
	POSITION pos = DblList[iColumn].GetHeadPosition();

	while( NULL != pos )
	{
		val = DblList[iColumn].GetNext( pos );

		if( val > dVal )
		{
			dVal = val;
		}
	}

	return true;
}

bool CDS_LoggedData::GetLowestValue( eChannelType chan, double &dVal )
{
	int iColumn = GetCBICol( chan );

	if( iColumn >= MAXLOGGEDCOLUMN )
	{
		return false;
	}

	if( 0 == DblList[iColumn].GetCount() )
	{
		return false;
	}

	double val = DBL_MAX;
	dVal = val;
	POSITION pos = DblList[iColumn].GetHeadPosition();

	while( pos )
	{
		val = DblList[iColumn].GetNext( pos );

		if( val < dVal )
		{
			dVal = val;
		}
	}

	return true;
}

bool CDS_LoggedData::GetValue( eChannelType chan, int iRow, double &dVal )
{
	int iColumnn = GetCBICol( chan );

	if( iColumnn >= MAXLOGGEDCOLUMN )
	{
		return false;
	}

	if( DblList[iColumnn].GetCount() <= iRow )
	{
		return false;
	}

	dVal = DblList[iColumnn].GetAt( DblList[iColumnn].FindIndex( iRow ) );
	return true;
}

// give the value with a date time closed to dt
// Return false if dt is less than StartDateTime
// give  the last value if dt is greater than the last DateTime
bool CDS_LoggedData::GetValue( eChannelType chan, CTime &dt, double &dVal )
{
	int iColumn = GetCBICol( chan );

	if( iColumn >= MAXLOGGEDCOLUMN )
	{
		return false;
	}

	if( false == m_bStartDate )
	{
		if( !InitStartDate() )
		{
			return false;
		}
	}

	if( dt < m_StartDate )
	{
		return false;
	}

	CTimeSpan ts = dt - m_StartDate;
	CTimeSpan tsi( GetInterval() );
	int iRow = ( int )( ts.GetTotalSeconds() / tsi.GetTotalSeconds() );

	if( DblList[iColumn].GetCount() <= iRow )
	{
		iRow = DblList[iColumn].GetCount() - 1;
	}

	GetDateTime( iRow, dt );
	return ( GetValue( chan, iRow, dVal ) );
}

bool CDS_LoggedData::GetValue( eChannelType chan, CTimeSpan &ts, double &dVal )
{
	int iColumn = GetCBICol( chan );

	if( iColumn >= MAXLOGGEDCOLUMN )
	{
		return false;
	}

	if( false == m_bStartDate )
	{
		if( false == InitStartDate() )
		{
			return false;
		}
	}

	CTime dt = m_StartDate + ts;
	GetValue( chan, dt, dVal );
	ts = dt - m_StartDate;
	return true;
}

bool CDS_LoggedData::GetFirst( eChannelType chan, double &dVal, int iIndex )
{
	int iColumn = GetCBICol( chan );

	if( iColumn >= MAXLOGGEDCOLUMN )
	{
		return false;
	}

	if( 0 == DblList[iColumn].GetCount() )
	{
		return false;
	}

	if( iIndex > DblList[iColumn].GetCount() )
	{
		return false;
	}

	m_Pos[iColumn] = DblList[iColumn].FindIndex( iIndex );
	dVal = DblList[iColumn].GetNext( m_Pos[iColumn] );
	return true;
}

bool CDS_LoggedData::GetNext( eChannelType chan, double &dVal )
{
	int iColumn = GetCBICol( chan );

	if( iColumn >= MAXLOGGEDCOLUMN )
	{
		return false;
	}

	if( 0 == DblList[iColumn].GetCount() )
	{
		return false;
	}

	if( !m_Pos[iColumn] )
	{
		return false;
	}

	dVal = DblList[iColumn].GetNext( m_Pos[iColumn] );
	return true;
}

CTime CDS_LoggedData::GetLogDateTime()
{ 
	if( false == InitStartDate() )
	{
		return m_StartDate;
	}
	else
	{
		return CTime( 0 );
	}
}

int	CDS_LoggedData::GetLength()
{
	return ( DblList[0].GetCount() );
}

bool CDS_LoggedData::GetDateTime( int iRow, CTime &dt )
{
	if( DblList[0].GetCount() <= iRow )
	{
		return false;
	}

	if( false == m_bStartDate )
	{
		if( false == InitStartDate() )
		{
			return false;
		}
	}

	// Delta T in seconds.
	long lInterval = GetInterval() * iRow;

	CTimeSpan TimeSpan( lInterval );
	dt = m_StartDate + TimeSpan;

	return true;
}

bool CDS_LoggedData::GetOleDateTime( int iRow, COleDateTime &dt )
{
	CTime time;

	if( false == GetDateTime( iRow, time ) )
	{
		return false;
	}

	dt = COleDateTime( time.GetYear(), time.GetMonth(), time.GetDay(), time.GetHour(), time.GetMinute(), time.GetSecond() );

	return true;
}

void CDS_LoggedData::Copy( CData *pclDestination )
{
	// Base class.
	CData::Copy( pclDestination );
	
	// Info.
	CDS_LoggedData *pclDestinationLoggedData = (CDS_LoggedData *)pclDestination;
	pclDestinationLoggedData->SetName( GetName() );
	pclDestinationLoggedData->SetSite( GetSite() );
	pclDestinationLoggedData->SetRef( GetRef() );
	pclDestinationLoggedData->SetValveIndex( GetValveIndex() );
	pclDestinationLoggedData->SetDate( GetDate() );
	pclDestinationLoggedData->SetTime( GetTime() );
	pclDestinationLoggedData->SetInterval((BYTE)GetInterval());
	pclDestinationLoggedData->SetMode(GetMode());

	for( int iColumn = 0; iColumn < 2; iColumn++ )
	{
		DblList[iColumn].GetCount();
		POSITION Pos = DblList[iColumn].GetHeadPosition();
		double dVal;
		
		while( NULL != Pos )
		{
			dVal = DblList[iColumn].GetNext( Pos );
			pclDestinationLoggedData->AddValue( iColumn, dVal );
		}
	}
}

bool CDS_LoggedData::WriteAsText( CString strPathName, bool bPointIndex, bool bHeader, CString strDelimiter )
{
	CString str, strDt, strLow, strHigh, TxtLine;
	CFileTxt f( strPathName, CFile::modeCreate | CFile::modeWrite );

	if( (HANDLE)0 == f.m_hFile )
	{
		return false;
	}

	BYTE tmpbuf[] = {0xff, 0xfe};
	f.Write( tmpbuf, 2 );
	
	// Write logged data name.
	TxtLine = GetName() + CString( _T("\n\n") );
	f.WriteTxtLine( (LPCTSTR)TxtLine );

	if( true == bHeader )
	{
		// Write logged data info block.
		str = TASApp.LoadLocalizedString( IDS_PLANT );
		str += _T(": ");
		TxtLine = str + GetSite() + CString( _T("\n") );
		f.WriteTxtLine( (LPCTSTR)TxtLine );

		str = TASApp.LoadLocalizedString( IDS_MODULE );
		str += _T(": ");
		TxtLine = str + GetRef() + CString( _T("\n") );
		f.WriteTxtLine( (LPCTSTR)TxtLine );

		str = TASApp.LoadLocalizedString( IDS_VALVEINDEX );
		str += _T(": ");
		strDt.Format( _T("%d"), GetValveIndex() );
		TxtLine = str + strDt + CString( _T("\n") );
		f.WriteTxtLine( (LPCTSTR)TxtLine );

		str = TASApp.LoadLocalizedString( IDS_STARTINGTIME );
		str += _T(": ");
		CTimeUnic dtu;
		GetDateTime( 0, dtu );
		strDt = dtu.Format( IDS_LOGDATETIME_FORMAT );
		TxtLine = str + strDt + CString( _T("\n") );
		f.WriteTxtLine( (LPCTSTR)TxtLine );

		str = TASApp.LoadLocalizedString( IDS_ENDINGTIME );
		str += _T(": ");
		GetDateTime( GetLength() - 1, dtu );
		strDt = dtu.Format( IDS_LOGDATETIME_FORMAT );
		TxtLine = str + strDt + CString( _T("\n") );
		f.WriteTxtLine( (LPCTSTR)TxtLine );

		str = TASApp.LoadLocalizedString( IDS_NBROFPOINTS );
		str += _T(": ");
		strDt.Format( _T("%d"), GetLength() );
		TxtLine = str + strDt + CString( _T("\n") );
		f.WriteTxtLine( (LPCTSTR)TxtLine );

		str = TASApp.LoadLocalizedString( IDS_DTBETWPTS );
		str += _T(": ");
		strDt.Format( _T("%d"), GetInterval() );
		CString stmp;
		stmp = TASApp.LoadLocalizedString( IDS_SEC );
		strDt += _T(" ") + stmp;
		TxtLine = str + strDt + CString( _T("\n") );
		f.WriteTxtLine( (LPCTSTR)TxtLine );

		double dVal;

		switch( GetMode() )
		{
			case CLog::LogType::LOGTYPE_DP:

				if( false == GetLowestValue( ect_Dp, dVal ) )
				{
					dVal = 0.0;
				}

				strLow = WriteCUDouble( _U_DIFFPRESS, dVal, true );

				if( false == GetHighestValue( ect_Dp, dVal ) )
				{
					dVal = 0.0;
				}

				strHigh = WriteCUDouble( _U_DIFFPRESS, dVal, true );
				break;

			case CLog::LogType::LOGTYPE_FLOW:

				if( false == GetLowestValue( ect_Flow, dVal ) )
				{
					dVal = 0.0;
				}

				strLow = WriteCUDouble( _U_FLOW, dVal, true );

				if( false == GetHighestValue( ect_Flow, dVal ) )
				{
					dVal = 0.0;
				}

				strHigh = WriteCUDouble( _U_FLOW, dVal, true );
				break;

			case CLog::LogType::LOGTYPE_TEMP:

				if( false == GetLowestValue( ect_Temp1, dVal ) )
				{
					dVal = 0.0;
				}

				strLow = WriteCUDouble( _U_TEMPERATURE, dVal, true );

				if( false == GetHighestValue( ect_Temp1, dVal ) )
				{
					dVal = 0.0;
				}

				strHigh = WriteCUDouble( _U_TEMPERATURE, dVal, true );
				break;

			case CLog::LogType::LOGTYPE_DPTEMP:	// Pressure drop and temperature
				
				if( false == GetLowestValue( ect_Dp, dVal ) )
				{
					dVal = 0.0;
				}

				strLow = WriteCUDouble( _U_DIFFPRESS, dVal, true );

				if( false == GetHighestValue( ect_Dp, dVal ) )
				{
					dVal = 0.0;
				}

				strHigh = WriteCUDouble( _U_DIFFPRESS, dVal, true );
				strLow += CString( _T("/") );
				strHigh += CString( _T("/") );

				if( false == GetLowestValue( ect_Temp1, dVal ) )
				{
					dVal = 0.0;
				}

				strLow += WriteCUDouble( _U_TEMPERATURE, dVal, true );

				if( false == GetHighestValue( ect_Temp1, dVal ) )
				{
					dVal = 0.0;
				}

				strHigh += WriteCUDouble( _U_TEMPERATURE, dVal, true );
				break;

			case CLog::LogType::LOGTYPE_FLOWTEMP:	// Flow and temperature
				if( false == GetLowestValue( ect_Flow, dVal ) )
				{
					dVal = 0.0;
				}

				strLow = WriteCUDouble( _U_FLOW, dVal, true );

				if( false == GetHighestValue( ect_Flow, dVal ) )
				{
					dVal = 0.0;
				}

				strHigh = WriteCUDouble( _U_FLOW, dVal, true );
				strLow +=  CString( _T("/") );
				strHigh +=  CString( _T("/") );

				if( false == GetLowestValue( ect_Temp1, dVal ) )
				{
					dVal = 0.0;
				}

				strLow += WriteCUDouble( _U_TEMPERATURE, dVal, true );

				if( false == GetHighestValue( ect_Temp1, dVal ) )
				{
					dVal = 0.0;
				}

				strHigh += WriteCUDouble( _U_TEMPERATURE, dVal, true );
				break;
		}

		str = TASApp.LoadLocalizedString( IDS_LOWSAMPLEDVAL );
		str += _T(": ");
		TxtLine = str + strLow + CString( _T("\n") );
		f.WriteTxtLine( (LPCTSTR)TxtLine );
		
		str = TASApp.LoadLocalizedString( IDS_HIGHSAMPLEDVAL );
		str += _T(": ");
		TxtLine = str + strHigh + CString( _T("\n\n") );
		f.WriteTxtLine( (LPCTSTR)TxtLine );

		if( true == bPointIndex )
		{
			str = TASApp.LoadLocalizedString( IDS_INDEX );
			TxtLine = str + strDelimiter;
			f.WriteTxtLine( (LPCTSTR)TxtLine );
		}

		str = TASApp.LoadLocalizedString( IDS_DATE );
		TxtLine = str + strDelimiter;
		f.WriteTxtLine( (LPCTSTR)TxtLine );
		
		str = TASApp.LoadLocalizedString( IDS_TIME );
		TxtLine = str + strDelimiter;
		f.WriteTxtLine( (LPCTSTR)TxtLine );

		switch( GetMode() )
		{
			case CLog::LogType::LOGTYPE_DP:		// Pressure drop
				str = TASApp.LoadLocalizedString( IDS_DP );
				TxtLine = str  + CString( _T("\n") );
				f.WriteTxtLine( (LPCTSTR)TxtLine );
				break;

			case CLog::LogType::LOGTYPE_FLOW:		// Flow
				str = TASApp.LoadLocalizedString( IDS_FLOW );
				TxtLine = str  + CString( _T("\n") );
				f.WriteTxtLine( (LPCTSTR)TxtLine );
				break;

			case CLog::LogType::LOGTYPE_TEMP:		// Temperature
				str = TASApp.LoadLocalizedString( IDS_TEMPERATURE );
				TxtLine = str  + CString( _T("\n") );
				f.WriteTxtLine( (LPCTSTR)TxtLine );
				break;

			case CLog::LogType::LOGTYPE_DPTEMP:	// Pressure drop and temperature
				str = TASApp.LoadLocalizedString( IDS_DP );
				TxtLine = str + strDelimiter;
				f.WriteTxtLine( (LPCTSTR)TxtLine );
				
				str = TASApp.LoadLocalizedString( IDS_TEMPERATURE );
				TxtLine = str  + CString( _T("\n") );
				f.WriteTxtLine( (LPCTSTR)TxtLine );
				break;

			case CLog::LogType::LOGTYPE_FLOWTEMP:	// Flow and temperature
				str = TASApp.LoadLocalizedString( IDS_FLOW );
				TxtLine = str + strDelimiter;
				f.WriteTxtLine( (LPCTSTR)TxtLine );
				
				str = TASApp.LoadLocalizedString( IDS_TEMPERATURE );
				TxtLine = str  + CString( _T("\n") );
				f.WriteTxtLine( (LPCTSTR)TxtLine );
				break;
		}
	}

	for( int iIndex = 0; iIndex < GetLength(); iIndex++ )
	{
		if( true == bPointIndex )
		{
			TxtLine.Format( _T("%d"), iIndex + 1 );
			TxtLine += strDelimiter;
			f.WriteTxtLine( (LPCTSTR)TxtLine );
		}

		// Write Date and Time.
		CTimeUnic dtu;
		GetDateTime( iIndex, dtu );
		TxtLine = dtu.Format( IDS_DATE_FORMAT ) + strDelimiter;
		f.WriteTxtLine( (LPCTSTR)TxtLine );
		
		TxtLine = dtu.Format( IDS_TIME_FORMAT ) + strDelimiter;
		f.WriteTxtLine( (LPCTSTR)TxtLine );

		// Write Dp, flow and temperature
		double dValue;
		( iIndex == 0 ) ? GetFirst( GetCBIFirstCol(), dValue ) : GetNext( GetCBIFirstCol(), dValue );

		switch( GetMode() )
		{
			case CLog::LOGTYPE_DP:
				str = WriteCUDouble( _U_DIFFPRESS, dValue, false );
				TxtLine = str  + CString( _T("\n") );
				f.WriteTxtLine( (LPCTSTR)TxtLine );
				break;

			case CLog::LOGTYPE_FLOW:
				str = WriteCUDouble( _U_FLOW, dValue, false );
				TxtLine = str  + CString( _T("\n") );
				f.WriteTxtLine( (LPCTSTR)TxtLine );
				break;

			case CLog::LOGTYPE_TEMP:
				str = WriteCUDouble( _U_TEMPERATURE, dValue, false );
				TxtLine = str  + CString( _T("\n") );
				f.WriteTxtLine( (LPCTSTR)TxtLine );
				break;

			case CLog::LOGTYPE_DPTEMP:
				str = WriteCUDouble( _U_DIFFPRESS, dValue, false );
				TxtLine = str  + strDelimiter;
				( iIndex ) ? GetNext( ect_Temp1, dValue ) : GetFirst( ect_Temp1, dValue );
				str = WriteCUDouble( _U_TEMPERATURE, dValue, false );
				TxtLine += str  + CString( _T("\n") );
				f.WriteTxtLine( (LPCTSTR)TxtLine );
				break;

			case CLog::LOGTYPE_FLOWTEMP:
				str = WriteCUDouble( _U_FLOW, dValue, false );
				TxtLine = str   + strDelimiter;
				( iIndex ) ? GetNext( ect_Temp1, dValue ) : GetFirst( ect_Temp1, dValue );
				str = WriteCUDouble( _U_TEMPERATURE, dValue, false );
				TxtLine += str  + CString( _T("\n") );
				f.WriteTxtLine( (LPCTSTR)TxtLine );
				break;
		}
	}

	f.Close();

	return true;
}

#define CDS_LOGGEDDATA_VERSION	1
void CDS_LoggedData::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_LOGGEDDATA_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CData::Write( outf );

	// Info.
	WriteString( outf, (LPCTSTR)Name );
	WriteString( outf, Site );
	WriteString( outf, Ref );
	WriteData<>( outf, Valve );
	WriteString( outf, Date );
	WriteString( outf, Time );
	WriteData<>( outf, Interval );
	WriteData<>( outf, Mode );

	for( int iColumn = 0; iColumn < 2; iColumn++ )
	{
		int count = DblList[iColumn].GetCount();
		WriteData<>( outf, count );
		POSITION Pos = DblList[iColumn].GetHeadPosition();
		double dVal;

		while( NULL != Pos )
		{
			dVal = DblList[iColumn].GetNext( Pos );
			WriteData<>( outf, dVal );
		}
	}
}

bool CDS_LoggedData::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_LOGGEDDATA_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_LOGGEDDATA_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Info.
	if( false == ReadString( inpf, Name, sizeof( Name ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, Site, sizeof( Site ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, Ref, sizeof( Ref ) ) )
	{
		return false;
	}

	inpf.read( (char *)&Valve, sizeof( Valve ) );

	if( false == ReadString( inpf, Date, sizeof( Date ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, Time, sizeof( Time ) ) )
	{
		return false;
	}

	inpf.read( (char *)&Interval, sizeof( Interval ) );
	inpf.read( (char *)&Mode, sizeof( Mode ) );

	for( int iColumn = 0; iColumn < 2; iColumn++ )
	{
		int size;
		inpf.read( (char *)&size, sizeof( size ) );
		double dVal;

		for( ; size; size-- )
		{
			inpf.read( (char *)&dVal, sizeof( dVal ) );
			AddValue( iColumn, dVal );
		}
	}

	return true;
}

///////////////////////////////////////////////////////////////////////////////////
// CPrjParams can be used without a connection to the database
#define CPRJPARAMS_VERSION	15
// Version 15: 2022-07-11 : Add smart differential pressure controller and "PipeByPassSerieID".
// Version 14: 2020-11-02 : Add smart control valve.
// Version 13: 2020-02-10 : Add checkbox value m_bOldProductsAvailable for build project with deleted products
// Version 12: 2019-08-19: Now m_iActuatorFailSafeFct is an integer and a new emum m_eActuatorDRPFct is added
// Version 11: 2016-07-11 -> Combined Dp controller, balancing and control valve.
// Version 10: 2014-03-20 -> separators added.
// Version 9: Add 'm_fUserForcedHMCalcMode' variable.
// Version 8: BCv and actuators variables added.
CPrjParams::CPrjParams( CData *pOwner )
{
	m_pOwner = pOwner;
	m_bInitialized = false;
	m_ParamID.SetSize( LASTID );
	m_CVMode = _CVMode::TAMode;
	m_CVCtrlType = CDB_ControlProperties::CvCtrlType::eCvOnOff;
	m_CVFunc = CDB_ControlProperties::eCVFUNC::ControlOnly;
	m_bActuatorAutomaticallySelect = false;
	m_bActuatorSelectedByPackage = true;
	m_iActuatorFailSafeFct = 0;
	m_eActuatorDRPFct = CDB_ControlValve::DRPFunction::drpfUndefined;
	m_Version = CPRJPARAMS_VERSION;
	m_fUserForcedHMCalcMode = false;
	m_bOldProductsAvailable = false;

	// HYS-1590: Don't call 'ResetPrjParams' because some variables are not yet ready.
	// Effectively, we create the 'CDS_ProjectParams' in the 'CTADatastruct::CreateTSPProjTable' method in the 'CTADatastruct::Init' method.
	// And this is just after the call to the 'CTADatastruct::CreateTSPProjTable' method that we call the 'CTADatastruct::ReInitTechAndSSelParam' that will
	// read some variables in the registry needed for the 'CPrjParams::ResetPrjParams' (Like the 'm_rTechParamData.m_strDefaultPipeSerieID').
	// ResetPrjParams();
}

void CPrjParams::SetPrjParamID( _PrjParamsID ID, CString str, bool bForceUpdate )
{
	ASSERT( ID < LASTID );

	// str could be empty US for instance No DpC
	if( true == str.IsEmpty() )
	{
		return;
	}

	bool bFound = true;
	IDPTR IDPtr = _NULL_IDPTR;

	// if ID is pipe related check existence in PIPEDB...
	if( _PrjParamsID::PipeCircSerieID == ID || _PrjParamsID::PipeByPassSerieID == ID || _PrjParamsID::PipeDistSupplySerieID == ID || _PrjParamsID::PipeDistReturnSerieID == ID )
	{
		IDPtr = TASApp.GetpPipeDB()->Get( (LPCTSTR)str );
		bFound = ( NULL != IDPtr.MP ) ? true : false;
	}
	else
	{
		// Otherwise check in TADB.

		IDPtr = TASApp.GetpTADB()->Get( (LPCTSTR)str );

		if( _T('\0') == *IDPtr.ID )
		{
			bFound = false;
		}

		// Verify connection above DN50 are really above DN50.
		if( _PrjParamsID::BvAbv50ConnectID == ID || _PrjParamsID::CvAbv50ConnectID == ID || _PrjParamsID::DpCAbv50ConnectID == ID )
		{
			CDB_StringID *pStrID = dynamic_cast<CDB_StringID *>( ( static_cast<CDB_Connect *>( IDPtr.MP ) )->GetDNMaxIDPtr().MP );

			if( NULL != pStrID )
			{
				int iDN = _ttoi( pStrID->GetIDstr() );

				CTableDN *pclTableDN = dynamic_cast<CTableDN *>( GetpTADB()->Get( _T("DN_TAB") ).MP );
				ASSERT( NULL != pclTableDN );

				int iDN50 = pclTableDN->GetSize( _T("DN_50") );

				if( iDN <= iDN50 )
				{
					bFound = false;
				}
			}
		}
	}

	// Set it only if found; otherwise keep default value.
	if( true == bFound && ( true == bForceUpdate || 0 != str.Compare( m_ParamID[ID].IDptr.ID ) ) )
	{
		m_ParamID[ID].IDptr = IDPtr;
		m_ParamID[ID].index = 0;

		// If ID is not related to StringID don't take care of index.
		CDB_StringID *pStrID = dynamic_cast<CDB_StringID *>( IDPtr.MP );

		if( NULL != pStrID )
		{
			pStrID->GetIDstrAs<unsigned int>( 0, m_ParamID[ID].index );
		}

		if( NULL != m_pOwner )
		{
			m_pOwner->Modified();
		}
	}

	m_bInitialized = true;
}

void CPrjParams::ResetPrjParams( bool bToDefault, CString strVersion )
{
	_string str1;

	CTADatabase *pTADB = TASApp.GetpTADB();
	ASSERT( NULL != pTADB );

	CTableDN *pclTableDN = static_cast<CTableDN *>( pTADB->Get( _T("DN_TAB") ).MP );
	ASSERT( NULL != pclTableDN );

	CString strSectionName = _T("DialogTechParam");

	if( true == bToDefault )
	{
		m_bOldProductsAvailable = false;
	}
	else
	{
		m_bOldProductsAvailable = ( 0 != ::AfxGetApp()->GetProfileInt( strSectionName, _T("OldProductsAvailableForHC"), 0 ) ) ? true : false;
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// BELOW 65
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	CRankEx ListEx;
	int iDN = pclTableDN->GetSize( _T("DN_50") );

	// BV Type.
	// Get BVType below DN65, don't get FO.
	int iCount = pTADB->GetBVTypeList( &ListEx, CTADatabase::ForHMCalc, 0, iDN, true );
	CData *pData = NULL;
	CString strKey;

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::BvBlw65TypeID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"BvBlw65TypeID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::BvBlw65TypeID, strKey );
		}
	}

	ListEx.PurgeAll();

	// BV Family.
	// Get BV family below DN65, don't get FO.
	iCount = pTADB->GetBVFamilyList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::BvBlw65TypeID ), CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{


		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::BvBlw65FamilyID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"BvBlw65FamilyID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::BvBlw65FamilyID, strKey );
		}
	}

	ListEx.PurgeAll();

	// BV BdyMat.
	// Get BV family below DN65, don't get FO.
	iCount = pTADB->GetBVBdyMatList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::BvBlw65TypeID )
									 , (LPCTSTR)GetPrjParamID( _PrjParamsID::BvBlw65FamilyID ), CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::BvBlw65BdyMatID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"BvBlw65BdyMatID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::BvBlw65BdyMatID, strKey );
		}
	}

	ListEx.PurgeAll();

	// BV Connection
	// Get connection for this BVType.
	iCount = pTADB->GetBVConnList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::BvBlw65TypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::BvBlw65FamilyID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::BvBlw65BdyMatID ) , CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::BvBlw65ConnectID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"BvBlw65ConnectID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::BvBlw65ConnectID, strKey );
		}
	}

	ListEx.PurgeAll();

	// BV Version.
	// Get version for this BVType and BV connection.
	iCount = pTADB->GetBVVersList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::BvBlw65TypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::BvBlw65FamilyID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::BvBlw65BdyMatID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::BvBlw65ConnectID ), CTADatabase::ForHMCalc );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::BvBlw65VersionID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"BvBlw65VersionID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::BvBlw65VersionID, strKey );
		}
	}

	ListEx.PurgeAll();

	// BV PN.
	// Get version for this BVType, connection and version.
	iCount = pTADB->GetBVPNList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::BvBlw65TypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::BvBlw65FamilyID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::BvBlw65BdyMatID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::BvBlw65ConnectID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::BvBlw65VersionID ),
			CTADatabase::ForHMCalc );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::BvBlw65PNID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"BvBlw65PNID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::BvBlw65PNID, strKey );
		}
	}

	ListEx.PurgeAll();

	// DpC Type.
	// Get DpC Type below DN65.
	iCount = pTADB->GetDpCTypeList( &ListEx, CTADatabase::ForHMCalc );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::DpCBlw65TypeID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"DpCBlw65TypeID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::DpCBlw65TypeID, strKey );
		}
	}

	ListEx.PurgeAll();

	// DpC Family.
	iCount = pTADB->GetDpCFamilyList( &ListEx, eDpCLoc::DpCLocDownStream, (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBlw65TypeID ), CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::DpCBlw65FamilyID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"DpCBlw65FamilyID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::DpCBlw65FamilyID, strKey );
		}
	}

	ListEx.PurgeAll();

	// DpC Body Material.
	iCount = pTADB->GetDpCBdyMatList( &ListEx, eDpCLoc::DpCLocDownStream, (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBlw65TypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBlw65FamilyID ), 
			CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::DpCBlw65BdyMatID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"DpCBlw65BdyMatID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::DpCBlw65BdyMatID, strKey );
		}
	}

	ListEx.PurgeAll();

	// DpC Connection.
	iCount = pTADB->GetDpCConnList( &ListEx, eDpCLoc::DpCLocDownStream, (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBlw65TypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBlw65FamilyID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBlw65BdyMatID ), CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::DpCBlw65ConnectID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"DpCBlw65ConnectID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::DpCBlw65ConnectID, strKey );
		}
	}

	ListEx.PurgeAll();

	// DpC Version.
	iCount = pTADB->GetDpCVersList( &ListEx, eDpCLoc::DpCLocDownStream, (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBlw65TypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBlw65FamilyID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBlw65BdyMatID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBlw65ConnectID ), CTADatabase::ForHMCalc );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::DpCBlw65VersionID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"DpCBlw65VersionID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::DpCBlw65VersionID, strKey );
		}
	}

	ListEx.PurgeAll();

	// DpC PN.
	iCount = pTADB->GetDpCPNList( &ListEx, eDpCLoc::DpCLocDownStream, (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBlw65TypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBlw65FamilyID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBlw65BdyMatID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBlw65ConnectID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBlw65VersionID ),
			CTADatabase::ForHMCalc );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::DpCBlw65PNID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"DpCBlw65PNID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::DpCBlw65PNID, strKey );
		}
	}

	ListEx.PurgeAll();

	// CV Type don't care about Cv2w3w or CvFunc.
	iCount = pTADB->GetTaCVTypeList( &ListEx, CTADatabase::eForHMCv, CDB_ControlProperties::CV2W3W::LastCV2W3W, CDB_ControlProperties::eCVFUNC::LastCVFUNC,
			CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::CvBlw65TypeID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"CvBlw65TypeID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::CvBlw65TypeID, strKey );
		}
	}

	ListEx.PurgeAll();

	// CV Family.
	iCount = pTADB->GetTaCVFamList( &ListEx	, CTADatabase::eForHMCv, CDB_ControlProperties::CV2W3W::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::CvBlw65TypeID ),
			CDB_ControlProperties::eCVFUNC::LastCVFUNC, CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::CvBlw65FamilyID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"CvBlw65FamilyID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::CvBlw65FamilyID, strKey );
		}
	}

	ListEx.PurgeAll();

	// CV BdyMat.
	iCount = pTADB->GetTaCVBdyMatList( &ListEx, CTADatabase::eForHMCv, CDB_ControlProperties::CV2W3W::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::CvBlw65TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::CvBlw65FamilyID ), CDB_ControlProperties::eCVFUNC::LastCVFUNC, CDB_ControlProperties::CvCtrlType::eCvNU,
			CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::CvBlw65BdyMatID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"CvBlw65BdyMatID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::CvBlw65BdyMatID, strKey );
		}
	}

	ListEx.PurgeAll();

	// CV Connection.
	iCount = pTADB->GetTaCVConnList( &ListEx, CTADatabase::eForHMCv, CDB_ControlProperties::CV2W3W::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::CvBlw65TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::CvBlw65FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::CvBlw65BdyMatID ), CDB_ControlProperties::eCVFUNC::LastCVFUNC,
			CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::CvBlw65ConnectID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"CvBlw65ConnectID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::CvBlw65ConnectID, strKey );
		}
	}

	ListEx.PurgeAll();

	// CV Version.
	iCount = pTADB->GetTaCVVersList( &ListEx, CTADatabase::eForHMCv, CDB_ControlProperties::CV2W3W::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::CvBlw65TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::CvBlw65FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::CvBlw65BdyMatID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::CvBlw65ConnectID ),
			CDB_ControlProperties::eCVFUNC::LastCVFUNC, CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::CvBlw65VersionID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"CvBlw65VersionID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::CvBlw65VersionID, strKey );
		}
	}

	ListEx.PurgeAll();

	// CV PN.
	iCount = pTADB->GetTaCVPNList( &ListEx	, CTADatabase::eForHMCv, CDB_ControlProperties::CV2W3W::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::CvBlw65TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::CvBlw65FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::CvBlw65BdyMatID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::CvBlw65ConnectID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::CvBlw65VersionID ), CDB_ControlProperties::eCVFUNC::LastCVFUNC, CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::CvBlw65PNID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"CvBlw65PNID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::CvBlw65PNID, strKey );
		}
	}

	ListEx.PurgeAll();

	// PICV Type.
	iCount = pTADB->GetTaCVTypeList( &ListEx, CTADatabase::eForPiCv, CDB_ControlProperties::LastCV2W3W, CDB_ControlProperties::LastCVFUNC, CDB_ControlProperties::eCvNU,
			CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::PICvBlw65TypeID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"PICvBlw65TypeID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::PICvBlw65TypeID, strKey );
		}
	}

	ListEx.PurgeAll();

	// PICV Family.
	iCount = pTADB->GetTaCVFamList( &ListEx	, CTADatabase::eForPiCv, CDB_ControlProperties::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::PICvBlw65TypeID ),
			CDB_ControlProperties::LastCVFUNC, CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::PICvBlw65FamilyID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"PICvBlw65FamilyID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::PICvBlw65FamilyID, strKey );
		}
	}

	ListEx.PurgeAll();

	// PICV BdyMat.
	iCount = pTADB->GetTaCVBdyMatList( &ListEx, CTADatabase::eForPiCv, CDB_ControlProperties::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::PICvBlw65TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::PICvBlw65FamilyID ), CDB_ControlProperties::LastCVFUNC, CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::PICvBlw65BdyMatID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"PICvBlw65BdyMatID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::PICvBlw65BdyMatID, strKey );
		}
	}

	ListEx.PurgeAll();

	// PICV Connection.
	iCount = pTADB->GetTaCVConnList( &ListEx, CTADatabase::eForPiCv, CDB_ControlProperties::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::PICvBlw65TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::PICvBlw65FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::PICvBlw65BdyMatID ), CDB_ControlProperties::LastCVFUNC,
			CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::PICvBlw65ConnectID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"PICvBlw65ConnectID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::PICvBlw65ConnectID, strKey );
		}
	}

	ListEx.PurgeAll();

	// PICV Version.
	iCount = pTADB->GetTaCVVersList( &ListEx, CTADatabase::eForPiCv, CDB_ControlProperties::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::PICvBlw65TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::PICvBlw65FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::PICvBlw65BdyMatID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::PICvBlw65ConnectID ),
			CDB_ControlProperties::LastCVFUNC, CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::PICvBlw65VersionID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"PICvBlw65VersionID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::PICvBlw65VersionID, strKey );
		}
	}

	ListEx.PurgeAll();

	// PICV PN.
	iCount = pTADB->GetTaCVPNList( &ListEx, CTADatabase::eForPiCv, CDB_ControlProperties::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::PICvBlw65TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::PICvBlw65FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::PICvBlw65BdyMatID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::PICvBlw65ConnectID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::PICvBlw65VersionID ), CDB_ControlProperties::LastCVFUNC, CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::PICvBlw65PNID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"PICvBlw65PNID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::PICvBlw65PNID, strKey );
		}
	}

	ListEx.PurgeAll();

	// BCv type (don't care about Cv2w3w or CvFunc).
	iCount = pTADB->GetTaCVTypeList( &ListEx, CTADatabase::eForBCv, CDB_ControlProperties::CV2W3W::LastCV2W3W, CDB_ControlProperties::eCVFUNC::LastCVFUNC,
			CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::BCvBlw65TypeID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"BCvBlw65TypeID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::BCvBlw65TypeID, strKey );
		}
	}

	ListEx.PurgeAll();

	// BCv family.
	iCount = pTADB->GetTaCVFamList( &ListEx, CTADatabase::eForBCv, CDB_ControlProperties::CV2W3W::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::BCvBlw65TypeID ),
			CDB_ControlProperties::eCVFUNC::LastCVFUNC, CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::BCvBlw65FamilyID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"BCvBlw65FamilyID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::BCvBlw65FamilyID, strKey );
		}
	}

	ListEx.PurgeAll();

	// BCv body material.
	iCount = pTADB->GetTaCVBdyMatList( &ListEx, CTADatabase::eForBCv, CDB_ControlProperties::CV2W3W::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::BCvBlw65TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::BCvBlw65FamilyID ), CDB_ControlProperties::eCVFUNC::LastCVFUNC, CDB_ControlProperties::CvCtrlType::eCvNU,
			CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::BCvBlw65BdyMatID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"BCvBlw65BdyMatID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::BCvBlw65BdyMatID, strKey );
		}
	}

	ListEx.PurgeAll();

	// BCv Connection.
	iCount = pTADB->GetTaCVConnList( &ListEx, CTADatabase::eForBCv, CDB_ControlProperties::CV2W3W::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::BCvBlw65TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::BCvBlw65FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::BCvBlw65BdyMatID ), CDB_ControlProperties::eCVFUNC::LastCVFUNC,
			CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::BCvBlw65ConnectID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"BCvBlw65ConnectID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::BCvBlw65ConnectID, strKey );
		}
	}

	ListEx.PurgeAll();

	// BCv version.
	iCount = pTADB->GetTaCVVersList( &ListEx, CTADatabase::eForBCv, CDB_ControlProperties::CV2W3W::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::BCvBlw65TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::BCvBlw65FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::BCvBlw65BdyMatID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::BCvBlw65ConnectID ),
			CDB_ControlProperties::eCVFUNC::LastCVFUNC, CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::BCvBlw65VersionID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"BCvBlw65VersionID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::BCvBlw65VersionID, strKey );
		}
	}

	ListEx.PurgeAll();

	// BCv PN.
	iCount = pTADB->GetTaCVPNList( &ListEx, CTADatabase::eForBCv, CDB_ControlProperties::CV2W3W::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::BCvBlw65TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::BCvBlw65FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::BCvBlw65BdyMatID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::BCvBlw65ConnectID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::BCvBlw65VersionID ), CDB_ControlProperties::eCVFUNC::LastCVFUNC, CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::BCvBlw65PNID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"BCvBlw65PNID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::BCvBlw65PNID, strKey );
		}
	}

	ListEx.PurgeAll();

	// DpCBCValve type.
	iCount = pTADB->GetTaCVTypeList( &ListEx, CTADatabase::eForDpCBCV );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::DpCBCValveBlw65TypeID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"DpCBCValveBlw65TypeID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::DpCBCValveBlw65TypeID, strKey );
		}
	}

	ListEx.PurgeAll();

	// DpCBCValve family.
	iCount = pTADB->GetTaCVFamList( &ListEx, CTADatabase::eForDpCBCV, CDB_ControlProperties::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveBlw65TypeID ),
			CDB_ControlProperties::LastCVFUNC, CDB_ControlProperties::eCvNU, CTADatabase::NoFiltering, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::DpCBCValveBlw65FamilyID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"DpCBCValveBlw65FamilyID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::DpCBCValveBlw65FamilyID, strKey );
		}
	}

	ListEx.PurgeAll();

	// DpCBCValve body material.
	pTADB->GetTaCVBdyMatList( &ListEx, CTADatabase::eForDpCBCV, CDB_ControlProperties::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveBlw65TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveBlw65FamilyID ), CDB_ControlProperties::LastCVFUNC, CDB_ControlProperties::eCvNU, CTADatabase::NoFiltering, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::DpCBCValveBlw65BdyMatID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"DpCBCValveBlw65BdyMatID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::DpCBCValveBlw65BdyMatID, strKey );
		}
	}

	// DpCBCValve connection.
	pTADB->GetTaCVConnList( &ListEx, CTADatabase::eForDpCBCV, CDB_ControlProperties::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveBlw65TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveBlw65FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveBlw65BdyMatID ),
			CDB_ControlProperties::LastCVFUNC, CDB_ControlProperties::eCvNU, CTADatabase::NoFiltering, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::DpCBCValveBlw65ConnectID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"DpCBCValveBlw65ConnectID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::DpCBCValveBlw65ConnectID, strKey );
		}
	}

	ListEx.PurgeAll();

	// DpCBCValve version.
	pTADB->GetTaCVVersList( &ListEx, CTADatabase::eForDpCBCV, CDB_ControlProperties::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveBlw65TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveBlw65FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveBlw65BdyMatID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveBlw65ConnectID ), CDB_ControlProperties::LastCVFUNC, CDB_ControlProperties::eCvNU, CTADatabase::NoFiltering,
			0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::DpCBCValveBlw65VersionID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"DpCBCValveBlw65VersionID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::DpCBCValveBlw65VersionID, strKey );
		}
	}

	ListEx.PurgeAll();

	// DpCBCValve PN.
	pTADB->GetTaCVPNList( &ListEx, CTADatabase::eForDpCBCV, CDB_ControlProperties::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveBlw65TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveBlw65FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveBlw65BdyMatID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveBlw65ConnectID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveBlw65PNID ),
			CDB_ControlProperties::LastCVFUNC, CDB_ControlProperties::eCvNU, CTADatabase::NoFiltering, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::DpCBCValveBlw65PNID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"DpCBCValveBlw65PNID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::DpCBCValveBlw65PNID, strKey );
		}
	}

	ListEx.PurgeAll();

	// Smart control valve type.
	iCount = pTADB->GetSmartControlValveTypeList( &ListEx, CTADatabase::NoFiltering, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SmartControlValveBlw65TypeID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"SmartControlValveBlw65TypeID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::SmartControlValveBlw65TypeID, strKey );
		}
	}

	ListEx.PurgeAll();

	// Smart control valve family.
	iCount = pTADB->GetSmartControlValveFamilyList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveBlw65TypeID ), CTADatabase::NoFiltering, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SmartControlValveBlw65FamilyID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"SmartControlValveBlw65FamilyID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::SmartControlValveBlw65FamilyID, strKey );
		}
	}

	ListEx.PurgeAll();

	// Smart control valve body material.
	pTADB->GetSmartControlValveBdyMatList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveBlw65TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveBlw65FamilyID ), CTADatabase::NoFiltering, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SmartControlValveBlw65BdyMatID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"SmartControlValveBlw65BdyMatID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::SmartControlValveBlw65BdyMatID, strKey );
		}
	}

	// Smart control valve connection.
	pTADB->GetSmartControlValveConnList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveBlw65TypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveBlw65FamilyID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveBlw65BdyMatID ), CTADatabase::NoFiltering, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SmartControlValveBlw65ConnectID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"SmartControlValveBlw65ConnectID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::SmartControlValveBlw65ConnectID, strKey );
		}
	}

	ListEx.PurgeAll();

	// Smart control valve version.
	pTADB->GetSmartControlValveVersList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveBlw65TypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveBlw65FamilyID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveBlw65BdyMatID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveBlw65ConnectID ), CTADatabase::NoFiltering, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SmartControlValveBlw65VersionID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"SmartControlValveBlw65VersionID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::SmartControlValveBlw65VersionID, strKey );
		}
	}

	ListEx.PurgeAll();

	// Smart control valve PN.
	pTADB->GetSmartControlValvePNList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveBlw65TypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveBlw65FamilyID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveBlw65BdyMatID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveBlw65ConnectID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveBlw65VersionID ), CTADatabase::NoFiltering, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SmartControlValveBlw65PNID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"SmartControlValveBlw65PNID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::SmartControlValveBlw65PNID, strKey );
		}
	}

	ListEx.PurgeAll();

	// Smart differential pressure controller type.
	iCount = pTADB->GetSmartDpCTypeList( &ListEx, CTADatabase::NoFiltering, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SmartDpCBlw65TypeID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"SmartDpCBlw65TypeID", pData->GetIDPtr().ID );
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::SmartDpCBlw65TypeID, strKey );
		}
	}

	ListEx.PurgeAll();

	// Smart differential pressure controller family.
	iCount = pTADB->GetSmartDpCFamilyList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCBlw65TypeID ), CTADatabase::NoFiltering, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SmartDpCBlw65FamilyID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"SmartDpCBlw65FamilyID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::SmartDpCBlw65FamilyID, strKey );
		}
	}

	ListEx.PurgeAll();

	// Smart differential pressure controller body material.
	pTADB->GetSmartDpCBdyMatList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCBlw65TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCBlw65FamilyID ), CTADatabase::NoFiltering, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SmartDpCBlw65BdyMatID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"SmartDpCBlw65BdyMatID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::SmartDpCBlw65BdyMatID, strKey );
		}
	}

	ListEx.PurgeAll();

	// Smart differential pressure controller connection.
	pTADB->GetSmartDpCConnList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCBlw65TypeID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCBlw65FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCBlw65BdyMatID ), CTADatabase::NoFiltering, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SmartDpCBlw65ConnectID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"SmartDpCBlw65ConnectID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::SmartDpCBlw65ConnectID, strKey );
		}
	}

	ListEx.PurgeAll();

	// Smart differential pressure controller version.
	pTADB->GetSmartDpCVersList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCBlw65TypeID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCBlw65FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCBlw65BdyMatID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCBlw65ConnectID ), CTADatabase::NoFiltering, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SmartDpCBlw65VersionID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"SmartDpCBlw65VersionID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::SmartDpCBlw65VersionID, strKey );
		}
	}

	ListEx.PurgeAll();

	// Smart differential pressure controller PN.
	pTADB->GetSmartDpCPNList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCBlw65TypeID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCBlw65FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCBlw65BdyMatID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCBlw65ConnectID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCBlw65VersionID ), CTADatabase::NoFiltering, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SmartDpCBlw65PNID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"SmartDpCBlw65PNID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::SmartDpCBlw65PNID, strKey );
		}
	}

	ListEx.PurgeAll();

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// ABOVE 50
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// BV Type.
	iDN = pclTableDN->GetSize( _T("DN_65") );
	iCount = pTADB->GetBVTypeList( &ListEx, CTADatabase::ForHMCalc, iDN, INT_MAX, true );										// Get BVType above DN50, don't get FO

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::BvAbv50TypeID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"BvAbv50TypeID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::BvAbv50TypeID, strKey );
		}
	}

	ListEx.PurgeAll();

	// BV Family.
	iCount = pTADB->GetBVFamilyList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::BvAbv50TypeID ), CTADatabase::ForHMCalc, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::BvAbv50FamilyID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"BvAbv50FamilyID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::BvAbv50FamilyID, strKey );
		}
	}

	ListEx.PurgeAll();

	// BV Body material.
	iCount = pTADB->GetBVBdyMatList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::BvAbv50TypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::BvAbv50FamilyID ),
			CTADatabase::ForHMCalc, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::BvAbv50BdyMatID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"BvAbv50BdyMatID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::BvAbv50BdyMatID, strKey );
		}
	}

	ListEx.PurgeAll();

	// BV Connection.
	iCount = pTADB->GetBVConnList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::BvAbv50TypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::BvAbv50FamilyID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::BvAbv50BdyMatID ), CTADatabase::ForHMCalc, iDN );		// Get connection for this BVType

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::BvAbv50ConnectID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"BvAbv50ConnectID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::BvAbv50ConnectID, strKey );
		}
	}

	ListEx.PurgeAll();

	// BV Version.
	iCount = pTADB->GetBVVersList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::BvAbv50TypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::BvAbv50FamilyID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::BvAbv50BdyMatID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::BvAbv50ConnectID ), CTADatabase::ForHMCalc );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::BvAbv50VersionID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"BvAbv50VersionID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::BvAbv50VersionID, strKey );
		}
	}

	ListEx.PurgeAll();

	// BV PN.
	iCount = pTADB->GetBVPNList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::BvAbv50TypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::BvAbv50FamilyID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::BvAbv50BdyMatID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::BvAbv50ConnectID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::BvAbv50VersionID ),
			CTADatabase::ForHMCalc );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::BvAbv50PNID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"BvAbv50PNID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::BvAbv50PNID, strKey );
		}
	}

	ListEx.PurgeAll();

	// DpC Type.
	iCount = pTADB->GetDpCTypeList( &ListEx, CTADatabase::ForHMCalc );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::DpCAbv50TypeID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"DpCAbv50TypeID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::DpCAbv50TypeID, strKey );
		}
	}

	ListEx.PurgeAll();

	// DpC Family.
	iCount = pTADB->GetDpCFamilyList( &ListEx, eDpCLoc::DpCLocDownStream, (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCAbv50TypeID ), CTADatabase::ForHMCalc, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::DpCAbv50FamilyID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"DpCAbv50FamilyID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::DpCAbv50FamilyID, strKey );
		}
	}

	ListEx.PurgeAll();

	// DpC Bdy material.
	iCount = pTADB->GetDpCBdyMatList( &ListEx, eDpCLoc::DpCLocDownStream, (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCAbv50TypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCAbv50FamilyID ), 
			CTADatabase::ForHMCalc, iDN );		// Get connection for this DpC Type

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::DpCAbv50BdyMatID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"DpCAbv50BdyMatID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::DpCAbv50BdyMatID, strKey );
		}
	}

	ListEx.PurgeAll();

	// DpC Connection.
	iCount = pTADB->GetDpCConnList( &ListEx, eDpCLoc::DpCLocDownStream, (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCAbv50TypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCAbv50FamilyID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::DpCAbv50BdyMatID ), CTADatabase::ForHMCalc, iDN );		// Get connection for this DpC Type

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::DpCAbv50ConnectID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"DpCAbv50ConnectID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::DpCAbv50ConnectID, strKey );
		}
	}

	ListEx.PurgeAll();

	// DpC PN.
	iCount = pTADB->GetDpCPNList( &ListEx, eDpCLoc::DpCLocDownStream, (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCAbv50TypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCAbv50FamilyID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::DpCAbv50BdyMatID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCAbv50ConnectID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCAbv50VersionID ),
			CTADatabase::ForHMCalc );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::DpCAbv50PNID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"DpCAbv50PNID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::DpCAbv50PNID, strKey );
		}
	}

	ListEx.PurgeAll();

	// CV Type don't care about Cv2w3w or CvFunc.
	iCount = pTADB->GetTaCVTypeList( &ListEx, CTADatabase::eForHMCv, CDB_ControlProperties::CV2W3W::LastCV2W3W, CDB_ControlProperties::eCVFUNC::LastCVFUNC,
			CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::CvAbv50TypeID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"CvAbv50TypeID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::CvAbv50TypeID, strKey );
		}
	}

	ListEx.PurgeAll();

	// CV Family.
	iCount = pTADB->GetTaCVFamList( &ListEx	, CTADatabase::eForHMCv, CDB_ControlProperties::CV2W3W::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::CvAbv50TypeID ),
			CDB_ControlProperties::eCVFUNC::LastCVFUNC, CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::CvAbv50FamilyID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"CvAbv50FamilyID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::CvAbv50FamilyID, strKey );
		}
	}

	ListEx.PurgeAll();

	// CV BdyMat.
	iCount = pTADB->GetTaCVBdyMatList( &ListEx, CTADatabase::eForHMCv, CDB_ControlProperties::CV2W3W::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::CvAbv50TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::CvAbv50FamilyID ), CDB_ControlProperties::eCVFUNC::LastCVFUNC, CDB_ControlProperties::CvCtrlType::eCvNU,
			CTADatabase::ForHMCalc, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::CvAbv50BdyMatID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"CvAbv50BdyMatID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::CvAbv50BdyMatID, strKey );
		}
	}

	ListEx.PurgeAll();

	// CV Connection.
	iCount = pTADB->GetTaCVConnList( &ListEx, CTADatabase::eForHMCv, CDB_ControlProperties::CV2W3W::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::CvAbv50TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::CvAbv50FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::CvAbv50BdyMatID ), CDB_ControlProperties::eCVFUNC::LastCVFUNC,
			CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::CvAbv50ConnectID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"CvAbv50ConnectID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::CvAbv50ConnectID, strKey );
		}
	}

	ListEx.PurgeAll();

	// CV Version.
	iCount = pTADB->GetTaCVVersList( &ListEx, CTADatabase::eForHMCv, CDB_ControlProperties::CV2W3W::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::CvAbv50TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::CvAbv50FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::CvAbv50BdyMatID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::CvAbv50ConnectID ),
			CDB_ControlProperties::eCVFUNC::LastCVFUNC, CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::CvAbv50VersionID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"CvAbv50VersionID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::CvAbv50VersionID, strKey );
		}
	}

	ListEx.PurgeAll();

	// CV PN.
	iCount = pTADB->GetTaCVPNList( &ListEx, CTADatabase::eForHMCv, CDB_ControlProperties::CV2W3W::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::CvAbv50TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::CvAbv50FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::CvAbv50BdyMatID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::CvAbv50ConnectID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::CvAbv50VersionID ), CDB_ControlProperties::eCVFUNC::LastCVFUNC, CDB_ControlProperties::CvCtrlType::eCvNU,
			CTADatabase::ForHMCalc, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::CvAbv50PNID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"CvAbv50PNID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::CvAbv50PNID, strKey );
		}
	}

	ListEx.PurgeAll();

	// PICV Type.
	iCount = pTADB->GetTaCVTypeList( &ListEx, CTADatabase::eForPiCv, CDB_ControlProperties::LastCV2W3W, CDB_ControlProperties::LastCVFUNC, CDB_ControlProperties::eCvNU,
			CTADatabase::ForHMCalc, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::PICvAbv50TypeID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"PICvAbv50TypeID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::PICvAbv50TypeID, strKey );
		}
	}

	ListEx.PurgeAll();

	// PICV Family.
	iCount = pTADB->GetTaCVFamList( &ListEx	, CTADatabase::eForPiCv, CDB_ControlProperties::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::PICvAbv50TypeID ),
			CDB_ControlProperties::LastCVFUNC, CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::PICvAbv50FamilyID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"PICvAbv50FamilyID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::PICvAbv50FamilyID, strKey );
		}
	}

	ListEx.PurgeAll();

	// PICV BdyMat.
	iCount = pTADB->GetTaCVBdyMatList( &ListEx, CTADatabase::eForPiCv, CDB_ControlProperties::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::PICvAbv50TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::PICvAbv50FamilyID ), CDB_ControlProperties::LastCVFUNC, CDB_ControlProperties::CvCtrlType::eCvNU,
			CTADatabase::ForHMCalc, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::PICvAbv50BdyMatID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"PICvAbv50BdyMatID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::PICvAbv50BdyMatID, strKey );
		}
	}

	ListEx.PurgeAll();

	// PICV Connection.
	iCount = pTADB->GetTaCVConnList( &ListEx, CTADatabase::eForPiCv, CDB_ControlProperties::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::PICvAbv50TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::PICvAbv50FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::PICvAbv50BdyMatID ), CDB_ControlProperties::LastCVFUNC,
			CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::PICvAbv50ConnectID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"PICvAbv50ConnectID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::PICvAbv50ConnectID, strKey );
		}
	}

	ListEx.PurgeAll();

	// PICV Version.
	iCount = pTADB->GetTaCVVersList( &ListEx, CTADatabase::eForPiCv, CDB_ControlProperties::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::PICvAbv50TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::PICvAbv50FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::PICvAbv50BdyMatID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::PICvAbv50ConnectID ),
			CDB_ControlProperties::LastCVFUNC, CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::PICvAbv50VersionID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"PICvAbv50VersionID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::PICvAbv50VersionID, strKey );
		}
	}

	ListEx.PurgeAll();

	// PICV PN.
	iCount = pTADB->GetTaCVPNList( &ListEx, CTADatabase::eForPiCv, CDB_ControlProperties::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::PICvAbv50TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::PICvAbv50FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::PICvAbv50BdyMatID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::PICvAbv50ConnectID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::PICvAbv50VersionID ), CDB_ControlProperties::LastCVFUNC, CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::PICvAbv50PNID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"PICvAbv50PNID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::PICvAbv50PNID, strKey );
		}
	}

	ListEx.PurgeAll();

	// BCv type (don't care about Cv2w3w or CvFunc).
	iCount = pTADB->GetTaCVTypeList( &ListEx, CTADatabase::eForBCv, CDB_ControlProperties::CV2W3W::LastCV2W3W, CDB_ControlProperties::eCVFUNC::LastCVFUNC,
			CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::BCvAbv50TypeID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"BCvAbv50TypeID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::BCvAbv50TypeID, strKey );
		}
	}

	ListEx.PurgeAll();

	// BCv family.
	iCount = pTADB->GetTaCVFamList(	&ListEx, CTADatabase::eForBCv, CDB_ControlProperties::CV2W3W::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::BCvAbv50TypeID ),
			CDB_ControlProperties::eCVFUNC::LastCVFUNC, CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::BCvAbv50FamilyID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"BCvAbv50FamilyID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::BCvAbv50FamilyID, strKey );
		}
	}

	ListEx.PurgeAll();

	// BCv body material.
	iCount = pTADB->GetTaCVBdyMatList( &ListEx, CTADatabase::eForBCv, CDB_ControlProperties::CV2W3W::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::BCvAbv50TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::BCvAbv50FamilyID ), CDB_ControlProperties::eCVFUNC::LastCVFUNC, CDB_ControlProperties::CvCtrlType::eCvNU,
			CTADatabase::ForHMCalc, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::BCvAbv50BdyMatID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"BCvAbv50BdyMatID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::BCvAbv50BdyMatID, strKey );
		}
	}

	ListEx.PurgeAll();

	// BCv connection.
	iCount = pTADB->GetTaCVConnList( &ListEx, CTADatabase::eForBCv, CDB_ControlProperties::CV2W3W::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::BCvAbv50TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::BCvAbv50FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::BCvAbv50BdyMatID ), CDB_ControlProperties::eCVFUNC::LastCVFUNC,
			CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::BCvAbv50ConnectID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"BCvAbv50ConnectID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::BCvAbv50ConnectID, strKey );
		}
	}

	ListEx.PurgeAll();

	// BCv version.
	iCount = pTADB->GetTaCVVersList( &ListEx, CTADatabase::eForBCv, CDB_ControlProperties::CV2W3W::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::BCvAbv50TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::BCvAbv50FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::BCvAbv50BdyMatID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::BCvAbv50ConnectID ),
			CDB_ControlProperties::eCVFUNC::LastCVFUNC, CDB_ControlProperties::CvCtrlType::eCvNU, CTADatabase::ForHMCalc, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::BCvAbv50VersionID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"BCvAbv50VersionID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::BCvAbv50VersionID, strKey );
		}
	}

	ListEx.PurgeAll();

	// BCv PN.
	iCount = pTADB->GetTaCVPNList( &ListEx, CTADatabase::eForHMCv, CDB_ControlProperties::CV2W3W::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::BCvAbv50TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::BCvAbv50FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::BCvAbv50BdyMatID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::BCvAbv50ConnectID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::BCvAbv50VersionID ), CDB_ControlProperties::eCVFUNC::LastCVFUNC, CDB_ControlProperties::CvCtrlType::eCvNU,
			CTADatabase::ForHMCalc, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::BCvAbv50PNID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"BCvAbv50PNID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::BCvAbv50PNID, strKey );
		}
	}

	ListEx.PurgeAll();

	CString defaultPowerSupply = _T("POW_24VAC");
	CString defaultInputSignal = _T("SIG_0-10V");

	// Actuator power supply.
	CTable *pclActuatorTable = static_cast<CTable *>( pTADB->Get( _T("ACTUATOR_TAB") ).MP );
	ASSERT( pclActuatorTable != NULL );

	CRank List;
	iCount = pTADB->GetActuatorPowerSupplyList( &List, pclActuatorTable, m_CVCtrlType, CTADatabase::ForHMCalc );
	CString str2;

	if( iCount > 0 && TRUE == List.GetFirstT<CData *>( str2, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::ActuatorPowerSupplyID, defaultPowerSupply );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"ActuatorPowerSupplyID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::ActuatorPowerSupplyID, strKey );
		}
	}

	List.PurgeAll();

	// Actuator input signal.
	iCount = pTADB->GetActuatorInputSignalList(	&List, pclActuatorTable, m_CVCtrlType, (LPCTSTR)GetPrjParamID( _PrjParamsID::ActuatorPowerSupplyID ), CTADatabase::ForHMCalc );

	if( iCount > 0 )
	{
		IDPTR idptrToDefault = _NULL_IDPTR;
		CDB_StringID *pstrID = NULL;
		List.GetFirstT<CDB_StringID *>( str2, pstrID );
		//by default
		idptrToDefault = pstrID->GetIDPtr();

		for( BOOL bContinue = List.GetFirstT<CDB_StringID *>( str2, pstrID ); TRUE == bContinue; bContinue = List.GetNextT<CDB_StringID *>( str2, pstrID ) )
		{
			// Try to find Proportional control
			int j = 0;

			if( true == pstrID->GetIDstrAs<int>( 0, j ) )
			{
				if( j == CDB_ControlProperties::eCvProportional )
				{
					idptrToDefault = pstrID->GetIDPtr();
					break;
				}
			}
		}

		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::ActuatorInputSignalID, idptrToDefault.ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"ActuatorInputSignalID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::ActuatorInputSignalID, strKey );
		}
	}

	List.PurgeAll();

	// Actuator fail safe.
	int iResult = pTADB->GetActuatorFailSafeValues(	pclActuatorTable, m_CVCtrlType, (LPCTSTR)GetPrjParamID( _PrjParamsID::ActuatorPowerSupplyID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::ActuatorInputSignalID ), CTADatabase::ForHMCalc );
	
	if( -1 != iResult && true == bToDefault )
	{
		m_iActuatorFailSafeFct = 0;
	}
	else if ( -1 != iResult )
	{
		m_iActuatorFailSafeFct = ::AfxGetApp()->GetProfileInt( strSectionName, L"ActuatorFailSafe", 0 );
	}

	// Actuator default return position.
	iCount = pTADB->GetActuatorDRPList(	&List, pclActuatorTable, m_CVCtrlType, NULL, (LPCTSTR)GetPrjParamID( _PrjParamsID::ActuatorPowerSupplyID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::ActuatorInputSignalID ), m_iActuatorFailSafeFct, CTADatabase::ForHMCalc );

	if( iCount > 0 && TRUE == List.GetFirstT<CData *>( str2, pData ) )
	{
		if( true == bToDefault )
		{
			m_eActuatorDRPFct = CDB_ControlValve::DRPFunction::drpfNone;
		}
		else
		{
			m_eActuatorDRPFct = (CDB_ControlValve::DRPFunction)::AfxGetApp()->GetProfileInt( strSectionName, L"ActuatorDRP", CDB_ControlValve::DRPFunction::drpfNone );
		}
	}

	List.PurgeAll();

	// Automatically select actuators for control valve.
	if( true == bToDefault )
	{
		m_bActuatorAutomaticallySelect = true;
	}
	else
	{
		m_bActuatorAutomaticallySelect = ( 0 == ::AfxGetApp()->GetProfileInt( strSectionName, L"ActuatorAutomaticallySelect", 1 ) ) ? false : true;
	}

	// Actuator selected by package.
	if( true == bToDefault )
	{
		m_bActuatorSelectedByPackage = true;
	}
	else
	{
		m_bActuatorSelectedByPackage = ( 0 == ::AfxGetApp()->GetProfileInt( strSectionName, L"ActuatorSelectedByPackage", 1 ) ) ? false : true;
	}

	// Separator type.
	iCount = pTADB->GetSeparatorTypeList( &ListEx, CTADatabase::ForHMCalc );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SeparatorTypeID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"SepTypeID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::SeparatorTypeID, strKey );
		}
	}

	ListEx.PurgeAll();

	// Separator family.
	iCount = pTADB->GetSeparatorFamilyList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::SeparatorTypeID ), CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SeparatorFamilyID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"SepFamilyID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::SeparatorFamilyID, strKey );
		}
	}

	ListEx.PurgeAll();

	// Separator Connection.
	iCount = pTADB->GetSeparatorConnList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::SeparatorTypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::SeparatorFamilyID ),
			CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SeparatorConnectID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"SepConnectID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::SeparatorConnectID, strKey );
		}
	}

	ListEx.PurgeAll();

	// Separator version.
	iCount = pTADB->GetSeparatorVersList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::SeparatorTypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::SeparatorFamilyID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::SeparatorConnectID ), CTADatabase::ForHMCalc, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SeparatorVersionID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"SepVersionID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::SeparatorVersionID, strKey );
		}
	}

	ListEx.PurgeAll();

	// DpCBCValve type.
	iCount = pTADB->GetTaCVTypeList( &ListEx, CTADatabase::eForDpCBCV );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::DpCBCValveAbv50TypeID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"DpCBCValveAbv50TypeID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::DpCBCValveAbv50TypeID, strKey );
		}
	}

	ListEx.PurgeAll();

	// DpCBCValve family.
	iCount = pTADB->GetTaCVFamList( &ListEx, CTADatabase::eForDpCBCV, CDB_ControlProperties::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveAbv50TypeID ),
			CDB_ControlProperties::LastCVFUNC, CDB_ControlProperties::eCvNU, CTADatabase::NoFiltering, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::DpCBCValveAbv50FamilyID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"DpCBCValveAbv50FamilyID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::DpCBCValveAbv50FamilyID, strKey );
		}
	}

	ListEx.PurgeAll();

	// DpCBCValve body material.
	pTADB->GetTaCVBdyMatList( &ListEx, CTADatabase::eForDpCBCV, CDB_ControlProperties::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveAbv50TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveAbv50FamilyID ), CDB_ControlProperties::LastCVFUNC, CDB_ControlProperties::eCvNU, CTADatabase::NoFiltering, 0, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::DpCBCValveAbv50BdyMatID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"DpCBCValveAbv50BdyMatID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::DpCBCValveAbv50BdyMatID, strKey );
		}
	}

	// DpCBCValve connection.
	pTADB->GetTaCVConnList( &ListEx, CTADatabase::eForDpCBCV, CDB_ControlProperties::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveAbv50TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveAbv50FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveAbv50BdyMatID ),
			CDB_ControlProperties::LastCVFUNC, CDB_ControlProperties::eCvNU, CTADatabase::NoFiltering, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::DpCBCValveAbv50ConnectID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"DpCBCValveAbv50ConnectID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::DpCBCValveAbv50ConnectID, strKey );
		}
	}

	ListEx.PurgeAll();

	// DpCBCValve version.
	pTADB->GetTaCVVersList( &ListEx, CTADatabase::eForDpCBCV, CDB_ControlProperties::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveAbv50TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveAbv50FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveAbv50BdyMatID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveAbv50ConnectID ), CDB_ControlProperties::LastCVFUNC, CDB_ControlProperties::eCvNU, CTADatabase::NoFiltering, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::DpCBCValveAbv50VersionID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"DpCBCValveAbv50VersionID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::DpCBCValveAbv50VersionID, strKey );
		}
	}

	ListEx.PurgeAll();

	// DpCBCValve PN.
	pTADB->GetTaCVPNList( &ListEx, CTADatabase::eForDpCBCV, CDB_ControlProperties::LastCV2W3W, (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveAbv50TypeID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveAbv50FamilyID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveAbv50BdyMatID ),
			(LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveAbv50ConnectID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::DpCBCValveAbv50PNID ),
			CDB_ControlProperties::LastCVFUNC, CDB_ControlProperties::eCvNU, CTADatabase::NoFiltering, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::DpCBCValveAbv50PNID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"DpCBCValveAbv50PNID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::DpCBCValveAbv50PNID, strKey );
		}
	}

	ListEx.PurgeAll();

	// ATTENTION: Before 4046 version of the CTADatastruct there was an error concerning the saving of parameters for smart control valves above DN 50.
	// For all calls to the 'GetSmartControlValveXXXList', we pass 0 and iDN respectively for the 'iDNMin' and 'iDNMax' arguments. So we had in fact 
	// the same parameters that the smart control valve below DN 65.
	bool bVerify = false;

	if( false == strVersion.IsEmpty() )
	{
		int iVersion = _ttoi( strVersion );
		bVerify = ( iVersion <= 4046 ) ? true : false;
	}
	
	// Smart control valve type.
	iCount = pTADB->GetSmartControlValveTypeList( &ListEx, CTADatabase::NoFiltering, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SmartControlValveAbv50TypeID, pData->GetIDPtr().ID );
		}
		else
		{
			CString strTypeID = ::AfxGetApp()->GetProfileString( strSectionName, L"SmartControlValveAbv50TypeID", pData->GetIDPtr().ID );

			if( false == strTypeID.IsEmpty() && true == bVerify )
			{
				CDB_StringID *pclTypeStringID = dynamic_cast<CDB_StringID *>( TASApp.GetpTADB()->Get( strTypeID ).MP );

				if( NULL != pclTypeStringID && false == ListEx.IfExist( pclTypeStringID->GetString() ) )
				{
					strTypeID = pData->GetIDPtr().ID;
				}
			}
			else if( true == strTypeID.IsEmpty() )
			{
				strTypeID = ( false == strTypeID.IsEmpty() ) ? strTypeID : pData->GetIDPtr().ID;
			}

			SetPrjParamID( _PrjParamsID::SmartControlValveAbv50TypeID, strTypeID );
		}
	}

	ListEx.PurgeAll();

	// Smart control valve family.
	iCount = pTADB->GetSmartControlValveFamilyList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveAbv50TypeID ), CTADatabase::NoFiltering, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SmartControlValveAbv50FamilyID, pData->GetIDPtr().ID );
		}
		else
		{
			CString strFamilyID = ::AfxGetApp()->GetProfileString( strSectionName, L"SmartControlValveAbv50FamilyID", pData->GetIDPtr().ID );

			if( false == strFamilyID.IsEmpty() && true == bVerify )
			{
				CDB_StringID *pclFamilyStringID = dynamic_cast<CDB_StringID *>( TASApp.GetpTADB()->Get( strFamilyID ).MP );

				if( NULL != pclFamilyStringID && false == ListEx.IfExist( pclFamilyStringID->GetString() ) )
				{
					strFamilyID = pData->GetIDPtr().ID;
				}
			}
			else if( true == strFamilyID.IsEmpty() )
			{
				strFamilyID = ( false == strFamilyID.IsEmpty() ) ? strFamilyID : pData->GetIDPtr().ID;
			}

			SetPrjParamID( _PrjParamsID::SmartControlValveAbv50FamilyID, strFamilyID );
		}
	}

	ListEx.PurgeAll();

	// Smart control valve body material.
	pTADB->GetSmartControlValveBdyMatList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveAbv50TypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveAbv50FamilyID ), 
			CTADatabase::NoFiltering, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SmartControlValveAbv50BdyMatID, pData->GetIDPtr().ID );
		}
		else
		{
			CString strBodyMaterialID = ::AfxGetApp()->GetProfileString( strSectionName, L"SmartControlValveAbv50BdyMatID", pData->GetIDPtr().ID );

			if( false == strBodyMaterialID.IsEmpty() && true == bVerify )
			{
				CDB_StringID *pclBodyMaterialStringID = dynamic_cast<CDB_StringID *>( TASApp.GetpTADB()->Get( strBodyMaterialID ).MP );

				if( NULL != pclBodyMaterialStringID && false == ListEx.IfExist( pclBodyMaterialStringID->GetString() ) )
				{
					strBodyMaterialID = pData->GetIDPtr().ID;
				}
			}
			else if( true == strBodyMaterialID.IsEmpty() )
			{
				strBodyMaterialID = ( false == strBodyMaterialID.IsEmpty() ) ? strBodyMaterialID : pData->GetIDPtr().ID;
			}

			SetPrjParamID( _PrjParamsID::SmartControlValveAbv50BdyMatID, strBodyMaterialID );
		}
	}

	// Smart control valve body connection.
	pTADB->GetSmartControlValveConnList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveAbv50TypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveAbv50FamilyID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveAbv50BdyMatID ), CTADatabase::NoFiltering, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SmartControlValveAbv50ConnectID, pData->GetIDPtr().ID );
		}
		else
		{
			CString strConnectionID = ::AfxGetApp()->GetProfileString( strSectionName, L"SmartControlValveAbv50ConnectID", pData->GetIDPtr().ID );

			if( false == strConnectionID.IsEmpty() && true == bVerify )
			{
				CDB_StringID *pclConnectionStringID = dynamic_cast<CDB_StringID *>( TASApp.GetpTADB()->Get( strConnectionID ).MP );

				if( NULL != pclConnectionStringID && false == ListEx.IfExist( pclConnectionStringID->GetString() ) )
				{
					strConnectionID = pData->GetIDPtr().ID;
				}
			}
			else if( true == strConnectionID.IsEmpty() )
			{
				strConnectionID = ( false == strConnectionID.IsEmpty() ) ? strConnectionID : pData->GetIDPtr().ID;
			}

			SetPrjParamID( _PrjParamsID::SmartControlValveAbv50ConnectID, strConnectionID );
		}
	}

	ListEx.PurgeAll();

	// Smart control valve version.
	pTADB->GetSmartControlValveVersList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveAbv50TypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveAbv50FamilyID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveAbv50BdyMatID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveAbv50ConnectID ), CTADatabase::NoFiltering, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SmartControlValveAbv50VersionID, pData->GetIDPtr().ID );
		}
		else
		{
			CString strVersionID = ::AfxGetApp()->GetProfileString( strSectionName, L"SmartControlValveAbv50VersionID", pData->GetIDPtr().ID );

			if( false == strVersionID.IsEmpty() && true == bVerify )
			{
				CDB_StringID *pclVersionStringID = dynamic_cast<CDB_StringID *>( TASApp.GetpTADB()->Get( strVersionID ).MP );

				if( NULL != pclVersionStringID && false == ListEx.IfExist( pclVersionStringID->GetString() ) )
				{
					strVersionID = pData->GetIDPtr().ID;
				}
			}
			else if( true == strVersionID.IsEmpty() )
			{
				strVersionID = ( false == strVersionID.IsEmpty() ) ? strVersionID : pData->GetIDPtr().ID;
			}

			SetPrjParamID( _PrjParamsID::SmartControlValveAbv50VersionID, strVersionID );
		}
	}

	ListEx.PurgeAll();

	// Smart control valve PN.
	pTADB->GetSmartControlValvePNList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveAbv50TypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveAbv50FamilyID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveAbv50BdyMatID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveAbv50ConnectID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::SmartControlValveAbv50VersionID ), CTADatabase::NoFiltering, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SmartControlValveAbv50PNID, pData->GetIDPtr().ID );
		}
		else
		{
			CString strPNID = ::AfxGetApp()->GetProfileString( strSectionName, L"SmartControlValveAbv50PNID", pData->GetIDPtr().ID );

			if( false == strPNID.IsEmpty() && true == bVerify )
			{
				CDB_StringID *pclPNStringID = dynamic_cast<CDB_StringID *>( TASApp.GetpTADB()->Get( strPNID ).MP );

				if( NULL != pclPNStringID && false == ListEx.IfExist( pclPNStringID->GetString() ) )
				{
					strPNID = pData->GetIDPtr().ID;
				}
			}
			else if( true == strPNID.IsEmpty() )
			{
				strPNID = ( false == strPNID.IsEmpty() ) ? strPNID : pData->GetIDPtr().ID;
			}

			SetPrjParamID( _PrjParamsID::SmartControlValveAbv50PNID, strPNID );
		}
	}

	ListEx.PurgeAll();

	// Smart differential pressure controller type.
	iCount = pTADB->GetSmartDpCTypeList( &ListEx, CTADatabase::NoFiltering, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SmartDpCAbv50TypeID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"SmartDpCAbv50TypeID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::SmartDpCAbv50TypeID, strKey );
		}
	}

	ListEx.PurgeAll();

	// Smart differential pressure controller family.
	iCount = pTADB->GetSmartDpCFamilyList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCAbv50TypeID ), CTADatabase::NoFiltering, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SmartDpCAbv50FamilyID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"SmartDpCAbv50FamilyID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::SmartDpCAbv50FamilyID, strKey );
		}
	}

	ListEx.PurgeAll();

	// Smart differential pressure controller body material.
	pTADB->GetSmartDpCBdyMatList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCAbv50TypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCAbv50FamilyID ), 
			CTADatabase::NoFiltering, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SmartDpCAbv50BdyMatID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"SmartDpCAbv50BdyMatID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::SmartDpCAbv50BdyMatID, strKey );
		}
	}

	ListEx.PurgeAll();

	// Smart differential pressure controller body connection.
	pTADB->GetSmartDpCConnList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCAbv50TypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCAbv50FamilyID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCAbv50BdyMatID ), CTADatabase::NoFiltering, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SmartDpCAbv50ConnectID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"SmartDpCAbv50ConnectID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::SmartDpCAbv50ConnectID, strKey );
		}
	}

	ListEx.PurgeAll();

	// Smart differential pressure controller version.
	pTADB->GetSmartDpCVersList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCAbv50TypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCAbv50FamilyID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCAbv50BdyMatID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCAbv50ConnectID ), CTADatabase::NoFiltering, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SmartDpCAbv50VersionID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"SmartDpCAbv50VersionID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::SmartDpCAbv50VersionID, strKey );
		}
	}

	ListEx.PurgeAll();

	// Smart differential pressure controller PN.
	pTADB->GetSmartDpCPNList( &ListEx, (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCAbv50TypeID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCAbv50FamilyID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCAbv50BdyMatID ), (LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCAbv50ConnectID ), 
			(LPCTSTR)GetPrjParamID( _PrjParamsID::SmartDpCAbv50VersionID ), CTADatabase::NoFiltering, iDN );

	if( iCount > 0 && ListEx.GetFirstT<CData *>( str1, pData ) )
	{
		if( true == bToDefault )
		{
			SetPrjParamID( _PrjParamsID::SmartDpCAbv50PNID, pData->GetIDPtr().ID );
		}
		else
		{
			strKey = ::AfxGetApp()->GetProfileString( strSectionName, L"SmartDpCAbv50PNID", pData->GetIDPtr().ID );
			
			strKey = ( false == strKey.IsEmpty() ) ? strKey : pData->GetIDPtr().ID;
			SetPrjParamID( _PrjParamsID::SmartDpCAbv50PNID, strKey );
		}
	}

	ListEx.PurgeAll();

	m_CVMode = _CVMode::TAMode;
	m_CVCtrlType = CDB_ControlProperties::CvCtrlType::eCvProportional;
	m_CVFunc = CDB_ControlProperties::eCVFUNC::ControlOnly;

	// Pipe series.
	CString str;
	CDS_TechnicalParameter *pTechParam = TASApp.GetpTADS()->GetpTechParams();

	if( NULL != pTechParam )
	{
		str = pTechParam->GetDefaultPipeSerieIDPtr().ID;
	}

	// Circuit pipe.
	if( true == bToDefault )
	{
		SetPrjParamID( _PrjParamsID::PipeCircSerieID, str );
	}
	else
	{
		CString strPipeSeries = ::AfxGetApp()->GetProfileString( strSectionName, L"PipeCircSerieID", str );
		_VerifyIfPipeSeriesExist( strPipeSeries );
		SetPrjParamID( _PrjParamsID::PipeCircSerieID, strPipeSeries );
	}

	// Bypass pipe.
	if( true == bToDefault )
	{
		SetPrjParamID( _PrjParamsID::PipeByPassSerieID, str );
	}
	else
	{
		CString strPipeSeries = ::AfxGetApp()->GetProfileString( strSectionName, L"PipeByPassSerieID", str );
		_VerifyIfPipeSeriesExist( strPipeSeries );
		SetPrjParamID( _PrjParamsID::PipeByPassSerieID, strPipeSeries );
	}

	// Distribution supply pipe.
	if( true == bToDefault )
	{
		SetPrjParamID( _PrjParamsID::PipeDistSupplySerieID, str );
	}
	else
	{
		// Open the registry key 'DialogTechParam'.
		HKEY hReg;
		CString strKeyName = _T("Software\\") + CRegAccess::GetTASRegistryKey() + _HYSELECT_NAME_BCKSLASH + strSectionName;

		if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER, strKeyName, 0, KEY_ALL_ACCESS, &hReg ) )
		{
			// Try to read the old value.
			DWORD dwType, dwSize;
			TCHAR tcBuffer[128];
			dwSize = sizeof( tcBuffer );

			if( ERROR_SUCCESS == RegQueryValueEx( hReg, _T("PipeDistSerieID"), NULL, &dwType, ( LPBYTE )tcBuffer, &dwSize ) )
			{
				// If success to read, we write into the new value.
				RegSetValueEx( hReg, _T("PipeDistSupplySerieID"), NULL, dwType, ( LPBYTE )tcBuffer, dwSize );

				// Delete old key.
				RegDeleteValue( hReg, _T("PipeDistSerieID") );
				SetPrjParamID( _PrjParamsID::PipeDistSupplySerieID, CString( tcBuffer ) );
			}
			else
			{
				// Read the new one.
				CString strPipeSeries = ::AfxGetApp()->GetProfileString( strSectionName, L"PipeDistSupplySerieID", str );
				_VerifyIfPipeSeriesExist( strPipeSeries );
				SetPrjParamID( _PrjParamsID::PipeDistSupplySerieID, strPipeSeries );
			}
		}
		else
		{
			// Can't read the key, write the default pipe series.
			SetPrjParamID( _PrjParamsID::PipeDistSupplySerieID, str );
		}
	}

	// Distribution return pipe.
	if( true == bToDefault )
	{
		SetPrjParamID( _PrjParamsID::PipeDistReturnSerieID, str );
	}
	else
	{
		CString strPipeSeries = ::AfxGetApp()->GetProfileString( strSectionName, L"PipeDistReturnSerieID", str );
		_VerifyIfPipeSeriesExist( strPipeSeries );
		SetPrjParamID( _PrjParamsID::PipeDistReturnSerieID, strPipeSeries );
	}
}

CString CPrjParams::GetPrjParamID( _PrjParamsID ID )
{
	ASSERT( ID < LASTID );
	return ( GetPrjParamIDPtr( ID ).ID );
}

IDPTR CPrjParams::GetPrjParamIDPtr( _PrjParamsID ID )
{
	ASSERT( ID < LASTID );
	return ( m_ParamID[ID].IDptr );
}

void CPrjParams::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CPRJPARAMS_VERSION;
	WriteData<>( outf, Version );
	int iLastID = LASTID;
	WriteData<>( outf, iLastID );

	for( int i = 0; i < iLastID; i++ )
	{
		WriteString( outf, (LPCTSTR)GetPrjParamID( ( _PrjParamsID )i ) );
	}

	WriteData<>( outf, m_CVFunc );
	WriteData<>( outf, m_CVCtrlType );

	// Version 8.
	WriteData<>( outf, m_bActuatorAutomaticallySelect );
	WriteData<>( outf, m_bActuatorSelectedByPackage );
	WriteData<>( outf, m_iActuatorFailSafeFct );

	// Version 9.
	WriteData<>( outf, m_fUserForcedHMCalcMode );

	// Version 12.
	WriteData<>( outf, m_eActuatorDRPFct );

	// Version 13.
	WriteData<>( outf, m_bOldProductsAvailable );
}

bool CPrjParams::Read( INPSTREAM inpf )
{
	// Version.
	inpf.read( (char *)&m_Version, sizeof( m_Version ) );

	if( m_Version < 1 || m_Version > CPRJPARAMS_VERSION )
	{
		return false;
	}

	// Base class.
	int LastID = CvAbv50PNID + 9;		// LASTID for version 3 and below

	if( 1 == m_Version )
	{
		LastID = PipeDistSupplySerieID + 1;
	}

	if( m_Version > 3 )
	{
		inpf.read( (char *)&LastID, sizeof( LastID ) );
	}

	// Variable created to calculate the correct position to set the "SetPrjParamID".
	int iParam = -1;

	for( int i = 0; i < LastID; i++ )
	{
		CString str;

		if( false == ReadString( inpf, str ) )
		{
			return false;
		}

		// BvByp values have been deleted in version 6.
		// Skip values for versions below 6.
		if( m_Version < 6 )
		{
			if( i >= ( PipeDistSupplySerieID + 1 ) && i <= ( PipeDistSupplySerieID + 8 ) )
			{
				continue;
			}
		}

		// Increment the correct position.
		iParam++;

		if( false == str.IsEmpty() )
		{
			SetPrjParamID( ( _PrjParamsID )iParam, str );
		}

		// New value: 'PipeDistReturnSerieID' added at the end.
		// !!! Remark: between version 5 and 6, eight variables has been removed. We must take in count this shift when
		//             using constant as 'PICvAbv50PNID'.
		int iSkipedLine = i - iParam;

		if( m_Version < 7 && i == PICvAbv50PNID + iSkipedLine )
		{
			break;
		}

		if( m_Version < 8 && i == PipeDistReturnSerieID + iSkipedLine )
		{
			break;
		}
	}

	inpf.read( (char *)&m_CVFunc, sizeof( m_CVFunc ) );

	if( m_Version < 3 )
	{
		typedef enum _CVCtrlType
		{
			OnOff,
			Proportional
		} ;
		_CVCtrlType bidon;
		inpf.read( (char *)&bidon, sizeof( bidon ) );
		m_CVCtrlType = CDB_ControlProperties::CvCtrlType::eCvOnOff;

		if( bidon != OnOff )
		{
			m_CVCtrlType =  CDB_ControlProperties::CvCtrlType::eCvProportional;
		}

		return true;
	}

	inpf.read( (char *)&m_CVCtrlType, sizeof( m_CVCtrlType ) );

	if( m_Version < 8 )
	{
		return true;
	}

	inpf.read( (char *)&m_bActuatorAutomaticallySelect, sizeof( m_bActuatorAutomaticallySelect ) );
	inpf.read( (char *)&m_bActuatorSelectedByPackage, sizeof( m_bActuatorSelectedByPackage ) );
	bool bIsDRPReaded = false;
	
	if( m_Version >= 12 )
	{
		inpf.read( (char *)&m_iActuatorFailSafeFct, sizeof( m_iActuatorFailSafeFct ) );
	}
	else
	{
		inpf.read( (char *)&m_eActuatorDRPFct, sizeof( m_eActuatorDRPFct ) );
		bIsDRPReaded = true;
		m_iActuatorFailSafeFct = 0;
	}

	if( m_Version < 9 )
	{
		return true;
	}

	inpf.read( (char *)&m_fUserForcedHMCalcMode, sizeof( m_fUserForcedHMCalcMode ) );

	if( m_Version < 12 )
	{
		return true;
	}

	if ( false == bIsDRPReaded )
	{
		inpf.read( (char *)&m_eActuatorDRPFct, sizeof( m_eActuatorDRPFct ) );
	}

	// HYS-1221
	if( m_Version < 13 )
	{
		return true;
	}

	inpf.read( (char *)&m_bOldProductsAvailable, sizeof( m_bOldProductsAvailable ) );

	
	return true;
}

void CPrjParams::Copy( CPrjParams *pPrjParams )
{
	for( int i = 0; i < LASTID; i++ )
	{
		pPrjParams->SetPrjParamID( ( _PrjParamsID )i, GetPrjParamID( ( _PrjParamsID )i ) );
	}

	pPrjParams->SetCVType( m_CVFunc );
	pPrjParams->SetCVCtrlType( m_CVCtrlType );
	pPrjParams->SetActuatorAutomaticallySelect( m_bActuatorAutomaticallySelect );
	pPrjParams->SetActuatorSelectedByPackage( m_bActuatorSelectedByPackage );
	pPrjParams->SetActuatorFailSafeFct( m_iActuatorFailSafeFct );
	pPrjParams->SetActuatorDRPFct( m_eActuatorDRPFct );
	pPrjParams->SetUserForcedHMCalcModeFlag( m_fUserForcedHMCalcMode );
	pPrjParams->SetCheckOldProductsAvailableForHC( m_bOldProductsAvailable );
}

bool CPrjParams::CompareBvID()
{
	if( GetPrjParamID( BvBlw65TypeID ) != GetPrjParamID( BvAbv50TypeID )
			|| GetPrjParamID( BvBlw65ConnectID ) != GetPrjParamID( BvAbv50ConnectID )
			|| GetPrjParamID( BvBlw65VersionID ) != GetPrjParamID( BvAbv50VersionID )
			|| GetPrjParamID( BvBlw65PNID ) != GetPrjParamID( BvAbv50PNID ) )
	{
		return true;
	}

	return false;
}

bool CPrjParams::CompareDpCID()
{
	if( GetPrjParamID( DpCBlw65TypeID ) != GetPrjParamID( DpCAbv50TypeID )
			|| GetPrjParamID( DpCBlw65ConnectID ) != GetPrjParamID( DpCAbv50ConnectID )
			|| GetPrjParamID( DpCBlw65PNID ) != GetPrjParamID( DpCAbv50PNID ) )
	{
		return true;
	}

	return false;
}

bool CPrjParams::operator==( CPrjParams &PrjParams )
{
	for( int i = 0; i < CPrjParams::LASTID; i++ )
	{
		if( PrjParams.GetPrjParamID( ( CPrjParams::_PrjParamsID )i ) != GetPrjParamID( ( CPrjParams::_PrjParamsID )i ) )
		{
			return false;
		}
	}

	return true;
}

void CPrjParams::_VerifyIfPipeSeriesExist( CString &strIDToVerify )
{
	if( NULL == TASApp.GetpTADS() || NULL == TASApp.GetpTADS()->GetpTechParams() )
	{
		ASSERT_RETURN;
	}

	CDS_TechnicalParameter *pTech = TASApp.GetpTADS()->GetpTechParams();
	CData *pclPipeSeriesToVerify = (CData *)( TASApp.GetpPipeDB()->Get( strIDToVerify ).MP );

	if( true == strIDToVerify.IsEmpty() || NULL == pclPipeSeriesToVerify || false == pclPipeSeriesToVerify->IsSelectable() )
	{
		// The generic pipe series is intentionnaly set to the first position.
		CData *pData = NULL;
		CRank List;
		int iCount = TASApp.GetpTADB()->GetPipeSerieList( &List, CTADatabase::ForHMCalc );

		CString str;

		if( iCount > 0 && List.GetFirstT<CData *>( str, pData ) )
		{
			if( NULL == pData )
			{
				ASSERT( 0 );
			}
			else
			{
				strIDToVerify = pData->GetIDPtr().ID;
			}
		}

		List.PurgeAll();
	}
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_ProjectParams
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_ProjectParams )

CDS_ProjectParams::CDS_ProjectParams( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
	uid = 1;
	Modified();
	m_pPrjParams = new CPrjParams( this );
	m_SafetyFactor = 1.05;
	m_bFreeze = true;
	m_bCompatibleCBI = false;
	m_bHNAutomaticCheck = true;
}

CDS_ProjectParams::~CDS_ProjectParams()
{
	delete m_pPrjParams;
}

void CDS_ProjectParams::Copy( CData *pclDestination )
{
	CDS_ProjectParams *pclDestinationProjectParams = dynamic_cast<CDS_ProjectParams *>( pclDestination );

	if( NULL == pclDestinationProjectParams )
	{
		ASSERT_RETURN;
	}

	CData::Copy( pclDestination );

	pclDestinationProjectParams->ResetUid( GetLastUid() );
	pclDestinationProjectParams->SetSafetyFactor( GetSafetyFactor() );
	pclDestinationProjectParams->SetFreeze( IsFreezed() );
	pclDestinationProjectParams->SetCompatibleCBI( IsCompatibleCBI() );
	pclDestinationProjectParams->SetHNAutomaticCheck( GetHNAutomaticCheck() );
	GetpHmCalcParams()->Copy( pclDestinationProjectParams->GetpHmCalcParams() );
}

#define CDS_PROJECTPARAMS_VERSION	4
void CDS_ProjectParams::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_PROJECTPARAMS_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CData::Write( outf );

	// Infos.
	WriteData<>( outf, uid );
	m_pPrjParams->Write( outf );
	WriteData<>( outf, m_SafetyFactor );
	WriteData<>( outf, m_bCompatibleCBI );
}

bool CDS_ProjectParams::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_PROJECTPARAMS_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_PROJECTPARAMS_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Infos.
	inpf.read( (char *)&uid, sizeof( uid ) );

	if( 1 == Version )
	{
		return true;
	}

	m_pPrjParams->Read( inpf );

	if( 2 == Version )
	{
		return true;
	}

	inpf.read( (char *)&m_SafetyFactor, sizeof( m_SafetyFactor ) );

	if( 3 == Version )
	{
		return true;
	}

	inpf.read( (char *)&m_bCompatibleCBI, sizeof( m_bCompatibleCBI ) );

	if( _ttoi( GetIDPtr().DB->GetVersion() ) < _ttoi( _T("4017") ) )
	{
		// Force compatibility to false for previous old project
		// Previous version contains a bug with the Compatibility flag that is not correctly saved.
		m_bCompatibleCBI = false;
	}

	return true;
}

// Scan all HydroMod and complete Missing UID
void CDS_ProjectParams::CompleteUID( CTable *pTab )
{
	for( IDPTR IDPtr = pTab->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pTab->GetNext( IDPtr.MP ) )
	{
		CDS_HydroMod *pHM = dynamic_cast<CDS_HydroMod *>( IDPtr.MP );

		if( NULL == pHM )
		{
			continue;
		}

		if( 0 == pHM->GetUid() )
		{
			pHM->SetUid( GetNextUid() );
		}

		if( true == pHM->IsaModule() )
		{
			CompleteUID( pHM );
		}
	}
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CSelectedInfos
// Class used with CDS_... selectable components
///////////////////////////////////////////////////////////////////////////////////

CSelectedInfos::CSelectedInfos( CData *pOwner )
{
	m_pOwner = pOwner;
	m_strReference1 = _T("");
	m_strReference2 = _T("");
	m_iQuantity = 0;
	m_dPrice = 0.0;
	m_strRemark = _T("");
	m_iRemarkIndex = 0;
	m_iRowIndex = 0;
	m_ModIDPtr = _NULL_IDPTR;
	m_dDT = 0.0;
	// For changeOver only
	m_dCoolingDT = 0.0;
	m_dHeatingDT = 0.0;
	m_eApplicationType = ProjectType::Heating;
}

void CSelectedInfos::SetReference( eReferences eReference, CString str )
{
	if( eRef1 == eReference && m_strReference1 != str )
	{
		m_strReference1 = str;
		m_pOwner->Modified();
	}
	else if( eRef2 == eReference && m_strReference2 != str )
	{
		m_strReference2 = str;
		m_pOwner->Modified();
	}
}

void CSelectedInfos::SetQuantity( int iQuantity )
{
	if( iQuantity != m_iQuantity )
	{
		m_iQuantity = iQuantity;
		m_pOwner->Modified();
	}
}

void CSelectedInfos::SetPrice( double dPrice )
{
	if( m_dPrice != dPrice )
	{
		m_dPrice = dPrice;
		m_pOwner->Modified();
	}
}

void CSelectedInfos::SetRemark( CString strRemark )
{
	if( m_strRemark != strRemark )
	{
		m_strRemark = strRemark;
		m_pOwner->Modified();
	}
}

void CSelectedInfos::SetRemarkIndex( int iRemarkIndex )
{
	if( m_iRemarkIndex != iRemarkIndex )
	{
		m_iRemarkIndex = iRemarkIndex;
		m_pOwner->Modified();
	}
}

void CSelectedInfos::SetRowIndex( int iRowIndex )
{
	if( m_iRowIndex != iRowIndex )
	{
		m_iRowIndex = iRowIndex;
		m_pOwner->Modified();
	}
}

#define CSELECTEDINFOS_VERSION	4
// Version 4: 2019-11-20: 'm_dCoolingDT' and 'm_dHeatingDT' variables added.
// Version 3: 2018-06-15: 'm_dDT' and 'm_eApplicationType' variables added.
void CSelectedInfos::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CSELECTEDINFOS_VERSION;
	WriteData<>( outf, Version );

	WriteString( outf, (LPCTSTR)m_strReference1 );
	WriteString( outf, (LPCTSTR)m_strReference2 );
	WriteData<>( outf, m_iQuantity );
	WriteData<>( outf, m_dPrice );
	WriteString( outf, (LPCTSTR)m_strRemark );
	WriteData<>( outf, m_iRowIndex );
	m_WC.Write( outf );

	// Version 3.
	WriteData<>( outf, m_dDT );
	WriteData<>( outf, m_eApplicationType );

	// Version 4.
	WriteData<>( outf, m_dCoolingDT );
	WriteData<>( outf, m_dHeatingDT );
}

bool CSelectedInfos::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CSELECTEDINFOS_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CSELECTEDINFOS_VERSION )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strReference1 ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strReference2 ) )
	{
		return false;
	}

	inpf.read( (char *)&m_iQuantity, sizeof( m_iQuantity ) );
	inpf.read( (char *)&m_dPrice, sizeof( m_dPrice ) );

	if( false == ReadString( inpf, m_strRemark ) )
	{
		return false;
	}

	inpf.read( (char *)&m_iRowIndex, sizeof( m_iRowIndex ) );

	if( Version != 1 )
	{
		m_WC.Read( inpf );
	}

	if( Version < 3 )
	{
		return true;
	}

	inpf.read( (char *)&m_dDT, sizeof( m_dDT ) );
	inpf.read( (char *)&m_eApplicationType, sizeof( m_eApplicationType ) );

	// HYS-1622: Before this card, in some circumstances, m_WC.b_IsForChangeOver was set to true when we are not in changeOver.
	// For these old projects we have to set m_WC.b_IsForChangeOver with the correct value.
	if( ChangeOver != m_eApplicationType && true == m_WC.GetIsForChangeOver() )
	{
		m_WC.SetIsForChangeOver( false );
	}

	if( Version < 4 )
	{
		return true;
	}

	inpf.read( (char *)&m_dCoolingDT, sizeof( m_dCoolingDT ) );
	inpf.read( (char *)&m_dHeatingDT, sizeof( m_dHeatingDT ) );

	return true;
}

void CSelectedInfos::Copy( CSelectedInfos *pSelectedInfos )
{
	pSelectedInfos->SetReference( eRef1, m_strReference1 );
	pSelectedInfos->SetReference( eRef2, m_strReference2 );
	pSelectedInfos->SetQuantity( m_iQuantity );
	pSelectedInfos->SetPrice( m_dPrice );
	pSelectedInfos->SetRemark( m_strRemark );
	pSelectedInfos->SetRowIndex( m_iRowIndex );
	*pSelectedInfos->GetpWCData() = m_WC;
	pSelectedInfos->SetModifiedObjIDPtr( GetModifiedObjIDPtr() );
	pSelectedInfos->SetDT( m_dDT );
	pSelectedInfos->SetApplicationType( m_eApplicationType );
	pSelectedInfos->SetCoolingDT( m_dCoolingDT );
	pSelectedInfos->SetHeatingDT( m_dHeatingDT );
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SelProd
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SelProd )

CDS_SelProd::CDS_SelProd( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
	m_dQ = 0.0;
	m_FlowDef = efdFlow;
	m_dPower = 0.0;
	m_dDT = 0.0;
	m_bSelectedAsAPackage = false;
	m_bDirSel = false;
	m_pSelectedInfos = new CSelectedInfos( this );
	ASSERT( NULL != m_pSelectedInfos );
	m_pSelPipe = new CSelectPipe( NULL );
	ASSERT( NULL != m_pSelPipe );
	m_HMIDptr = _NULL_IDPTR;
	m_strTypeID = _T("");
	m_strFamilyID = _T("");
	m_strMaterialID = _T("");
	m_strConnectID = _T("");
	m_strVersionID = _T("");
	m_strPNID = _T("");
	m_strPipeSeriesID = _T("");
	m_strPipeID = _T("");
	m_eProductSubCategory = ProductSubCategory::PSC_Undefined;
}

CDS_SelProd::~CDS_SelProd()
{
	if( NULL != m_pSelectedInfos )
	{
		delete m_pSelectedInfos;
	}

	if( NULL != m_pSelPipe )
	{
		delete m_pSelPipe;
	}

	m_pSelectedInfos = NULL;
	m_pSelPipe = NULL;
}

IDPTR CDS_SelProd::GetHMIDptr()
{
	return GetMbrIDPtr( m_HMIDptr, reinterpret_cast<CTADatabase *>( TASApp.GetpTADS() ) );
}

IDPTR CDS_SelProd::GetMbrIDPtr( IDPTR &IDPtr, CTADatabase *pDB )
{
	if( _T('\0') != *IDPtr.ID )
	{
		if( NULL == IDPtr.MP )
		{
			if( NULL == pDB )
			{
				IDPtr.DB = TASApp.GetpTADB();
			}
			else
			{
				IDPtr.DB = pDB;
			}

			Extend( &IDPtr );
		}
	}
	else
	{
		return _NULL_IDPTR;
	}

	return IDPtr;
}

void CDS_SelProd::SetMbreIDPtr( IDPTR &TrgIDPtr, const IDPTR &IDPtr,  CTADatabase *pDB )
{
	if( TrgIDPtr != IDPtr )
	{
		TrgIDPtr = IDPtr;

		if( _T('\0') != *TrgIDPtr.ID && NULL == TrgIDPtr.MP )
		{
			if( NULL == pDB )
			{
				TrgIDPtr.DB = TASApp.GetpTADB();
			}
			else
			{
				TrgIDPtr.DB = pDB;
			}

			Extend( &TrgIDPtr );
		}

		Modified();
	}
}

void CDS_SelProd::SetHMIDptr( const IDPTR &idptr )
{
	SetMbreIDPtr( m_HMIDptr, idptr, reinterpret_cast<CTADatabase *>( TASApp.GetpTADS() ) );
}

void CDS_SelProd::SetTypeID( CString strTypeID )
{
	if( 0 != m_strTypeID.Compare( strTypeID ) )
	{
		m_strTypeID = strTypeID;
		Modified();
	}
}

void CDS_SelProd::SetFamilyID( CString strFamilyID )
{
	if( 0 != m_strFamilyID.Compare( strFamilyID ) )
	{
		m_strFamilyID = strFamilyID;
		Modified();
	}
}

void CDS_SelProd::SetMaterialID( CString strMaterialID )
{
	if( 0 != m_strMaterialID.Compare( strMaterialID ) )
	{
		m_strMaterialID = strMaterialID;
		Modified();
	}
}

void CDS_SelProd::SetConnectID( CString strConnectID )
{
	if( 0 != m_strConnectID.Compare( strConnectID ) )
	{
		m_strConnectID = strConnectID;
		Modified();
	}
}

void CDS_SelProd::SetVersionID( CString strVersionID )
{
	if( 0 != m_strVersionID.Compare( strVersionID ) )
	{
		m_strVersionID = strVersionID;
		Modified();
	}
}

void CDS_SelProd::SetPNID( CString strPNID )
{
	if( 0 != m_strPNID.Compare( strPNID ) )
	{
		m_strPNID = strPNID;
		Modified();
	}
}

void CDS_SelProd::SetPipeSeriesID( CString strPipeSeriesID )
{
	if( 0 != m_strPipeSeriesID.Compare( strPipeSeriesID ) )
	{
		m_strPipeSeriesID = strPipeSeriesID;
		Modified();
	}
}

void CDS_SelProd::SetPipeID( CString strPipeID )
{
	if( 0 != m_strPipeID.Compare( strPipeID ) )
	{
		m_strPipeID = strPipeID;
		Modified();
	}
}

void CDS_SelProd::SetProductSubCategory( ProductSubCategory eProductSubCategory )
{
	if( eProductSubCategory != m_eProductSubCategory )
	{
		m_eProductSubCategory = eProductSubCategory;
		Modified();
	}
}

void CDS_SelProd::Copy( CData *pclDestination )
{
	CDS_SelProd *pclDestinationSelProd = dynamic_cast<CDS_SelProd *>( pclDestination );
	ASSERT(  NULL != pclDestinationSelProd );

	if( NULL != pclDestinationSelProd )
	{
		CData::Copy( pclDestination );
		pclDestinationSelProd->SetSelectedAsAPackage( IsSelectedAsAPackage() );
		pclDestinationSelProd->SetFromDirSel( IsFromDirSel() );
		pclDestinationSelProd->SetQ( GetQ() );
		pclDestinationSelProd->SetFlowDef( GetFlowDef() );
		pclDestinationSelProd->SetPower( GetPower() );
		pclDestinationSelProd->SetDT( GetDT() );
		pclDestinationSelProd->SetTypeID( GetTypeID() );
		pclDestinationSelProd->SetFamilyID( GetFamilyID() );
		pclDestinationSelProd->SetMaterialID( GetMaterialID() );
		pclDestinationSelProd->SetConnectID( GetConnectID() );
		pclDestinationSelProd->SetVersionID( GetVersionID() );
		pclDestinationSelProd->SetPNID( GetPNID() );
		pclDestinationSelProd->SetPipeSeriesID( GetPipeSeriesID() );
		pclDestinationSelProd->SetPipeID( GetPipeID() );
		pclDestinationSelProd->SetHMIDptr( GetHMIDptr() );
		pclDestinationSelProd->SetProductSubCategory( GetProductSubCategory() );
		m_pSelectedInfos->Copy( pclDestinationSelProd->GetpSelectedInfos() );
		m_pSelPipe->Copy( pclDestinationSelProd->GetpSelPipe() );
	}
}

void CDS_SelProd::OnDatabaseDestroy()
{
	CData::OnDatabaseDestroy();
}

#define CDS_SELPROD_VERSION	4
// Version 4: 2017-06-01: deleted of the 'SelProdType' enum and replace by 'ProductSubCategory' in DataBObj.h
void CDS_SelProd::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SELPROD_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CData::Write( outf );

	// Info.
	WriteData<>( outf, m_dQ );
	WriteData<>( outf, m_FlowDef );
	WriteData<>( outf, m_dPower );
	WriteData<>( outf, m_dDT );
	WriteData<>( outf, m_bSelectedAsAPackage );
	WriteData<>( outf, m_bDirSel );

	WriteString( outf, (LPCTSTR)m_strTypeID );
	WriteString( outf, (LPCTSTR)m_strFamilyID );
	WriteString( outf, (LPCTSTR)m_strMaterialID );
	WriteString( outf, (LPCTSTR)m_strConnectID );
	WriteString( outf, (LPCTSTR)m_strVersionID );
	WriteString( outf, (LPCTSTR)m_strPNID );
	WriteString( outf, (LPCTSTR)m_strPipeSeriesID );
	WriteString( outf, (LPCTSTR)m_strPipeID );
	WriteString( outf, (LPCTSTR)m_HMIDptr.ID );
	m_pSelectedInfos->Write( outf );
	m_pSelPipe->Write( outf );

	// Version 3: new variable to help to check type of inherited class.
	WriteData<>( outf, m_eProductSubCategory );
}

bool CDS_SelProd::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_SELPROD_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SELPROD_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Info.
	inpf.read( (char *)&m_dQ, sizeof( m_dQ ) );

	// Power, DT and flow definition added in version 2
	if( Version > 1 )
	{
		inpf.read( (char *)&m_FlowDef, sizeof( m_FlowDef ) );
		inpf.read( (char *)&m_dPower, sizeof( m_dPower ) );
		inpf.read( (char *)&m_dDT, sizeof( m_dDT ) );
		inpf.read( (char *)&m_bSelectedAsAPackage, sizeof( m_bSelectedAsAPackage ) );
	}

	inpf.read( (char *)&m_bDirSel, sizeof( m_bDirSel ) );

	m_strTypeID = _T("");
	m_strFamilyID = _T("");
	m_strMaterialID = _T("");
	m_strConnectID = _T("");
	m_strVersionID = _T("");
	m_strPNID = _T("");
	m_strPipeSeriesID = _T("");
	m_strPipeID = _T("");
	m_HMIDptr = _NULL_IDPTR;

	if( false == ReadString( inpf, m_strTypeID ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strFamilyID ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strMaterialID ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strConnectID ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strVersionID ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strPNID ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strPipeSeriesID ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strPipeID ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_HMIDptr.ID, sizeof( m_HMIDptr.ID ) ) )
	{
		return false;
	}

	m_pSelectedInfos->Read( inpf );
	m_pSelPipe->Read( inpf );

	if( Version < 3 )
	{
		return true;
	}

	// Version 3: new variable to help to check type of inherited class.
	int iEnum;
	inpf.read( (char *)&iEnum, sizeof( iEnum ) );

	if( Version < 4 )
	{
		// Need to match old enum definition (CDS_SelProd::SelProdType) by the new one (ProductSubCategory defines in DataBObj.h).
		std::map<int, ProductSubCategory> mapConvert;
		mapConvert[Obsolete_eSPT_BCv] = PSC_BC_BalAndCtrlValve;
		mapConvert[Obsolete_eSPT_Bv] = PSC_BC_RegulatingValve;
		mapConvert[Obsolete_eSPT_Cv] = PSC_BC_ControlValve;
		mapConvert[Obsolete_eSPT_DpC] = PSC_BC_DpController;
		mapConvert[Obsolete_eSPT_PICv] = PSC_BC_PressureIndepCtrlValve;
		mapConvert[Obsolete_eSPT_Trv] = PSC_TC_ThermostaticValve;
		mapConvert[Obsolete_eSPT_AirVent] = PSC_PM_AirVent;
		mapConvert[Obsolete_eSPT_Separator] = PSC_PM_Separator;
		mapConvert[Obsolete_eSPT_DpCBCV] = PSC_BC_CombinedDpCBalCtrlValve;
		mapConvert[Obsolete_eSPT_Sv] = PSC_ESC_ShutoffValve;
		mapConvert[Obsolete_eSPT_None] = PSC_Undefined;

		if( 0 == mapConvert.count( iEnum ) )
		{
			m_eProductSubCategory = ProductSubCategory::PSC_Undefined;
		}
		else
		{
			m_eProductSubCategory = mapConvert[iEnum];
		}
	}
	else
	{
		m_eProductSubCategory = ( ProductSubCategory )iEnum;
	}

	return true;
}

bool CDS_SelProd::IsSelectedAsAPackage( bool fVerifyPackage )
{
	return m_bSelectedAsAPackage;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CAccessoryList
//
///////////////////////////////////////////////////////////////////////////////////

void CAccessoryList::Clear( AccessoryType eAccessoryType )
{
	if( false == m_mmapAccessories.empty() )
	{
		switch( eAccessoryType )
		{
			case _AT_Accessory:
			case _AT_Adapter:
			case _AT_SetAccessory:
			{
				mmapTypeAccessoryIter mapIter = m_mmapAccessories.begin();

				while( mapIter != m_mmapAccessories.end() )
				{
					if( eAccessoryType == mapIter->first )
					{
						mmapTypeAccessoryIter mapNextIter = mapIter;
						++mapNextIter;
						m_mmapAccessories.erase( mapIter );
						mapIter = mapNextIter;
					}
					else
					{
						++mapIter;
					}
				}
			}
			break;

			case _AT_Undefined:
				m_mmapAccessories.clear();
				break;
		}
	}
}

void CAccessoryList::Add( const IDPTR &idptr, AccessoryType eAccessoryType, CDB_RuledTableBase *pclRuledTable, bool bCheckType )
{
	// Try first to cast in CDB_Accessory for verification.
	CDB_Product *pclAccessory = dynamic_cast<CDB_Product *>( idptr.MP );

	if( ( NULL == pclAccessory ) || ( false == pclAccessory->IsAnAccessory() ) )
	{
		return;
	}

	// Check if we must determine type
	// For old CDS_SSel version without 'CAccessoryList' member variable (see .h for remark).
	if( true == bCheckType )
	{
		eAccessoryType = _AT_Accessory;

		if( 0 == wcscmp( pclAccessory->GetTypeIDPtr().ID, _T("ADAPTYP_CV") ) )
		{
			eAccessoryType = _AT_Adapter;
		}
	}

	AccessoryItem rAccessoryItem;
	rAccessoryItem.IDPtr = idptr;
	rAccessoryItem.eAccessoryType = eAccessoryType;

	if( NULL != pclRuledTable )
	{
		rAccessoryItem.fByPair = pclRuledTable->IsByPair( idptr.ID );
		rAccessoryItem.fDistributed = pclRuledTable->IsDistributed( idptr.ID );
	}

	m_mmapAccessories.insert( std::pair<AccessoryType, AccessoryItem>( eAccessoryType, rAccessoryItem ) );
}

void CAccessoryList::Add( AccessoryType eAccessoryType, AccessoryItem *prAccessoryItem )
{
	if( NULL == prAccessoryItem )
	{
		return;
	}

	AccessoryItem rAccessoryItem;
	rAccessoryItem.IDPtr = prAccessoryItem->IDPtr;
	rAccessoryItem.eAccessoryType = prAccessoryItem->eAccessoryType;
	rAccessoryItem.fByPair = prAccessoryItem->fByPair;
	rAccessoryItem.fDistributed = prAccessoryItem->fDistributed;
    
	// HYS-987: copy the edited quantity value.
	if( -1 != prAccessoryItem->lEditedQty )
	{
		rAccessoryItem.lEditedQty = prAccessoryItem->lEditedQty;
	}
	
	m_mmapAccessories.insert( std::pair<AccessoryType, AccessoryItem>( eAccessoryType, rAccessoryItem ) );
}

int CAccessoryList::GetCount( AccessoryType eAccessoryType )
{
	int iCount = 0;

	if( m_mmapAccessories.size() > 0 )
	{
		switch( eAccessoryType )
		{
			case _AT_Accessory:
			case _AT_Adapter:
			case _AT_SetAccessory:

				for( mmapTypeAccessoryIter mapIter = m_mmapAccessories.begin(); mapIter != m_mmapAccessories.end(); ++mapIter )
				{
					if( eAccessoryType == mapIter->first )
					{
						iCount++;
					}
				}

				break;

			case _AT_Undefined:
				iCount = m_mmapAccessories.size();
				break;
		}
	}

	return iCount;
}

CAccessoryList::AccessoryItem CAccessoryList::GetFirst( AccessoryType eAccessoryType )
{
	AccessoryItem rAccessory;
	rAccessory.IDPtr = _NULL_IDPTR;
	rAccessory.fByPair = false;
	rAccessory.fDistributed = false;
	rAccessory.eAccessoryType = _AT_Undefined;

	if( m_mmapAccessories.size() > 0 )
	{
		m_mmapIter = m_mmapAccessories.end();

		switch( eAccessoryType )
		{
			case _AT_Accessory:
			case _AT_Adapter:
			case _AT_SetAccessory:

				for( m_mmapIter = m_mmapAccessories.begin(); m_mmapIter != m_mmapAccessories.end(); ++m_mmapIter )
				{
					if( eAccessoryType == m_mmapIter->first )
					{
						break;
					}
				}

				break;

			case _AT_Undefined:
				m_mmapIter = m_mmapAccessories.begin();
				break;
		}

		if( m_mmapIter != m_mmapAccessories.end() )
		{
			rAccessory.IDPtr = m_mmapIter->second.IDPtr;
			rAccessory.fByPair = m_mmapIter->second.fByPair;
			rAccessory.fDistributed = m_mmapIter->second.fDistributed;
			rAccessory.eAccessoryType = m_mmapIter->second.eAccessoryType;
			
			// HYS-987: Copy lEditedQty.
			rAccessory.lEditedQty = m_mmapIter->second.lEditedQty;

			if( _T('\0') != *rAccessory.IDPtr.ID )
			{
				if( NULL == rAccessory.IDPtr.MP )
				{
					rAccessory.IDPtr.DB = TASApp.GetpTADB();
					Extend( &rAccessory.IDPtr );
					m_mmapIter->second.IDPtr = rAccessory.IDPtr;
				}
			}
			else
			{
				rAccessory.IDPtr = _NULL_IDPTR;
			}
		}
	}

	return rAccessory;
}

CAccessoryList::AccessoryItem CAccessoryList::GetNext( AccessoryType eAccessoryType )
{
	AccessoryItem rAccessory;
	rAccessory.IDPtr = _NULL_IDPTR;
	rAccessory.fByPair = false;
	rAccessory.fDistributed = false;
	rAccessory.eAccessoryType = _AT_Undefined;

	if( m_mmapAccessories.size() > 0 && m_mmapIter != m_mmapAccessories.end() )
	{
		// Try to go next accessory.
		++m_mmapIter;

		// If next accessory exist...
		if( m_mmapIter != m_mmapAccessories.end() )
		{
			switch( eAccessoryType )
			{
				case _AT_Accessory:
				case _AT_Adapter:
				case _AT_SetAccessory:
					
					for( ; m_mmapIter != m_mmapAccessories.end(); ++m_mmapIter )
					{
						if( eAccessoryType == m_mmapIter->first )
						{
							break;
						}
					}

					break;

				case _AT_Undefined:
					// Do nothing.
					break;
			}
		}

		if( m_mmapIter != m_mmapAccessories.end() )
		{
			rAccessory.IDPtr = m_mmapIter->second.IDPtr;
			rAccessory.fByPair = m_mmapIter->second.fByPair;
			rAccessory.fDistributed = m_mmapIter->second.fDistributed;
			rAccessory.eAccessoryType = m_mmapIter->second.eAccessoryType;
			
			// HYS-987: Copy lEditedQty.
			rAccessory.lEditedQty = m_mmapIter->second.lEditedQty;

			if( _T('\0') != *rAccessory.IDPtr.ID )
			{
				if( NULL == rAccessory.IDPtr.MP )
				{
					rAccessory.IDPtr.DB = TASApp.GetpTADB();
					Extend( &rAccessory.IDPtr );
					m_mmapIter->second.IDPtr = rAccessory.IDPtr;
				}
			}
			else
			{
				rAccessory.IDPtr = _NULL_IDPTR;
			}
		}
	}

	return rAccessory;
}

CAccessoryList::AccessoryItem CAccessoryList::GetItem( int iIndex )
{
	AccessoryItem rAccessory;
	rAccessory.IDPtr = _NULL_IDPTR;
	rAccessory.fByPair = false;
	rAccessory.fDistributed = false;
	rAccessory.eAccessoryType = _AT_Undefined;

	if( 0 == (int)m_mmapAccessories.size() || iIndex < 0 || iIndex >= (int)m_mmapAccessories.size() )
	{
		return rAccessory;
	}
	
	mmapTypeAccessoryIter iter = m_mmapAccessories.begin();

	for( int i = 0; i < iIndex; i++ )
	{
		iter++;
	}

	if( iter != m_mmapAccessories.end() )
	{
		rAccessory.IDPtr = iter->second.IDPtr;
		rAccessory.fByPair = iter->second.fByPair;
		rAccessory.fDistributed = iter->second.fDistributed;
		rAccessory.eAccessoryType = iter->second.eAccessoryType;
			
		// HYS-987: Copy lEditedQty.
		rAccessory.lEditedQty = iter->second.lEditedQty;

		if( _T('\0') != *rAccessory.IDPtr.ID )
		{
			if( NULL == rAccessory.IDPtr.MP )
			{
				rAccessory.IDPtr.DB = TASApp.GetpTADB();
				Extend( &rAccessory.IDPtr );
				iter->second.IDPtr = rAccessory.IDPtr;
			}
		}
		else
		{
			rAccessory.IDPtr = _NULL_IDPTR;
		}
	}

	return rAccessory;
}

CAccessoryList::AccessoryType CAccessoryList::GetAccessoryType( IDPTR IDPtr )
{
	AccessoryType eReturn = _AT_Undefined;

	if( m_mmapAccessories.size() > 0 )
	{
		for( mmapTypeAccessoryIter mapIter = m_mmapAccessories.begin(); mapIter != m_mmapAccessories.end(); ++mapIter )
		{
			if( mapIter->second.IDPtr == IDPtr )
			{
				eReturn = mapIter->first;
				break;
			}
		}
	}

	return eReturn;
}

void CAccessoryList::CopyTo( CAccessoryList *pclAccessoryList )
{
	if( NULL != pclAccessoryList && m_mmapAccessories.size() > 0 )
	{
		for( mmapTypeAccessoryIter mapIter = m_mmapAccessories.begin(); mapIter != m_mmapAccessories.end(); ++mapIter )
		{
			pclAccessoryList->Add( mapIter->first, &mapIter->second );
		}
	}
}

#define CACCESSORYLIST_VERSION	4
// Version 4: HYS-987 add lEditedQty 
// Version 3: add' fDistributed' and IDPtr on the ruled table base in which belongs the accessory.
// Version 2: add 'fByPair'.
// Version 1: doesn't exist because no version at start.
void CAccessoryList::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CACCESSORYLIST_VERSION;
	WriteData<>( outf, Version );

	int i = m_mmapAccessories.size();
	WriteData<>( outf, i );

	for( mmapTypeAccessoryIter mapIter = m_mmapAccessories.begin(); mapIter != m_mmapAccessories.end(); ++mapIter )
	{
		// Write type.
		WriteData<>( outf, mapIter->second.eAccessoryType );

		// Write object.
		WriteString( outf, (LPCTSTR)mapIter->second.IDPtr.ID );

		// Version 2.
		WriteData<>( outf, mapIter->second.fByPair );

		// Version 3.
		WriteData<>( outf, mapIter->second.fDistributed );
		
		// Version 4: HYS-987.
		WriteData<>( outf, mapIter->second.lEditedQty );
	}
}

// Because at start there was no version, we have incremented the version number of CDS_SSel.
// And it is this class that tells to 'CAccessoryList' if it must read with version or not.
bool CAccessoryList::Read( INPSTREAM inpf, bool fWithVersion )
{
	Clear();

	BYTE Version = 1;

	if( true == fWithVersion )
	{
		inpf.read( (char *)&Version, sizeof( Version ) );

		if( Version < 1 || Version > CACCESSORYLIST_VERSION )
		{
			return false;
		}
	}

	int i = 0;
	inpf.read( (char *)&i, sizeof( int ) );

	for( ; i > 0; i-- )
	{
		AccessoryItem rAccessoryItem;
		rAccessoryItem.IDPtr = _NULL_IDPTR;
		rAccessoryItem.fByPair = false;
		rAccessoryItem.fDistributed = false;
		rAccessoryItem.eAccessoryType = _AT_Undefined;

		// Read type.
		inpf.read( (char *)&rAccessoryItem.eAccessoryType, sizeof( rAccessoryItem.eAccessoryType ) );

		// Read object.
		if( false == ReadString( inpf, rAccessoryItem.IDPtr.ID, sizeof( rAccessoryItem.IDPtr.ID ) ) )
		{
			return false;
		}

		rAccessoryItem.IDPtr.DB = TASApp.GetpTADB();
		Extend( &rAccessoryItem.IDPtr );

		if( Version > 1 )
		{
			inpf.read( (char *)&rAccessoryItem.fByPair, sizeof( rAccessoryItem.fByPair ) );

			if( Version > 2 )
			{
				inpf.read( (char *)&rAccessoryItem.fDistributed, sizeof( rAccessoryItem.fDistributed ) );
			}
		}

		// HYS-987.
		if( Version > 3 )
		{
			inpf.read( (char *)&rAccessoryItem.lEditedQty, sizeof( rAccessoryItem.lEditedQty ) );
		}

		m_mmapAccessories.insert( std::pair<AccessoryType, AccessoryItem>( rAccessoryItem.eAccessoryType, rAccessoryItem ) );
	}

	return true;
}

void CAccessoryList::SetEditedQty( AccessoryItem AccItem, long lQty )
{
	std::multimap<CAccessoryList::AccessoryType, CAccessoryList::AccessoryItem>::iterator it;

	for( it = m_mmapAccessories.begin(); it != m_mmapAccessories.end(); ++it )
	{
		if( AccItem.IDPtr.IDMatch( it->second.IDPtr.ID) )
		{
			it->second.lEditedQty = lQty;
			break;
		}
	}
}

bool CAccessoryList::Remove( AccessoryItem AccessoryItem )
{
	bool breturn = false;
	std::multimap<CAccessoryList::AccessoryType, CAccessoryList::AccessoryItem>::iterator it;

	for( it = m_mmapAccessories.begin(); it != m_mmapAccessories.end(); ++it )
	{
		if( AccessoryItem.IDPtr.IDMatch( it->second.IDPtr.ID ) )
		{
			// if remove is used from loop with iterator
			std::multimap<CAccessoryList::AccessoryType, CAccessoryList::AccessoryItem>::iterator nextiter = m_mmapIter;
			nextiter++;
			m_mmapAccessories.erase( it );

			if( m_mmapAccessories.size() > 0 )
			{
				m_mmapIter = nextiter;
			}
			else
			{
				m_mmapIter = m_mmapAccessories.end();
			}

			breturn = true;
			break;
		}
	}
	
	return breturn;
}

bool CAccessoryList::FindItem( IDPTR IdptrToFind )
{
	bool bFound = false;
	std::multimap<CAccessoryList::AccessoryType, CAccessoryList::AccessoryItem>::iterator it;

	for( it = m_mmapAccessories.begin(); it != m_mmapAccessories.end(); ++it )
	{
		if( IdptrToFind.IDMatch( it->second.IDPtr.ID ) )
		{
			bFound = true;
			break;
		}
	}
	
	return bFound;
}

CAccessoryList::AccessoryItem CAccessoryList::GetGlobalPostion()
{
	if( m_mmapIter != m_mmapAccessories.end() )
	{
		return m_mmapIter->second;
	}
	else
	{
		return AccessoryItem();
	}
}


///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SSel
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SSel )

CDS_SSel::CDS_SSel( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SelProd( pDataBase, ID )
{
	m_dDpKv = 0.0;
	m_dOpening = 0.0;
	m_ProductIDPtr = _NULL_IDPTR;
}

void CDS_SSel::Copy( CData *pclDestination )
{
	CDS_SSel *pclDestinationSSel = dynamic_cast<CDS_SSel *>( pclDestination );
	ASSERT( pclDestinationSSel );

	if( NULL != pclDestinationSSel )
	{
		CDS_SelProd::Copy( static_cast<CDS_SSel *>( pclDestinationSSel ) );

		pclDestinationSSel->SetDp( m_dDpKv );
		pclDestinationSSel->SetOpening( m_dOpening );
		pclDestinationSSel->SetProductIDPtr( GetProductIDPtr() );

		CAccessoryList *pclAccessoryList = pclDestinationSSel->GetAccessoryList();

		if( NULL != pclAccessoryList )
		{
			pclAccessoryList->Clear();
			m_clAccessoryList.CopyTo( pclAccessoryList );
		}
	}
}

int CDS_SSel::CompareSelectionTo( CData *pclSelectionCompareWith, int iKey )
{
	if( NULL == pclSelectionCompareWith )
	{
		return 0;
	}

	CDS_SSel *pclSelProdCompareWith = dynamic_cast<CDS_SSel *>( pclSelectionCompareWith );

	if( NULL == pclSelProdCompareWith )
	{
		return CDS_SelProd::CompareSelectionTo( pclSelectionCompareWith, iKey );
	}

	CDB_TAProduct *pclTAProductToCompare = GetProductAs<CDB_TAProduct>();
	CDB_TAProduct *pclTAProductCompareWidth = pclSelProdCompareWith->GetProductAs<CDB_TAProduct>();

	int iReturn = 0;

	switch( iKey )
	{
		case PageField_enum::epfBVINFOPRODUCTNAME:

			if( NULL != pclTAProductToCompare && NULL != pclTAProductCompareWidth )
			{
				iReturn = StringCompare( pclTAProductToCompare->GetName(), pclTAProductCompareWidth->GetName() );
			}

			break;

		case PageField_enum::epfBVINFOPRODUCTSIZE:

			if( NULL != pclTAProductToCompare && NULL != pclTAProductCompareWidth )
			{
				int iSizeToCompare = pclTAProductToCompare->GetSizeKey();
				int iSizeCompareWith = pclTAProductCompareWidth->GetSizeKey();

				if( -1 == iSizeToCompare || -1 == iSizeCompareWith )
				{
					iReturn = 0;
				}
				else if( iSizeToCompare < iSizeCompareWith )
				{
					iReturn = -1;
				}
				else if( iSizeToCompare > iSizeCompareWith )
				{
					iReturn = 1;
				}
			}

			break;

		case PageField_enum::epfARTICLE:

			if( NULL != pclTAProductToCompare && NULL != pclTAProductCompareWidth )
			{
				if( false == TASApp.IsTAArtNumberHidden() )
				{
					iReturn = StringCompare( pclTAProductToCompare->GetArtNum(), pclTAProductCompareWidth->GetArtNum() );
				}
				else
				{
					CString strLocArtNum1 = LocArtNumTab.GetLocalArticleNumber( pclTAProductToCompare->GetArtNum() );
					CString strLocArtNum2 = LocArtNumTab.GetLocalArticleNumber( pclTAProductCompareWidth->GetArtNum() );
					iReturn = StringCompare( strLocArtNum1, strLocArtNum2 );
				}
			}

			break;

		default:
			iReturn = CData::CompareSelectionTo( pclSelectionCompareWith, iKey );
	}

	return iReturn;
}

#define CDS_SSEL_VERSION	4
// 3: accessory container class added.
// 4: accessory container class version added.
void CDS_SSel::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SSEL_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CDS_SelProd::Write( outf );

	// Info.
	WriteData<>( outf, m_dDpKv );

	m_clAccessoryList.Write( outf );

	WriteString( outf, (LPCTSTR)m_ProductIDPtr.ID );
	WriteData<>( outf, m_dOpening );
}

bool CDS_SSel::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_SSEL_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SSEL_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDS_SelProd::Read( inpf ) )
	{
		return false;
	}

	// Info.
	inpf.read( (char *)&m_dDpKv, sizeof( m_dDpKv ) );

	if( Version < 3 )
	{
		m_clAccessoryList.Clear();
		int i = 0;
		inpf.read( (char *)&i, sizeof( int ) );

		for( ; i > 0; i-- )
		{
			IDPTR idptr = _NULL_IDPTR;
			idptr.DB = TASApp.GetpTADB();

			if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
			{
				return false;
			}

			Extend( &idptr );
			m_clAccessoryList.Add( idptr, CAccessoryList::_AT_Undefined, NULL, true );
		}
	}
	else
	{
		// 3: accessory container class added BUT no version.
		// >3: version has been added in the accessory container class.
		m_clAccessoryList.Read( inpf, ( Version > 3 ) ? true : false );
	}

	if( false == ReadString( inpf, m_ProductIDPtr.ID, sizeof( m_ProductIDPtr.ID ) ) )
	{
		return false;
	}

	if( Version >= 2 )
	{
		inpf.read( (char *)&m_dOpening, sizeof( m_dOpening ) );
	}

	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SSelBv
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SSelBv )

CDS_SSelBv::CDS_SSelBv( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SSel( pDataBase, ID )
{
	SetProductSubCategory( ProductSubCategory::PSC_BC_RegulatingValve );
}

void CDS_SSelBv::Copy( CData *pclDestination )
{
	CDS_SSelBv *pclDestinationSSelBv = dynamic_cast<CDS_SSelBv *>( pclDestination );
	ASSERT( NULL != pclDestinationSSelBv );

	if( NULL != pclDestinationSSelBv )
	{
		CDS_SSel::Copy( pclDestinationSSelBv );
	}
}

#define CDS_SSELBV_VERSION	1
void CDS_SSelBv::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SSELBV_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CDS_SSel::Write( outf );

	// Infos.
}

bool CDS_SSelBv::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_SSELBV_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SSELBV_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDS_SSel::Read( inpf ) )
	{
		return false;
	}

	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SSelSv
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SSelSv )

CDS_SSelSv::CDS_SSelSv( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SSel( pDataBase, ID )
{
	m_eProductSubCategory = ProductSubCategory::PSC_ESC_ShutoffValve;
	m_ActrIDPtr = _NULL_IDPTR;
}

void CDS_SSelSv::Copy( CData *pclDestination )
{
	CDS_SSelSv *pclDestinationSSelSv = dynamic_cast<CDS_SSelSv *>( pclDestination );
	ASSERT( NULL != pclDestinationSSelSv );

	if( NULL != pclDestinationSSelSv )
	{
		CDS_SSel::Copy( pclDestinationSSelSv );

		pclDestinationSSelSv->SetActrIDPtr( GetActrIDPtr() );
		
		CAccessoryList *pclActuatorAccessoryList = pclDestinationSSelSv->GetActuatorAccessoryList();

		if( NULL != pclActuatorAccessoryList )
		{
			pclActuatorAccessoryList->Clear();
			m_clActuatorAccessoryList.CopyTo( pclActuatorAccessoryList );
		}

	}
}

#define CDS_SSELSV_VERSION	2
// Version 2: 2018-08-14: Actuators and its accessories are now existing in the DB.
void CDS_SSelSv::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SSELSV_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CDS_SSel::Write( outf );

	// Infos.
	WriteString( outf, (LPCTSTR)m_ActrIDPtr.ID );

	// Actuator accessories.
	m_clActuatorAccessoryList.Write( outf );
}

bool CDS_SSelSv::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_SSELSV_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SSELSV_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDS_SSel::Read( inpf ) )
	{
		return false;
	}

	if( Version < 2 )
	{
		return true;
	}

	// Version 2.
	if( false == ReadString( inpf, m_ActrIDPtr.ID, sizeof( m_ActrIDPtr.ID ) ) )
	{
		return false;
	}

	m_clActuatorAccessoryList.Read( inpf, true );

	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SSelDpC
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SSelDpC )

CDS_SSelDpC::CDS_SSelDpC( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SSel( pDataBase, ID )
{
	m_eDpStab = eDpStab::DpStabOnBranch;
	m_eDpCLoc = eDpCLoc::DpCLocUpStream;
	m_eMvLoc = eMvLoc::MvLocPrimary;
	m_clDpCAccessoryList.Clear();
	m_uiSchemeIndex = 0;
	m_dDpL = 0.0;				//Dp Load
	m_dKv = 0.0;
	m_dDpMax = 0.0;
	m_DpCIDPtr = _NULL_IDPTR;
	m_eProductSubCategory = ProductSubCategory::PSC_BC_DpController;
}

void CDS_SSelDpC::Copy( CData *pclDestination )
{
	CDS_SSelDpC *pclDestinationSSelDpC = dynamic_cast<CDS_SSelDpC *>( pclDestination );
	ASSERT( pclDestinationSSelDpC );

	if( NULL != pclDestinationSSelDpC )
	{
		CDS_SSel::Copy( static_cast<CDS_SSelDpC *>( pclDestinationSSelDpC ) );
		pclDestinationSSelDpC->SetDpL( m_dDpL );
		pclDestinationSSelDpC->SetKv( m_dKv );
		pclDestinationSSelDpC->SetDpMax( m_dDpMax );
		pclDestinationSSelDpC->SetDpStab( m_eDpStab );
		pclDestinationSSelDpC->SetDpCLoc( m_eDpCLoc );
		pclDestinationSSelDpC->SetMvLoc( m_eMvLoc );

		CAccessoryList *pclDpCAccessoryList = pclDestinationSSelDpC->GetDpCAccessoryList();

		if( NULL != pclDpCAccessoryList )
		{
			pclDpCAccessoryList->Clear();
			m_clDpCAccessoryList.CopyTo( pclDpCAccessoryList );
		}

		pclDestinationSSelDpC->SetDpCIDPtr( GetDpCIDPtr() );
	}
}

int CDS_SSelDpC::CompareSelectionTo( CData *pclSelectionCompareWith, int iKey )
{
	if( NULL == pclSelectionCompareWith )
	{
		return 0;
	}

	CDS_SSelDpC *pclSSelDpCCompareWith = dynamic_cast<CDS_SSelDpC *>( pclSelectionCompareWith );

	if( NULL == pclSSelDpCCompareWith )
	{
		return CDS_SSel::CompareSelectionTo( pclSelectionCompareWith, iKey );
	}

	CDB_TAProduct *pclTAProductToCompare = dynamic_cast<CDB_TAProduct *>( GetDpCIDPtr().MP );
	CDB_TAProduct *pclTAProductCompareWidth = dynamic_cast<CDB_TAProduct *>( pclSSelDpCCompareWith->GetDpCIDPtr().MP );

	int iReturn = 0;

	switch( iKey )
	{
		case PageField_enum::epfBVINFOPRODUCTNAME:

			if( NULL != pclTAProductToCompare && NULL != pclTAProductCompareWidth )
			{
				iReturn = StringCompare( pclTAProductToCompare->GetName(), pclTAProductCompareWidth->GetName() );
			}

			break;

		case PageField_enum::epfBVINFOPRODUCTSIZE:

			if( NULL != pclTAProductToCompare && NULL != pclTAProductCompareWidth )
			{
				int iSizeToCompare = pclTAProductToCompare->GetSizeKey();
				int iSizeCompareWith = pclTAProductCompareWidth->GetSizeKey();

				if( -1 == iSizeToCompare || -1 == iSizeCompareWith )
				{
					iReturn = 0;
				}
				else if( iSizeToCompare < iSizeCompareWith )
				{
					iReturn = -1;
				}
				else if( iSizeToCompare > iSizeCompareWith )
				{
					iReturn = 1;
				}
			}

			break;

		case PageField_enum::epfARTICLE:

			if( NULL != pclTAProductToCompare && NULL != pclTAProductCompareWidth )
			{
				if( false == TASApp.IsTAArtNumberHidden() )
				{
					iReturn = StringCompare( pclTAProductToCompare->GetArtNum(), pclTAProductCompareWidth->GetArtNum() );
				}
				else
				{
					CString strLocArtNum1 = LocArtNumTab.GetLocalArticleNumber( pclTAProductToCompare->GetArtNum() );
					CString strLocArtNum2 = LocArtNumTab.GetLocalArticleNumber( pclTAProductCompareWidth->GetArtNum() );
					iReturn = StringCompare( strLocArtNum1, strLocArtNum2 );
				}
			}

			break;

		default:
			iReturn = CDS_SSel::CompareSelectionTo( pclSelectionCompareWith, iKey );
	}

	return iReturn;
}

#define CDS_SSELDPC_VERSION	6
// Version 6: 'm_eDpCLoc' added.
// Version 5: Dp max added.
// Version 4: DpC accessory container class version added.
// Version 3: no more need of 'm_dDpCSetting' variable.
// Version 2: new version of DpC accessory container.
void CDS_SSelDpC::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SSELDPC_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CDS_SSel::Write( outf );

	// Info.
	WriteData<>( outf, m_eDpStab );
	WriteData<>( outf, m_eMvLoc );
	WriteData<>( outf, m_dDpL );
	WriteData<>( outf, m_dKv );

	// DpC accessories.
	// Version 2: new version of DpC accessory container.
	m_clDpCAccessoryList.Write( outf );

	WriteString( outf, (LPCTSTR)m_DpCIDPtr.ID );

	// Version 5: Dp max added.
	WriteData<>( outf, m_dDpMax );

	// Version 6: DpC location.
	WriteData<>( outf, m_eDpCLoc );
}

bool CDS_SSelDpC::Read( INPSTREAM  inpf )
{
	// Version.
	BYTE Version = CDS_SSELDPC_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SSELDPC_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDS_SSel::Read( inpf ) )
	{
		return false;
	}

	// Info.
	inpf.read( (char *)&m_eDpStab, sizeof( m_eDpStab ) );
	inpf.read( (char *)&m_eMvLoc, sizeof( m_eMvLoc ) );
	inpf.read( (char *)&m_dDpL, sizeof( m_dDpL ) );
	inpf.read( (char *)&m_dKv, sizeof( m_dKv ) );

	if( Version < 3 )
	{
		// Version 3: no more need of 'm_dDpCSetting' variable.
		double dValue;
		inpf.read( (char *)&dValue, sizeof( dValue ) );
	}

	if( Version < 2 )
	{
		m_clDpCAccessoryList.Clear();
		int i = 0;
		inpf.read( (char *)&i, sizeof( int ) );

		for( ; i > 0; i-- )
		{
			IDPTR idptr = _NULL_IDPTR;
			idptr.DB = TASApp.GetpTADB();

			if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
			{
				return false;
			}

			Extend( &idptr );
			m_clDpCAccessoryList.Add( idptr, CAccessoryList::_AT_Undefined, NULL, true );
		}
	}
	else
	{
		// 2: new version of DpC accessories.
		// >3: version has been added in the accessory container class.
		m_clDpCAccessoryList.Read( inpf, ( Version > 3 ) ? true : false );
	}

	if( false == ReadString( inpf, m_DpCIDPtr.ID, sizeof( m_DpCIDPtr.ID ) ) )
	{
		return false;
	}

	if( Version < 5 )
	{
		return true;
	}

	inpf.read( (char *)&m_dDpMax, sizeof( m_dDpMax ) );

	if( Version < 6 )
	{
		return true;
	}

	inpf.read( (char *)&m_eDpCLoc, sizeof( m_eDpCLoc ) );

	return true;
}

CString CDS_SSelDpC::GetSchemeName()
{
	CString SchemeName = GetDpStab() ? _T("1" ) : _T( "0");
	SchemeName += GetMvLoc() ? _T("1" ) : _T( "0");
	CDB_TAProduct *pDpC = dynamic_cast<CDB_TAProduct *>( GetDpCIDPtr().MP );
	CDB_TAProduct *pMV = dynamic_cast<CDB_TAProduct *>( GetProductIDPtr().MP );

	if( NULL != pMV )
	{
		SchemeName += pMV->GetProdPicID();
	}

	if( NULL != pDpC )
	{
		SchemeName += pDpC->GetProdPicID();
	}

	return SchemeName;
}

double CDS_SSelDpC::GetDpCSetting()
{
	double dSetting = 0.0;
	CDB_DpController *pDpC = dynamic_cast<CDB_DpController *>( GetDpCIDPtr().MP );

	if( NULL == pDpC )
	{
		return dSetting;
	}

	CDB_DpCCharacteristic *pDpCChar = pDpC->GetDpCCharacteristic();

	if( NULL == pDpCChar || -1.0 == pDpCChar->GetDplmin() || -1.0 == pDpCChar->GetDplmax() )
	{
		return dSetting;
	}

	double dRho = GetpSelectedInfos()->GetpWCData()->GetDens();
	double dDpToStab = GetDpToStab();

	if( dDpToStab >= pDpCChar->GetDplmin() && dDpToStab <= pDpCChar->GetDplmax() )
	{
		dSetting = pDpCChar->GetOpening( dDpToStab );
	}

	return dSetting;
}

double CDS_SSelDpC::GetDpMin()
{
	double dDpmin = 0.0;
	CDB_DpController *pDpC = dynamic_cast< CDB_DpController * >( GetDpCIDPtr().MP );

	if( NULL == pDpC )
	{
		return dDpmin;
	}

	CDB_DpCCharacteristic *pDpCChar = pDpC->GetDpCCharacteristic();

	if( NULL == pDpCChar )
	{
		return dDpmin;
	}

	double dRho = GetpSelectedInfos()->GetpWCData()->GetDens();
	pDpCChar->DpCSolve( GetQ(), &dDpmin, dRho );
	return dDpmin;
}

double CDS_SSelDpC::GetHMin()
{
	CDS_TechnicalParameter *pTechP = TASApp.GetpTADS()->GetpTechParams();
	double dRho = GetpSelectedInfos()->GetpWCData()->GetDens();
	double dNu = GetpSelectedInfos()->GetpWCData()->GetKinVisc();
	double dHMin = GetDpMin();
	double dDpToStab = GetDpToStab();
	dHMin += dDpToStab;

	if( eMvLoc::MvLocPrimary == m_eMvLoc )
	{
		double dDpMv = 0.0;
		CDB_TAProduct *pMV = GetProductAs<CDB_TAProduct>();

		if( NULL != pMV )
		{
			CDB_ValveCharacteristic *pMvChar = pMV->GetValveCharacteristic();

			if( NULL != pMvChar && true == pMvChar->HasKvCurve() )
			{
				// For fully open Mv (Nordic thing).
				if( 0 != pTechP->GetDpCHminFullyOpenMv() )
				{
					// Hmin calculated with Dp .
					dDpMv = pMvChar->GetDpFullOpening( GetQ(), dRho, dNu );
				}
				else
				{
					// Standard way.
					pMvChar->GetValveDp( GetQ(), &dDpMv, GetOpening(), dRho, dNu );
				}
			}
			else
			{
				CDB_FixOCharacteristic *pFOChar = dynamic_cast<CDB_FixOCharacteristic *>( pMV->GetValveCharDataPointer() );

				if( NULL != pFOChar )
				{
					dDpMv = CalcDp( GetQ(), pFOChar->GetKv(), dRho );
				}
			}
		}

		if( dDpMv > 0.0 )
		{
			dHMin += dDpMv;
		}
	}

	return dHMin;
}

double CDS_SSelDpC::GetDpToStab()
{
	double dDpToStab = 0.0;
	CDB_DpController *pDpC = dynamic_cast< CDB_DpController * >( GetDpCIDPtr().MP );

	if( NULL == pDpC )
	{
		return 0.0;
	}

	CDB_DpCCharacteristic *pDpCChar = pDpC->GetDpCCharacteristic();

	if( NULL == pDpCChar )
	{
		return 0.0;
	}

	double dRho = GetpSelectedInfos()->GetpWCData()->GetDens();
	double dNu = GetpSelectedInfos()->GetpWCData()->GetKinVisc();
	double dDpMv = 0.0;

	// Calculate the DpToStab.
	if( DpStabOnCV == GetDpStab() && GetKv() > 0.0 )
	{
		// Dp stab on control valve.
		dDpToStab = CalcDp( GetQ(), GetKv(), dRho );
	}
	else
	{
		// Dp stab on branch.
		dDpToStab =  GetDpL();
	}

	if( eMvLoc::MvLocSecondary == m_eMvLoc )
	{
		CDB_TAProduct *pMV =  GetProductAs<CDB_TAProduct>();

		if( NULL != pMV )
		{
			CDB_ValveCharacteristic *pMvChar = pMV->GetValveCharacteristic();

			if( NULL != pMvChar && true == pMvChar->HasKvCurve() )
			{
				pMvChar->GetValveDp( GetQ(), &dDpMv, GetOpening(), dRho, dNu );
			}
			else
			{
				CDB_FixOCharacteristic *pFOChar = dynamic_cast<CDB_FixOCharacteristic *>( pMV->GetValveCharDataPointer() );

				if( NULL != pFOChar )
				{
					dDpMv = CalcDp( GetQ(), pFOChar->GetKv(), dRho );
				}
			}
		}

		if( dDpMv > 0.0 )
		{
			dDpToStab += dDpMv;
		}
	}

	return dDpToStab;
}

double CDS_SSelDpC::GetAuthority()
{
	double dBeta = 0.0;
	CDB_DpController *pDpC = dynamic_cast< CDB_DpController * >( GetDpCIDPtr().MP );

	if( NULL == pDpC )
	{
		return dBeta;
	}

	CDB_DpCCharacteristic *pDpCChar = pDpC->GetDpCCharacteristic();

	if( NULL == pDpCChar )
	{
		return dBeta;
	}

	// Dp stab on branch or Kv unknown.
	if( eDpStab::DpStabOnCV != GetDpStab() || GetKv() <= 0.0 )
	{
		return dBeta;
	}

	double dBP = pDpCChar->GetProportionalBand( GetDpToStab() );
	double dRho = GetpSelectedInfos()->GetpWCData()->GetDens();
	double dDpCv = CalcDp( GetQ(), GetKv(), dRho );

	if( true == pDpCChar->IsProportionalBandAbsolute() )
	{
		dBeta = dDpCv / ( GetDpToStab() + dBP );
	}
	else
	{
		dBeta = dDpCv / ( ( 1.0 + dBP ) * ( GetDpToStab() ) );
	}

	return dBeta;
}

IDPTR CDS_SSelDpC::GetDpCMvPackageIDPtr()
{
	if( _T('\0') == *( m_DpCMvPackageIDPtr.ID ) )
	{
		m_DpCMvPackageIDPtr = _NULL_IDPTR;
		CTableSet *pDpCMvSetTab = dynamic_cast<CTableSet *>( TASApp.GetpTADB()->Get( _T("DPCMVSET_TAB") ).MP );
		ASSERT( NULL != pDpCMvSetTab );

		CDB_Set *pSet = pDpCMvSetTab->FindCompatibleSet( GetDpCIDPtr().ID, GetProductIDPtr().ID );

		if( pSet != NULL )
		{
			m_DpCMvPackageIDPtr = pSet->GetIDPtr();
		}
	}

	return GetMbrIDPtr( m_DpCMvPackageIDPtr );
}

bool CDS_SSelDpC::IsSelectedAsAPackage( bool bVerifyPackage )
{
	bool bIsSelectedAsPackage = m_bSelectedAsAPackage;

	if( true == bIsSelectedAsPackage && true == bVerifyPackage )
	{
		CDB_Set *pSet = dynamic_cast<CDB_Set *>( GetDpCMvPackageIDPtr().MP );
		bIsSelectedAsPackage = ( NULL != pSet ) ? true : false;
	}

	return bIsSelectedAsPackage;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SSelDpReliefValve
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SSelDpReliefValve )

CDS_SSelDpReliefValve::CDS_SSelDpReliefValve( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SSel( pDataBase, ID )
{
}

void CDS_SSelDpReliefValve::Copy( CData *pclDestination )
{
	CDS_SSelDpReliefValve *pclDestinationSSelDpReliefValve = dynamic_cast<CDS_SSelDpReliefValve *>( pclDestination );
	ASSERT( NULL != pclDestinationSSelDpReliefValve );

	if( NULL != pclDestinationSSelDpReliefValve )
	{
		CDS_SSel::Copy( static_cast<CDS_SSelDpReliefValve *>( pclDestinationSSelDpReliefValve ) );
	}
}

#define CDS_SSELDPRELIEFVALVE_VERSION	1
void CDS_SSelDpReliefValve::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SSELDPRELIEFVALVE_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CDS_SSel::Write( outf );

	// Info.
}

bool CDS_SSelDpReliefValve::Read( INPSTREAM  inpf )
{
	// Version.
	BYTE Version = CDS_SSELDPRELIEFVALVE_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SSELDPRELIEFVALVE_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDS_SSel::Read( inpf ) )
	{
		return false;
	}

	// Info.
	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SSelRadSet
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SSelRadSet )

CDS_SSelRadSet::CDS_SSelRadSet( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SSel( pDataBase, ID )
{
	m_eProductSubCategory = ProductSubCategory::PSC_TC_ThermostaticValve;

	m_strRVFamilyID = _T("");
	m_strRVConnectID = _T("");
	m_strRVVersionID = _T("");
	memset( &m_RadInfos, 0, sizeof( RadInfo_struct ) );
	m_eReturnValveMode = RadiatorReturnValveMode::RRVM_Nothing;
	m_iActuatorType = ActuatorType::AT_ThermoStatic;
	m_iRadiatorValveType = 0;
	m_strSVInsertName[0] = '\0';
	m_fIsInsertInKv = false;
	m_dInsertKvValue = 0.0;
	m_strActuatorTypeID = _T("");
	m_strActuatorFamilyID = _T("");
	m_strActuatorVersionID = _T("");
	m_strSupplyValveActuatorID = _NULL_IDPTR;
	m_dSupplyValveDp = 0.0;
	m_strReturnValveID = _NULL_IDPTR;
	m_dReturnValveOpening = 0.0;
	m_dReturnValveDp = 0.0;
}

void CDS_SSelRadSet::SetSupplyValveFamilyID( CString strSupplyValveFamilyID )
{
	if( 0 != m_strFamilyID.Compare( strSupplyValveFamilyID ) )
	{
		m_strFamilyID = strSupplyValveFamilyID;
		Modified();
	}
}

void CDS_SSelRadSet::SetSupplyValveTypeID( CString strSupplyValveTypeID )
{
	if( 0 != m_strTypeID.Compare( strSupplyValveTypeID ) )
	{
		m_strTypeID = strSupplyValveTypeID;
		Modified();
	}
}

void CDS_SSelRadSet::SetSupplyValveVersionID( CString strSupplyValveVersionID )
{
	if( 0 != m_strVersionID.Compare( strSupplyValveVersionID ) )
	{
		m_strVersionID = strSupplyValveVersionID;
		Modified();
	}
}

void CDS_SSelRadSet::SetSupplyValveConnectID( CString strSupplyValveConnectID )
{
	if( 0 != m_strConnectID.Compare( strSupplyValveConnectID ) )
	{
		m_strConnectID = strSupplyValveConnectID;
		Modified();
	}
}

void CDS_SSelRadSet::SetReturnValveFamilyID( CString strReturnValveFamilyID )
{
	if( 0 != m_strRVFamilyID.Compare( strReturnValveFamilyID ) )
	{
		m_strRVFamilyID = strReturnValveFamilyID;
		Modified();
	}
}

void CDS_SSelRadSet::SetReturnValveVersionID( CString strReturnValveVersionID )
{
	if( 0 != m_strRVVersionID.Compare( strReturnValveVersionID ) )
	{
		m_strRVVersionID = strReturnValveVersionID;
		Modified();
	}
}

void CDS_SSelRadSet::SetReturnValveConnectID( CString strReturnValveConnectID )
{
	if( 0 != m_strRVConnectID.Compare( strReturnValveConnectID ) )
	{
		m_strRVConnectID = strReturnValveConnectID;
		Modified();
	}
}

void CDS_SSelRadSet::GetRadInfos( RadInfo_struct *prRadInfos )
{
	if( NULL != prRadInfos )
	{
		memcpy( prRadInfos, &m_RadInfos, sizeof( RadInfo_struct ) );
	}
}

void CDS_SSelRadSet::SetRadInfos( RadInfo_struct *prRadInfos )
{
	if( NULL != prRadInfos )
	{
		memcpy( &m_RadInfos, prRadInfos, sizeof( RadInfo_struct ) );
	}
}

void CDS_SSelRadSet::SetActuatorTypeID( CString strActuatorTypeID )
{
	if( 0 != m_strActuatorTypeID.Compare( strActuatorTypeID ) )
	{
		m_strActuatorTypeID = strActuatorTypeID;
		Modified();
	}
}

void CDS_SSelRadSet::SetActuatorFamilyID( CString strActuatorFamilyID )
{
	if( 0 != m_strActuatorFamilyID.Compare( strActuatorFamilyID ) )
	{
		m_strActuatorFamilyID = strActuatorFamilyID;
		Modified();
	}
}

void CDS_SSelRadSet::SetActuatorVersionID( CString strActuatorVersionID )
{
	if( 0 != m_strActuatorVersionID.Compare( strActuatorVersionID ) )
	{
		m_strActuatorVersionID = strActuatorVersionID;
		Modified();
	}
}

void CDS_SSelRadSet::Copy( CData *pclDestination )
{
	CDS_SSelRadSet *pclDestinationSSelRadSet = dynamic_cast<CDS_SSelRadSet *>( pclDestination );
	ASSERT( NULL != pclDestinationSSelRadSet );

	if( NULL != pclDestinationSSelRadSet )
	{
		// Call base class.
		CDS_SSel::Copy( static_cast<CDS_SSel *>( pclDestinationSSelRadSet ) );

		// Remark: supply valve and its accessories copy is done in base class.

		// Return valve combos info.
		// Remark: Supply valve combos info are saved in base class.
		pclDestinationSSelRadSet->SetReturnValveFamilyID( m_strRVFamilyID );
		pclDestinationSSelRadSet->SetReturnValveConnectID( m_strRVConnectID );
		pclDestinationSSelRadSet->SetReturnValveVersionID( m_strRVVersionID );

		// DialogSizeRad infos.
		pclDestinationSSelRadSet->SetRadInfos( &m_RadInfos );

		// Copy the return valve mode (see enum 'enRetVMode' in datastruct.h -> Nothing, Other or IMI).
		pclDestinationSSelRadSet->SetReturnValveMode( m_eReturnValveMode );

		// Copy the thermostatic used check box state.
		pclDestinationSSelRadSet->SetActuatorType( m_iActuatorType );

		// Copy the radiator valve type.
		pclDestinationSSelRadSet->SetRadiatorValveType( m_iRadiatorValveType );

		// Copy the insert name ('Heimeier insert' or 'Other insert').
		pclDestinationSSelRadSet->SetSVInsertName( m_strSVInsertName );

		// Copy Kv insert mode flag.
		pclDestinationSSelRadSet->SetInsertInKv( m_fIsInsertInKv );

		// Copy kv insert value.
		pclDestinationSSelRadSet->SetInsertKvValue( m_dInsertKvValue );

		// Copy information about actuators..
		pclDestinationSSelRadSet->SetActuatorTypeID( m_strActuatorTypeID );
		pclDestinationSSelRadSet->SetActuatorFamilyID( m_strActuatorFamilyID );
		pclDestinationSSelRadSet->SetActuatorVersionID( m_strActuatorVersionID );

		// Supply valve actuator (there is no actuator in base class 'CDS_SSel'.
		pclDestinationSSelRadSet->SetSupplyValveActuatorIDPtr( GetSupplyValveActuatorIDPtr() );

		// Supply valve actuator accessories.
		CAccessoryList *pclSVActuatorAccessoryList = pclDestinationSSelRadSet->GetSVActuatorAccessoryList();

		if( NULL != pclSVActuatorAccessoryList )
		{
			pclSVActuatorAccessoryList->Clear();
			m_clSVActuatorAccessoryList.CopyTo( pclSVActuatorAccessoryList );
		}

		// Copy Dp computed on supply valve.
		// Remark: PAY ATTENTION: Dp written in base class is the total DP!!
		pclDestinationSSelRadSet->SetSupplyValveDp( m_dSupplyValveDp );

		// Return valve.
		pclDestinationSSelRadSet->SetReturnValveIDPtr( GetReturnValveIDPtr() );

		// Return valve accessories.
		CAccessoryList *pclReturnValveAccessoryList = pclDestinationSSelRadSet->GetReturnValveAccessoryList();

		if( NULL != pclReturnValveAccessoryList )
		{
			pclReturnValveAccessoryList->Clear();
			m_clReturnValveAccessoryList.CopyTo( pclReturnValveAccessoryList );
		}

		// Copy opening computed on return valve.
		// Remark: Supply valve opening is written in base class.
		pclDestinationSSelRadSet->SetReturnValveOpening( m_dReturnValveOpening );

		// Copy Dp computed on return valve.
		pclDestinationSSelRadSet->SetReturnValveDp( m_dReturnValveDp );
	}
}

int CDS_SSelRadSet::CompareSelectionTo( CData *pclSelectionCompareWith, int iKey )
{
	if( NULL == pclSelectionCompareWith )
	{
		return 0;
	}

	CDS_SSelRadSet *pclSSelRadSetCompareWith = dynamic_cast<CDS_SSelRadSet *>( pclSelectionCompareWith );

	if( NULL == pclSSelRadSetCompareWith )
	{
		return CDS_SSel::CompareSelectionTo( pclSelectionCompareWith, iKey );
	}

	CDB_TAProduct *pclTAProductToCompare = dynamic_cast<CDB_TAProduct *>( GetSupplyValveIDPtr().MP );
	CDB_TAProduct *pclTAProductCompareWidth = dynamic_cast<CDB_TAProduct *>( pclSSelRadSetCompareWith->GetSupplyValveIDPtr().MP );

	int iReturn = 0;

	switch( iKey )
	{
		case PageField_enum::epfBVINFOPRODUCTNAME:

			if( NULL != pclTAProductToCompare && NULL != pclTAProductCompareWidth )
			{
				iReturn = StringCompare( pclTAProductToCompare->GetName(), pclTAProductCompareWidth->GetName() );
			}

			break;

		case PageField_enum::epfBVINFOPRODUCTSIZE:

			if( NULL != pclTAProductToCompare && NULL != pclTAProductCompareWidth )
			{
				int iSizeToCompare = pclTAProductToCompare->GetSizeKey();
				int iSizeCompareWith = pclTAProductCompareWidth->GetSizeKey();

				if( -1 == iSizeToCompare || -1 == iSizeCompareWith )
				{
					iReturn = 0;
				}
				else if( iSizeToCompare < iSizeCompareWith )
				{
					iReturn = -1;
				}
				else if( iSizeToCompare > iSizeCompareWith )
				{
					iReturn = 1;
				}
			}

			break;

		case PageField_enum::epfARTICLE:

			if( NULL != pclTAProductToCompare && NULL != pclTAProductCompareWidth )
			{
				if( false == TASApp.IsTAArtNumberHidden() )
				{
					iReturn = StringCompare( pclTAProductToCompare->GetArtNum(), pclTAProductCompareWidth->GetArtNum() );
				}
				else
				{
					CString strLocArtNum1 = LocArtNumTab.GetLocalArticleNumber( pclTAProductToCompare->GetArtNum() );
					CString strLocArtNum2 = LocArtNumTab.GetLocalArticleNumber( pclTAProductCompareWidth->GetArtNum() );
					iReturn = StringCompare( strLocArtNum1, strLocArtNum2 );
				}
			}

			break;

		default:
			iReturn = CDS_SSel::CompareSelectionTo( pclSelectionCompareWith, iKey );
	}

	return iReturn;
}

#define CDS_SSELTRV_VERSION	3
// Version 2: accessory container class version added.
// Version 3: 'm_fIsWorkWithInsert' is replaced by 'm_iRadiatorValveType'.
void CDS_SSelRadSet::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SSELTRV_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	// Remark: Write of supply valve and its accessories is done in base class.
	CDS_SSel::Write( outf );

	// Infos.

	// Return valve combos info.
	// Remark: Supply valve combos info are saved in base class.
	WriteString( outf, (LPCTSTR)m_strRVFamilyID );
	WriteString( outf, (LPCTSTR)m_strRVConnectID );
	WriteString( outf, (LPCTSTR)m_strRVVersionID );

	// DialogSizeRad infos.
	WriteData<>( outf, m_RadInfos );

	// Write the return valve mode (see the 'RadiatorReturnValveMode' enum definition in the 'DataBObj.h' file -> Nothing, Other or IMI).
	WriteData<>( outf, m_eReturnValveMode );

	// Write the actuator type used on trv.
	WriteData<>( outf, m_iActuatorType );

	// Write the insert mode.
	WriteData<>( outf, m_iRadiatorValveType );

	// Write the insert name ('Heimeier insert' or 'Other insert').
	WriteString( outf, (LPCTSTR)m_strSVInsertName );

	// Write insert Kv mode flag.
	WriteData<>( outf, m_fIsInsertInKv );

	// Write insert Kv value.
	WriteData<>( outf, m_dInsertKvValue );

	// Write information about actuators.
	WriteString( outf, (LPCTSTR)m_strActuatorTypeID );
	WriteString( outf, (LPCTSTR)m_strActuatorFamilyID );
	WriteString( outf, (LPCTSTR)m_strActuatorVersionID );

	// Supply valve actuator (there is no actuator in base class 'CDS_SSel'.
	WriteString( outf, (LPCTSTR)m_strSupplyValveActuatorID.ID );

	// Supply valve actuator accessories.
	m_clSVActuatorAccessoryList.Write( outf );

	// Write Dp computed on supply valve.
	// Remark: PAY ATTENTION: Dp written in base class is the total DP!!
	WriteData<>( outf, m_dSupplyValveDp );

	// Return valve.
	WriteString( outf, (LPCTSTR)m_strReturnValveID.ID );

	// Return valve accessories.
	m_clReturnValveAccessoryList.Write( outf );

	// Write opening computed on return valve.
	// Remark: Supply valve opening is written in base class.
	WriteData<>( outf, m_dReturnValveOpening );

	// Write Dp computed on return valve.
	WriteData<>( outf, m_dReturnValveDp );
}

bool CDS_SSelRadSet::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_SSELTRV_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SSELTRV_VERSION )
	{
		return false;
	}

	// Base class.
	// Remark: Write of supply valve and its accessories is done in base class.
	if( false == CDS_SSel::Read( inpf ) )
	{
		return false;
	}

	// Infos.
	m_strRVFamilyID = _T("");
	m_strRVConnectID = _T("");
	m_strRVVersionID = _T("");

	// Return valve combos info.
	// Remark: Supply valve combos info are read in base class.
	if( false == ReadString( inpf, m_strRVFamilyID ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strRVConnectID ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strRVVersionID ) )
	{
		return false;
	}

	// DialogSizeRad infos.
	inpf.read( (char *)&m_RadInfos, sizeof( RadInfo_struct ) );

	// Read the return valve mode (see enum 'enRetVMode' in datastruct.h -> Nothing, Other or IMI).
	inpf.read( (char *)&m_eReturnValveMode, sizeof( m_eReturnValveMode ) );

	// Read the actuator type used on trv.
	inpf.read( (char *)&m_iActuatorType, sizeof( m_iActuatorType ) );

	// Since version 3, 'm_fIsWorkWithInsert' has been replaced by 'm_iRadiatorValveType'. If version is
	// older, we don't care about the value.
	if( Version < 3 )
	{
		bool fDummy;
		inpf.read( (char *)&fDummy, sizeof( fDummy ) );
	}
	else
	{
		inpf.read( (char *)&m_iRadiatorValveType, sizeof( m_iRadiatorValveType ) );
	}

	// Read the insert name ('Heimeier insert' or 'Other insert').
	if( false == ReadString( inpf, m_strSVInsertName, sizeof( m_strSVInsertName ) ) )
	{
		return false;
	}

	// Read the insert Kv flag.
	inpf.read( (char *)&m_fIsInsertInKv, sizeof( m_fIsInsertInKv ) );

	// Read insert Kv value.
	inpf.read( (char *)&m_dInsertKvValue, sizeof( m_dInsertKvValue ) );

	// Read information about actuators.
	if( false == ReadString( inpf, m_strActuatorTypeID ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strActuatorFamilyID ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strActuatorVersionID ) )
	{
		return false;
	}

	// Supply valve actuator (there is no actuator in base class 'CDS_SSel'.
	if( false == ReadString( inpf, m_strSupplyValveActuatorID.ID, sizeof( m_strSupplyValveActuatorID.ID ) ) )
	{
		return false;
	}

	// Read supply valve actuator accessories.
	m_clSVActuatorAccessoryList.Read( inpf, ( Version > 1 ) ? true : false );

	// Read Dp computed on supply valve.
	// Remark: PAY ATTENTION: Dp read in base class is the total DP!!
	inpf.read( (char *)&m_dSupplyValveDp, sizeof( m_dSupplyValveDp ) );

	// Return valve.
	if( false == ReadString( inpf, m_strReturnValveID.ID, sizeof( m_strReturnValveID.ID ) ) )
	{
		return false;
	}

	// Read return valve accessories (new version of return valve accessories).
	m_clReturnValveAccessoryList.Read( inpf, ( Version > 1 ) ? true : false );

	// Read opening computed on return valve.
	// Remark: Supply valve opening is read in base class.
	inpf.read( (char *)&m_dReturnValveOpening, sizeof( m_dReturnValveOpening ) );

	// Read Dp computed on return valve.
	inpf.read( (char *)&m_dReturnValveDp, sizeof( m_dReturnValveDp ) );

	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SSelCtrl
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SSelCtrl )

CDS_SSelCtrl::CDS_SSelCtrl( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SSel( pDataBase, ID )
{
	m_CtrlProp = CDB_ControlProperties::CV2W3W::CV2W;
	m_CtrlType = CDB_ControlProperties::CvCtrlType::eCvProportional;
	m_ActrIDPtr = _NULL_IDPTR;
	m_CvActrSetIDPtr = _NULL_IDPTR;
	m_fCheckPackageEnable = TRUE;
	m_strActuatorPowerSupplyID = _T("");
	m_strActuatorInputSignalID = _T("");
	m_iFailSafeFunction = 0;
	m_eDefaultRPFunction = CDB_ControlValve::DRPFunction::drpfUndefined;
}

bool CDS_SSelCtrl::IsSelectedAsAPackage( bool bVerifyPackage )
{
	bool bIsSelectedAsPackage = m_bSelectedAsAPackage;

	if( true == bIsSelectedAsPackage && true == bVerifyPackage )
	{
		CDB_Set *pSet = dynamic_cast<CDB_Set *>( GetCvActrSetIDPtr().MP );
		bIsSelectedAsPackage = ( NULL != pSet ) ? true : false;
	}

	return bIsSelectedAsPackage;
}

void CDS_SSelCtrl::SetActuatorPowerSupplyID( CString strActuatorPowerSupplyID )
{
	if( 0 != m_strActuatorPowerSupplyID.Compare( strActuatorPowerSupplyID ) )
	{
		m_strActuatorPowerSupplyID = strActuatorPowerSupplyID;
		Modified();
	}
}

void CDS_SSelCtrl::SetActuatorInputSignalID( CString strActuatorInputSignalID )
{
	if( 0 != m_strActuatorInputSignalID.Compare( strActuatorInputSignalID ) )
	{
		m_strActuatorInputSignalID = strActuatorInputSignalID;
		Modified();
	}
}

void CDS_SSelCtrl::SetFailSafeFunction( int iFailSafeFct )
{
	if( m_iFailSafeFunction != iFailSafeFct )
	{
		m_iFailSafeFunction = iFailSafeFct;
		Modified();
	}
}

void CDS_SSelCtrl::SetDRPFunction( CDB_ControlValve::DRPFunction eDRPFct )
{
	if( m_eDefaultRPFunction != eDRPFct )
	{
		m_eDefaultRPFunction = eDRPFct;
		Modified();
	}
}

void CDS_SSelCtrl::Copy( CData *pclDestination )
{
	CDS_SSelCtrl *pclDestinationSSelCtr = dynamic_cast<CDS_SSelCtrl *>( pclDestination );
	ASSERT( NULL != pclDestinationSSelCtr );

	if( NULL != pclDestinationSSelCtr )
	{
		CDS_SSel::Copy( static_cast<CDS_SSel *>( pclDestinationSSelCtr ) );

		pclDestinationSSelCtr->SetCtrlProp( GetCtrlProp() );
		pclDestinationSSelCtr->SetCtrlType( GetCtrlType() );
		pclDestinationSSelCtr->SetActrIDPtr( GetActrIDPtr() );

		CAccessoryList *pclActuatorAccessoryList = pclDestinationSSelCtr->GetActuatorAccessoryList();

		if( NULL != pclActuatorAccessoryList )
		{
			pclActuatorAccessoryList->Clear();
			m_clActuatorAccessoryList.CopyTo( pclActuatorAccessoryList );
		}

		pclDestinationSSelCtr->SetCheckPackageEnable( m_fCheckPackageEnable );

		// Copy information about actuators..
		pclDestinationSSelCtr->SetActuatorPowerSupplyID( m_strActuatorPowerSupplyID );
		pclDestinationSSelCtr->SetActuatorInputSignalID( m_strActuatorInputSignalID );
		pclDestinationSSelCtr->SetFailSafeFunction( m_iFailSafeFunction );
		pclDestinationSSelCtr->SetDRPFunction( m_eDefaultRPFunction );
	}
}

#define CDS_SELCTRL_VERSION	7
// Version 7: 2019-08-19: 'm_eDefaultRPFunction' variable added
// Version 5: new version of actuator accessory container.
// Version 6: - actuator accessory container class version added.
//			  - add information about actuators and selection by set.
void CDS_SSelCtrl::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SELCTRL_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CDS_SSel::Write( outf );

	// Info.
	WriteData<>( outf, m_CtrlProp );
	WriteData<>( outf, m_CtrlType );

	// Actuator accessories.
	m_clActuatorAccessoryList.Write( outf );

	WriteString( outf, (LPCTSTR)m_ProductIDPtr.ID );
	WriteString( outf, (LPCTSTR)m_ActrIDPtr.ID );

	// Version 6: Write information about actuators.
	WriteString( outf, (LPCTSTR)m_strActuatorPowerSupplyID );
	WriteString( outf, (LPCTSTR)m_strActuatorInputSignalID );
	WriteData<>( outf, m_iFailSafeFunction );

	// Version 6: Add the checkbox package enable status (Enable/Disable).
	WriteData<>( outf, m_fCheckPackageEnable );

	// Version 7.
	WriteData<>( outf, m_eDefaultRPFunction );
}

bool CDS_SSelCtrl::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_SELCTRL_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SELCTRL_VERSION )
	{
		return false;
	}

	// Base class.
	if( Version <= 2 )
	{
		if( false == CDS_SelProd::Read( inpf ) )
		{
			return false;
		}
	}
	else
	{
		if( false == CDS_SSel::Read( inpf ) )
		{
			return false;
		}
	}

	// Info.
	inpf.read( (char *)&m_CtrlProp, sizeof( m_CtrlProp ) );
	inpf.read( (char *)&m_CtrlType, sizeof( m_CtrlType ) );

	m_ActrIDPtr = _NULL_IDPTR;

	if( Version <= 2 )
	{
		if( false == ReadString( inpf, m_ActrIDPtr.ID, sizeof( m_ActrIDPtr.ID ) ) )
		{
			return false;
		}

		if( false == ReadString( inpf, m_CvActrSetIDPtr.ID, sizeof( m_CvActrSetIDPtr.ID ) ) )
		{
			return false;
		}

		if( _T('\0') != *m_CvActrSetIDPtr.ID )
		{
			SetSelectedAsAPackage( true );
		}

		m_clAccessoryList.Clear();
		int i = 0;
		inpf.read( (char *)&i, sizeof( int ) );

		for( ; i > 0; i-- )
		{
			IDPTR idptr = _NULL_IDPTR;
			idptr.DB = TASApp.GetpTADB();

			if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
			{
				return false;
			}

			Extend( &idptr );
			m_clAccessoryList.Add( idptr, CAccessoryList::_AT_Undefined, NULL, true );
		}
	}

	if( Version < 5 )
	{
		m_clActuatorAccessoryList.Clear();
		int i = 0;
		inpf.read( (char *)&i, sizeof( int ) );

		for( ; i > 0; i-- )
		{
			IDPTR idptr = _NULL_IDPTR;
			idptr.DB = TASApp.GetpTADB();

			if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
			{
				return false;
			}

			Extend( &idptr );
			m_clActuatorAccessoryList.Add( idptr, CAccessoryList::_AT_Undefined, NULL, true );
		}
	}
	else
	{
		// 5: new version of actuator accessories.
		// >5: version has been added in the actuator accessory container class.
		m_clActuatorAccessoryList.Read( inpf, ( Version > 5 ) ? true : false );
	}

	if( Version <= 1 )
	{
		BYTE dummy;
		inpf.read( (char *)&dummy, sizeof( dummy ) );

		if( false == ReadString( inpf, m_ProductIDPtr.ID, sizeof( m_ProductIDPtr.ID ) ) )
		{
			return false;
		}

		double d;
		inpf.read( (char *)&d, sizeof( d ) );
		
		bool b;
		inpf.read( (char *)&b, sizeof( b ) );
	}
	else
	{
		if( false == ReadString( inpf, m_ProductIDPtr.ID, sizeof( m_ProductIDPtr.ID ) ) )
		{
			return false;
		}
	}

	if( Version <= 3 )
	{
		return true;
	}

	if( false == ReadString( inpf, m_ActrIDPtr.ID, sizeof( m_ActrIDPtr.ID ) ) )
	{
		return false;
	}

	if( Version < 6 )
	{
		return true;
	}

	// Version 6: Read information about actuators.
	if( false == ReadString( inpf, m_strActuatorPowerSupplyID ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strActuatorInputSignalID ) )
	{
		return false;
	}

	bool bIsDRPReaded = false;

	if( Version >= 7 )
	{
		inpf.read( (char *)&m_iFailSafeFunction, sizeof( m_iFailSafeFunction ) );
	}
	else
	{
		inpf.read( (char *)&m_eDefaultRPFunction, sizeof( m_eDefaultRPFunction ) );
		bIsDRPReaded = true;

		if( NULL != dynamic_cast<CDB_ElectroActuator*> ( m_ActrIDPtr.MP ) 
			&& (int)( dynamic_cast<CDB_ElectroActuator*> ( m_ActrIDPtr.MP ) )->GetFailSafe() > 0 )
		{
			m_iFailSafeFunction = 1;
		}
		else
		{
			m_iFailSafeFunction = 0;
		}
	}

	// Version 6: Read the checkbox set enable status (Enable/Disable).
	inpf.read( (char *)&m_fCheckPackageEnable, sizeof( m_fCheckPackageEnable ) );

	if( Version < 7 )
	{
		return true;
	}

	// Version 7
	if( false == bIsDRPReaded )
	{
		inpf.read( (char *)&m_eDefaultRPFunction, sizeof( m_eDefaultRPFunction ) );
	}

	return true;
}

IDPTR CDS_SSelCtrl::GetCvActrSetIDPtr()
{
	if( _T('\0') == *( m_CvActrSetIDPtr.ID ) )
	{
		m_CvActrSetIDPtr = _NULL_IDPTR;
		CTableSet *pCVActSetTab = dynamic_cast<CTableSet *>( TASApp.GetpTADB()->Get( _T("CVACTSET_TAB") ).MP );
		ASSERT( NULL != pCVActSetTab );

		CDB_Set *pCVActSet = pCVActSetTab->FindCompatibleSet( GetProductIDPtr().ID, GetActrIDPtr().ID );

		if( pCVActSet != NULL )
		{
			m_CvActrSetIDPtr = pCVActSet->GetIDPtr();
		}
	}

	return GetMbrIDPtr( m_CvActrSetIDPtr );
}

void CDS_SSelCtrl::ResetCVActrSetIDPtr()
{
	m_CvActrSetIDPtr = _NULL_IDPTR;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SSelCv
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SSelCv )

CDS_SSelCv::CDS_SSelCv( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SSelCtrl( pDataBase, ID )
{
	m_eProductSubCategory = ProductSubCategory::PSC_BC_ControlValve;
	m_dKvs = 0.0;
	m_dDp = 0.0;
	m_bCheckBoxKvsDp = false;
	m_eRadioKvsOrDp = KvsOrDp::Dp;
}

void CDS_SSelCv::Copy( CData *pclDestination )
{
	CDS_SSelCv *pclDestinationSSelCv = dynamic_cast<CDS_SSelCv *>( pclDestination );
	ASSERT( NULL != pclDestinationSSelCv );

	if( NULL != pclDestinationSSelCv )
	{
		CDS_SSelCtrl::Copy( static_cast<CDS_SSelCtrl *>( pclDestinationSSelCv ) );

		pclDestinationSSelCv->SetKvs( GetKvs() );
		pclDestinationSSelCv->SetDp( GetDp() );
		pclDestinationSSelCv->SetCheckBoxKvsDp( GetCheckBoxKvsDp() );
		pclDestinationSSelCv->SetRadioKvsOrDp( GetRadioKvsOrDp() );
	}
}

#define CDS_SELCV_VERSION	4
// Version 4: 2017-06-11 - The 'm_bRadioKvs' (boolean) becomes 'm_eRadioKvsOrDp' (enum).
void CDS_SSelCv::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SELCV_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CDS_SSelCtrl::Write( outf );

	// Info.
	WriteData<>( outf, m_dKvs );
	WriteData<>( outf, m_dDp );
	WriteData<>( outf, m_bCheckBoxKvsDp );
	WriteData<>( outf, m_eRadioKvsOrDp );
}

bool CDS_SSelCv::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_SELCV_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SELCV_VERSION )
	{
		return false;
	}

	if( Version < 3 )
	{
		// Base class.
		if( false == CData::Read( inpf ) )
		{
			return false;
		}

		// Info.
		inpf.read( (char *)&m_dQ, sizeof( m_dQ ) );
		inpf.read( (char *)&m_dKvs, sizeof( m_dKvs ) );
		inpf.read( (char *)&m_dDp, sizeof( m_dDp ) );
		inpf.read( (char *)&m_bCheckBoxKvsDp, sizeof( m_bCheckBoxKvsDp ) );

		// Before version 4, this variable was a boolean.
		bool bRadioKvs;
		inpf.read( (char *)&bRadioKvs, sizeof( bRadioKvs ) );
		m_eRadioKvsOrDp = ( true == bRadioKvs ) ? KvsOrDp::Kvs : KvsOrDp::Dp;

		inpf.read( (char *)&m_CtrlProp, sizeof( m_CtrlProp ) );
		inpf.read( (char *)&m_CtrlType, sizeof( m_CtrlType ) );
		inpf.read( (char *)&m_bDirSel, sizeof( m_bDirSel ) );

		m_strTypeID = _T("");
		m_strFamilyID = _T("");
		m_strMaterialID = _T("");
		m_strConnectID = _T("");
		m_strVersionID = _T("");
		m_strPNID = _T("");
		m_strPipeSeriesID = _T("");
		m_strPipeID = _T("");
		m_ActrIDPtr = _NULL_IDPTR;
		m_HMIDptr = _NULL_IDPTR;

		if( false == ReadString( inpf, m_strTypeID ) )
		{
			return false;
		}

		if( false == ReadString( inpf, m_strFamilyID ) )
		{
			return false;
		}

		if( false == ReadString( inpf, m_strMaterialID ) )
		{
			return false;
		}

		if( false == ReadString( inpf, m_strConnectID ) )
		{
			return false;
		}

		if( false == ReadString( inpf, m_strVersionID ) )
		{
			return false;
		}

		if( false == ReadString( inpf, m_strPNID ) )
		{
			return false;
		}

		if( false == ReadString( inpf, m_strPipeSeriesID ) )
		{
			return false;
		}

		if( false == ReadString( inpf, m_strPipeID ) )
		{
			return false;
		}

		if( false == ReadString( inpf, m_ActrIDPtr.ID, sizeof( m_ActrIDPtr.ID ) ) )
		{
			return false;
		}

		if( false == ReadString( inpf, m_CvActrSetIDPtr.ID, sizeof( m_CvActrSetIDPtr.ID ) ) )
		{
			return false;
		}

		if( 2 == Version )
		{
			if( false == ReadString( inpf, m_HMIDptr.ID, sizeof( m_HMIDptr.ID ) ) )
			{
				return false;
			}
		}

		m_clAccessoryList.Clear();
		int i = 0;
		inpf.read( (char *)&i, sizeof( int ) );

		for( ; i > 0; i-- )
		{
			IDPTR idptr = _NULL_IDPTR;
			idptr.DB = TASApp.GetpTADB();

			if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
			{
				return false;
			}

			Extend( &idptr );
			m_clAccessoryList.Add( idptr, CAccessoryList::_AT_Undefined, NULL, true );
		}

		m_clActuatorAccessoryList.Clear();
		inpf.read( (char *)&i, sizeof( int ) );

		for( ; i > 0; i-- )
		{
			IDPTR idptr = _NULL_IDPTR;
			idptr.DB = TASApp.GetpTADB();

			if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
			{
				return false;
			}

			Extend( &idptr );
			m_clActuatorAccessoryList.Add( idptr, CAccessoryList::_AT_Undefined, NULL, true );
		}

		m_pSelectedInfos->Read( inpf );
		{
			BYTE dummy;
			inpf.read( (char *)&dummy, sizeof( dummy ) );

			if( false == ReadString( inpf, m_ProductIDPtr.ID, sizeof( m_ProductIDPtr.ID ) ) )
			{
				return false;
			}

			double d;
			inpf.read( (char *)&d, sizeof( d ) );
			bool b;
			inpf.read( (char *)&b, sizeof( b ) );
		}

		m_pSelPipe->Read( inpf );
	}
	else
	{
		// Base class.
		if( false == CDS_SSelCtrl::Read( inpf ) )
		{
			return false;
		}

		// Info.
		inpf.read( (char *)&m_dKvs, sizeof( m_dKvs ) );
		inpf.read( (char *)&m_dDp, sizeof( m_dDp ) );
		inpf.read( (char *)&m_bCheckBoxKvsDp, sizeof( m_bCheckBoxKvsDp ) );

		// Before version 4, this variable was a boolean.
		if( Version < 4 )
		{
			bool bRadioKvs;
			inpf.read( (char *)&bRadioKvs, sizeof( bRadioKvs ) );
			m_eRadioKvsOrDp = ( true == bRadioKvs ) ? KvsOrDp::Kvs : KvsOrDp::Dp;
		}
		else
		{
			inpf.read( (char *)&m_eRadioKvsOrDp, sizeof( m_eRadioKvsOrDp ) );
		}
	}

	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SSelPICv
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SSelPICv )

CDS_SSelPICv::CDS_SSelPICv( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SSelCtrl( pDataBase, ID )
{
	m_eProductSubCategory = ProductSubCategory::PSC_BC_PressureIndepCtrlValve;
	m_PICVActrSetIDPtr = _NULL_IDPTR;
	m_dDpMax = 0.0;
}

void CDS_SSelPICv::ResetCVActrSetIDPtr()
{
	m_PICVActrSetIDPtr = _NULL_IDPTR;
}

IDPTR CDS_SSelPICv::GetPICVActrSetIDPtr()
{
	if( _T('\0') == *( m_PICVActrSetIDPtr.ID ) )
	{
		m_PICVActrSetIDPtr = _NULL_IDPTR;
		CTableSet *pPICVActSetTab = dynamic_cast<CTableSet *>( TASApp.GetpTADB()->Get( _T("PICVACTSET_TAB") ).MP );

		if( NULL != pPICVActSetTab )
		{
			CDB_Set *pPICVActSet = pPICVActSetTab->FindCompatibleSet( GetProductIDPtr().ID, GetActrIDPtr().ID );

			if( pPICVActSet != NULL )
			{
				m_PICVActrSetIDPtr = pPICVActSet->GetIDPtr();
			}
			// HYS-1877: For PIBCV Sets that are linked with 6-way valve set tab.
			else if( NULL != dynamic_cast<CTableSet*>(TASApp.GetpTADB()->Get( _T( "6WAYCTRLVALVSET_TAB" ) ).MP) )
			{
				pPICVActSetTab = dynamic_cast<CTableSet*>(TASApp.GetpTADB()->Get( _T( "6WAYCTRLVALVSET_TAB" ) ).MP);
				CDB_Set* pPICVActSet = pPICVActSetTab->FindCompatibleSet6WayValve( GetProductIDPtr().ID, GetActrIDPtr().ID );

				if( pPICVActSet != NULL )
				{
					m_PICVActrSetIDPtr = pPICVActSet->GetIDPtr();
				}
			}
		}
	}

	return GetMbrIDPtr( m_PICVActrSetIDPtr );
}

void CDS_SSelPICv::Copy( CData *pclDestination )
{
	CDS_SSelPICv *pclDestinationSSelPICv = dynamic_cast<CDS_SSelPICv *>( pclDestination );
	ASSERT( pclDestinationSSelPICv != NULL );

	if( pclDestinationSSelPICv != NULL )
	{
		// Call base class.
		CDS_SSelCtrl::Copy( static_cast<CDS_SSelCtrl *>( pclDestinationSSelPICv ) );

		pclDestinationSSelPICv->SetDpMax( m_dDpMax );
	}
}

#define CDS_SELPICV_VERSION	5
// Version 5: Dp max added.
// Version 4: actuators info and checkbox set are now in the base class.
void CDS_SSelPICv::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SELPICV_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CDS_SSelCtrl::Write( outf );

	// Version 5: Dp max added.
	WriteData<>( outf, m_dDpMax );
}

bool CDS_SSelPICv::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_SELPICV_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SELPICV_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDS_SSelCtrl::Read( inpf ) )
	{
		return false;
	}

	if( Version < 2 )
	{
		return true;
	}

	if( Version < 4 )
	{
		if( false == ReadString( inpf, m_strActuatorPowerSupplyID ) )
		{
			return false;
		}

		if( false == ReadString( inpf, m_strActuatorInputSignalID ) )
		{
			return false;
		}

		CDB_ElectroActuator::DefaultReturnPosition eDRP;
		inpf.read( (char *)&eDRP, sizeof( eDRP ) );

		if( Version < 3 )
		{
			return true;
		}

		inpf.read( (char *)&m_fCheckPackageEnable, sizeof( m_fCheckPackageEnable ) );
	}

	if( Version < 5 )
	{
		return true;
	}

	inpf.read( (char *)&m_dDpMax, sizeof( m_dDpMax ) );

	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SSelBCv
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SSelBCv )

CDS_SSelBCv::CDS_SSelBCv( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SSelCtrl( pDataBase, ID )
{
	m_eProductSubCategory = ProductSubCategory::PSC_BC_BalAndCtrlValve;
	m_BCVActrSetIDPtr = _NULL_IDPTR;
}

void CDS_SSelBCv::ResetCVActrSetIDPtr()
{
	m_BCVActrSetIDPtr = _NULL_IDPTR;
}

IDPTR CDS_SSelBCv::GetBCVActrSetIDPtr()
{
	if( _T('\0') == *( m_BCVActrSetIDPtr.ID ) )
	{
		m_BCVActrSetIDPtr = _NULL_IDPTR;
		CTableSet *pBCVActSetTab = dynamic_cast<CTableSet *>( TASApp.GetpTADB()->Get( _T("BCVACTSET_TAB") ).MP );

		if( NULL != pBCVActSetTab )
		{
			CDB_Set *pBCVActSet = pBCVActSetTab->FindCompatibleSet( GetProductIDPtr().ID, GetActrIDPtr().ID );

			if( pBCVActSet != NULL )
			{
				m_BCVActrSetIDPtr = pBCVActSet->GetIDPtr();
			}
		}
	}

	return GetMbrIDPtr( m_BCVActrSetIDPtr );
}

void CDS_SSelBCv::Copy( CData *pclDestination )
{
	CDS_SSelBCv *pclDestinationSSelBCv = dynamic_cast<CDS_SSelBCv *>( pclDestination );
	ASSERT( pclDestinationSSelBCv != NULL );

	if( pclDestinationSSelBCv != NULL )
	{
		// Call base class.
		CDS_SSelCtrl::Copy( static_cast<CDS_SSelCtrl *>( pclDestinationSSelBCv ) );
	}
}

#define CDS_SELBCV_VERSION	5
// Version 5: actuators info and checkbox set are now in the base class.
void CDS_SSelBCv::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SELBCV_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CDS_SSelCtrl::Write( outf );
}

bool CDS_SSelBCv::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_SELBCV_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SELBCV_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDS_SSelCtrl::Read( inpf ) )
	{
		return false;
	}

	if( 1 == Version )
	{
		bool b;
		inpf.read( (char *)&b, sizeof( b ) );
		double dDp = 0.0;
		inpf.read( (char *)&dDp, sizeof( dDp ) );
		SetDp( dDp );
		inpf.read( (char *)&m_dOpening, sizeof( m_dOpening ) );
	}

	if( Version < 3 )
	{
		return true;
	}

	if( Version < 5 )
	{
		// Version 3: read actuators information.
		if( false == ReadString( inpf, m_strActuatorPowerSupplyID ) )
		{
			return false;
		}

		if( false == ReadString( inpf, m_strActuatorInputSignalID ) )
		{
			return false;
		}

		inpf.read( (char *)&m_eDefaultRPFunction, sizeof( m_eDefaultRPFunction ) );

		if( Version < 4 )
		{
			return true;
		}

		inpf.read( (char *)&m_fCheckPackageEnable, sizeof( m_fCheckPackageEnable ) );
	}

	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SSel6WayValve
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SSel6WayValve )

CDS_SSel6WayValve::CDS_SSel6WayValve( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SSelCtrl( pDataBase, ID )
{
	m_eProductSubCategory = ProductSubCategory::PSC_BC_6WayControlValve;
	m_dCoolingFlow = 0.0;
	m_dCoolingPower = 0.0;
	m_dCoolingDT = 0.0;
	m_dHeatingFlow = 0.0;
	m_dHeatingPower = 0.0;
	m_dHeatingDT = 0.0;
	m_IDPtrCDSSSelPICv1 = _NULL_IDPTR;
	m_pclCDSSelPICv1 = NULL;
	m_IDPtrCDSSSelPICv2 = _NULL_IDPTR;
	m_pclCDSSelPICv2 = NULL;
	m_IDPtrCDSSSelBv1 = _NULL_IDPTR;
	m_pclCDSSelBv1 = NULL;
	m_IDPtrCDSSSelBv2 = _NULL_IDPTR;
	m_pclCDSSelBv2 = NULL;
	m_iCheckboxFastConnection = 0;
	// HYS-1877
	m_iCheckboxOnlyForSet = 0;
	m_6WayValveSetIDPtr = _NULL_IDPTR;
	m_eSelectionMode = e6WayValveSelectionMode::e6Way_Undefined;
}

CDS_SSel6WayValve::~CDS_SSel6WayValve()
{
	// Objects pointed by these following variables are all in the "6WAYCTRLVALVHELPER_TAB" table.
	// The objects will be then properly deleted when this table will be deleted.
	m_IDPtrCDSSSelPICv1 = _NULL_IDPTR;
	m_IDPtrCDSSSelPICv2 = _NULL_IDPTR;
	m_IDPtrCDSSSelBv1 = _NULL_IDPTR;
	m_IDPtrCDSSSelBv2 = _NULL_IDPTR;

	m_pclCDSSelPICv1 = NULL;
	m_pclCDSSelPICv2 = NULL;
	m_pclCDSSelBv1 = NULL;
	m_pclCDSSelBv2 = NULL;
}

CDS_SSelPICv *CDS_SSel6WayValve::GetCDSSSelPICv( SideDefinition eSideDefinition )
{
	try
	{
		CDS_SSelPICv *pclCDSSelPIBCv = NULL;

		if( BothSide == eSideDefinition || HeatingSide == eSideDefinition )
		{
			if( NULL == m_pclCDSSelPICv1 )
			{
				if( _NULL_IDPTR == m_IDPtrCDSSSelPICv1 )
				{
					GetDB()->CreateObject( m_IDPtrCDSSSelPICv1, CLASS( CDS_SSelPICv ) );

					CTable *pTab = dynamic_cast<CTable *>( GetDB()->Get( _T("6WAYCTRLVALVHELPER_TAB") ).MP );

					if( NULL == pTab )
					{
						HYSELECT_THROW( _T("Internal error: Can't retrieve the '6WAYCTRLVALVHELPER_TAB' table from the database.") );
					}

					pTab->Insert( m_IDPtrCDSSSelPICv1 );
				}
				else if( _T('\0') != *m_IDPtrCDSSSelPICv1.ID )
				{
					m_IDPtrCDSSSelPICv1.DB = GetDB();
					Extend( &m_IDPtrCDSSSelPICv1 );
				}

				m_pclCDSSelPICv1 = dynamic_cast<CDS_SSelPICv *>( m_IDPtrCDSSSelPICv1.MP );
			}

			pclCDSSelPIBCv = m_pclCDSSelPICv1;
		}
		else
		{
			if( NULL == m_pclCDSSelPICv2 )
			{
				if( _NULL_IDPTR == m_IDPtrCDSSSelPICv2 )
				{
					GetDB()->CreateObject( m_IDPtrCDSSSelPICv2, CLASS( CDS_SSelPICv ) );
					
					CTable *pTab = dynamic_cast<CTable *>( GetDB()->Get( _T("6WAYCTRLVALVHELPER_TAB") ).MP );

					if( NULL == pTab )
					{
						HYSELECT_THROW( _T("Internal error: Can't retrieve the '6WAYCTRLVALVHELPER_TAB' table from the database.") );
					}

					pTab->Insert( m_IDPtrCDSSSelPICv2 );
				}
				else if( _T('\0') != *m_IDPtrCDSSSelPICv2.ID )
				{
					m_IDPtrCDSSSelPICv2.DB = GetDB();
					Extend( &m_IDPtrCDSSSelPICv2 );
				}

				m_pclCDSSelPICv2 = dynamic_cast<CDS_SSelPICv *>( m_IDPtrCDSSSelPICv2.MP );
			}

			pclCDSSelPIBCv = m_pclCDSSelPICv2;
		}

		return pclCDSSelPIBCv;
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDS_SSel6WayValve::GetCDSSSelPICv'."), __LINE__, __FILE__ );
		throw;
	}
}

CDS_SSelBv *CDS_SSel6WayValve::GetCDSSSelBv( SideDefinition eSideDefinition )
{
	try
	{
		CDS_SSelBv *pclCDSSelBv = NULL;

		if( BothSide == eSideDefinition || HeatingSide == eSideDefinition )
		{
			if( NULL == m_pclCDSSelBv1 )
			{
				if( _NULL_IDPTR == m_IDPtrCDSSSelBv1 )
				{
					GetDB()->CreateObject( m_IDPtrCDSSSelBv1, CLASS( CDS_SSelBv ) );

					CTable *pTab = dynamic_cast<CTable *>( GetDB()->Get( _T("6WAYCTRLVALVHELPER_TAB") ).MP );

					if( NULL == pTab )
					{
						HYSELECT_THROW( _T("Internal error: Can't retrieve the '6WAYCTRLVALVHELPER_TAB' table from the database.") );
					}

					pTab->Insert( m_IDPtrCDSSSelBv1 );
				}
				else if( _T('\0') != *m_IDPtrCDSSSelBv1.ID )
				{
					m_IDPtrCDSSSelBv1.DB = GetDB();
					Extend( &m_IDPtrCDSSSelBv1 );
				}

				m_pclCDSSelBv1 = dynamic_cast<CDS_SSelBv *>( m_IDPtrCDSSSelBv1.MP );
			}
			
			pclCDSSelBv = m_pclCDSSelBv1;
		}
		else
		{
			if( NULL == m_pclCDSSelBv2 )
			{
				if( _NULL_IDPTR == m_IDPtrCDSSSelBv2 )
				{
					GetDB()->CreateObject( m_IDPtrCDSSSelBv2, CLASS( CDS_SSelBv ) );

					CTable *pTab = dynamic_cast<CTable *>( GetDB()->Get( _T("6WAYCTRLVALVHELPER_TAB") ).MP );
					
					if( NULL == pTab )
					{
						HYSELECT_THROW( _T("Internal error: Can't retrieve the '6WAYCTRLVALVHELPER_TAB' table from the database.") );
					}

					pTab->Insert( m_IDPtrCDSSSelBv2 );
				}
				else if( _T('\0') != *m_IDPtrCDSSSelBv2.ID )
				{
					m_IDPtrCDSSSelBv2.DB = GetDB();
					Extend( &m_IDPtrCDSSSelBv2 );
				}

				m_pclCDSSelBv2 = dynamic_cast<CDS_SSelBv *>( m_IDPtrCDSSSelBv2.MP );
			}
			
			pclCDSSelBv = m_pclCDSSelBv2;
		}

		return pclCDSSelBv;
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDS_SSel6WayValve::GetCDSSSelBv'."), __LINE__, __FILE__ );
		throw;
	}
}

void CDS_SSel6WayValve::SetCDSSelPIVvIDPtr1( IDPTR IDPtrCDSSSelPICv1 )
{ 
	if( NULL != m_IDPtrCDSSSelPICv1.MP || _NULL_IDPTR == IDPtrCDSSSelPICv1 || NULL == dynamic_cast<CDS_SSelPICv *>( IDPtrCDSSSelPICv1.MP ) )
	{
		ASSERT_RETURN;
	}

	m_IDPtrCDSSSelPICv1 = IDPtrCDSSSelPICv1;
	m_pclCDSSelPICv1 = dynamic_cast<CDS_SSelPICv *>( m_IDPtrCDSSSelPICv1.MP );
}

void CDS_SSel6WayValve::SetCDSSelPIVvIDPtr2( IDPTR IDPtrCDSSSelPICv2 )
{ 
	if( NULL != m_IDPtrCDSSSelPICv2.MP || _NULL_IDPTR == IDPtrCDSSSelPICv2 || NULL == dynamic_cast<CDS_SSelPICv *>( IDPtrCDSSSelPICv2.MP ) )
	{
		ASSERT_RETURN;
	}

	m_IDPtrCDSSSelPICv2 = IDPtrCDSSSelPICv2;
	m_pclCDSSelPICv2 = dynamic_cast<CDS_SSelPICv *>( m_IDPtrCDSSSelPICv2.MP );
}

void CDS_SSel6WayValve::SetCDSSelBvIDPtr1( IDPTR IDPtrCDSSSelBv1 )
{ 
	if( NULL != m_IDPtrCDSSSelBv1.MP || _NULL_IDPTR == IDPtrCDSSSelBv1 || NULL == dynamic_cast<CDS_SSelBv *>( IDPtrCDSSSelBv1.MP ) )
	{
		ASSERT_RETURN;
	}

	m_IDPtrCDSSSelBv1 = IDPtrCDSSSelBv1;
	m_pclCDSSelBv1 = dynamic_cast<CDS_SSelBv *>( m_IDPtrCDSSSelBv1.MP );
}

void CDS_SSel6WayValve::SetCDSSelBvIDPtr2( IDPTR IDPtrCDSSSelBv2 )
{ 
	if( NULL != m_IDPtrCDSSSelBv2.MP || _NULL_IDPTR == IDPtrCDSSSelBv2 || NULL == dynamic_cast<CDS_SSelBv *>( IDPtrCDSSSelBv2.MP ) )
	{
		ASSERT_RETURN;
	}

	m_IDPtrCDSSSelBv2 = IDPtrCDSSSelBv2;
	m_pclCDSSelBv2 = dynamic_cast<CDS_SSelBv *>( m_IDPtrCDSSSelBv2.MP );
}

void CDS_SSel6WayValve::Copy( CData *pclDestination )
{
	try
	{
		CDS_SSel6WayValve *pclDestinationSSel6WayValve = dynamic_cast<CDS_SSel6WayValve *>( pclDestination );

		if( NULL == pclDestinationSSel6WayValve )
		{
			HYSELECT_THROW( _T("Internal error: 'pData' argument is not a 'pSel6WayCv' object.") );
		}

		// Call base class.
		CDS_SSelCtrl::Copy( static_cast<CDS_SSelCtrl *>( pclDestinationSSel6WayValve ) );

		pclDestinationSSel6WayValve->SetCoolingFlow( GetCoolingFlow() );
		pclDestinationSSel6WayValve->SetCoolingPower( GetCoolingPower() );
		pclDestinationSSel6WayValve->SetCoolingDT( GetCoolingDT() );
		pclDestinationSSel6WayValve->SetCoolingWC( GetCoolingWC() );

		pclDestinationSSel6WayValve->SetHeatingFlow( GetHeatingFlow() );
		pclDestinationSSel6WayValve->SetHeatingPower( GetHeatingPower() );
		pclDestinationSSel6WayValve->SetHeatingDT( GetHeatingDT() );
		pclDestinationSSel6WayValve->SetHeatingWC( GetHeatingWC() );

		// For pressure independent balancing & control valve.
		
		// Heating side.
		if( NULL != m_pclCDSSelPICv1 )
		{
			IDPTR IDPtrCDSSSel = _NULL_IDPTR;
			GetDB()->CreateObject( IDPtrCDSSSel, CLASS( CDS_SSelPICv ) );

			CTable *pTab = dynamic_cast<CTable *>( GetDB()->Get( _T("6WAYCTRLVALVHELPER_TAB") ).MP );

			if( NULL == pTab )
			{
				HYSELECT_THROW( _T("Internal error: Can't retrieve the '6WAYCTRLVALVHELPER_TAB' table from the database.") );
			}
			
			pTab->Insert( IDPtrCDSSSel );

			CDS_SSelPICv *pclSSelPICv = dynamic_cast<CDS_SSelPICv *>( IDPtrCDSSSel.MP );
			m_pclCDSSelPICv1->Copy( pclSSelPICv );
			pclDestinationSSel6WayValve->SetCDSSelPIVvIDPtr1( IDPtrCDSSSel );
		}

		// Cooling side.
		if( NULL != m_pclCDSSelPICv2 )
		{
			IDPTR IDPtrCDSSSel = _NULL_IDPTR;
			GetDB()->CreateObject( IDPtrCDSSSel, CLASS( CDS_SSelPICv ) );

			CTable *pTab = dynamic_cast<CTable *>( GetDB()->Get( _T("6WAYCTRLVALVHELPER_TAB") ).MP );
			
			if( NULL == pTab )
			{
				HYSELECT_THROW( _T("Internal error: Can't retrieve the '6WAYCTRLVALVHELPER_TAB' table from the database.") );
			}

			pTab->Insert( IDPtrCDSSSel );

			CDS_SSelPICv *pclSSelPICv = dynamic_cast<CDS_SSelPICv *>( IDPtrCDSSSel.MP );
			m_pclCDSSelPICv2->Copy( pclSSelPICv );
			pclDestinationSSel6WayValve->SetCDSSelPIVvIDPtr2( IDPtrCDSSSel );
		}

		// For balancing valve.
		
		// Heating side.
		if( NULL != m_pclCDSSelBv1 )
		{
			IDPTR IDPtrCDSSSel = _NULL_IDPTR;
			GetDB()->CreateObject( IDPtrCDSSSel, CLASS( CDS_SSelBv ) );

			CTable *pTab = dynamic_cast<CTable *>( GetDB()->Get( _T("6WAYCTRLVALVHELPER_TAB") ).MP );

			if( NULL == pTab )
			{
				HYSELECT_THROW( _T("Internal error: Can't retrieve the '6WAYCTRLVALVHELPER_TAB' table from the database.") );
			}

			pTab->Insert( IDPtrCDSSSel );

			CDS_SSelBv *pclSSelBv = dynamic_cast<CDS_SSelBv *>( IDPtrCDSSSel.MP );
			m_pclCDSSelBv1->Copy( pclSSelBv );
			pclDestinationSSel6WayValve->SetCDSSelBvIDPtr1( IDPtrCDSSSel );
		}

		// Cooling side.
		if( NULL != m_pclCDSSelBv2 )
		{
			IDPTR IDPtrCDSSSel = _NULL_IDPTR;
			GetDB()->CreateObject( IDPtrCDSSSel, CLASS( CDS_SSelBv ) );

			CTable *pTab = dynamic_cast<CTable *>( GetDB()->Get( _T("6WAYCTRLVALVHELPER_TAB") ).MP );

			if( NULL == pTab )
			{
				HYSELECT_THROW( _T("Internal error: Can't retrieve the '6WAYCTRLVALVHELPER_TAB' table from the database.") );
			}

			pTab->Insert( IDPtrCDSSSel );

			CDS_SSelBv *pclSSelBv = dynamic_cast<CDS_SSelBv *>( IDPtrCDSSSel.MP );
			m_pclCDSSelBv2->Copy( pclSSelBv );
			pclDestinationSSel6WayValve->SetCDSSelBvIDPtr2( IDPtrCDSSSel );
		}

		pclDestinationSSel6WayValve->SetCheckboxFastConnection( m_iCheckboxFastConnection );

		// HYS-1877.
		pclDestinationSSel6WayValve->SetCheckboxOnlyForSet( m_iCheckboxOnlyForSet );
		pclDestinationSSel6WayValve->SetSelectionMode( (e6WayValveSelectionMode)GetSelectionMode() );
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDS_SSel6WayValve::Copy'."), __LINE__, __FILE__ );
		throw;
	}
}

IDPTR CDS_SSel6WayValve::Get6WayValveActrSetIDPtr()
{
	if( _T( '\0' ) == *(m_6WayValveSetIDPtr.ID) )
	{
		m_6WayValveSetIDPtr = _NULL_IDPTR;
		CTableSet* p6WValveSetTab = dynamic_cast<CTableSet*>(TASApp.GetpTADB()->Get( _T( "6WAYCTRLVALVSET_TAB" ) ).MP);
		ASSERT( NULL != p6WValveSetTab );

		CDB_Set* pCVActSet = p6WValveSetTab->FindCompatibleSet( GetProductIDPtr().ID, GetActrIDPtr().ID );

		if( pCVActSet != NULL )
		{
			m_6WayValveSetIDPtr = pCVActSet->GetIDPtr();
		}
	}

	return GetMbrIDPtr( m_6WayValveSetIDPtr );
}

void CDS_SSel6WayValve::ResetCVActrSetIDPtr()
{
	m_6WayValveSetIDPtr = _NULL_IDPTR;
}

bool CDS_SSel6WayValve::IsSelectedAsAPackage( bool bVerifyPackage )
{
	bool bIsSelectedAsPackage = m_bSelectedAsAPackage;

	if( true == bIsSelectedAsPackage && true == bVerifyPackage )
	{
		CDB_Set* pSet = dynamic_cast<CDB_Set*>(GetCvActrSetIDPtr().MP);
		bIsSelectedAsPackage = (NULL != pSet) ? true : false;
	}

	return bIsSelectedAsPackage;
}

#define CDS_SEL6WAYCV_VERSION	2

// Version 2: 2022-06-27 HYS-1877, add m_iCheckboxOnlyForSet

void CDS_SSel6WayValve::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SEL6WAYCV_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CDS_SSelCtrl::Write( outf );

	// Version 1.
	WriteData<>( outf, m_dCoolingFlow );
	WriteData<>( outf, m_dCoolingPower );
	WriteData<>( outf, m_dCoolingDT );
	m_clCoolingWC.Write( outf );

	WriteData<>( outf, m_dHeatingFlow );
	WriteData<>( outf, m_dHeatingPower );
	WriteData<>( outf, m_dHeatingDT );
	m_clHeatingWC.Write( outf );

	// For pressure independent balancing & control valve.
	// We just need here to write the ID. The corresponding object has been created in the database. 
	// And this object will be written outside of this method.
	WriteString( outf, (LPCTSTR)m_IDPtrCDSSSelPICv1.ID );
	WriteString( outf, (LPCTSTR)m_IDPtrCDSSSelPICv2.ID );

	// For balancing valve.
	WriteString( outf, (LPCTSTR)m_IDPtrCDSSSelBv1.ID );
	WriteString( outf, (LPCTSTR)m_IDPtrCDSSSelBv2.ID );

	WriteData<>( outf, m_iCheckboxFastConnection );
	WriteData<>( outf, m_eSelectionMode );
	// HYS-1877: Version 2
	WriteData<>( outf, m_iCheckboxOnlyForSet );
}

bool CDS_SSel6WayValve::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_SEL6WAYCV_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SEL6WAYCV_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDS_SSelCtrl::Read( inpf ) )
	{
		return false;
	}

	inpf.read( (char *)&m_dCoolingFlow, sizeof( m_dCoolingFlow ) );
	inpf.read( (char *)&m_dCoolingPower, sizeof( m_dCoolingPower ) );
	inpf.read( (char *)&m_dCoolingDT, sizeof( m_dCoolingDT ) );
	m_clCoolingWC.Read( inpf );

	inpf.read( (char *)&m_dHeatingFlow, sizeof( m_dHeatingFlow ) );
	inpf.read( (char *)&m_dHeatingPower, sizeof( m_dHeatingPower ) );
	inpf.read( (char *)&m_dHeatingDT, sizeof( m_dHeatingDT ) );
	m_clHeatingWC.Read( inpf );

	// For pressure independent balancing & control valve.
	// We just need here to read the ID. The corresponding object has been created in the database. 
	// And this object will be read outside of this method.
	if( false == ReadString( inpf, m_IDPtrCDSSSelPICv1.ID, sizeof( m_IDPtrCDSSSelPICv1.ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_IDPtrCDSSSelPICv2.ID, sizeof( m_IDPtrCDSSSelPICv2.ID ) ) )
	{
		return false;
	}

	// For balancing valve.
	if( false == ReadString( inpf, m_IDPtrCDSSSelBv1.ID, sizeof( m_IDPtrCDSSSelBv1.ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_IDPtrCDSSSelBv2.ID, sizeof( m_IDPtrCDSSSelBv2.ID ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_iCheckboxFastConnection, sizeof( m_iCheckboxFastConnection ) );
	inpf.read( (char *)&m_eSelectionMode, sizeof( m_eSelectionMode ) );

	// HYS-1877: Version 2
	if( 2 > Version )
	{
		return true;
	}

	inpf.read( (char *)&m_iCheckboxOnlyForSet, sizeof( m_iCheckboxOnlyForSet ) );

	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SSelAirVentSeparator
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SSelAirVentSeparator )

CDS_SSelAirVentSeparator::CDS_SSelAirVentSeparator( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SSel( pDataBase, ID )
{
	m_eProductSubCategory = ProductSubCategory::PSC_PM_Separator;
}

void CDS_SSelAirVentSeparator::Copy( CData *pclDestination )
{
	CDS_SSelAirVentSeparator *pclDestinationSSelAirVentSeparator = dynamic_cast<CDS_SSelAirVentSeparator *>( pclDestination );
	ASSERT( NULL != pclDestinationSSelAirVentSeparator );

	if( NULL != pclDestinationSSelAirVentSeparator )
	{
		CDS_SSel::Copy( pclDestinationSSelAirVentSeparator );
	}
}

#define CDS_SSELSEPARATOR_VERSION	1
void CDS_SSelAirVentSeparator::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SSELSEPARATOR_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CDS_SSel::Write( outf );

	// Infos.
}

bool CDS_SSelAirVentSeparator::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_SSELSEPARATOR_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SSELSEPARATOR_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDS_SSel::Read( inpf ) )
	{
		return false;
	}

	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SSelPMaint
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SSelPMaint )

CDS_SSelPMaint::CDS_SSelPMaint( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
	m_bDirectSel = false;
	m_pSelectedInfos = new CSelectedInfos( this );
	m_pclInputUser = new CPMInputUser();

	m_eSelectionMode = ProductSelectionMode_Individual;
	m_eSelectionType = SelectionType::Undefined;

	// Values common to vessel.
	m_VesselIDPtr = _NULL_IDPTR;
	m_nVesselNumber = 0;
	m_dVesselInitialPressure = 0.0;
	m_dVesselWaterReserve = 0.0;

	// Values for tecbox Compresso or Transfero.
	m_TecBoxCompTransfIDPtr = _NULL_IDPTR;
	m_nTecBoxCompTransfNumber = 0;

	// Values for Transfero.
	m_TecBoxIntegratedVesselIDPtr = _NULL_IDPTR;

	// Values for primary Compresso vessel.

	// Values for primary Transfero vessel.

	// Values for secondary Compresso & Transfero vessel.
	m_SecondaryVesselIDPtr = _NULL_IDPTR;
	m_nSecondaryVesselNumber = 0;

	// Values for intermediate vessels.
	m_IntermediateVesselIDPtr = _NULL_IDPTR;
	m_nIntermediateVesselNumber = 0;

	// Values for Pleno (Pleno alone).
	m_TecBoxPlenoIDPtr = _NULL_IDPTR;
	m_AdditionalTecBoxPlenoIDPtr = _NULL_IDPTR;			// Remark: this is a IDPTR on a 'CDB_Set' object!
	m_TecBoxPlenoProtectionIDPtr = _NULL_IDPTR;			
	m_nTecBoxPlenoNumber = 0;

	// Values for Vento (Vento alone or a combination of VP).
	m_TecBoxVentoIDPtr = _NULL_IDPTR;
	m_nTecBoxVentoNumber = 0;

	// Values for Pleno Refill (Selected with a Pleno or alone (in direct selection)).
	m_PlenoRefillIDPtr = _NULL_IDPTR;
	m_nPlenoRefillNumber = 0;
}

CDS_SSelPMaint::~CDS_SSelPMaint()
{
	if( NULL != m_pclInputUser )
	{
		delete m_pclInputUser;
	}

	if( NULL != m_pSelectedInfos )
	{
		delete m_pSelectedInfos;
	}

	m_pclInputUser = NULL;
	m_pSelectedInfos = NULL;
}

void CDS_SSelPMaint::Reset()
{
	m_bDirectSel = false;

	m_eSelectionMode = ProductSelectionMode_Individual;
	m_eSelectionType = SelectionType::Undefined;

	// Values common to vessel.
	m_VesselIDPtr = _NULL_IDPTR;
	m_nVesselNumber = 0;
	m_dVesselInitialPressure = 0.0;
	m_dVesselWaterReserve = 0.0;
	m_clVesselAccessoryList.Clear();

	// Values for tecbox Compresso or Transfero.
	m_TecBoxCompTransfIDPtr = _NULL_IDPTR;
	m_nTecBoxCompTransfNumber = 0;
	m_clTecBoxCompTransfAccessoryList.Clear();
	
	// HYS-872.
	m_clTecBoxIntegratedVesselAccessoryList.Clear();

	// Values for Transfero.
	m_TecBoxIntegratedVesselIDPtr = _NULL_IDPTR;

	// Values for primary Compresso vessel.

	// Values for primary Transfero vessel.

	// Values for secondary Compresso & Transfero vessel.
	m_SecondaryVesselIDPtr = _NULL_IDPTR;
	m_nSecondaryVesselNumber = 0;

	// Values for intermediate vessels.
	m_IntermediateVesselIDPtr = _NULL_IDPTR;
	m_nIntermediateVesselNumber = 0;
	m_clIntermediateVesselAccessoryList.Clear();

	// Values for Pleno (Pleno alone).
	m_TecBoxPlenoIDPtr = _NULL_IDPTR;
	m_TecBoxPlenoProtectionIDPtr = _NULL_IDPTR;
	m_AdditionalTecBoxPlenoIDPtr = _NULL_IDPTR;
	m_nTecBoxPlenoNumber = 0;
	m_clTecBoxPlenoAccessoryList.Clear();
	m_clTecBoxPlenoProtecAccessoryList.Clear();

	// Values for Vento (Vento alone or a combination of VP).
	m_TecBoxVentoIDPtr = _NULL_IDPTR;
	m_nTecBoxVentoNumber = 0;
	m_clTecBoxVentoAccessoryList.Clear();

	// Values for Pleno Refill (Selected with a Pleno or alone (in direct selection)).
	m_PlenoRefillIDPtr = _NULL_IDPTR;
	m_nPlenoRefillNumber = 0;
	m_clPlenoRefillAccessoryList.Clear();
}

CDB_Product *CDS_SSelPMaint::GetSelectedProduct()
{
	if( Undefined == m_eSelectionType && false == m_bDirectSel )
	{
		return NULL;
	}

	CDB_Product *pclProduct = NULL;

	if( false == m_bDirectSel )
	{
		// We are in the individual selection.

		if( SelectionType::NoPressurization != m_eSelectionType )
		{
			// Complete pressurisation selection.

			if( SelectionType::Statico == m_eSelectionType )
			{
				pclProduct = static_cast<CDB_Product *>( GetVesselIDPtr().MP );
			}
			else
			{
				pclProduct = static_cast<CDB_Product *>( GetTecBoxCompTransfIDPtr().MP );
			}

		}
		else
		{
			// Selection without pressurisation (Pleno/Vento alone).

			if( NULL != GetTecBoxPlenoIDPtr().MP )
			{
				pclProduct = static_cast<CDB_Product *>( GetTecBoxPlenoIDPtr().MP );
			}
			else if( NULL != GetTecBoxVentoIDPtr().MP )
			{
				pclProduct = static_cast<CDB_Product *>( GetTecBoxVentoIDPtr().MP );
			}
		}
	}
	else
	{
		// We are in the direct selection.

		if( NULL != GetVesselIDPtr().MP )
		{
			pclProduct = static_cast<CDB_Product *>( GetVesselIDPtr().MP );
		}
		else if( NULL != GetSecondaryVesselIDPtr().MP )
		{
			pclProduct = static_cast<CDB_Product *>( GetSecondaryVesselIDPtr().MP );
		}
		else if( NULL != GetIntermediateVesselIDPtr().MP )
		{
			pclProduct = static_cast<CDB_Product *>( GetIntermediateVesselIDPtr().MP );
		}
		else if( NULL != GetTecBoxCompTransfIDPtr().MP )
		{
			pclProduct = static_cast<CDB_Product *>( GetTecBoxCompTransfIDPtr().MP );
		}
		else if( NULL != GetTecBoxPlenoIDPtr().MP )
		{
			pclProduct = static_cast<CDB_Product *>( GetTecBoxPlenoIDPtr().MP );
		}
		else if( NULL != GetTecBoxVentoIDPtr().MP )
		{
			pclProduct = static_cast<CDB_Product *>( GetTecBoxVentoIDPtr().MP );
		}
		else if( NULL != GetPlenoRefillIDPtr().MP )
		{
			pclProduct = static_cast<CDB_Product *>( GetPlenoRefillIDPtr().MP );
		}
	}

	return pclProduct;
}

void CDS_SSelPMaint::Copy( CData *pclDestination )
{
	CDS_SSelPMaint *pclDestinationSSelPMaint = dynamic_cast<CDS_SSelPMaint *>( pclDestination );
	ASSERT( NULL != pclDestinationSSelPMaint );

	if( NULL != pclDestinationSSelPMaint )
	{
		CData::Copy( pclDestination );

		// Infos.
		pclDestinationSSelPMaint->SetFromDirSel( m_bDirectSel );
		pclDestinationSSelPMaint->SetSelectionMode( GetSelectionMode() );
		pclDestinationSSelPMaint->SetSelectionType( GetSelectionType() );

		// HYS-981: Copy only user's input if the selection has not been done in direct selection.
		if( false == m_bDirectSel )
		{
			pclDestinationSSelPMaint->GetpInputUser()->CopyFrom( m_pclInputUser );
		}

		m_pSelectedInfos->Copy( pclDestinationSSelPMaint->GetpSelectedInfos() );

		// Values for vessel.
		pclDestinationSSelPMaint->SetVesselIDPtr( GetVesselIDPtr() );
		pclDestinationSSelPMaint->SetVesselNumber( GetVesselNumber() );
		pclDestinationSSelPMaint->SetVesselInitialPressure( GetVesselInitialPressure() );
		pclDestinationSSelPMaint->SetVesselWaterReserve( GetVesselWaterReserve() );
		CAccessoryList *pclVesselAccessoryList = pclDestinationSSelPMaint->GetVesselAccessoryList();

		if( NULL != pclVesselAccessoryList )
		{
			pclVesselAccessoryList->Clear();
			m_clVesselAccessoryList.CopyTo( pclVesselAccessoryList );
		}

		// Values for tecbox Compresso or Transfero.
		pclDestinationSSelPMaint->SetTecBoxCompTransfIDPtr( GetTecBoxCompTransfIDPtr() );
		pclDestinationSSelPMaint->SetTecBoxCompTransfNumber( GetTecBoxCompTransfNumber() );
		CAccessoryList *pclTechBoxCompTransfAccessoryList = pclDestinationSSelPMaint->GetTecBoxCompTransfAccessoryList();
		CAccessoryList *pclTechBoxIntegratedVesselAccessoryList = pclDestinationSSelPMaint->GetTecBoxIntegratedVesselAccessoryList();
		if( NULL != pclTechBoxCompTransfAccessoryList )
		{
			pclTechBoxCompTransfAccessoryList->Clear();
			m_clTecBoxCompTransfAccessoryList.CopyTo( pclTechBoxCompTransfAccessoryList );
		}
		
		// HYS-872.
		if (NULL != pclTechBoxIntegratedVesselAccessoryList)
		{
			pclTechBoxIntegratedVesselAccessoryList->Clear();
			m_clTecBoxIntegratedVesselAccessoryList.CopyTo(pclTechBoxIntegratedVesselAccessoryList);
		}

		// Values for Transfero.
		pclDestinationSSelPMaint->SetTecBoxIntegratedVesselIDPtr( GetTecBoxIntegratedVesselIDPtr() );

		// Values for primary Compresso vessel.

		// Values for primary Transfero vessel.

		// Values for secondary Compresso & Transfero vessel.
		pclDestinationSSelPMaint->SetSecondaryVesselIDPtr( GetSecondaryVesselIDPtr() );
		pclDestinationSSelPMaint->SetSecondaryVesselNumber( GetSecondaryVesselNumber() );

		// Values for intermediate vessels.
		pclDestinationSSelPMaint->SetIntermediateVesselIDPtr( GetIntermediateVesselIDPtr() );
		pclDestinationSSelPMaint->SetIntermediateVesselNumber( GetIntermediateVesselNumber() );
		CAccessoryList *pclAccessoryList = pclDestinationSSelPMaint->GetIntermediateVesselAccessoryList();

		if( NULL != pclAccessoryList )
		{
			pclAccessoryList->Clear();
			m_clIntermediateVesselAccessoryList.CopyTo( pclAccessoryList );
		}

		// Values for Pleno (Pleno alone).
		pclDestinationSSelPMaint->SetTecBoxPlenoIDPtr( GetTecBoxPlenoIDPtr() );
		pclDestinationSSelPMaint->SetAdditionalTecBoxPlenoIDPtr( GetAdditionalTecBoxPlenoIDPtr() );
		pclDestinationSSelPMaint->SetTecBoxPlenoNumber( GetTecBoxPlenoNumber() );
		CAccessoryList *pclTechBoxPlenoAccessoryList = pclDestinationSSelPMaint->GetTecBoxPlenoAccessoryList();

		if( NULL != pclTechBoxPlenoAccessoryList )
		{
			pclTechBoxPlenoAccessoryList->Clear();
			m_clTecBoxPlenoAccessoryList.CopyTo( pclTechBoxPlenoAccessoryList );
		}

		// HYS-1121 Values for Protection module with Pleno.
		pclDestinationSSelPMaint->SetTecBoxPlenoProtectionIDPtr( GetTecBoxPlenoProtectionIDPtr() );
		CAccessoryList *pclTechBoxPlenoProtecAccessoryList = pclDestinationSSelPMaint->GetTecBoxPlenoProtecAccessoryList();

		if( NULL != pclTechBoxPlenoProtecAccessoryList )
		{
			pclTechBoxPlenoProtecAccessoryList->Clear();
			m_clTecBoxPlenoProtecAccessoryList.CopyTo( pclTechBoxPlenoProtecAccessoryList );
		}

		// Values for Vento (Vento alone or a combination of VP).
		pclDestinationSSelPMaint->SetTecBoxVentoIDPtr( GetTecBoxVentoIDPtr() );
		pclDestinationSSelPMaint->SetTecBoxVentoNumber( GetTecBoxVentoNumber() );
		CAccessoryList *pclTechBoxVentoAccessoryList = pclDestinationSSelPMaint->GetTecBoxVentoAccessoryList();

		if( NULL != pclTechBoxVentoAccessoryList )
		{
			pclTechBoxVentoAccessoryList->Clear();
			m_clTecBoxVentoAccessoryList.CopyTo( pclTechBoxVentoAccessoryList );
		}

		// Values for Pleno Refill (Selected with a Pleno or alone (in direct selection)).
		pclDestinationSSelPMaint->SetPlenoRefillIDPtr( GetPlenoRefillIDPtr() );
		pclDestinationSSelPMaint->SetPlenoRefillNumber( GetPlenoRefillNumber() );
		CAccessoryList *pclPlenoRefillAccessoryList = pclDestinationSSelPMaint->GetPlenoRefillAccessoryList();

		if( NULL != pclPlenoRefillAccessoryList )
		{
			pclPlenoRefillAccessoryList->Clear();
			m_clPlenoRefillAccessoryList.CopyTo( pclPlenoRefillAccessoryList );
		}
	}
}

int CDS_SSelPMaint::CompareSelectionTo( CData *pclSelectionCompareWith, int iKey )
{
	if( NULL == pclSelectionCompareWith )
	{
		return 0;
	}

	CDS_SSelPMaint *pclSSelPMaintCompareWith = dynamic_cast<CDS_SSelPMaint *>( pclSelectionCompareWith );

	if( NULL == pclSSelPMaintCompareWith )
	{
		return CData::CompareSelectionTo( pclSelectionCompareWith, iKey );
	}

	CDB_Vessel *pclVesselToCompare = NULL;
	CDB_TecBox *pclTecBoxToCompare = NULL;
	CDB_Product *pclProductToCompare = GetSelectedProduct();

	if( CDS_SSelPMaint::Statico == m_eSelectionType )
	{
		pclVesselToCompare = dynamic_cast<CDB_Vessel *>( pclProductToCompare );
	}
	else
	{
		pclTecBoxToCompare = dynamic_cast<CDB_TecBox *>( pclProductToCompare );
	}

	CDB_Vessel *pclVesselCompareWith = NULL;
	CDB_TecBox *pclTecBoxCompareWith = NULL;
	CDB_Product *pclProductCompareWith = pclSSelPMaintCompareWith->GetSelectedProduct();

	if( CDS_SSelPMaint::Statico == m_eSelectionType )
	{
		pclVesselCompareWith = dynamic_cast<CDB_Vessel *>( pclProductCompareWith );
	}
	else
	{
		pclTecBoxCompareWith = dynamic_cast<CDB_TecBox *>( pclProductCompareWith );
	}

	int iReturn = 0;

	switch( iKey )
	{
		case PageField_enum::epfBVINFOPRODUCTNAME:

			if( NULL != pclProductToCompare && NULL != pclProductCompareWith )
			{
				iReturn = StringCompare( pclProductToCompare->GetName(), pclProductCompareWith->GetName() );
			}

			break;

		case PageField_enum::epfBVINFOPRODUCTSIZE:
		{
			double dSizeToCompare = -1.0;

			if( NULL != pclVesselToCompare )
			{
				dSizeToCompare = pclVesselToCompare->GetHeight();
			}
			else if( NULL != pclTecBoxToCompare )
			{
				dSizeToCompare = pclTecBoxToCompare->GetHeight();
			}

			double dSizeCompareWith = -1.0;

			if( NULL != pclVesselCompareWith )
			{
				dSizeCompareWith = pclVesselCompareWith->GetHeight();
			}
			else if( NULL != pclTecBoxCompareWith )
			{
				dSizeCompareWith = pclTecBoxCompareWith->GetHeight();
			}

			if( -1.0 != dSizeToCompare && -1.0 != dSizeCompareWith )
			{
				if( dSizeToCompare < dSizeCompareWith )
				{
					iReturn = -1;
				}
				else if( dSizeToCompare > dSizeCompareWith )
				{
					iReturn = 1;
				}
			}
		}
		break;

		case PageField_enum::epfARTICLE:

			if( NULL != pclProductToCompare && NULL != pclProductCompareWith )
			{
				if( false == TASApp.IsTAArtNumberHidden() )
				{
					iReturn = StringCompare( pclProductToCompare->GetArtNum(), pclProductCompareWith->GetArtNum() );
				}
				else
				{
					CString strLocArtNum1 = LocArtNumTab.GetLocalArticleNumber( pclProductToCompare->GetArtNum() );
					CString strLocArtNum2 = LocArtNumTab.GetLocalArticleNumber( pclProductCompareWith->GetArtNum() );
					iReturn = StringCompare( strLocArtNum1, strLocArtNum2 );
				}
			}

			break;

		default:
			iReturn = CData::CompareSelectionTo( pclSelectionCompareWith, iKey );
	}

	return iReturn;
}

#define CDS_SSELPMAINT_VERSION	7
// Version 7: 2019-09-20 - HYS-1121: Pleno connect + water make-up protection
// Version 6: 2019-02-18 - HYS-1022: 'pa' becomes 'pa,min'; 'pa,opt' becomes 'pa' and 'Vwr,opt' becomes 'Vwr'.
// Version 5: 2018-11-26 - Add m_clTecBoxIntegratedVesselAccessoryList
// Version 4: 2017-07-12 - Add 'm_eSelectionMode'.
// Version 3: 2015-08-26 - add Pleno Refill and an additional Pleno
// Version 2: add Pleno & Vento.
void CDS_SSelPMaint::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SSELPMAINT_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CData::Write( outf );

	// Infos.
	WriteData<>( outf, m_bDirectSel );

	m_pclInputUser->Write( outf );
	m_pSelectedInfos->Write( outf );

	WriteData<>( outf, m_eSelectionType );

	// Values for vessel.
	WriteString( outf, (LPCTSTR)m_VesselIDPtr.ID );
	WriteData<>( outf, m_nVesselNumber );
	WriteData<>( outf, m_dVesselInitialPressure );
	WriteData<>( outf, m_dVesselWaterReserve );
	m_clVesselAccessoryList.Write( outf );

	// Values for tecbox Compresso or Transfero.
	WriteString( outf, (LPCTSTR)m_TecBoxCompTransfIDPtr.ID );
	WriteData<>( outf, m_nTecBoxCompTransfNumber );
	m_clTecBoxCompTransfAccessoryList.Write( outf );

	// Values for Transfero.
	WriteString( outf, (LPCTSTR)m_TecBoxIntegratedVesselIDPtr.ID );

	// Values for primary Compresso vessel.

	// Values for primary Transfero vessel.

	// Values for secondary Compresso & Transfero vessel.
	WriteString( outf, (LPCTSTR)m_SecondaryVesselIDPtr.ID );
	WriteData<>( outf, m_nSecondaryVesselNumber );

	// Values for intermediate vessels.
	WriteString( outf, (LPCTSTR)m_IntermediateVesselIDPtr.ID );
	WriteData<>( outf, m_nIntermediateVesselNumber );
	m_clIntermediateVesselAccessoryList.Write( outf );

	// Values for Pleno (Pleno alone).
	WriteString( outf, (LPCTSTR)m_TecBoxPlenoIDPtr.ID );
	WriteData<>( outf, m_nTecBoxPlenoNumber );
	m_clTecBoxPlenoAccessoryList.Write( outf );	
	
	// Values for Vento (Vento alone or a combination of VP).
	WriteString( outf, (LPCTSTR)m_TecBoxVentoIDPtr.ID );
	WriteData<>( outf, m_nTecBoxVentoNumber );
	m_clTecBoxVentoAccessoryList.Write( outf );

	// Version 3.
	// Values for Pleno Refill (Selected with a Pleno or alone (in direct selection)).
	WriteString( outf, (LPCTSTR)m_PlenoRefillIDPtr.ID );
	WriteData<>( outf, m_nPlenoRefillNumber );
	m_clPlenoRefillAccessoryList.Write( outf );

	WriteString( outf, (LPCTSTR)m_AdditionalTecBoxPlenoIDPtr.ID );

	// Version 4.
	WriteData<>( outf, m_eSelectionMode );
	// Version 5
	m_clTecBoxIntegratedVesselAccessoryList.Write( outf );

	// Version 7
	WriteString( outf, (LPCTSTR)m_TecBoxPlenoProtectionIDPtr.ID );
	m_clTecBoxPlenoProtecAccessoryList.Write( outf );
}

bool CDS_SSelPMaint::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_SSELPMAINT_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SSELPMAINT_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Infos.
	inpf.read( (char *)&m_bDirectSel, sizeof( m_bDirectSel ) );

	if( false == m_pclInputUser->Read( inpf ) )
	{
		return false;
	}

	m_pclInputUser->SetpTADB( TASApp.GetpTADB() );
	m_pclInputUser->SetpTADS( TASApp.GetpTADS() );

	if( false == m_pSelectedInfos->Read( inpf ) )
	{
		return false;
	}

	m_pclInputUser->SetWC( *m_pSelectedInfos->GetpWCData() );

	inpf.read( (char *)&m_eSelectionType, sizeof( m_eSelectionType ) );

	// Values for vessel.
	if( false == ReadString( inpf, m_VesselIDPtr.ID, sizeof( m_VesselIDPtr.ID ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_nVesselNumber, sizeof( m_nVesselNumber ) );

	if( Version < 6 )
	{
		// HYS-1022: 'pa,opt' becomes 'pa' and 'pa' becomes 'pa,min'. Thus we don't need anymore to read this variable here.
		double dDummy = 0.0;
		inpf.read( (char *)&dDummy, sizeof( dDummy ) );
	}

	// HYS-1022: 'pa,opt' becomes 'pa' and 'Vwr,opt' becomes 'Vwr'.
	inpf.read( (char *)&m_dVesselInitialPressure, sizeof( m_dVesselInitialPressure ) );
	inpf.read( (char *)&m_dVesselWaterReserve, sizeof( m_dVesselWaterReserve ) );
	m_clVesselAccessoryList.Read( inpf, true );

	// Values for tecbox Compresso or Transfero.
	if( false == ReadString( inpf, m_TecBoxCompTransfIDPtr.ID, sizeof( m_TecBoxCompTransfIDPtr.ID ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_nTecBoxCompTransfNumber, sizeof( m_nTecBoxCompTransfNumber ) );
	m_clTecBoxCompTransfAccessoryList.Read( inpf, true );

	// Values for Transfero.
	if( false == ReadString( inpf, m_TecBoxIntegratedVesselIDPtr.ID, sizeof( m_TecBoxIntegratedVesselIDPtr.ID ) ) )
	{
		return false;
	}

	// Values for primary Compresso vessel.

	// Values for primary Transfero vessel.

	// Values for secondary Compresso & Transfero vessel.
	if( false == ReadString( inpf, m_SecondaryVesselIDPtr.ID, sizeof( m_SecondaryVesselIDPtr.ID ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_nSecondaryVesselNumber, sizeof( m_nSecondaryVesselNumber ) );

	// Values for intermediate vessels.
	if( false == ReadString( inpf, m_IntermediateVesselIDPtr.ID, sizeof( m_IntermediateVesselIDPtr.ID ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_nIntermediateVesselNumber, sizeof( m_nIntermediateVesselNumber ) );
	m_clIntermediateVesselAccessoryList.Read( inpf, true );

	// Values for Pleno (Pleno alone).
	if( false == ReadString( inpf, m_TecBoxPlenoIDPtr.ID, sizeof( m_TecBoxPlenoIDPtr.ID ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_nTecBoxPlenoNumber, sizeof( m_nTecBoxPlenoNumber ) );
	m_clTecBoxPlenoAccessoryList.Read( inpf, true );

	// Values for Vento (Vento alone or a combination of VP).
	if( false == ReadString( inpf, m_TecBoxVentoIDPtr.ID, sizeof( m_TecBoxVentoIDPtr.ID ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_nTecBoxVentoNumber, sizeof( m_nTecBoxVentoNumber ) );
	m_clTecBoxVentoAccessoryList.Read( inpf, true );

	if( Version < 3 )
	{
		return true;
	}

	// Values for Pleno Refill (Selected with a Pleno or alone (in direct selection)).
	if( false == ReadString( inpf, m_PlenoRefillIDPtr.ID, sizeof( m_PlenoRefillIDPtr.ID ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_nPlenoRefillNumber, sizeof( m_nPlenoRefillNumber ) );
	m_clPlenoRefillAccessoryList.Read( inpf, true );

	if( false == ReadString( inpf, m_AdditionalTecBoxPlenoIDPtr.ID, sizeof( m_AdditionalTecBoxPlenoIDPtr.ID ) ) )
	{
		return false;
	}

	if( Version < 4 )
	{
		return true;
	}

	inpf.read( (char *)&m_eSelectionMode, sizeof( m_eSelectionMode ) );

	if( Version < 5 )
	{
		return true;
	}

	m_clTecBoxIntegratedVesselAccessoryList.Read( inpf, true );

	if( Version < 7 )
	{
		return true;
	}
	// Protection module with pleno.
	if( false == ReadString( inpf, m_TecBoxPlenoProtectionIDPtr.ID, sizeof( m_TecBoxPlenoProtectionIDPtr.ID ) ) )
	{
		return false;
	}

	m_clTecBoxPlenoProtecAccessoryList.Read( inpf, true );

	return true;
}

IDPTR CDS_SSelPMaint::_GetMbrIDPtr( IDPTR &idptr, CTADatabase *pDB )
{
	if( _T('\0') != *idptr.ID )
	{
		if( NULL == idptr.MP )
		{
			if( NULL == pDB )
			{
				idptr.DB = TASApp.GetpTADB();
			}
			else
			{
				idptr.DB = pDB;
			}

			Extend( &idptr );
		}
	}
	else
	{
		return _NULL_IDPTR;
	}

	return idptr;
}

void CDS_SSelPMaint::_SetMbreIDPtr( IDPTR &TrgIDPtr, const IDPTR &idptr, CTADatabase *pDB )
{
	if( TrgIDPtr != idptr )
	{
		TrgIDPtr = idptr;

		if( _T('\0') != *TrgIDPtr.ID && NULL == TrgIDPtr.MP )
		{
			if( NULL == pDB )
			{
				TrgIDPtr.DB = TASApp.GetpTADB();
			}
			else
			{
				TrgIDPtr.DB = pDB;
			}

			Extend( &TrgIDPtr );
		}

		Modified();
	}
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SSelDpCBCV
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SSelDpCBCV )

CDS_SSelDpCBCV::CDS_SSelDpCBCV( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SSelCtrl( pDataBase, ID )
{
	m_eProductSubCategory = ProductSubCategory::PSC_BC_CombinedDpCBalCtrlValve;
	m_DpCBCVActrSetIDPtr = _NULL_IDPTR;
	m_dDpToStabilize = 0.0;
	m_dHMin = 0.0;
	m_clSVAccessoryList.Clear();
	m_SVIDPtr = _NULL_IDPTR;
	m_iCheckboxWithSTS = BST_UNCHECKED;
}

void CDS_SSelDpCBCV::ResetCVActrSetIDPtr()
{
	m_DpCBCVActrSetIDPtr = _NULL_IDPTR;
}

IDPTR CDS_SSelDpCBCV::GetDpCBCVActrSetIDPtr()
{
	if( _T('\0') == *( m_DpCBCVActrSetIDPtr.ID ) )
	{
		m_DpCBCVActrSetIDPtr = _NULL_IDPTR;
		CTableSet *pDpCBCVActSetTab = dynamic_cast<CTableSet *>( TASApp.GetpTADB()->Get( _T("DPCBCVACTSET_TAB") ).MP );

		if( NULL != pDpCBCVActSetTab )
		{
			CDB_Set *pDpCBCVActSet = pDpCBCVActSetTab->FindCompatibleSet( GetProductIDPtr().ID, GetActrIDPtr().ID );

			if( pDpCBCVActSet != NULL )
			{
				m_DpCBCVActrSetIDPtr = pDpCBCVActSet->GetIDPtr();
			}
		}
	}

	return GetMbrIDPtr( m_DpCBCVActrSetIDPtr );
}

void CDS_SSelDpCBCV::Copy( CData *pclDestination )
{
	CDS_SSelDpCBCV *pclDestinationSSelDpCBCV = dynamic_cast<CDS_SSelDpCBCV *>( pclDestination );
	ASSERT( pclDestinationSSelDpCBCV != NULL );

	if( pclDestinationSSelDpCBCV != NULL )
	{
		// Call base class.
		CDS_SSelCtrl::Copy( static_cast<CDS_SSelCtrl *>( pclDestinationSSelDpCBCV ) );

		pclDestinationSSelDpCBCV->SetDpToStalibize( m_dDpToStabilize );
		pclDestinationSSelDpCBCV->SetHMin( m_dHMin );
		pclDestinationSSelDpCBCV->SetCheckboxWithSTS( m_iCheckboxWithSTS );
		pclDestinationSSelDpCBCV->SetSVIDPtr( GetSVIDPtr() );

		CAccessoryList *pclSVAccessoryList = pclDestinationSSelDpCBCV->GetSVAccessoryList();

		if( NULL != pclSVAccessoryList )
		{
			pclSVAccessoryList->Clear();
			m_clSVAccessoryList.CopyTo( pclSVAccessoryList );
		}
	}
}

#define CDS_SELDPCBCV_VERSION	2
// Version 2: 2016-09-12: Shutoff valve added.
void CDS_SSelDpCBCV::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SELDPCBCV_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CDS_SSelCtrl::Write( outf );

	WriteData<>( outf, m_dDpToStabilize );
	WriteData<>( outf, m_dHMin );

	// Version 2.
	WriteData<>( outf, m_iCheckboxWithSTS );
	WriteString( outf, (LPCTSTR)m_SVIDPtr.ID );
	m_clSVAccessoryList.Write( outf );
}

bool CDS_SSelDpCBCV::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_SELDPCBCV_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SELDPCBCV_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDS_SSelCtrl::Read( inpf ) )
	{
		return false;
	}

	inpf.read( (char *)&m_dDpToStabilize, sizeof( m_dDpToStabilize ) );
	inpf.read( (char *)&m_dHMin, sizeof( m_dHMin ) );

	if( Version < 2 )
	{
		return true;
	}

	inpf.read( (char *)&m_iCheckboxWithSTS, sizeof( m_iCheckboxWithSTS ) );

	if( false == ReadString( inpf, m_SVIDPtr.ID, sizeof( m_SVIDPtr.ID ) ) )
	{
		return false;
	}

	m_clSVAccessoryList.Read( inpf, true );

	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SSelSafetyValve
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SSelSafetyValve )

CDS_SSelSafetyValve::CDS_SSelSafetyValve( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SSel( pDataBase, ID )
{
	m_strSystemHeatGeneratorTypeID = _T("");
	m_strNormID = _T("");
	m_dInstalledPower = 0.0;
	m_dInstalledCollector = 0.0;
	m_strSafetyValveFamilyID = _T("");
	m_strSafetyValveConnectID = _T("");
	m_dSetPressure = 0.0;
	m_iQuantityNeeded = 0;
	m_eProductSubCategory = ProductSubCategory::PSC_PM_SafetyValve;
	m_BlowTankIDPtr = _NULL_IDPTR;
	m_clBlowTankAccessoryList.Clear();
}

void CDS_SSelSafetyValve::Copy( CData *pclDestination )
{
	CDS_SSelSafetyValve *pclDestinationSSelSafetyValve = dynamic_cast<CDS_SSelSafetyValve *>( pclDestination );
	ASSERT( NULL != pclDestinationSSelSafetyValve );

	if( NULL != pclDestinationSSelSafetyValve )
	{
		CDS_SSel::Copy( pclDestinationSSelSafetyValve );

		pclDestinationSSelSafetyValve->SetSystemHeatGeneratorTypeID( GetSystemHeatGeneratorTypeID() );
		pclDestinationSSelSafetyValve->SetNormID( GetNormID() );
		pclDestinationSSelSafetyValve->SetInstalledPower( GetInstalledPower() );
		pclDestinationSSelSafetyValve->SetInstalledCollector( GetInstalledPower() );
		pclDestinationSSelSafetyValve->SetSafetyValveFamilyID( GetSafetyValveFamilyID() );
		pclDestinationSSelSafetyValve->SetSafetyValveConnectID( GetSafetyValveConnectID() );
		pclDestinationSSelSafetyValve->SetSetPressure( GetSetPressure() );
		pclDestinationSSelSafetyValve->SetQuantityNeeded( GetQuantityNeeded() );
		pclDestinationSSelSafetyValve->SetBlowTankIDPtr( GetBlowTankIDPtr() );

		CAccessoryList *pclBlowTankAccessoryList = pclDestinationSSelSafetyValve->GetBlowTankAccessoryList();

		if( NULL != pclBlowTankAccessoryList )
		{
			pclBlowTankAccessoryList->Clear();
			m_clBlowTankAccessoryList.CopyTo( pclBlowTankAccessoryList );
		}
	}
}

void CDS_SSelSafetyValve::SetSystemHeatGeneratorTypeID( CString strSystemHeatGeneratorTypeID )
{
	if( 0 != m_strSystemHeatGeneratorTypeID.Compare( strSystemHeatGeneratorTypeID ) )
	{
		m_strSystemHeatGeneratorTypeID = strSystemHeatGeneratorTypeID;
		Modified();
	}
}

void CDS_SSelSafetyValve::SetNormID( CString strNormID )
{
	if( 0 != m_strNormID.Compare( strNormID ) )
	{
		m_strNormID = strNormID;
		Modified();
	}
}

void CDS_SSelSafetyValve::SetSafetyValveFamilyID( CString strSafetyValveTypeID )
{
	if( 0 != m_strSafetyValveFamilyID.Compare( strSafetyValveTypeID ) )
	{
		m_strSafetyValveFamilyID = strSafetyValveTypeID;
		Modified();
	}
}

void CDS_SSelSafetyValve::SetSafetyValveConnectID( CString strSafetyValveConnectID )
{
	if( 0 != m_strSafetyValveConnectID.Compare( strSafetyValveConnectID ) )
	{
		m_strSafetyValveConnectID = strSafetyValveConnectID;
		Modified();
	}
}

#define CDS_SSELSAFETYVALVE_VERSION		2
// Version 2: HYS-1061: Add blow tank selection.
void CDS_SSelSafetyValve::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SSELSAFETYVALVE_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CDS_SSel::Write( outf );

	// Infos.
	WriteString( outf, (LPCTSTR)m_strSystemHeatGeneratorTypeID );
	WriteString( outf, (LPCTSTR)m_strNormID );
	WriteData<>( outf, m_dInstalledPower );
	WriteData<>( outf, m_dInstalledCollector );
	WriteString( outf, (LPCTSTR)m_strSafetyValveFamilyID );
	WriteString( outf, (LPCTSTR)m_strSafetyValveConnectID );
	WriteData<>( outf, m_dSetPressure );
	WriteData<>( outf, m_iQuantityNeeded );

	// Version 2.
	WriteString( outf, (LPCTSTR)m_BlowTankIDPtr.ID );
	m_clBlowTankAccessoryList.Write( outf );
}

bool CDS_SSelSafetyValve::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_SSELSAFETYVALVE_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SSELSAFETYVALVE_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDS_SSel::Read( inpf ) )
	{
		return false;
	}

	// Info.
	m_strSystemHeatGeneratorTypeID = _T("");

	if( false == ReadString( inpf, m_strSystemHeatGeneratorTypeID ) )
	{
		return false;
	}

	m_strNormID = _T("");

	if( false == ReadString( inpf, m_strNormID ) )
	{
		return false;
	}

	inpf.read( (char *)&m_dInstalledPower, sizeof( m_dInstalledPower ) );
	inpf.read( (char *)&m_dInstalledCollector, sizeof( m_dInstalledCollector ) );

	m_strSafetyValveFamilyID = _T("");

	if( false == ReadString( inpf, m_strSafetyValveFamilyID ) )
	{
		return false;
	}

	m_strSafetyValveConnectID = _T("");

	if( false == ReadString( inpf, m_strSafetyValveConnectID ) )
	{
		return false;
	}

	inpf.read( (char *)&m_dSetPressure, sizeof( m_dSetPressure ) );
	inpf.read( (char *)&m_iQuantityNeeded, sizeof( m_iQuantityNeeded ) );

	if( Version < 2 )
	{
		return true;
	}

	if( false == ReadString( inpf, m_BlowTankIDPtr.ID, sizeof( m_BlowTankIDPtr.ID ) ) )
	{
		return false;
	}

	m_clBlowTankAccessoryList.Read( inpf, true );

	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SSelFloorHeatingManifold
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SSelFloorHeatingManifold )

CDS_SSelFloorHeatingManifold::CDS_SSelFloorHeatingManifold( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SSel( pDataBase, ID )
{
	m_eProductSubCategory = ProductSubCategory::PSC_TC_FloorHeatingControl;
}

void CDS_SSelFloorHeatingManifold::Copy( CData *pclDestination )
{
	CDS_SSelFloorHeatingManifold *pclDestinationSSelFloorHeatingManifold = dynamic_cast<CDS_SSelFloorHeatingManifold *>( pclDestination );
	ASSERT( NULL != pclDestinationSSelFloorHeatingManifold );

	if( NULL != pclDestinationSSelFloorHeatingManifold )
	{
		CDS_SSel::Copy( pclDestinationSSelFloorHeatingManifold );
	}
}

#define CDS_SSELFLOORHEATINGMANIFOLD_VERSION	1
void CDS_SSelFloorHeatingManifold::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SSELFLOORHEATINGMANIFOLD_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CDS_SSel::Write( outf );

	// Infos.
}

bool CDS_SSelFloorHeatingManifold::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_SSELFLOORHEATINGMANIFOLD_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SSELFLOORHEATINGMANIFOLD_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDS_SSel::Read( inpf ) )
	{
		return false;
	}

	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SSelFloorHeatingValve
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SSelFloorHeatingValve )

CDS_SSelFloorHeatingValve::CDS_SSelFloorHeatingValve( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SSel( pDataBase, ID )
{
	m_eProductSubCategory = ProductSubCategory::PSC_TC_FloorHeatingControl;
}

void CDS_SSelFloorHeatingValve::Copy( CData *pclDestination )
{
	CDS_SSelFloorHeatingValve *pclDestinationSSelFloorHeatingValve = dynamic_cast<CDS_SSelFloorHeatingValve *>( pclDestination );
	ASSERT( NULL != pclDestinationSSelFloorHeatingValve );

	if( NULL != pclDestinationSSelFloorHeatingValve )
	{
		CDS_SSel::Copy( pclDestinationSSelFloorHeatingValve );
	}
}

#define CDS_SSELFLOORHEATINGVALVE_VERSION	1
void CDS_SSelFloorHeatingValve::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SSELFLOORHEATINGVALVE_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CDS_SSel::Write( outf );

	// Infos.
}

bool CDS_SSelFloorHeatingValve::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_SSELFLOORHEATINGVALVE_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SSELFLOORHEATINGVALVE_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDS_SSel::Read( inpf ) )
	{
		return false;
	}

	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SSelFloorHeatingController
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SSelFloorHeatingController )

CDS_SSelFloorHeatingController::CDS_SSelFloorHeatingController( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SSel( pDataBase, ID )
{
	m_eProductSubCategory = ProductSubCategory::PSC_TC_FloorHeatingControl;
}

void CDS_SSelFloorHeatingController::Copy( CData *pclDestination )
{
	CDS_SSelFloorHeatingController *pclDestinationSSelFloorHeatingController = dynamic_cast<CDS_SSelFloorHeatingController *>( pclDestination );
	ASSERT( NULL != pclDestinationSSelFloorHeatingController );

	if( NULL != pclDestinationSSelFloorHeatingController )
	{
		CDS_SSel::Copy( pclDestinationSSelFloorHeatingController );
	}
}

#define CDS_SSELFLOORHEATINGCONTROLLER_VERSION	1
void CDS_SSelFloorHeatingController::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SSELFLOORHEATINGCONTROLLER_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CDS_SSel::Write( outf );

	// Infos.
}

bool CDS_SSelFloorHeatingController::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_SSELFLOORHEATINGCONTROLLER_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SSELFLOORHEATINGCONTROLLER_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDS_SSel::Read( inpf ) )
	{
		return false;
	}

	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SSelTapWaterControl
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SSelTapWaterControl )

CDS_SSelTapWaterControl::CDS_SSelTapWaterControl( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SSel( pDataBase, ID )
{
	m_eProductSubCategory = ProductSubCategory::PSC_TC_TapWaterControl;
}

void CDS_SSelTapWaterControl::Copy( CData *pclDestination )
{
	CDS_SSelTapWaterControl *pclDestinationSSelTapWaterControl = dynamic_cast<CDS_SSelTapWaterControl *>( pclDestination );
	ASSERT( NULL != pclDestinationSSelTapWaterControl );

	if( NULL != pclDestinationSSelTapWaterControl )
	{
		CDS_SSel::Copy( pclDestinationSSelTapWaterControl );
	}
}

#define CDS_SSELTAPWATERCONTROL_VERSION	1
void CDS_SSelTapWaterControl::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SSELTAPWATERCONTROL_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CDS_SSel::Write( outf );

	// Infos.
}

bool CDS_SSelTapWaterControl::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_SSELTAPWATERCONTROL_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SSELTAPWATERCONTROL_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDS_SSel::Read( inpf ) )
	{
		return false;
	}

	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SSelSmartControlValve
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SSelSmartControlValve )

CDS_SSelSmartControlValve::CDS_SSelSmartControlValve( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SSel( pDataBase, ID )
{
	m_eProductSubCategory = ProductSubCategory::PSC_BC_SmartControlValve;
	m_dDpMax = 0.0;
}

void CDS_SSelSmartControlValve::Copy( CData *pclDestination )
{
	CDS_SSelSmartControlValve *pclDestinationSSelSmartControlValve = dynamic_cast<CDS_SSelSmartControlValve *>( pclDestination );
	ASSERT( NULL != pclDestinationSSelSmartControlValve );

	if( NULL != pclDestinationSSelSmartControlValve )
	{
		CDS_SSel::Copy( static_cast<CDS_SSel *>( pclDestinationSSelSmartControlValve ) );

		pclDestinationSSelSmartControlValve->SetDpMax( m_dDpMax );
	}
}

#define CDS_SSELSMARTCONTROLVALVE_VERSION		2
// Version 2: 11-07-2022 - HYS-1939: TA-Smart Dp - 06 - Individual selection: create the datastruct object. Add Dpmax
void CDS_SSelSmartControlValve::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SSELSMARTCONTROLVALVE_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CDS_SSel::Write( outf );

	// Info.
	// Version 2: HYS-1939: TA-Smart Dp - 06 - Individual selection: create the datastruct object.
	WriteData<>( outf, m_dDpMax );
}

bool CDS_SSelSmartControlValve::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_SSELSMARTCONTROLVALVE_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SSELSMARTCONTROLVALVE_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDS_SSel::Read( inpf ) )
	{
		return false;
	}

	// Info.
	// HYS-1939: TA-Smart Dp - 06 - Individual selection: create the datastruct object.
	if( Version < 2 )
	{
		return true;
	}
	inpf.read( (char*)&m_dDpMax, sizeof( m_dDpMax ) );

	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SSelSmartDpC
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SSelSmartDpC )

CDS_SSelSmartDpC::CDS_SSelSmartDpC( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SSel( pDataBase, ID )
{
	m_DpSensorIDPtr = _NULL_IDPTR;
	m_SetIDPtr = _NULL_IDPTR;
	m_clDpSensorAccessoryList.Clear( CAccessoryList::_AT_Accessory );
	m_clSetContentAccessoryList.Clear( CAccessoryList::_AT_SetAccessory );
	m_iCheckboxDpBranch = BST_UNCHECKED;
	m_dDpBranch = 0.0;
	m_iCheckboxDpMax = BST_UNCHECKED;
	m_dDpMax = 0.0;
	m_iCheckboxOnlyForSet = 0;
	m_eProductSubCategory = ProductSubCategory::PSC_BC_SmartDpC;
}

void CDS_SSelSmartDpC::Copy( CData *pclDestination )
{
	CDS_SSelSmartDpC *pclDestinationSSelSmartDpC = dynamic_cast<CDS_SSelSmartDpC *>( pclDestination );
	ASSERT( NULL != pclDestinationSSelSmartDpC );

	if( NULL != pclDestinationSSelSmartDpC )
	{
		CDS_SSel::Copy( static_cast<CDS_SSel *>(pclDestinationSSelSmartDpC) );

		pclDestinationSSelSmartDpC->SetCheckboxDpBranch( GetCheckboxDpBranch() );
		pclDestinationSSelSmartDpC->SetDpBranchValue( GetDpBranchValue() );
		pclDestinationSSelSmartDpC->SetCheckboxDpMax( GetCheckboxDpMax() );
		pclDestinationSSelSmartDpC->SetDpMaxValue( GetDpMaxValue() );
		// HYS-1992: Remove set possibility of TA Smart Dp.
		//pclDestinationSSelSmartDpC->SetCheckboxOnlyForSet( GetCheckboxOnlyForSet() );
		pclDestinationSSelSmartDpC->SetDpSensorIDPtr( GetDpSensorIDPtr() );
		pclDestinationSSelSmartDpC->SetSetIDPtr( GetSetIDPtr() );

		CAccessoryList *pclDpSensorAccessoryList = pclDestinationSSelSmartDpC->GetDpSensorAccessoryList();

		if( NULL != pclDpSensorAccessoryList )
		{
			pclDpSensorAccessoryList->Clear( CAccessoryList::_AT_Accessory );
			m_clDpSensorAccessoryList.CopyTo( pclDpSensorAccessoryList );
		}

		CAccessoryList *pclConnectionSetAccessoryList = pclDestinationSSelSmartDpC->GetSetContentAccessoryList();

		if( NULL != pclConnectionSetAccessoryList )
		{
			pclConnectionSetAccessoryList->Clear( CAccessoryList::_AT_SetAccessory );
			m_clSetContentAccessoryList.CopyTo( pclConnectionSetAccessoryList );
		}
	}
}

#define CDS_SSELSMARTDPC_VERSION		2
// Version 2: 2022-12-05 HYS-1992: Remove set possibility of TA Smart Dp.
// Version 1: 2022-08-07 HYS-1939: TA-Smart Dp - 06 - Individual selection: create the datastruct object.
void CDS_SSelSmartDpC::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SSELSMARTDPC_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CDS_SSel::Write( outf );

	// Info.
	WriteData<>( outf, m_iCheckboxDpBranch );
	WriteData<>( outf, m_dDpBranch );
	WriteData<>( outf, m_iCheckboxDpMax );
	WriteData<>( outf, m_dDpMax );
	// HYS-1992:
	//WriteData<>( outf, m_iCheckboxOnlyForSet );
	WriteString( outf, (LPCTSTR)m_DpSensorIDPtr.ID );
	WriteString( outf, (LPCTSTR)m_SetIDPtr.ID );

	m_clDpSensorAccessoryList.Write( outf );
	m_clSetContentAccessoryList.Write( outf );
}

bool CDS_SSelSmartDpC::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_SSELSMARTDPC_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SSELSMARTDPC_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDS_SSel::Read( inpf ) )
	{
		return false;
	}

	// Info.
	inpf.read( (char*)&m_iCheckboxDpBranch, sizeof( m_iCheckboxDpBranch ) );
	inpf.read( (char*)&m_dDpBranch, sizeof( m_dDpBranch ) );
	inpf.read( (char*)&m_iCheckboxDpMax, sizeof( m_iCheckboxDpMax ) );
	inpf.read( (char*)&m_dDpMax, sizeof( m_dDpMax ) );

	// HYS-1992: Remove set possibility of TA Smart Dp.
	if( Version == 1 )
	{
		inpf.read( (char*)&m_iCheckboxOnlyForSet, sizeof( m_iCheckboxOnlyForSet ) );
	}

	if( false == ReadString( inpf, m_DpSensorIDPtr.ID, sizeof( m_DpSensorIDPtr.ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_SetIDPtr.ID, sizeof( m_SetIDPtr.ID ) ) )
	{
		return false;
	}

	m_clDpSensorAccessoryList.Read( inpf, true );
	m_clSetContentAccessoryList.Read( inpf, true );

	return true;
}

IDPTR CDS_SSelSmartDpC::_GetMbrIDPtr( IDPTR &idptr, CTADatabase *pDB )
{
	if( _T('\0') != *idptr.ID )
	{
		if( NULL == idptr.MP )
		{
			if( NULL == pDB )
			{
				idptr.DB = TASApp.GetpTADB();
			}
			else
			{
				idptr.DB = pDB;
			}

			Extend( &idptr );
		}
	}
	else
	{
		return _NULL_IDPTR;
	}

	return idptr;
}

void CDS_SSelSmartDpC::_SetMbreIDPtr( IDPTR &TrgIDPtr, const IDPTR &idptr, CTADatabase *pDB )
{
	if( TrgIDPtr != idptr )
	{
		TrgIDPtr = idptr;

		if( _T('\0') != *TrgIDPtr.ID && NULL == TrgIDPtr.MP )
		{
			if( NULL == pDB )
			{
				TrgIDPtr.DB = TASApp.GetpTADB();
			}
			else
			{
				TrgIDPtr.DB = pDB;
			}

			Extend( &TrgIDPtr );
		}

		Modified();
	}
}

///////////////////////////////////////////////////////////////////////////////////
//
//								HYS-1741: CDS_SelPWQAccServices
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SelPWQAccServices )

CDS_SelPWQAccServices::CDS_SelPWQAccServices( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SSel( pDataBase, ID )
{
	m_eProductSubCategory = ProductSubCategory::PSC_PM_SafetyValve;
}

void CDS_SelPWQAccServices::Copy( CData *pclDestination )
{
	CDS_SelPWQAccServices *pclDestinationSelPWQAccServices = dynamic_cast<CDS_SelPWQAccServices *>( pclDestination );
	ASSERT( NULL != pclDestinationSelPWQAccServices );

	if( NULL != pclDestinationSelPWQAccServices )
	{
		CDS_SSel::Copy( static_cast<CDS_SSel *>(pclDestinationSelPWQAccServices) );

		// No data yet.
	}
}

#define CDS_SELPWQACCANDSERVICES_VERSION		1
void CDS_SelPWQAccServices::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SELPWQACCANDSERVICES_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CDS_SSel::Write( outf );

	// Info.
	// No data yet.
}

bool CDS_SelPWQAccServices::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_SELPWQACCANDSERVICES_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SELPWQACCANDSERVICES_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDS_SSel::Read( inpf ) )
	{
		return false;
	}

	// Info.
	// No data yet.

	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SelPWQPressureReducer
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_SelPWQPressureReducer )

CDS_SelPWQPressureReducer::CDS_SelPWQPressureReducer( CDataBase *pDataBase, LPCTSTR ID )
	: CDS_SelPWQAccServices( pDataBase, ID )
{
	m_dMaxInletPressure = 0.0;
	m_dMinOutletPressure = 0.0;
	m_dMaxOutletPressure = 0.0;
}

void CDS_SelPWQPressureReducer::Copy( CData *pclDestination )
{
	CDS_SelPWQPressureReducer *pclDestinationSelPWQPressureReducer = dynamic_cast<CDS_SelPWQPressureReducer*>( pclDestination );
	ASSERT( NULL != pclDestinationSelPWQPressureReducer );

	if( NULL != pclDestinationSelPWQPressureReducer )
	{
		CDS_SelPWQAccServices::Copy( static_cast<CDS_SelPWQAccServices*>(pclDestinationSelPWQPressureReducer) );

		pclDestinationSelPWQPressureReducer->SetMaxInletPressure( GetMaxInletPressure() );
		pclDestinationSelPWQPressureReducer->SetMinOutletPressure( GetMinOutletPressure() );
		pclDestinationSelPWQPressureReducer->SetMaxOutletPressure( GetMaxOutletPressure() );
	}
}

#define CDS_SELPWQPRESSUREREDUCER_VERSION		1
void CDS_SelPWQPressureReducer::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_SELPWQPRESSUREREDUCER_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CDS_SelPWQAccServices::Write( outf );

	// Info.
	WriteData<>( outf, m_dMaxInletPressure );
	WriteData<>( outf, m_dMinOutletPressure );
	WriteData<>( outf, m_dMaxOutletPressure );
}

bool CDS_SelPWQPressureReducer::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_SELPWQPRESSUREREDUCER_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_SELPWQPRESSUREREDUCER_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDS_SelPWQAccServices::Read( inpf ) )
	{
		return false;
	}

	// Info.
	inpf.read( (char*)&m_dMaxInletPressure, sizeof( m_dMaxInletPressure ) );
	inpf.read( (char*)&m_dMinOutletPressure, sizeof( m_dMinOutletPressure ) );
	inpf.read( (char*)&m_dMaxOutletPressure, sizeof( m_dMaxOutletPressure ) );

	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_SSelDpSensor
//
///////////////////////////////////////////////////////////////////////////////////
// HYS-2007: Add CDS_SSelDpSensor for TA Link selected alone.

IMPLEMENT_DATA( CDS_SSelDpSensor )

CDS_SSelDpSensor::CDS_SSelDpSensor( CDataBase* pDataBase, LPCTSTR ID )
	: CDS_SSel( pDataBase, ID )
{
	m_pSelectedInfos = new CSelectedInfos( this );
}

CDS_SSelDpSensor::~CDS_SSelDpSensor()
{
	if( NULL != m_pSelectedInfos )
	{
		delete m_pSelectedInfos;
	}
}

void CDS_SSelDpSensor::Copy( CData* pclDestination )
{
	CData::Copy( pclDestination );

	CDS_SSelDpSensor* pclDestinationDpSensor = dynamic_cast<CDS_SSelDpSensor*>(pclDestination);

	if( NULL != pclDestinationDpSensor )
	{
		m_pSelectedInfos->Copy( pclDestinationDpSensor->GetpSelectedInfos() );
	}
}

int CDS_SSelDpSensor::CompareSelectionTo( CData* pclSelectionCompareWith, int iKey )
{
	if( NULL == pclSelectionCompareWith )
	{
		return 0;
	}

	CDS_SSelDpSensor* pclDpSensorCompareWith = dynamic_cast<CDS_SSelDpSensor*>(pclSelectionCompareWith);

	if( NULL == pclDpSensorCompareWith )
	{
		return CData::CompareSelectionTo( pclSelectionCompareWith, iKey );
	}

	CDB_DpSensor* pclDpSensorToCompare = GetProductAs<CDB_DpSensor>();
	CDB_DpSensor* pclDpSensorCompareWidth = pclDpSensorCompareWith->GetProductAs<CDB_DpSensor>();

	int iReturn = 0;

	switch( iKey )
	{
	case PageField_enum::epfBVINFOPRODUCTNAME:

		if( (NULL != pclDpSensorToCompare && NULL != pclDpSensorCompareWidth) )
		{
			iReturn = StringCompare( pclDpSensorToCompare->GetName(), pclDpSensorCompareWidth->GetName() );
		}

		break;

	case PageField_enum::epfARTICLE:

		if( (NULL != pclDpSensorToCompare && NULL != pclDpSensorCompareWidth) )
		{
			if( false == TASApp.IsTAArtNumberHidden() )
			{
				iReturn = StringCompare( pclDpSensorToCompare->GetArtNum(), pclDpSensorCompareWidth->GetArtNum() );
			}
			else
			{
				CString strLocArtNum1 = LocArtNumTab.GetLocalArticleNumber( pclDpSensorToCompare->GetArtNum() );
				CString strLocArtNum2 = LocArtNumTab.GetLocalArticleNumber( pclDpSensorCompareWidth->GetArtNum() );
				iReturn = StringCompare( strLocArtNum1, strLocArtNum2 );
			}
		}

		break;

	default:
		iReturn = CData::CompareSelectionTo( pclSelectionCompareWith, iKey );
	}

	return iReturn;
}

#define CDS_DPSENSOR_VERSION	1
void CDS_SSelDpSensor::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_DPSENSOR_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CDS_SSel::Write( outf );

	// Info.
	m_pSelectedInfos->Write( outf );
}

bool CDS_SSelDpSensor::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_DPSENSOR_VERSION;
	inpf.read( (char*)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_DPSENSOR_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDS_SSel::Read( inpf ) )
	{
		return false;
	}

	// Info.
	m_pSelectedInfos->Read( inpf );
	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_Actuator
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_Actuator )

CDS_Actuator::CDS_Actuator( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
	m_pSelectedInfos = new CSelectedInfos( this );
	m_ActuatorIDPtr = _NULL_IDPTR;
	m_vecActuatorAccessory.clear();
}

CDS_Actuator::~CDS_Actuator()
{
	if( m_pSelectedInfos != NULL )
	{
		delete m_pSelectedInfos;
	}
}

void CDS_Actuator::SetActuatorIDPtr( const IDPTR &idptr )
{
	if( m_ActuatorIDPtr != idptr )
	{
		m_ActuatorIDPtr = idptr;

		if( _T('\0') != *m_ActuatorIDPtr.ID && NULL == m_ActuatorIDPtr.MP )
		{
			m_ActuatorIDPtr.DB = TASApp.GetpTADB();
			Extend( &m_ActuatorIDPtr );
		}

		Modified();
	}
}

void CDS_Actuator::AddActuatorAccessory( const IDPTR &idptr, CDB_RuledTableBase *pclRuledTable )
{
	AccessoryItem rAccessoryItem;
	rAccessoryItem.IDPtr = idptr;
	rAccessoryItem.fByPair = false;
	
	// HYS-987: Init lEditedQty.
	rAccessoryItem.lEditedQty = -1;

	if( NULL != pclRuledTable && true == pclRuledTable->IsByPair( idptr.ID ) )
	{
		rAccessoryItem.fByPair = true;
	}

	m_vecActuatorAccessory.push_back( rAccessoryItem );
	Modified();
}

void CDS_Actuator::AddActuatorAccessory( AccessoryItem *prAccessoryItem )
{
	if( NULL == prAccessoryItem )
	{
		return;
	}

	AccessoryItem rAccessoryItem;
	rAccessoryItem.IDPtr = prAccessoryItem->IDPtr;
	rAccessoryItem.fByPair = prAccessoryItem->fByPair;
	
	// HYS-987: Copy lEditedQty.
	rAccessoryItem.lEditedQty = prAccessoryItem->lEditedQty;
	m_vecActuatorAccessory.push_back( rAccessoryItem );
	Modified();
}

void CDS_Actuator::SetEditedQty( AccessoryItem AccItem, long lQty )
{
	for( int i = 0; i < (int)m_vecActuatorAccessory.size(); i++ )
	{
		if( m_vecActuatorAccessory[i].IDPtr.IDMatch( AccItem.IDPtr.ID ) )
		{
			m_vecActuatorAccessory[i].lEditedQty = lQty;
		}
	}
}

IDPTR CDS_Actuator::GetActuatorIDPtr()
{
	if( _T('\0') != *m_ActuatorIDPtr.ID )
	{
		if( NULL == m_ActuatorIDPtr.MP )
		{
			m_ActuatorIDPtr.DB = TASApp.GetpTADB();
			Extend( &m_ActuatorIDPtr );
		}
	}
	else
	{
		return _NULL_IDPTR;
	}

	return m_ActuatorIDPtr;
}

void CDS_Actuator::Copy( CData *pclDestination )
{
	CData::Copy( pclDestination );
	CDS_Actuator *pclDestinationActuator = dynamic_cast<CDS_Actuator *>( pclDestination );

	if( NULL != pclDestinationActuator )
	{
		pclDestinationActuator->SetActuatorIDPtr( GetActuatorIDPtr() );
		pclDestinationActuator->ClearActuatorAccessories();

		for( int i = 0; i < ( int )m_vecActuatorAccessory.size(); i++ )
		{
			pclDestinationActuator->AddActuatorAccessory( &m_vecActuatorAccessory[i] );
		}

		m_pSelectedInfos->Copy( pclDestinationActuator->GetpSelectedInfos() );
	}
}

int CDS_Actuator::CompareSelectionTo( CData *pclSelectionCompareWith, int iKey )
{
	if( NULL == pclSelectionCompareWith )
	{
		return 0;
	}

	CDS_Actuator *pclActuatorCompareWith = dynamic_cast<CDS_Actuator *>( pclSelectionCompareWith );

	if( NULL == pclActuatorCompareWith )
	{
		return CData::CompareSelectionTo( pclSelectionCompareWith, iKey );
	}

	CDB_Actuator *pclActuatorToCompare = dynamic_cast<CDB_Actuator *>( m_ActuatorIDPtr.MP );
	CDB_Actuator *pclActuatorCompareWidth = dynamic_cast<CDB_Actuator *>( pclActuatorCompareWith->GetActuatorIDPtr().MP );

	int iReturn = 0;

	switch( iKey )
	{
		case PageField_enum::epfBVINFOPRODUCTNAME:

			if( NULL != pclActuatorToCompare && NULL != pclActuatorCompareWidth )
			{
				iReturn = StringCompare( pclActuatorToCompare->GetName(), pclActuatorCompareWidth->GetName() );
			}

			break;

		case PageField_enum::epfARTICLE:

			if( NULL != pclActuatorToCompare && NULL != pclActuatorCompareWidth )
			{
				if( false == TASApp.IsTAArtNumberHidden() )
				{
					iReturn = StringCompare( pclActuatorToCompare->GetArtNum(), pclActuatorCompareWidth->GetArtNum() );
				}
				else
				{
					CString strLocArtNum1 = LocArtNumTab.GetLocalArticleNumber( pclActuatorToCompare->GetArtNum() );
					CString strLocArtNum2 = LocArtNumTab.GetLocalArticleNumber( pclActuatorCompareWidth->GetArtNum() );
					iReturn = StringCompare( strLocArtNum1, strLocArtNum2 );
				}
			}

			break;

		default:
			iReturn = CData::CompareSelectionTo( pclSelectionCompareWith, iKey );
	}

	return iReturn;
}

#define CDS_ACTUATOR_VERSION	2
// Version 2: add 'fByPair'.
void CDS_Actuator::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_ACTUATOR_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CData::Write( outf );

	// Info.
	WriteString( outf, (LPCTSTR)m_ActuatorIDPtr.ID );
	m_pSelectedInfos->Write( outf );

	int i = m_vecActuatorAccessory.size();
	WriteData<>( outf, i );

	for( int i = 0; i < ( int )m_vecActuatorAccessory.size(); i++ )
	{
		WriteString( outf, (LPCTSTR)m_vecActuatorAccessory[i].IDPtr.ID );
		WriteData<>( outf, m_vecActuatorAccessory[i].fByPair );
	}
}

bool CDS_Actuator::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_ACTUATOR_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_ACTUATOR_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Info.
	m_ActuatorIDPtr = _NULL_IDPTR;

	if( false == ReadString( inpf, m_ActuatorIDPtr.ID, sizeof( m_ActuatorIDPtr.ID ) ) )
	{
		return false;
	}

	m_pSelectedInfos->Read( inpf );

	m_vecActuatorAccessory.clear();
	int i = 0;
	inpf.read( (char *)&i, sizeof( int ) );

	for( ; i > 0; i-- )
	{
		AccessoryItem rAccessoryItem;
		rAccessoryItem.IDPtr = _NULL_IDPTR;
		rAccessoryItem.fByPair = false;
		rAccessoryItem.IDPtr.DB = TASApp.GetpTADB();

		if( false == ReadString( inpf, rAccessoryItem.IDPtr.ID, sizeof( rAccessoryItem.IDPtr.ID ) ) )
		{
			return false;
		}

		Extend( &rAccessoryItem.IDPtr );

		if( Version > 1 )
		{
			inpf.read( (char *)&rAccessoryItem.fByPair, sizeof( rAccessoryItem.fByPair ) );
		}

		m_vecActuatorAccessory.push_back( rAccessoryItem );
	}

	return true;
}
///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_Accessory
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDS_Accessory )

CDS_Accessory::CDS_Accessory( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
	m_pSelectedInfos = new CSelectedInfos( this );
	m_AccessoryIDPtr = _NULL_IDPTR;
}

CDS_Accessory::~CDS_Accessory()
{
	if( NULL != m_pSelectedInfos )
	{
		delete m_pSelectedInfos;
	}
}

void CDS_Accessory::SetAccessoryIDPtr( const IDPTR &idptr )
{
	if( m_AccessoryIDPtr != idptr )
	{
		m_AccessoryIDPtr = idptr;

		if( _T('\0') != *m_AccessoryIDPtr.ID && NULL == m_AccessoryIDPtr.MP )
		{
			m_AccessoryIDPtr.DB = TASApp.GetpTADB();
			Extend( &m_AccessoryIDPtr );
		}

		Modified();
	}
}

IDPTR CDS_Accessory::GetAccessoryIDPtr()
{
	if( _T('\0') != *m_AccessoryIDPtr.ID )
	{
		if( NULL == m_AccessoryIDPtr.MP )
		{
			m_AccessoryIDPtr.DB = TASApp.GetpTADB();
			Extend( &m_AccessoryIDPtr );
		}
	}
	else
	{
		return _NULL_IDPTR;
	}

	return m_AccessoryIDPtr;
}

void CDS_Accessory::Copy( CData *pclDestination )
{
	CData::Copy( pclDestination );
	
	CDS_Accessory *pclDestinationAccessory = dynamic_cast<CDS_Accessory *>( pclDestination );

	if( NULL != pclDestinationAccessory )
	{
		pclDestinationAccessory->SetAccessoryIDPtr( GetAccessoryIDPtr() );
		m_pSelectedInfos->Copy( pclDestinationAccessory->GetpSelectedInfos() );
	}
}

int CDS_Accessory::CompareSelectionTo( CData *pclSelectionCompareWith, int iKey )
{
	if( NULL == pclSelectionCompareWith )
	{
		return 0;
	}

	CDS_Accessory *pclAccessoryCompareWith = dynamic_cast<CDS_Accessory *>( pclSelectionCompareWith );

	if( NULL == pclAccessoryCompareWith )
	{
		return CData::CompareSelectionTo( pclSelectionCompareWith, iKey );
	}

	CDB_Product *pclAccessoryToCompare = dynamic_cast<CDB_Product *>( m_AccessoryIDPtr.MP );
	CDB_Product *pclAccessoryCompareWidth = dynamic_cast<CDB_Product *>( pclAccessoryCompareWith->GetAccessoryIDPtr().MP );

	int iReturn = 0;

	switch( iKey )
	{
		case PageField_enum::epfBVINFOPRODUCTNAME:

			if( ( NULL != pclAccessoryToCompare && NULL != pclAccessoryCompareWidth ) 
					&&  ( pclAccessoryToCompare->IsAnAccessory() ) && ( pclAccessoryCompareWidth->IsAnAccessory() ) )
			{
				iReturn = StringCompare( pclAccessoryToCompare->GetName(), pclAccessoryCompareWidth->GetName() );
			}

			break;

		case PageField_enum::epfARTICLE:

			if( ( NULL != pclAccessoryToCompare && NULL != pclAccessoryCompareWidth )
					&& ( pclAccessoryToCompare->IsAnAccessory() ) && ( pclAccessoryCompareWidth->IsAnAccessory() ) )
			{
				if( false == TASApp.IsTAArtNumberHidden() )
				{
					iReturn = StringCompare( pclAccessoryToCompare->GetArtNum(), pclAccessoryCompareWidth->GetArtNum() );
				}
				else
				{
					CString strLocArtNum1 = LocArtNumTab.GetLocalArticleNumber( pclAccessoryToCompare->GetArtNum() );
					CString strLocArtNum2 = LocArtNumTab.GetLocalArticleNumber( pclAccessoryCompareWidth->GetArtNum() );
					iReturn = StringCompare( strLocArtNum1, strLocArtNum2 );
				}
			}

			break;

		default:
			iReturn = CData::CompareSelectionTo( pclSelectionCompareWith, iKey );
	}

	return iReturn;
}

#define CDS_ACCESSORY_VERSION	1
void CDS_Accessory::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_ACCESSORY_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CData::Write( outf );

	// Info.
	WriteString( outf, (LPCTSTR)m_AccessoryIDPtr.ID );
	m_pSelectedInfos->Write( outf );
}

bool CDS_Accessory::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_ACCESSORY_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_ACCESSORY_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Info.
	m_AccessoryIDPtr = _NULL_IDPTR;

	if( false == ReadString( inpf, m_AccessoryIDPtr.ID, sizeof( m_AccessoryIDPtr.ID ) ) )
	{
		return false;
	}

	m_pSelectedInfos->Read( inpf );
	return true;
}
#endif

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_PlantX
//
///////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DATA( CDS_PlantX )
CDS_PlantX::CDS_PlantX( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_MultiString( pDataBase, ID )
{
	m_QMMap.clear();
	memset( &m_HMXData, 0, sizeof( m_HMXData ) );
	m_LogVector.clear();
	memset( &m_TSCFn, 0, 30 * sizeof( char ) );
	m_ModDate = 0;
}

#define CDS_PLANTX_VERSION	5
void CDS_PlantX::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_PLANTX_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CDB_MultiString::Write( outf );
	outf.write( (char *)&m_TSCFn, sizeof( m_TSCFn ) );
	WriteData<>( outf, m_ModDate );

	// Specific treatment for MetaData File.
	// Plant_Info exist only ones and should be updated with the current content of DB,
	// for other Plants (object are dynamically created) data should be written as they are.
	if( 0 == IDcmp( _T("PLANT_INFO"), GetIDPtr().ID ) )
	{
		CDS_QMTable *pQMTab = static_cast<CDS_QMTable *>( ( static_cast<CDataBase *>( GetIDPtr().DB ) )->Get( _T("QUICKMEAS_TAB") ).MP );
		int iExist = 0x55AA55AA;

		if( NULL != pQMTab )
		{
			iExist = 0x55AA55AA;
			WriteData<>( outf, iExist );
			pQMTab->WriteShortInfos( outf );
		}
		else
		{
			iExist = 0x0;
			WriteData<>( outf, iExist );
		}

		CDS_HMXTable *pHMXTab = static_cast<CDS_HMXTable *>( ( static_cast<CDataBase *>( GetIDPtr().DB ) )->Get( _T("PIPING_TAB") ).MP );

		if( NULL != pHMXTab )
		{
			iExist = 0x55AA55AA;
			WriteData<>( outf, iExist );
			pHMXTab->WriteShortInfos( outf );
		}
		else
		{
			iExist = 0x0;
			WriteData<>( outf, iExist );
		}

		CDS_LogTable *pLogTable = static_cast<CDS_LogTable *>( ( static_cast<CDataBase *>( GetIDPtr().DB ) )->Get( _T("LOGGEDDATA_TAB") ).MP );

		if( NULL != pLogTable )
		{
			iExist = 0x55AA55AA;
			WriteData<>( outf, iExist );
			pLogTable->WriteShortInfos( outf );
		}
		else
		{
			iExist = 0x0;
			WriteData<>( outf, iExist );
		}
	}
	else
	{
		int iExist = 0x55AA55AA;
		WriteData<>( outf, iExist );
		CDS_QMTable::WriteShortInfos( outf, &m_QMMap );

		WriteData<>( outf, iExist );
		CDS_HMXTable::WriteShortInfos( outf, &m_HMXData );

		WriteData<>( outf, iExist );
		CDS_LogTable::WriteShortInfos( outf, &m_LogVector );
	}
}

bool CDS_PlantX::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_PLANTX_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_PLANTX_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDB_MultiString::Read( inpf ) )
	{
		return false;
	}

	if( Version > 4 )
	{
		inpf.read( (char *)&m_TSCFn, sizeof( m_TSCFn ) );
	}

	inpf.read( (char *)&m_ModDate, sizeof( m_ModDate ) );
	int iExist = -1;

	if( Version < 4 )
	{
		if( false == CDS_QMTable::ReadShortInfos( inpf, &m_QMMap ) )
		{
			return false;
		}

		if( false == CDS_HMXTable::ReadShortInfos( inpf, &m_HMXData ) )
		{
			return false;
		}

		if( false == CDS_LogTable::ReadShortInfos( inpf, &m_LogVector ) )
		{
			return false;
		}
	}
	else
	{
		inpf.read( (char *)&iExist, sizeof( iExist ) );

		if( 0x55AA55AA == iExist )
		{
			if( !CDS_QMTable::ReadShortInfos( inpf, &m_QMMap ) )
			{
				return false;
			}
		}

		inpf.read( (char *)&iExist, sizeof( iExist ) );

		if( 0x55AA55AA == iExist )
		{
			if( !CDS_HMXTable::ReadShortInfos( inpf, &m_HMXData ) )
			{
				return false;
			}
		}

		inpf.read( (char *)&iExist, sizeof( iExist ) );

		if( 0x55AA55AA == iExist )
		{
			if( !CDS_LogTable::ReadShortInfos( inpf, &m_LogVector ) )
			{
				return false;
			}
		}
	}

	return true;
}
///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_LogTable
// Tools table replace the 'standard' CTable for LOGGEDDATA_TAB
//
///////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DATA( CDS_LogTable )

#define CDS_LOGTABLE_SHORTINFOS_VERSION	1
bool CDS_LogTable::WriteShortInfos( OUTSTREAM outf, std::vector<CDS_LogTable::sLogTable> *pList )
{
	if( NULL == pList )
	{
		return false;
	}

	// Version.
	BYTE Version = CDS_LOGTABLE_SHORTINFOS_VERSION;
	WriteData<>( outf, Version );

	// Log Number.
	int Nlog = pList->size();
	sLogTable LogTable;
	WriteData<>( outf, Nlog );

	for( int i = 0; i < Nlog; i++ )
	{
		LogTable = pList->at( i );
		WriteData<>( outf, LogTable.LogType );
		WriteString( outf, LogTable.Name );
		WriteData<>( outf, LogTable.uSize );
		WriteData<>( outf, LogTable.tStartingDateTime );
		WriteData<>( outf, LogTable.MeasStep );
	}

	return true;
}

bool CDS_LogTable::WriteShortInfos( OUTSTREAM outf )
{
	sLogTable LogTable;
	std::vector<CDS_LogTable::sLogTable> List;
	
	// Log Number.
	int Nlog = GetItemCount();
	List.resize( Nlog );
	int i = 0;

	// Write information for each log.
	for( IDPTR idptr = GetFirst(); NULL != idptr.MP; idptr = GetNext( idptr.MP ) )
	{
		CDS_LogDataX *pLDX = dynamic_cast<CDS_LogDataX *>( idptr.MP );

		if( NULL == pLDX )
		{
			continue;
		}

		LogTable.LogType = pLDX->GetLogType();

#ifdef TACBX
		wcscpy( LogTable.Name, pLDX->GetName() );
#else
		wcscpy_s( LogTable.Name, SIZEOFINTCHAR( LogTable.Name ), pLDX->GetName() );
#endif

		LogTable.uSize =  pLDX->GetSize();
		LogTable.MeasStep = pLDX->GetStartingDateTime( &LogTable.tStartingDateTime );
		List[i] = LogTable;
		i++;
	}

	bool bRet = WriteShortInfos( outf, &List );

	return bRet;
}

bool CDS_LogTable::ReadShortInfos( INPSTREAM  inpf, std::vector<CDS_LogTable::sLogTable> *pList )
{
	if( NULL == pList )
	{
		return false;
	}

	// Version.
	BYTE Version = CDS_LOGTABLE_SHORTINFOS_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_LOGTABLE_SHORTINFOS_VERSION )
	{
		return false;
	}

	// Log Number.
	int Nlog = 0;
	inpf.read( (char *)&Nlog, sizeof( Nlog ) );
	sLogTable LogTable;
	pList->resize( Nlog );

	for( int i = 0; i < Nlog; i++ )
	{
		inpf.read( (char *)&LogTable.LogType, sizeof( LogTable.LogType ) );

		if( false == ReadString( inpf, LogTable.Name, sizeof( LogTable.Name ) ) )
		{
			return false;
		}

		inpf.read( (char *)&LogTable.uSize, sizeof( LogTable.uSize ) );
		inpf.read( (char *)&LogTable.tStartingDateTime, sizeof( LogTable.tStartingDateTime ) );
		inpf.read( (char *)&LogTable.MeasStep, sizeof( LogTable.MeasStep ) );
		( *pList )[i] = LogTable;
	}

	return true;
}

bool CDS_LogTable::VerifyLogExist( CDS_LogDataX *pLog, IDPTR *idptr )
{
	// Variables.
	__time32_t StartingDateTime;
	__time32_t CurrentStartingDateTime;

	// Make the verification with the name and the Date.
	LPCTSTR lpName = pLog->GetName();
	pLog->GetStartingDateTime( &StartingDateTime );

	// Do a loop on the table and verify the object.
	for( IDPTR IDPtr = GetFirst( CLASS( CDS_LogDataX ) ); _T('\0') != *IDPtr.ID; IDPtr = GetNext( IDPtr.MP ) )
	{
		CDS_LogDataX *pLogX = dynamic_cast<CDS_LogDataX *>( IDPtr.MP );
		ASSERT( NULL != pLogX );

		if( NULL != pLogX )
		{
			if( 0 == IDcmp( pLogX->GetName(), lpName ) )
			{
				pLogX->GetStartingDateTime( &CurrentStartingDateTime );

				if( StartingDateTime == CurrentStartingDateTime )
				{
					*idptr = IDPtr;
					return true;
				}
			}
		}
	}

	return false;
}

void CDS_LogTable::Copy( CData *pclDestination )
{
	CTable::Copy( pclDestination );
}

#define CDS_LOGTABLE_VERSION	1
void CDS_LogTable::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_LOGTABLE_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CTable::Write( outf );
}

bool CDS_LogTable::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_LOGTABLE_VERSION;

	// Manage old version of TAScope where CDS_LogTable was not written.
	if( _ttoi( GetIDPtr().DB->GetVersion() ) > _ttoi( TASCOPE_BASE_FORMAT_VERSION ) )
	{
		inpf.read( (char *)&Version, sizeof( Version ) );
	}

	if( Version < 1 || Version > CDS_LOGTABLE_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CTable::Read( inpf ) )
	{
		return false;
	}

	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_HMXTable
//
///////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DATA( CDS_HMXTable )

void CDS_HMXTable::CountBalancedValves( CTable *pTab, sHMXTab *pHMXData )
{
	if( NULL == pTab || NULL == pHMXData )
	{
		return;
	}

	for( IDPTR IDPtr = pTab->GetFirst(); NULL != IDPtr.MP; IDPtr = pTab->GetNext( IDPtr.MP ) )
	{
		CDS_HydroModX *pHM = dynamic_cast<CDS_HydroModX *>( IDPtr.MP );

		if( NULL == pHM )
		{
			continue;
		}

		// Add flow only of top modules.
		CDS_HydroModX *pParentHMX = dynamic_cast<CDS_HydroModX *>( pHM->GetIDPtr().PP );

		if( NULL == pParentHMX )
		{
			pHMXData->dHMXTotalQ += pHM->GetDesignFlow( CDS_HydroModX::InPrimary );
		}

		if( NULL != pHM->GetpMeasValve( CDS_HydroModX::InPrimary ) )
		{
			if( pHM->IsTABalMeasCompleted( CDS_HydroModX::InPrimary ) )
			{
				pHMXData->HMXAdjValve++;
			}

			pHMXData->HMXNbrValve++;
		}

		if( NULL != pHM->GetpMeasValve( CDS_HydroModX::InSecondary ) )
		{
			if( true == pHM->IsTABalMeasCompleted( CDS_HydroModX::InSecondary ) )
			{
				pHMXData->HMXAdjValve++;
			}

			pHMXData->HMXNbrValve++;
		}

		if( true == pHM->IsaModule() )
		{
			if( true == pHM->IsBalanced() )
			{
				pHMXData->HMXBalMod++;
			}

			pHMXData->HMXNbrMod++;
			CountBalancedValves( pHM, pHMXData );
		}
	}
}

#ifndef TACBX
// Run all distribution/circuit pipes in all modules to check if exists in user database.
bool CDS_HMXTable::IsAllPipeExistsInUserDB( CTable *pTable, CDataBase *pUserDB )
{
	bool bReturn = true;

	// Run all hydromodx.
	for( IDPTR IDPtr = pTable->GetFirst(); NULL != IDPtr.MP; IDPtr = pTable->GetNext( IDPtr.MP ) )
	{
		CDS_HydroModX *pHM = dynamic_cast<CDS_HydroModX *>( IDPtr.MP );

		if( NULL == pHM )
		{
			continue;
		}

		// Distribution supply pipe.
		CHMXPipe *pHMXPipe = pHM->GetpPipe( CHMXPipe::epipeOnDistributionSupply );

		if( NULL != pHMXPipe && 0 != pHMXPipe->GetLength() )
		{
			if( NULL == pHMXPipe->GetpPipe() )
			{
				return false;
			}
		}

		// Distribution return pipe.
		pHMXPipe = pHM->GetpPipe( CHMXPipe::epipeOnDistributionReturn );

		if( NULL != pHMXPipe && 0 != pHMXPipe->GetLength() )
		{
			if( NULL == pHMXPipe->GetpPipe() )
			{
				return false;
			}
		}

		// Circuit pipe on primary.
		pHMXPipe = pHM->GetpPipe( CHMXPipe::epipeOnCircuit );

		if( NULL != pHMXPipe && 0 != pHMXPipe->GetLength() )
		{
			if( NULL == pHMXPipe->GetpPipe() )
			{
				return false;
			}
		}

		// Circuit pipe on secondary.
		pHMXPipe = pHM->GetpPipe( CHMXPipe::epipeOnSecondaryCircuit );

		if( NULL != pHMXPipe && 0 != pHMXPipe->GetLength() )
		{
			if( NULL == pHMXPipe->GetpPipe() )
			{
				return false;
			}
		}

		// If current hydromodx is a module...
		if( true == pHM->IsaModule() && false == pHM->HasHMXStatus( CDS_HydroModX::sfBlackBox ) )
		{
			bReturn = IsAllPipeExistsInUserDB( pHM, pUserDB );
		}
	}

	return bReturn;
}

void CDS_HMXTable::ReplaceUserPipeByGenericPipe( CTable *pTable, CDataBase *pUserDB )
{
	// This method is called when downloading a project from TA-Scope and there are pipes defined that are not existing in HySelect.
	// We than replace user pipes with the closest default pipes.

	// Run all hydromodx.
	for( IDPTR IDPtr = pTable->GetFirst(); NULL != IDPtr.MP; IDPtr = pTable->GetNext( IDPtr.MP ) )
	{
		CDS_HydroModX *pHM = dynamic_cast<CDS_HydroModX *>( IDPtr.MP );

		if( NULL == pHM )
		{
			continue;
		}

		for( int i = 0; i < 2; i++ )
		{
			CHMXPipe::ePipeLoc pipeLoc = ( 0 == i ) ? CHMXPipe::epipeOnDistributionSupply : CHMXPipe::epipeOnCircuit;
			CPrjParams::_PrjParamsID eParamsID = ( 0 == i ) ? CPrjParams::PipeDistSupplySerieID : CPrjParams::PipeCircSerieID;

			CHMXPipe *pHMXPipe = pHM->GetpPipe( pipeLoc );

			if( NULL == pHMXPipe || NULL == pHMXPipe->GetpPipe() )
			{
				continue;
			}

			if( NULL != pUserDB->Get( pHMXPipe->GetpPipe()->GetIDPtr().ID ).MP )
			{
				continue;
			}

			CWaterChar *pWC = pHM->GetpWaterChar( NULL );
			double dKv = 0.0;

			if( 0.0 != pHMXPipe->GetRLin() )
			{
				dKv = CalcKv( pHMXPipe->GetRLin(), pWC->GetDens() );
			}

			double dDPlinear = CalcDp( pHMXPipe->GetFlow(), dKv, pWC->GetDens() );

			if( 0.0 != dDPlinear )
			{
				CDS_ProjectParams *pPrjParams = TASApp.GetpTADS()->GetpProjectParams();
				ASSERT( NULL != pPrjParams );

				if( NULL != pPrjParams )
				{
					IDPTR idptr = pPrjParams->GetpHmCalcParams()->GetPrjParamIDPtr( eParamsID );
					CTable *pDefaultPipeSeries = static_cast<CTable *>( pPrjParams->GetpHmCalcParams()->GetPrjParamIDPtr( eParamsID ).MP );

					if( NULL != pDefaultPipeSeries )
					{
						double dDPDifference = 1e200;
						CDB_Pipe *pGenericPipeFound = NULL;

						for( IDPTR IDPtr = pDefaultPipeSeries->GetFirst(); NULL != idptr.MP; IDPtr = pDefaultPipeSeries->GetNext( IDPtr.MP ) )
						{
							CDB_Pipe *pGenericPipe = dynamic_cast<CDB_Pipe *>( IDPtr.MP );
							double dDPLinearGeneric = pGenericPipe->GetLinearDp( pHMXPipe->GetFlow(), pWC->GetDens(), pWC->GetKinVisc() );

							if( abs( dDPLinearGeneric - dDPlinear ) < dDPDifference )
							{
								dDPDifference = abs( dDPLinearGeneric - dDPlinear );
								pGenericPipeFound = pGenericPipe;
							}
						}

						if( NULL != pGenericPipeFound )
						{
							CHMXPipe *pNewPipe = pHM->AddPipe( pipeLoc );

							if( NULL != pNewPipe )
							{
								pNewPipe->SetPipeID( pGenericPipeFound->GetIDPtr().ID );
								pNewPipe->SetKvFix( pHMXPipe->GetKvFix() );
								pNewPipe->SetLength( pHMXPipe->GetLength() );
								pNewPipe->SetFlow( pHMXPipe->GetFlow() );
								pNewPipe->SetpParentHMX( pHMXPipe->GetpParentHMX() );
								pNewPipe->SetRLin( CalcR( pHMXPipe->GetKvFix(), pWC->GetDens() ) );
							}
						}
					}
				}
			}

			if( NULL != pWC )
			{
				delete pWC;
			}
		}

		// If current hydromodx is a module...
		if( true == pHM->IsaModule() && false == pHM->HasHMXStatus( CDS_HydroModX::sfBlackBox ) )
		{
			ReplaceUserPipeByGenericPipe( pHM, pUserDB );
		}
	}
}

void CDS_HMXTable::VerifyMeasTABalDateTime( void )
{
	// Sometimes there is a bug with the date & time of measures coming from TA Scope (Values are negative).
	// In this case, we reset the date & time. But we can't reset to 0. Because 0 is used to check if measures
	// exist or not. Thus we reset to 1.
	// BUT we can not reset all to 1. Because if two measures have the same date, they are considered as equal.
	// And the second one will not be imported in the CDS_HydroMod (see CDS_HydroMod::TransferMeasFromHMX).
	m_iMeasDateTimeIndex = 1;
	m_iTABalDateTimeIndex = 1;

	_VerifyMeasTABalDateTime( this );
}

void CDS_HMXTable::_VerifyMeasTABalDateTime( CTable *pTable )
{
	if( NULL == pTable )
	{
		return;
	}

	for( IDPTR IDPtr = pTable->GetFirst(); NULL != IDPtr.MP; IDPtr = pTable->GetNext( IDPtr.MP ) )
	{
		CDS_HydroModX *pHM = dynamic_cast<CDS_HydroModX *>( IDPtr.MP );

		if( NULL == pHM )
		{
			continue;
		}

		CDS_HydroModX::eLocate locate = CDS_HydroModX::InPrimary;

		for( int iLocate = 0; iLocate < 2; iLocate++ )
		{
			if( 1 == iLocate )
			{
				locate = CDS_HydroModX::InSecondary;
			}

			// Quick measure.
			if( pHM->GetMeasDateTime( locate ) < 0 )
			{
				if( CDS_HydroModX::QMundef != pHM->GetQMType() )
				{
					pHM->SetMeasDateTime( m_iMeasDateTimeIndex++, locate );
				}
				else
				{
					pHM->SetMeasDateTime( 0, locate );
				}
			}

			// TA Balance.
			if( pHM->GetTABalDateTime( locate ) < 0 )
			{
				if( true == pHM->IsTABalMeasCompleted( locate ) || CDS_HydroModX::etabmTABalPlusStarted == pHM->GetTABalanceMode()
					|| CDS_HydroModX::etabmTABalPlus == pHM->GetTABalanceMode() )
				{
					pHM->SetTABalDateTime( m_iTABalDateTimeIndex++, locate );
				}
				else
				{
					pHM->SetTABalDateTime( 0, locate );
				}
			}
		}

		if( true == pHM->IsaModule() )
		{
			_VerifyMeasTABalDateTime( pHM );
		}
	}
}
#endif

void CDS_HMXTable::SetFlagReadyForBalancing( CTable *pTab )
{
	if( NULL == pTab )
	{
		pTab = this;
	}

	CDS_HydroModX *pPHMX = dynamic_cast<CDS_HydroModX *>( pTab );

	CDS_HydroModX *pHMXRef = NULL;

	if( NULL != pPHMX )
	{
		pHMXRef = pPHMX->GetpRefValve();    // Get reference valve
	}

	bool bAllBalanced = true;
	bool bAllValveFitBalancingMethod = true;

	for( IDPTR IDPtr = pTab->GetFirst(); NULL != IDPtr.MP; IDPtr = pTab->GetNext( IDPtr.MP ) )
	{
		CDS_HydroModX *pHM = dynamic_cast<CDS_HydroModX *>( IDPtr.MP );

		if( NULL == pHM )
		{
			continue;
		}

		if( true == pHM->IsBalanced() )
		{
			continue;
		}

		if( true == pHM->IsaModule() && false == pHM->HasHMXStatus( CDS_HydroModX::sfBlackBox ) )	//Do not check module childrens if black box
		{
			SetFlagReadyForBalancing( pHM );
			bAllBalanced = false;
		}

		CDS_HydroModX::eLocate locate = CDS_HydroModX::InPrimary;
		// If module and 2wInj circuit, use secondary
		//if (true == pHM->IsaModule() && true == pHM->GetpSch()->GetpSchCateg()->Is2WInj())
		//	locate = CDS_HydroModX::InSecondary;

		// Measuring valve exist?
		if( NULL != pHM->GetpMeasValve( locate ) )
		{
			// Test for measurable data

			// Needed only at reference position
			if( pHM == pHMXRef && false == pHM->CircuitFitForMethod( CDS_HydroModX::etammTAD, locate ) )
			{
				bAllValveFitBalancingMethod =  false;
			}

			else if( NULL == pHM->GetpMeasValve( locate ) )
			{
				bAllValveFitBalancingMethod =  false;
			}

			// if balancing valve exist it should be a TAValve
			else if( CDS_HydroModX::TAmode != pHM->GetpMeasValve( locate )->GetMode() )
			{
				bAllValveFitBalancingMethod =  false;
			}

			// Test for measurable data
			else if( false == pHM->CircuitFitForMethod( CDS_HydroModX::etammTAD, locate ) )
			{
				bAllValveFitBalancingMethod =  false;
			}

		}
		else
		{
			// Balancing valve doesn't exist
			// NOT allowed if there is no balancing valve at the reference position.
			//if (pHM == pHMXRef)
			bAllValveFitBalancingMethod =  false;
		}
	}

	if( NULL != pPHMX )
	{
		if( NULL != pTab->GetFirst().MP )	// Module should contain at least one children
		{
			if( true == bAllValveFitBalancingMethod )	// All valves are OK for balancing
			{
				pPHMX->SetReadyForBalancing( bAllBalanced );
				pPHMX->SetNonMeasurablePoint( false );
			}
			else								// Some valves are NOT OK for balancing
			{
				pPHMX->SetReadyForBalancing( bAllBalanced );
				pPHMX->SetNonMeasurablePoint( true );
			}
		}
		else
		{
			pPHMX->SetReadyForBalancing( false );
		}
	}
}

#define CDS_HMXTABLE_SHORTINFOS_VERSION	1
bool CDS_HMXTable::WriteShortInfos( OUTSTREAM outf, sHMXTab *pHMXData )
{
	if( NULL == pHMXData )
	{
		return false;
	}

	BYTE Version = CDS_HMXTABLE_SHORTINFOS_VERSION;
	WriteData<>( outf, Version );
	WriteData<>( outf, pHMXData->HMXAdjValve );
	WriteData<>( outf, pHMXData->HMXBalMod );
	WriteData<>( outf, pHMXData->HMXNbrMod );
	WriteData<>( outf, pHMXData->HMXNbrValve );
	WriteDouble( outf, pHMXData->dHMXTotalQ );
	return true;
}

bool CDS_HMXTable::WriteShortInfos( OUTSTREAM outf )
{
	// Version.
	sHMXTab HMXData;
	HMXData.HMXAdjValve = HMXData.HMXBalMod = HMXData.HMXNbrMod = HMXData.HMXNbrValve = 0;
	HMXData.dHMXTotalQ = 0.0;
	CountBalancedValves( this, &HMXData );
	WriteShortInfos( outf, &HMXData );
	return true;
}

bool CDS_HMXTable::ReadShortInfos( INPSTREAM  inpf, sHMXTab *pHMXData )
{
	// Version.
	BYTE Version = CDS_HMXTABLE_SHORTINFOS_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_HMXTABLE_SHORTINFOS_VERSION )
	{
		return false;
	}

	pHMXData->HMXAdjValve = pHMXData->HMXBalMod = pHMXData->HMXNbrMod = pHMXData->HMXNbrValve = 0;
	pHMXData->dHMXTotalQ = 0.0;
	inpf.read( (char *)&pHMXData->HMXAdjValve, sizeof( pHMXData->HMXAdjValve ) );
	inpf.read( (char *)&pHMXData->HMXBalMod, sizeof( pHMXData->HMXBalMod ) );
	inpf.read( (char *)&pHMXData->HMXNbrMod, sizeof( pHMXData->HMXNbrMod ) );
	inpf.read( (char *)&pHMXData->HMXNbrValve, sizeof( pHMXData->HMXNbrValve ) );
	pHMXData->dHMXTotalQ = ReadDouble( inpf );

	return true;
}

#define CDS_HMXTABLE_VERSION	1
void CDS_HMXTable::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_HMXTABLE_VERSION;
	WriteData<>( outf, Version );
	
	// Base class.
	CTable::Write( outf );
}

bool CDS_HMXTable::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_HMXTABLE_VERSION;

	// Manage old version of TAScope where CDS_HMXTable was not written.
	if( _ttoi( GetIDPtr().DB->GetVersion() ) > _ttoi( TASCOPE_BASE_FORMAT_VERSION ) )
	{
		inpf.read( (char *)&Version, sizeof( Version ) );
	}

	if( Version < 1 || Version > CDS_HMXTABLE_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CTable::Read( inpf ) )
	{
		return false;
	}

	return true;
}

#ifndef TACBX
///////////////////////////////////////////////////////////////////////////////////
//
//								CTableHM
//
///////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DATA( CTableHM )
//	SaveToTADataStructX(CTADataStructX *pTADSX)
//	Used to fill in a CTADataStructX with CTADataStruct's content

CTableHM::CTableHM( CDataBase *pDataBase, LPCTSTR ID ) : CTable( pDataBase, ID )
{
	m_bDiversityExist = false;
	// HYS-1777
	m_vecHMToReviewForChildrenAuthority.clear();
}

bool CTableHM::SaveToHMXTable( CTable *pTabSrcHM, CTable *pTabTrgHMX, CDS_WaterCharacteristic *pWC )
{
	try
	{
		// We start with piping table.
		if( NULL == pTabSrcHM )
		{
			HYSELECT_THROW( _T("Internal error: 'pTabSrcHM' argument can't be NULL.") );
		}
		else if( NULL == pTabTrgHMX )
		{
			HYSELECT_THROW( _T("Internal error: 'pTabTrgHMX' argument can't be NULL.") );
		}
		else if( NULL == pWC )
		{
			HYSELECT_THROW( _T("Internal error: 'pWC' argument can't be NULL.") );
		}

		bool bSuccess = false;

		// Retrieve DataStructX.
		CTADataStructX *pDSX = dynamic_cast<CTADataStructX *>( pTabTrgHMX->GetIDPtr().DB );

		if( NULL == pDSX )
		{
			HYSELECT_THROW( _T("Internal error: Database containing the 'pTabTrgHMX' object is not a 'CTADataStructX' object.") );
		}

		// For each hydromod.
		for( IDPTR IDPtr = pTabSrcHM->GetFirst(); NULL != IDPtr.MP; IDPtr = pTabSrcHM->GetNext( IDPtr.MP ) )
		{
			CDS_HydroMod *pHM = dynamic_cast<CDS_HydroMod *>( IDPtr.MP );

			if( NULL == pHM )
			{
				HYSELECT_THROW( _T("Internal error: Object '%s' is not a 'CDS_HydroMod' object."), IDPtr.ID );
			}

			// Balancing type.
			CDB_CircuitScheme *pSch = dynamic_cast<CDB_CircuitScheme *>( pHM->GetSchemeIDPtr().MP );

			if( NULL == pSch )
			{
				HYSELECT_THROW( _T("Internal error: Object '%s' in the hydromod '%s' is not a 'CDB_CircuitScheme' object."), pHM->GetSchemeIDPtr().ID, IDPtr.ID );
			}

			// Correction for circuit defined in CBI mode b Kv/CV or partially defined valve...
			// HYS-1750: Add Pending circuit for terminal unit.
			if( 0 == _tcscmp( pSch->GetIDPtr().ID, _T("SP") ) || 0 == _tcscmp( pSch->GetIDPtr().ID, _T("PDG") ) )
			{
				if( enum_VDescriptionType::edt_KvCv == pHM->GetVDescrType() || true == pHM->IsBvExist() )
				{
					pSch = dynamic_cast<CDB_CircuitScheme *>( TASApp.GetpTADB()->Get( _T("DC_BV") ).MP );
					pHM->SetSchemeIDPtr( pSch->GetIDPtr() );
				}
			}

			if( false == pHM->HasHMStatus( CDS_HydroMod::eHMStatusFlags::sfSelected ) )
			{
				// Verify children.
				if( true == pHM->IsaModule() )
				{
					// Don't change the target HMX table.
					SaveToHMXTable( pHM, pTabTrgHMX, pWC );
				}

				continue;
			}

			// Create a new HydroModX and insert it into his parent.
			IDPTR ObjIDPtr;
			pDSX->CreateObject( ObjIDPtr, CLASS( CDS_HydroModX ) );
			pTabTrgHMX->Insert( ObjIDPtr );

			CDS_HydroModX *pHMX = dynamic_cast<CDS_HydroModX *>( ObjIDPtr.MP );
			pHMX->SetReturnType( ( CDS_HydroModX::ReturnType )pHM->GetReturnType() );
			
			pHMX->SetSchemeIDPtr( pHM->GetSchemeIDPtr() );

			// In case of module pass through all children.
			if( true == pHM->IsaModule() )
			{
				pHMX->SetFlagModule( true );

				// Check Orphan flag if needed
				CDS_HydroMod *pPHM = dynamic_cast<CDS_HydroMod *>( pHM->GetIDPtr().PP );

				// If Parent is not a HydroMod, it should be the container table CTableHM.
				unsigned char HMXStatus = 0;

				if( NULL != pPHM )
				{
					// Parent module is a HydroMod, if it is not selected this module is Orphan.
					if( false == pPHM->HasHMStatus( CDS_HydroMod::eHMStatusFlags::sfSelected ) )
					{
						HMXStatus |= CDS_HydroModX::eHMStatusFlags::sfOrphan;
					}
				}

				// Check black box status.
				if( true == pHM->HasHMStatus( CDS_HydroMod::eHMStatusFlags::sfBlackBox ) )
				{
					HMXStatus |= CDS_HydroModX::eHMStatusFlags::sfBlackBox;
				}

				pHMX->SetHMXStatus( HMXStatus );

				// Is not a black box proceed children.
				if( !( pHMX->GetHMXStatus() & CDS_HydroModX::eHMStatusFlags::sfBlackBox ) )
				{
					SaveToHMXTable( pHM, pHMX, pWC );
				}
			}
			else
			{
				pHMX->SetFlagModule( false );
			}

			// Cross references.
			pHMX->SetHMID( ( wchar_t * )pHM->GetIDPtr().ID );
			pHMX->SetUid( pHM->GetUid() );

			// Circuit characteristics.
			CString str = pHM->GetHMName();

			if( CDS_HydroModX::eHMStatusFlags::sfOrphan == ( pHMX->GetHMXStatus() & CDS_HydroModX::eHMStatusFlags::sfOrphan ) )
			{
				// For a black box remove '*' to forbid automatic renaming into TA-SCOPE
				if( _T('*') == str.GetAt( 0 ) )
				{
					str.Delete( 0, 1 );
				}
			}

			pHMX->SetHMName( (LPCTSTR)str );

			pHMX->SetDescription( (LPCTSTR)pHM->GetDescription() );
			pHMX->SetPosition( pHM->GetPos() );
			pHMX->SetWaterCharIDPtr( ( IDPTR & )pWC->GetIDPtr() );
			pHMX->SetFlagIndexCircuit( pHM->IsCircuitIndex() );

			pHMX->BuildCircuit( pSch, pHM->GetpSecBv() != NULL ? true : false, pHM->IsShutoffValveExist( true ), false );

			// Valve defined by his KV?
			if( enum_VDescriptionType::edt_KvCv == pHM->GetVDescrType() )
			{
				// Add a balancing valve in the primary side in KvMode.
				CDS_HydroModX::CBV *pBV = pHMX->GetpBV( CDS_HydroModX::eLocate::InPrimary );
				pBV->SetMode( CDS_HydroModX::Kvmode );

				// Design flow.
				pBV->SetDesignFlow( pHM->GetDistrTotQ() );
				pBV->SetKv( pHM->GetKvCv() );
			}

			pHMX->SetFlagModule( pHM->IsaModule() );
			pHMX->SetFlagIndexCircuit( pHM->IsCircuitIndex() );

			// For Each Balancing Valve.
			if( true == pHM->IsBvExist() )
			{
				bSuccess = pHM->GetpBv()->FillBvInfoIntoHMX( pHMX );
			}

			if( true == pHM->IsCvExist() )
			{
				pHM->GetpCV()->FillCvInfoIntoHMX( pHMX );
			}

			if( true == pHM->IsBvBypExist() )
			{
				pHM->GetpBypBv()->FillBvInfoIntoHMX( pHMX );
			}

			if( true == pHM->IsBvSecExist() )
			{
				pHM->GetpSecBv()->FillBvInfoIntoHMX( pHMX );
			}

			// Dp Controller.
			if( true == pHM->IsDpCExist() )
			{
				bSuccess = pHM->GetpDpC()->FillDpCInfoIntoHMX( pHMX );
			}

			if( true == pHM->IsShutoffValveExist( CDS_HydroMod::eShutoffValveSupply, true ) )
			{
				pHM->GetpShutoffValve( CDS_HydroMod::eShutoffValveSupply )->FillShutoffValveInfoIntoHMX( pHMX, CDS_HydroMod::eShutoffValveSupply );
			}

			if( true == pHM->IsShutoffValveExist( CDS_HydroMod::eShutoffValveReturn, true ) )
			{
				pHM->GetpShutoffValve( CDS_HydroMod::eShutoffValveReturn )->FillShutoffValveInfoIntoHMX( pHMX, CDS_HydroMod::eShutoffValveReturn );
			}

			// PIPES.
			for( int i = CHMXPipe::epipeOnDistributionSupply; i < CHMXPipe::epipeLast ; i++ )
			{
				CPipes *pHMPipe = NULL;
				CHMXPipe *pHMXPipe = NULL;

				// HYS-1716: For the moment in the TA-Scope we have only one water char by pipe.
				// So, we try to put the same as it was the case for before.
				CWaterChar *pclWaterChar = NULL;

				switch( i )
				{
					// Distribution supply.
					case CHMXPipe::epipeOnDistributionSupply:
						pHMPipe = pHM->GetpDistrSupplyPipe();
						pHMXPipe = pHMX->AddPipe( CHMXPipe::epipeOnDistributionSupply );

						if( NULL != pHMPipe )
						{
							pclWaterChar = pHM->GetpWaterChar( CAnchorPt::PipeType_Distribution, CAnchorPt::PipeLocation_Supply );
						}

						break;

					// Circuit.
					case CHMXPipe::epipeOnCircuit:
						pHMPipe = pHM->GetpCircuitPrimaryPipe();
						pHMXPipe = pHMX->AddPipe( CHMXPipe::epipeOnCircuit );

						if( NULL != pHMPipe )
						{
							pclWaterChar = pHM->GetpWaterChar( CAnchorPt::PipeType_Circuit, CAnchorPt::PipeLocation_Supply, CAnchorPt::CircuitSide_Primary );
						}

						break;

					// Distribution return.
					case CHMXPipe::epipeOnDistributionReturn:
						pHMPipe = pHM->GetpDistrReturnPipe();
						pHMXPipe = pHMX->AddPipe( CHMXPipe::ePipeLoc::epipeOnDistributionReturn );

						if( NULL != pHMPipe )
						{
							pclWaterChar = pHM->GetpWaterChar( CAnchorPt::PipeType_Distribution, CAnchorPt::PipeLocation_Return );
						}

						break;

					// Circuit on secondary side.
					case CHMXPipe::epipeOnSecondaryCircuit:
						pHMPipe = pHM->GetpCircuitSecondaryPipe();
						pHMXPipe = pHMX->AddPipe( CHMXPipe::ePipeLoc::epipeOnSecondaryCircuit );

						if( NULL != pHMPipe )
						{
							pclWaterChar = pHM->GetpWaterChar( CAnchorPt::PipeType_Circuit, CAnchorPt::PipeLocation_Supply, CAnchorPt::CircuitSide_Secondary );
						}

						break;
				}

				if( NULL == pHMPipe || NULL == pHMXPipe )
				{
					continue;
				}

				if( NULL == pclWaterChar )
				{
					ASSERT_CONTINUE;
				}

				pHMXPipe->SetPipeID( pHMPipe->GetIDPtr().ID );
				double dLinDp = pHMPipe->GetLinDp();
				double dKv = CalcKv( pHMPipe->GetRealQ(), dLinDp, pclWaterChar->GetDens() );

				if( dKv != 0.0 )
				{
					double dRLin = CalcR( dKv, pclWaterChar->GetDens() );
					pHMXPipe->SetRLin( dRLin );
				}

				// Kv for singularities.
				dKv = CalcKv( pHMPipe->GetRealQ(), pHMPipe->GetSingularityTotalDp( true ), pclWaterChar->GetDens() );
				pHMXPipe->SetKvFix( dKv );
				pHMXPipe->SetFlow( pHMPipe->GetRealQ() );
				pHMXPipe->SetLength( pHMPipe->GetLength() );
			}

			// TU: save Dp.
			if( NULL != pHM->GetpTermUnit() )
			{
				pHMX->AddTU();
				pHMX->GetpTU()->SetDp( pHM->GetpTermUnit()->GetDp() );
				// Design flow is set with SetDesignFlow below
			}

			// TU: save Q.
			CDS_HmInj *pInj = dynamic_cast<CDS_HmInj *>( pHM );

			if( NULL != pInj )
			{
				// Ask for terminal unit flow.
				if( NULL != pHM->GetpTermUnit() )
				{
					pHMX->SetDesignFlow( pHM->GetpTermUnit()->GetQ() );
				}
			}
			else	// TU flow to be verified with CBI installation
			{
				pHMX->SetDesignFlow( pHM->GetQDesign() );
			}

			CDS_TechnicalParameter *pTechParam = TASApp.GetpTADS()->GetpTechParams();

			if( NULL != pTechParam )
			{
				pHMX->SetTABalValMinDp( pTechParam->GetValvMinDp() );
			}

			// Fill other information relative to inherited class (ie: CDS_Hm2W, CDS_Hm3w and so on).
			pHM->FillOtherInfoIntoHMX( pHMX );
		}

		return bSuccess;
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CTableHM::SaveToHMXTable'."), __LINE__, __FILE__ );
		throw;
	}
}

bool CTableHM::LoadFromHMXTable( bool bFromScratch, CTable *pTabHMX, CDS_HydroMod *pHMParent, int iLevel )
{
	try
	{
		if( NULL == pTabHMX )
		{
			return false;
		}

		// Do a loop on the table to recuperate modules.
		bool bSucessFullLoaded = true;

		for( IDPTR IDPtr = pTabHMX->GetFirst(); NULL != IDPtr.MP && bSucessFullLoaded; IDPtr = pTabHMX->GetNext( IDPtr.MP ) )
		{
			CDS_HydroModX *pHMXChild = dynamic_cast<CDS_HydroModX *>( IDPtr.MP );

			if( NULL == pHMXChild )
			{
				bSucessFullLoaded = false;
				continue;
			}

			// Verify the Module already exist
			// by matching the HMID and the uid
			IDPTR ObjIDptr = _NULL_IDPTR;

			if( false == bFromScratch )
			{
				ObjIDptr = TASApp.GetpTADS()->Get( pHMXChild->GetHMID() );

				if( NULL == ObjIDptr.MP || ( ( static_cast<CDS_HydroMod *>( ObjIDptr.MP ) )->GetUid() != 0
						&& ( static_cast<CDS_HydroMod *>( ObjIDptr.MP ) )->GetUid() != pHMXChild->GetUid() ) )
				{
					// Not Found or UID doesn't match'.
					ObjIDptr = _NULL_IDPTR;
					IDPTR ObjParentIDptr = TASApp.GetpTADS()->Get( ( static_cast<CDS_HydroModX *>( pHMXChild->GetIDPtr().PP ) )->GetHMID() );

					CTable *pParentTab = dynamic_cast<CTable *>( ObjParentIDptr.MP );

					if( NULL == pParentTab )
					{
						pParentTab = TASApp.GetpTADS()->GetpHydroModTable();
					}

					if( NULL != pParentTab )
					{
						for( IDPTR HMIDPtr = pParentTab->GetFirst(); NULL != HMIDPtr.MP; HMIDPtr = pParentTab->GetNext( HMIDPtr.MP ) )
						{
							CDS_HydroMod *pHM = dynamic_cast<CDS_HydroMod *>( HMIDPtr.MP );

							if( NULL == pHM )
							{
								continue;
							}

							if( pHM->GetPos() == pHMXChild->GetPosition() )
							{
								ObjIDptr = HMIDPtr;
								break;
							}
						}
					}
				}
				else
				{
					// The HydroMod was found, verify it's position by checking it's parent and the position.

					CDS_HydroModX *pHMXParent = static_cast<CDS_HydroModX *>( pHMXChild->GetIDPtr().PP );
					CDS_HydroMod *pParentObj = static_cast<CDS_HydroMod *>( ObjIDptr.PP );

					if( NULL != pParentObj && NULL != pHMXParent )
					{
						// Verify the parent class, if it's the root for both of them it's placed correctly.
						if( false == pParentObj->IsClass( L"CTableHM" ) || false == pHMXParent->IsClass( L"CDS_HMXTable" ) )
						{
							// Verify it's an orphan placed in the root table.
							if( true == pHMXParent->IsClass( L"CDS_HMXTable" ) && ( CDS_HydroModX::eHMStatusFlags::sfOrphan & pHMXChild->GetHMXStatus() ) )
							{
								// The orphan will be replaced correctly one level under his parent in HySelect
							}
							else if( pParentObj->GetUid() != pHMXParent->GetUid() )
							{
								// Verify it's the same parent.

								pParentObj->Remove( ObjIDptr );
								pHMParent->Insert( ObjIDptr );

								( static_cast<CDS_HydroMod *>( ObjIDptr.MP ) )->SetParentTable( pHMParent );
							}
						}
					}
				}
			}

			bool bImportInExistingHM = true;

			if( NULL == ObjIDptr.MP )
			{
				// HM not found.
				CDB_ControlProperties::CvCtrlType CtrlType = CDB_ControlProperties::CvCtrlType::eCvProportional;

				if( NULL != pHMXChild->GetpCv() )
				{
					CtrlType = CDB_ControlProperties::CvCtrlType::eCvProportional;
					CDB_TAProduct *pTAP = dynamic_cast<CDB_TAProduct *>( pHMXChild->GetpCv()->GetValveIDPtr().MP );

					if( NULL != pTAP )
					{

						if( NULL != pTAP->GetCtrlProp() )
						{
							CtrlType = pTAP->GetCtrlProp()->GetCtrlType();
						}
					}
				}

				CDS_HydroMod *pHM = TASApp.GetpTADS()->CreateNewHM( ( NULL == pHMParent ) ? this : static_cast<CTable *>( pHMParent ), pHMXChild->GetpSch(), CtrlType,
						true, pHMXChild->IsaModule() == false, pHMXChild->GetReturnType() );

				ObjIDptr = pHM->GetIDPtr();
				bImportInExistingHM = false;
			}

			// Retrieve the pointer of the new class.
			CDS_HydroMod *pHMChild = dynamic_cast<CDS_HydroMod *>( ObjIDptr.MP );
			ASSERT( NULL != pHMChild );

			if( NULL == pHMChild )
			{
				bSucessFullLoaded = false;
				continue;
			}

			// Copy all necessary values from CDS_HydroModX to CDS_HydroMod.
			bSucessFullLoaded = pHMChild->LoadFromHMX( pHMXChild, pHMParent, iLevel, bImportInExistingHM );

			if( false == bSucessFullLoaded )
			{
				return false;
			}

			// Equal the HMID and UID of HydroMod and HydroModX.
			pHMXChild->SetHMID( ( wchar_t * )pHMChild->GetIDPtr().ID );
			pHMXChild->SetUid( pHMChild->GetUid() );


			// Save the current level.
			int iSaveLevel = iLevel;

			// Do the recursive function.
			if( pHMXChild->IsaModule() )
			{
				bSucessFullLoaded = LoadFromHMXTable( bFromScratch, pHMXChild, pHMChild, ++iLevel );
			}

			// Retrieve the current level
			iLevel = iSaveLevel;
		}

		return bSucessFullLoaded;
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CTableHM::LoadFromHMXTable'."), __LINE__, __FILE__ );
		throw;
	}
}

void CTableHM::GetLowerUpperDataTime( COleDateTime &clLowerDateTime, COleDateTime &clUpperDateTime )
{
	clLowerDateTime.SetDateTime( 9999, 1, 1, 0, 0, 0 );
	clUpperDateTime.SetDateTime( 100, 1, 1, 0, 0, 0 );

	CTableHM *pclRootHM = dynamic_cast<CTableHM *>( TASApp.GetpTADS()->GetpHydroModTable() );

	if( NULL == pclRootHM || 0 == pclRootHM->GetItemCount() )
	{
		return;
	}

	_GetLowerUpperDataTime( pclRootHM, clLowerDateTime, clUpperDateTime );

	if( clLowerDateTime == COleDateTime( 9999, 1, 1, 0, 0, 0 ) && clUpperDateTime == COleDateTime( 100, 1, 1, 0, 0, 0 ) )
	{
		clLowerDateTime = COleDateTime( 1970, 1, 1, 0, 0, 0 );
		clUpperDateTime = COleDateTime( 1970, 1, 1, 0, 0, 0 );
	}
	else if( clLowerDateTime == COleDateTime( 9999, 1, 1, 0, 0, 0 ) )
	{
		clLowerDateTime = clUpperDateTime;
	}
	else if( clUpperDateTime == COleDateTime( 100, 1, 1, 0, 0, 0 ) )
	{
		clUpperDateTime = clLowerDateTime;
	}
}

bool CTableHM::GetDFModuleList( CDS_HydroMod *pHMRoot, vecHydroMod &ModuleList, double &dDiversityFactor )
{
	ModuleList.clear();
	dDiversityFactor = 1.0;
	bool bReturn = true;

	if( NULL == pHMRoot )
	{
		for( IDPTR IDPtr = GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = GetNext() )
		{
			CDS_HydroMod *pHM = dynamic_cast<CDS_HydroMod *>( (CData *)IDPtr.MP );

			if( NULL != pHM )
			{
				bReturn = _GetDFModuleList( pHM, ModuleList, dDiversityFactor );
			}

			if( false == bReturn )
			{
				break;
			}
		}
	}
	else
	{
		bReturn = _GetDFModuleList( pHMRoot, ModuleList, dDiversityFactor );
	}

	return bReturn;
}

#define CTABLEHM_VERSION	2
void CTableHM::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CTABLEHM_VERSION;
	WriteData<>( outf, Version );
	
	// Base class.
	CTable::Write( outf );
	WriteData<>( outf, m_bDiversityExist );
}

bool CTableHM::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = 1;

	// Manage old version of TAScope where CDS_LogTable was not written.
	if( _ttoi( GetIDPtr().DB->GetVersion() ) > _ttoi( TASCOPE_BASE_FORMAT_VERSION ) )
	{
		inpf.read( (char *)&Version, sizeof( Version ) );
	}

	if( Version < 1 || Version > CTABLEHM_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CTable::Read( inpf ) )
	{
		return false;
	}

	if( Version < 2 )
	{
		return true;
	}

	inpf.read( (char *)&m_bDiversityExist, sizeof( m_bDiversityExist ) );
	return true;
}

void CTableHM::VerifyMeasTABalDateTime()
{
	// Sometimes there is a bug with the date & time of measures coming from TA Scope (Values are negative).
	// With old projects there was no reset of the date & time. Thus we do it now.
	m_iResetMeasDateTimeIndex = 1;
	m_iResetTABalDateTimeIndex = 1;

	_VerifyMeasTABalDateTime( this );
}

void CTableHM::VerifyAllWaterCharacteristics( bool bDeepestToHighest )
{
	// Do the job for each root module.
	for( IDPTR IDPtrRootModule = this->GetFirst(); NULL != IDPtrRootModule.MP; IDPtrRootModule = this->GetNext() )
	{
		CDS_HydroMod *pclRootModule = dynamic_cast<CDS_HydroMod *>( IDPtrRootModule.MP );

		if( NULL == pclRootModule )
		{
			ASSERT_CONTINUE;
		}

		// If current root is not in HM calc mode, we don't verify.
		if( false == pclRootModule->IsHMCalcMode() )
		{
			continue;
		}

		m_mapDesignTemperatureInterfaces.clear();

		// HYS-1882: Fill the map accordingly to the order we use to check each circuits.
		if( true == bDeepestToHighest )
		{
			// We fill the map with all design temperature interfaces that are only with injection circuits.
			FillDesignTemperatureInterfaceMap( pclRootModule, bDeepestToHighest );
			// Root module is added to this map. We go through from deepest.
			m_mapDesignTemperatureInterfaces.insert( make_pair( INT_MIN, pclRootModule ) );
		}
		else
		{
			// Root module is added to this map. We go through from the top.
			m_mapDesignTemperatureInterfaces.insert( make_pair( INT_MIN, pclRootModule ) );
			// We fill the map with all design temperature interfaces that are only with injection circuits.
			FillDesignTemperatureInterfaceMap( pclRootModule, bDeepestToHighest );
		}

		// We run the map starting by the deepest design temperature interface and going to the pump.
		bool bStop = false;
		std::multimap<int, CDS_HydroMod *>::iterator it = m_mapDesignTemperatureInterfaces.begin();

		while( false == bStop )
		{
			CDS_HydroMod *pHM = it->second;
			++it;

			if( it == m_mapDesignTemperatureInterfaces.end() )
			{
				bStop = true;
			}
	
			// Do the job by passing pPI pointeur to the method.
			if( true == bDeepestToHighest )
			{
				pHM->VerifyAllWaterCharacteristics( pHM );
			}
			else
			{
				// HYS-1882: Update pHM water char and temperature then check pHM children recursively.
				pHM->DistributeWaterCharacteristics( pHM );
			}
		}
	}
}

void CTableHM::VerifyAllBVSecForAll3WayCircuits( CTable *pTab )
{
	if( NULL == pTab )
	{
		pTab = TASApp.GetpTADS()->GetpHydroModTable();
	}

	if( NULL == pTab )
	{
		ASSERT_RETURN;
	}

	bool bReturn = true;
	CRank rkList;
	IDPTR IDPtr = _NULL_IDPTR;
	CDS_HydroMod *pHM = NULL;

	for( IDPtr = pTab->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pTab->GetNext( IDPtr.MP ) )
	{
		pHM = static_cast<CDS_HydroMod *>( IDPtr.MP );

		// HYS-1873: Stopping case.We verify only for 3-way circuit.
		if( NULL == pHM || NULL == pHM->GetpSch() 
			|| ( NULL != pHM->GetpSchcat() && CDB_ControlProperties::CV2W3W::CV3W != pHM->GetpSchcat()->Get2W3W() ) )
		{
			continue;
		}

		if( true == pHM->IsaModule() )
		{
			VerifyAllBVSecForAll3WayCircuits( pHM );
		}

		if( true == pHM->GetpSch()->IsAnchorPtExist( CAnchorPt::eFunc::BV_S ) 
				&& false == pHM->GetpSch()->IsAnchorPtOptional( CAnchorPt::eFunc::BV_S )
				&& NULL == pHM->GetpSecBv() )
		{
			pHM->CreateBv( CDS_HydroMod::eHMObj::eBVsec );
		}
	}
}

void CTableHM::FillHMToReviewForChildrenAuthority( CDS_HydroMod* pHM )
{
	if( NULL == pHM )
	{
		return;
	}

	if( false == pHM->IsaModule() )
	{
		return;
	}

	// Root module is not concerned.
	if( 0 != pHM->GetLevel() )
	{
		// We store the 3-way mixing if it isn't in the vector yet
		std::vector<CDS_HydroMod*>::iterator It;
		It = std::find( m_vecHMToReviewForChildrenAuthority.begin(), m_vecHMToReviewForChildrenAuthority.end(), pHM );
		if( It == m_vecHMToReviewForChildrenAuthority.end() )
		{
			m_vecHMToReviewForChildrenAuthority.push_back( pHM );
		}
	}
}

void CTableHM::Copy( CData *pTo, bool fResetDiversityFactor )
{
	try
	{
		if( NULL == pTo )
		{
			HYSELECT_THROW( _T("Internal error: 'pDestinationIndSelParameter' argument can't be NULL.") );
		}
		else if( NULL == dynamic_cast<CTableHM *>( pTo ) )
		{
			HYSELECT_THROW( _T("Internal error: 'pDestinationIndSelParameter' object is not a 'CTableHM' object.") );
		}

		CTableHM *pTableHMDst = dynamic_cast<CTableHM *>( pTo );

		// Call base class first.
		CTable::Copy( pTableHMDst );

		pTableHMDst->SetDiversityExist( ( true == fResetDiversityFactor ) ? false : IsDiversityExist() );
		pTableHMDst->SetDiversityActive( ( true == fResetDiversityFactor ) ? false : GetDiversityActive() );

		// Copy all hydromod.
		std::vector<CTable *> vecScr;
		std::vector<CTable *> vecDst;
		int iCurrentDeep = 0;
		bool bCanStop = false;
		CTable *pTableSrc = static_cast<CTable *>( this );
		CTable *pTableDst = static_cast<CTable *>( pTableHMDst );
		CDS_HydroMod *pHMSrc = dynamic_cast<CDS_HydroMod * >( (CData *)( GetFirst().MP ) );
		CDS_HydroMod *pHMDst = NULL;

		do
		{
			if( NULL != pHMSrc )
			{
				CTADatastruct *pTADS = dynamic_cast<CTADatastruct *>( GetDB() );

				if( NULL != pTADS )
				{
					IDPTR IDPtr;
					pTableDst->GetDB()->CreateObject( IDPtr, pHMSrc->GetClassName(), pHMSrc->GetIDPtr().ID );
					pTableDst->Insert( IDPtr );

					pHMDst = dynamic_cast<CDS_HydroMod *>( (CData *)( IDPtr.MP ) );

					if( true == pHMSrc->IsClass( CLASS( CDS_Hm2W ) ) )
					{
						CDS_Hm2W *pHm2W = static_cast<CDS_Hm2W *>( pHMSrc );
						pHm2W->Copy( static_cast<CDS_Hm2W *>( pHMDst ), false, true, false, false );
					}
					else if( true == pHMSrc->IsClass( CLASS( CDS_Hm2WInj ) ) )
					{
						CDS_Hm2WInj *pHm2WInj = static_cast<CDS_Hm2WInj *>( pHMSrc );
						pHm2WInj->Copy( static_cast<CDS_Hm2WInj *>( pHMDst ), false, true, false, false );
					}
					else if( true == pHMSrc->IsClass( CLASS( CDS_Hm3WInj ) ) )
					{
						CDS_Hm3WInj *pHm2WInj = static_cast<CDS_Hm3WInj *>( pHMSrc );
						pHm2WInj->Copy( static_cast<CDS_Hm3WInj *>( pHMDst ), false, true, false, false );
					}
					else if( true == pHMSrc->IsClass( CLASS( CDS_Hm3W ) ) )
					{
						CDS_Hm3W *pHm3W = static_cast<CDS_Hm3W *>( pHMSrc );
						pHm3W->Copy( static_cast<CDS_Hm3W *>( pHMDst ), false, true, false, false );
					}
					else if( true == pHMSrc->IsClass( CLASS( CDS_HmHub ) ) )
					{
					}
					else if( true == pHMSrc->IsClass( CLASS( CDS_HmHubStation ) ) )
					{
					}
					else
					{
						pHMDst->SetSchemeID( pHMSrc->GetSchemeID() );
						pHMSrc->Copy( pHMDst, false, true, false, false );
						// Because in copy method diversity factor coefficient is reseted,
					}
				}
			}

			if( NULL == pHMSrc )
			{
				if( vecScr.size() > 0 )
				{
					iCurrentDeep--;
					pTableSrc = vecScr.back();
					pTableDst = vecDst.back();
					pHMSrc = dynamic_cast<CDS_HydroMod *>( (CData *)( pTableSrc->GetNext().MP ) );
					vecScr.pop_back();
					vecDst.pop_back();
				}
				else
				{
					bCanStop = true;
				}
			}
			else if( NULL != pHMSrc->GetFirst().MP )
			{
				iCurrentDeep++;
				vecScr.push_back( pTableSrc );
				vecDst.push_back( pTableDst );
				pTableSrc = static_cast<CTable *>( pHMSrc );
				pTableDst = static_cast<CTable *>( pHMDst );
				pHMSrc = dynamic_cast<CDS_HydroMod *>( (CData *)( pTableSrc->GetFirst().MP ) );
			}
			else
			{
				pHMSrc = dynamic_cast<CDS_HydroMod *>( (CData *)( pTableSrc->GetNext().MP ) );
			}
		}
		while( false == bCanStop );
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CTableHM::Copy'."), __LINE__, __FILE__ );
		throw;
	}
}

void CTableHM::DropData( OUTSTREAM outf, int *piLevel )
{
	CString strTab = _T("");

	for( int i = *piLevel; i; i-- )
	{
		strTab += _T("\t");
	}

	// Database info.
	CString str;
	str.Format( _T("TABLEHM \"%s\" {ID = %s}\n"), GetName(), CString( GetIDPtr().ID ) );
	WriteFormatedStringA2( outf, str, strTab );
	str.Format( _T("m_bDiversityExist = %s\n" ), ( true == m_bDiversityExist ) ? _T("true") : _T( "false") );
	WriteFormatedStringA2( outf, str, strTab );
	str.Format( _T("m_fDiversityActive = %s\n\n" ), ( true == m_fDiversityActive ) ? _T("true") : _T( "false") );
	WriteFormatedStringA2( outf, str, strTab );

	// Write base class.
	( *piLevel )++;
	CTable::DropData( outf, piLevel );
	( *piLevel )--;
}

void CTableHM::_GetLowerUpperDataTime( CTable *pclHydroMod, COleDateTime &clLowerDateTime, COleDateTime &clUpperDateTime )
{
	if( NULL == pclHydroMod )
	{
		return;
	}

	for( IDPTR IDPtr = pclHydroMod->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pclHydroMod->GetNext( IDPtr.MP ) )
	{
		CDS_HydroMod *pHM = dynamic_cast<CDS_HydroMod *>( IDPtr.MP );

		if( NULL == pHM )
		{
			continue;
		}

		unsigned int uiNbrMeasData = pHM->GetMeasDataSize();

		for( unsigned int uiLoopMeasure = 0; uiLoopMeasure < uiNbrMeasData; uiLoopMeasure++ )
		{
			// Get the MeasData.
			CDS_HydroMod::CMeasData *pMeasData = pHM->GetpMeasData( uiLoopMeasure );

			// Skip CBI Measures (no date time).
			if( CDS_HydroMod::eInstrumentUsed::TACBI == pMeasData->GetInstrument() )
			{
				continue;
			}

			__time32_t time32Min = min( ( 0 == pMeasData->GetMeasDateTime() ) ? LONG_MAX : pMeasData->GetMeasDateTime(),
					( 0 == pMeasData->GetTABalDateTime() ) ? LONG_MAX : pMeasData->GetTABalDateTime() );

			__time32_t time32Max = max( ( 0 == pMeasData->GetMeasDateTime() ) ? 0 : pMeasData->GetMeasDateTime(),
					( 0 == pMeasData->GetTABalDateTime() ) ? 0 : pMeasData->GetTABalDateTime() );

			if( time32Min == LONG_MAX && time32Max <= 0 )
			{
				continue;
			}

			COleDateTime timMin;

			if( time32Min > 0 )
			{
				tm dt;
				_gmtime32_s( &dt, &time32Min );
				timMin.SetDateTime( dt.tm_year + 1900, dt.tm_mon + 1, dt.tm_mday, dt.tm_hour, dt.tm_min, dt.tm_sec );
			}

			COleDateTime timMax;

			if( time32Max > 0 )
			{
				tm dt;
				_gmtime32_s( &dt, &time32Max );
				timMax.SetDateTime( dt.tm_year + 1900, dt.tm_mon + 1, dt.tm_mday, dt.tm_hour, dt.tm_min, dt.tm_sec );
			}

			if( timMin > 0 && timMin < clLowerDateTime )
			{
				clLowerDateTime = timMin;
			}

			if( timMax > 0 && timMax > clUpperDateTime )
			{
				clUpperDateTime = timMax;
			}
		}

		if( true == pHM->IsaModule() )
		{
			_GetLowerUpperDataTime( pHM, clLowerDateTime, clUpperDateTime );
		}
	}
}

/**
*	@brief Recursive function that fill MAP: m_mapPressureInterfaces with the list of modules including a ShortCutBypass
*				 Modules are ordered with a key composed of 10000*Level + position
*				 When we will travel in this map we will start from lower value (close to root module)
* @param CDS_HydroMod *pHM Starting HM for recursivity
* @param 'bOnlyInjectionPressureInterface' if true we put in the map only pressure interface that are injection circuit.
*/
void CTableHM::FillPressureInterfaceMap( CDS_HydroMod *pHM, bool bOnlyInjectionPressureInterface )
{
	if( NULL == pHM )
	{
		return;
	}

	if( false == pHM->IsaModule() )
	{
		return;
	}
	
	// Root module is included outside this method.
	if( 0 != pHM->GetLevel() )
	{
		if( ( true == pHM->IsPressureInterfaceExist() && false == bOnlyInjectionPressureInterface )
				|| ( true == pHM->IsPressureInterfaceExist() && true == pHM->IsInjectionCircuit() ) )
		{
			// 'IsPressureInterfaceExist' verify if a secondary side exist or if a Dp controller in on the branch in the primary.
			// 1: If pressure interface exists AND we want all types -> 1.
			// 2: If pressure interface exists and we want only injection circuit AND this circuit is an injection circuit -> 1.
			int iKey = 1 * ( pHM->GetLevel() * 10000 + pHM->GetPos() );
			m_mapPressureInterfaces.insert( make_pair( iKey, pHM ) );
		}
	}

	for( IDPTR idptr = pHM->GetFirst(); NULL != idptr.MP; idptr = pHM->GetNext( idptr.MP ) )
	{
		CDS_HydroMod *pCHM = dynamic_cast<CDS_HydroMod *>( idptr.MP );

		if( NULL == pCHM )
		{
			ASSERT_CONTINUE;
		}

		if( false == pCHM->IsaModule() )
		{
			continue;
		}

		// Go deeper inside this module
		FillPressureInterfaceMap( pCHM );
	}
}

void CTableHM::FillDesignTemperatureInterfaceMap( CDS_HydroMod *pHM, bool bDeepestToHighest )
{
	if( NULL == pHM )
	{
		return;
	}

	if( false == pHM->IsaModule() )
	{
		return;
	}
	
	// Root module is included outside this method.
	if( 0 != pHM->GetLevel() )
	{
		// Remark: the 'IsInjectionCircuit' method does not return the 3-way mixing circuit!
		if( true == pHM->IsInjectionCircuit() )
		{
			int iKey = ( pHM->GetLevel() * 10000 ) + pHM->GetPos();

			if( true == bDeepestToHighest )
			{
				iKey *= -1;
			}

			m_mapDesignTemperatureInterfaces.insert( make_pair( iKey, pHM ) );
		}
	}

	for( IDPTR idptr = pHM->GetFirst(); NULL != idptr.MP; idptr = pHM->GetNext( idptr.MP ) )
	{
		CDS_HydroMod *pclChildHM = dynamic_cast<CDS_HydroMod *>( idptr.MP );

		if( NULL == pclChildHM )
		{
			ASSERT_CONTINUE;
		}

		if( false == pclChildHM->IsaModule() )
		{
			continue;
		}

		// Go deeper inside this module.
		FillDesignTemperatureInterfaceMap( pclChildHM, bDeepestToHighest );
	}
}

void CTableHM::FillInjectionCircuitMap( std::map<int, CDS_HydroMod *> *pmapHydraulicInjectionCircuit, CDS_HydroMod *pHM, bool bAddParent, bool bDeepestToHighest )
{
	if( NULL == pmapHydraulicInjectionCircuit || NULL == pHM )
	{
		return;
	}

	// Remark: the 'IsInjectionCircuit' method does not return the 3-way mixing circuit!
	if( true == bAddParent && true == pHM->IsInjectionCircuit() )
	{
		int iKey = ( pHM->GetLevel() * 10000 ) + pHM->GetPos();

		if( true == bDeepestToHighest )
		{
			iKey *= -1;
		}

		pmapHydraulicInjectionCircuit->insert( make_pair( iKey, pHM ) );
	}

	for( IDPTR idptr = pHM->GetFirst(); NULL != idptr.MP; idptr = pHM->GetNext( idptr.MP ) )
	{
		CDS_HydroMod *pclChildHM = dynamic_cast<CDS_HydroMod *>( idptr.MP );

		if( NULL == pclChildHM )
		{
			ASSERT_CONTINUE;
		}

		if( true == pclChildHM->IsaModule() )
		{
			// Go deeper inside this module.
			// Remark: Even if the first call to the 'FillInjectionCircuitMap' passed the 'bAddParent' argument with 'true', now we want to add children
			//         so we can reset this variable to 'false'.
			FillInjectionCircuitMap( pmapHydraulicInjectionCircuit, pclChildHM, false, bDeepestToHighest );
		}

		if( true == pclChildHM->IsInjectionCircuit() )
		{
			int iKey = ( pclChildHM->GetLevel() * 10000 ) + pclChildHM->GetPos();

			if( true == bDeepestToHighest )
			{
				iKey *= -1;
			}

			pmapHydraulicInjectionCircuit->insert( make_pair( iKey, pclChildHM ) );
		}
	}
}

bool CTableHM::IsInjectionCircuitTemperatureErrorForPasteOperation( CTable *pclSourceTable, CTable *pclDestinationTable,
		std::multimap<CDS_HydroMod *, CTable *> *pmmapInjectionCircuitWithTemperatureError,
		std::vector<CDS_HydroMod *> *pvecAllInjectionCircuitsWithTemperatureError, bool bProjectTypeDifferent )
{
	// See "DataStruct.h" for more details.

	if( NULL == TASApp.GetpTADS() || NULL == TASApp.GetpTADS()->GetpTechParams() )
	{
		ASSERTA_RETURN( true );
	}

	if( NULL == pclSourceTable && NULL != pclDestinationTable )
	{
		// This case must never happen.
		ASSERTA_RETURN( true );
	}

	bool bAtLeastOneError = false;

	if( ( NULL == pclSourceTable || NULL != dynamic_cast<CTableHM *>( pclSourceTable ) )
			&& NULL == pclDestinationTable )
	{
		// Do the job for each root module (*A, *B, ...).
		for( IDPTR IDPtrRootModule = this->GetFirst(); NULL != IDPtrRootModule.MP; IDPtrRootModule = this->GetNext() )
		{
			CDS_HydroMod *pclRootModule = dynamic_cast<CDS_HydroMod *>( IDPtrRootModule.MP );

			if( NULL == pclRootModule )
			{
				ASSERT_CONTINUE;
			}

			bAtLeastOneError |= IsInjectionCircuitTemperatureErrorForPasteOperation( pclRootModule, pclDestinationTable, pmmapInjectionCircuitWithTemperatureError,
					pvecAllInjectionCircuitsWithTemperatureError, bProjectTypeDifferent );
		}
	}
	else
	{
		CDS_HydroMod *pclSourceHM = dynamic_cast<CDS_HydroMod *>( pclSourceTable );

		if( NULL == pclSourceHM )
		{
			ASSERTA_RETURN( true );
		}

		// We fill the map with all injection circuits from the table that we need to check (It can be module or circuit).
		// 'bAddParent' to 'true': we want also to add 'pclSourceHM' in the map (Obviously if it's an injection circuit).
		// 'bDeepestToHighest' to 'false': we want at the first position the injection circuit that is closest to 'pclSourceTable' and at the 
		// last position the deepest injection circuit.
		std::map<int, CDS_HydroMod *> mapSourceInjectionCircuits;
		FillInjectionCircuitMap( &mapSourceInjectionCircuits, pclSourceHM, true, false );

		if( 0 == (int)mapSourceInjectionCircuits.size() )
		{
			return false;
		}

		ProjectType eProjectType = TASApp.GetpTADS()->GetpTechParams()->GetProjectApplicationType();
		double dDesignSupplyTemperature = -273.15;
		double dDesignReturnTemperature = -273.15;
		CDS_HydroMod *pclDesignTemperatureInterfaceHM = NULL;

		if( NULL == pclDestinationTable || NULL != dynamic_cast<CTableHM *>( pclDestinationTable ) )
		{
			// If we don't have destination table or the destination is the network itself, we must take the 
			// temperatures from the general settings of the project.
			dDesignSupplyTemperature = TASApp.GetpTADS()->GetpTechParams()->GetDefaultPrjTps();
			dDesignReturnTemperature = TASApp.GetpTADS()->GetpTechParams()->GetDefaultPrjTpr();
		}
		else
		{
			pclDesignTemperatureInterfaceHM = dynamic_cast<CDS_HydroMod *>( pclDestinationTable );

			if( NULL == pclDesignTemperatureInterfaceHM )
			{
				ASSERTA_RETURN( true );
			}

			if( false == pclDesignTemperatureInterfaceHM->IsDesignTemperatureInterface() )
			{
				pclDesignTemperatureInterfaceHM = pclDesignTemperatureInterfaceHM->GetpDesignTemperatureInterface();
			}

			if( NULL == pclDesignTemperatureInterfaceHM || false == pclDesignTemperatureInterfaceHM->IsInjectionCircuit() )
			{
				// We can have 'pclDesignTemperatureInterfaceHM' that is NULL. That means that the destination is the root. 
				// Or we can also have the case where 'pclDesignTemperatureInterfaceHM' is not null but it is not an injection circuit (Excluded 3-way mixing).
				// In this case we are with the root.
				// So, we take the temperatures from the general settings of the project.
				dDesignSupplyTemperature = TASApp.GetpTADS()->GetpTechParams()->GetDefaultPrjTps();
				dDesignReturnTemperature = TASApp.GetpTADS()->GetpTechParams()->GetDefaultPrjTpr();
			}
			else
			{
				// We must be in an injection circuit here.
				CDS_HmInj *pclDestinationHMInj = dynamic_cast<CDS_HmInj *>( pclDesignTemperatureInterfaceHM );

				if( NULL == pclDestinationHMInj )
				{
					ASSERTA_RETURN( true );
				}

				dDesignSupplyTemperature = pclDestinationHMInj->GetDesignCircuitSupplySecondaryTemperature();
				dDesignReturnTemperature = pclDestinationHMInj->GetDesignCircuitReturnSecondaryTemperature();
			}
		}

		// We run the 'mapSourceInjectionCircuits' map going from the highest design interface to the deeper.
		// We need to verify for each injection circuit if it's ok with the 'pclDestinationTable' design temperature.
		// If at least one injection circuit is found with error, we put the 'pclSourceHM' in the list.
		// When we will correct it by calling the 'CorrectAllInjectionCircuits' method, we will need to manage all 
		// the injection circuit children.
		for( auto &iterSourceInterface : mapSourceInjectionCircuits )
		{
			CDS_HmInj *pclSourceHMInj = dynamic_cast<CDS_HmInj *>( iterSourceInterface.second );

			if( NULL == pclSourceHMInj )
			{
				// We must have ONLY injection circuit (Except 3-way mixing circuit) in the 'm_mapDesignTemperatureInterfaces' map.
				ASSERTA_RETURN( true );
			}

			// Compare secondary temperatures of the current injection circuit with the parent design temperature.
			double dSourceSecondarySupplyTemperature = pclSourceHMInj->GetDesignCircuitSupplySecondaryTemperature();
			double dSourceSecondaryReturnTemperature = pclSourceHMInj->GetDesignCircuitReturnSecondaryTemperature();
			bool bError = false;

			if( ProjectType::Heating == eProjectType )
			{
				if( dSourceSecondarySupplyTemperature > dDesignSupplyTemperature )
				{
					bError = true;
				}
				else if( true == bProjectTypeDifferent && dSourceSecondaryReturnTemperature > dSourceSecondarySupplyTemperature )
				{
					// If project to import is in cooling and the current one is in heating, automatically the return temperature is bigger than the supply temperature.
					// It's just to have the list of injection circuits in 'pvecAllInjectionCircuitsWithTemperatureError' to manage them after the 
					// change if user wants automatic correction.
					bError = true;
				}
			}
			else if( ProjectType::Cooling == eProjectType )
			{
				if( dSourceSecondarySupplyTemperature < dDesignSupplyTemperature )
				{
					bError = true;
				}
				else if( true == bProjectTypeDifferent && dSourceSecondaryReturnTemperature < dSourceSecondarySupplyTemperature )
				{
					// If project to import is in heating and the current one is in cooling, automatically the return temperature is lower than the supply temperature.
					// It's just to have the list of injection circuits in 'pvecAllInjectionCircuitsWithTemperatureError' to manage them after the 
					// change if user wants automatic correction.
					bError = true;
				}
			}
			else
			{
				ASSERT_CONTINUE;
			}

			if( true == bError )
			{
				// We insert only one time a parent if this one has temperature error.
				if( false == bAtLeastOneError )
				{
					if( NULL != pmmapInjectionCircuitWithTemperatureError )
					{
						pmmapInjectionCircuitWithTemperatureError->insert( std::pair<CDS_HydroMod *, CTable *>( iterSourceInterface.second, pclDestinationTable ) );
					}
				}
				
				// To have a list of all injection circuits with error to show in the 'CDlgInjectionErrors' dialog.
				if( NULL != pvecAllInjectionCircuitsWithTemperatureError )
				{
					// Insert only one time each module in error.
					// Remark: the 'IsInjectionCircuitTemperatureErrorForPasteOperation' can be called several times for a same module (Or circuit) if for example user
					// wants to copy paste a module (Or circuit) in several modules.
					CTableHM::vecHydroMod::iterator iter = std::find( pvecAllInjectionCircuitsWithTemperatureError->begin(), pvecAllInjectionCircuitsWithTemperatureError->end(), iterSourceInterface.second );

					if( pvecAllInjectionCircuitsWithTemperatureError->end() == iter )
					{
						pvecAllInjectionCircuitsWithTemperatureError->push_back( iterSourceInterface.second );
					}
				}

				bAtLeastOneError |= bError;
			}
		}
	}

	return bAtLeastOneError;
}

bool CTableHM::IsInjectionCircuitTemperatureErrorForEditOperation( CTable *pclSourceTable, double dNewSupplyTemperature,
			std::multimap<CDS_HydroMod *, CTable *> *pmmapInjectionCircuitWithTemperatureError, 
			std::vector<CDS_HydroMod *> *pvecAllInjectionCircuitsWithTemperatureError, bool bForGeneralSettings, bool bForApplicationTypeChange )
{
	// See "DataStruct.h" for more details.

	if( NULL == TASApp.GetpTADS() || NULL == TASApp.GetpTADS()->GetpTechParams() )
	{
		ASSERTA_RETURN( true );
	}

	bool bAtLeastOneError = false;
	CTable *pclDestinationTable = NULL;

	if( NULL == pclSourceTable || NULL != dynamic_cast<CTableHM *>( pclSourceTable ) )
	{
		// Do the job for each root module (*A, *B, ...).
		for( IDPTR IDPtrRootModule = this->GetFirst(); NULL != IDPtrRootModule.MP; IDPtrRootModule = this->GetNext() )
		{
			CDS_HydroMod *pclRootModule = dynamic_cast<CDS_HydroMod *>( IDPtrRootModule.MP );

			if( NULL == pclRootModule )
			{
				ASSERT_CONTINUE;
			}

			// The last 'true' parameter is to specify that the root must be added in the 'mapSourceInjectionCircuits' map for the checking 
			// Obviously if this root is also an injection circuit (3-way mixing excluded).
			bAtLeastOneError |= IsInjectionCircuitTemperatureErrorForEditOperation( pclRootModule, dNewSupplyTemperature, 
					pmmapInjectionCircuitWithTemperatureError, pvecAllInjectionCircuitsWithTemperatureError, true, bForApplicationTypeChange );
		}
	}
	else
	{
		CDS_HydroMod *pclSourceHM = dynamic_cast<CDS_HydroMod *>( pclSourceTable );

		if( NULL == pclSourceHM )
		{
			ASSERTA_RETURN( true );
		}

		// We fill the map with all injection circuit from the table that we need to check (It can be module or circuit).
		// 'bAddParent' = 'bForGeneralSettings':
		//     * bForGeneralSettings = true : we are running all root modules in the network, we WANT to add 'pclSourceHM' (Obviously if it's an injection circuit).
		//     * bForGeneralSettings = false: we are editing an hydraulic circuit in the network, we DO NO WANT to add 'pclSourceHM'.
		// 'bDeepestToHighest' to 'false': we want at the first position the injection circuit that is closest to 'pclSourceTable' and at the 
		// last position the deepest injection circuit.
		std::map<int, CDS_HydroMod *> mapInjectionCircuits;
		FillInjectionCircuitMap( &mapInjectionCircuits, pclSourceHM, bForGeneralSettings, false );

		if( 0 == (int)mapInjectionCircuits.size() )
		{
			return false;
		}

		// If user wants to change temperature for the general settings of the project, we run all the network with the 'for' loop above.
		// In this case the destination table must be NULL.
		pclDestinationTable = ( true == bForGeneralSettings ) ? NULL : pclSourceHM;
		ProjectType eProjectType = TASApp.GetpTADS()->GetpTechParams()->GetProjectApplicationType();

		// We run the 'mapSourceInjectionCircuits' map going from the highest design interface to the deeper.
		// We need to verify for each injection circuit if it's ok with the both 'dNewSupplyTemperature' and 'dNewReturnTemperature' variables.
		// If at least one injection circuit is found with error, we put the 'pclSourceHM' in the list.
		// When we will correct it by calling the 'CorrectAllInjectionCircuits' method, we will need to manage all 
		// the injection circuit children.
		for( auto &iterInterface : mapInjectionCircuits )
		{
			CDS_HmInj *pclHMInj = dynamic_cast<CDS_HmInj *>( iterInterface.second );

			if( NULL == pclHMInj )
			{
				// We must have ONLY injection circuit (Except 3-way mixing circuit) in the 'm_mapDesignTemperatureInterfaces' map.
				ASSERTA_RETURN( true );
			}

			// Compare secondary temperatures of the current injection circuit with the parent design temperature.
			// Remark: we just need to compare the supply (Return is not needed).
			double dCurrentSecondarySupplyTemperature = pclHMInj->GetDesignCircuitSupplySecondaryTemperature();
			double dCurrentSecondaryReturnTemperature = pclHMInj->GetDesignCircuitReturnSecondaryTemperature();
			bool bError = false;

			if( ProjectType::Heating == eProjectType )
			{
				if( dCurrentSecondarySupplyTemperature > dNewSupplyTemperature )
				{
					bError = true;
				}
				else if( true == bForApplicationTypeChange && dCurrentSecondaryReturnTemperature > dCurrentSecondarySupplyTemperature )
				{
					// If project was in cooling and user changes to heating, automatically the return temperature is bigger than the supply temperature.
					// It's just to have the list of injection circuits in 'pvecAllInjectionCircuitsWithTemperatureError' to manage them after the 
					// change if user wants automatic correction.
					bError = true;
				}
			}
			else if( ProjectType::Cooling == eProjectType )
			{
				if( dCurrentSecondarySupplyTemperature < dNewSupplyTemperature )
				{
					bError = true;
				}
				else if( true == bForApplicationTypeChange && dCurrentSecondaryReturnTemperature < dCurrentSecondarySupplyTemperature )
				{
					// If project was in heating and user changes to cooling, automatically the return temperature is lower than the supply temperature.
					// It's just to have the list of injection circuits in 'pvecAllInjectionCircuitsWithTemperatureError' to manage them after the 
					// change if user wants automatic correction.
					bError = true;
				}
			}
			else
			{
				ASSERT_CONTINUE;
			}

			if( true == bError )
			{
				// We insert only one time a parent if this one has temperature error.
				if( false == bAtLeastOneError )
				{
					if( NULL != pmmapInjectionCircuitWithTemperatureError )
					{
						pmmapInjectionCircuitWithTemperatureError->insert( std::pair<CDS_HydroMod *, CTable *>( iterInterface.second, pclDestinationTable ) );
					}
				}
				
				// To have a list of all injection circuits with error to show in the 'CDlgInjectionErrors' dialog.
				if( NULL != pvecAllInjectionCircuitsWithTemperatureError )
				{
					// Insert only one time each module in error.
					// Remark: the 'IsInjectionCircuitTemperatureErrorForPasteOperation' can be called several times for a same module (Or circuit) if for example user
					// wants to copy paste a module (Or circuit) in several modules.
					CTableHM::vecHydroMod::iterator iter = std::find( pvecAllInjectionCircuitsWithTemperatureError->begin(), pvecAllInjectionCircuitsWithTemperatureError->end(), iterInterface.second );

					if( pvecAllInjectionCircuitsWithTemperatureError->end() == iter )
					{
						pvecAllInjectionCircuitsWithTemperatureError->push_back( iterInterface.second );
					}
				}

				bAtLeastOneError |= bError;
			}
		}
	}

	return bAtLeastOneError;
}

void CTableHM::CorrectAllInjectionCircuits( std::multimap<CDS_HydroMod *, CTable *> *pmmapInjectionCircuitWithTemperatureError, bool bForApplicationTypeChange )
{
	if( NULL == pmmapInjectionCircuitWithTemperatureError || 0 == (int)pmmapInjectionCircuitWithTemperatureError->size() )
	{
		return;
	}

	for( auto &iterMap : *pmmapInjectionCircuitWithTemperatureError )
	{
		CorrectOneInjectionCircuit( iterMap.first, iterMap.second, bForApplicationTypeChange );
	}
}

void CTableHM::CorrectOneInjectionCircuit( CDS_HydroMod *pclSourceInjectionCircuit, CTable *pclDestinationTable, bool bForApplicationTypeChange )
{
	// See 'DataStruct.h' for more details.

	if( NULL == TASApp.GetpTADS() || NULL == TASApp.GetpTADS()->GetpTechParams() )
	{
		ASSERT_RETURN;
	}

	if( NULL == pclSourceInjectionCircuit || NULL == dynamic_cast<CDS_HmInj *>( pclSourceInjectionCircuit ) )
	{
		// 'pclSourceInjectionCircuit' must be an injection circuit (Excepted 3-way mixing circuit).
		ASSERT_RETURN;
	}

	// We fill the map with all injection circuits from the table that we need to check.
	// 'bAddParent' to 'true': we want also to add 'pclSourceInjectionCircuit' in the map (Obviously if it's an injection circuit).
	// 'bDeepestToHighest' to 'false': we want at the first position the injection circuit that is closest to 'pclSourceTable' and at the 
	// last position the deepest injection circuit.
	std::map<int, CDS_HydroMod *> mapInjectionCircuits;
	FillInjectionCircuitMap( &mapInjectionCircuits, pclSourceInjectionCircuit, true, false );

	// If 'pclSourceInjectionCircuit' is a root and is an injection circuit we add it to the list to verify.
	// (Because the 'FillInjectionCircuitMap' does not add root in the 'mapSourceInjectionCircuits').
	if( 0 == pclSourceInjectionCircuit->GetLevel() && true == pclSourceInjectionCircuit->IsInjectionCircuit() )
	{
		mapInjectionCircuits.insert( std::pair<int, CDS_HydroMod *>( -INT_MAX, pclSourceInjectionCircuit ) );
	}

	if( 0 == (int)mapInjectionCircuits.size() )
	{
		return;
	}

	ProjectType eProjectType = TASApp.GetpTADS()->GetpTechParams()->GetProjectApplicationType();
	double dDesignSupplyTemperature = -273.15;
	double dDesignReturnTemperature = -273.15;
	CDS_HydroMod *pclDestinationHM = NULL;

	if( NULL == pclDestinationTable || NULL != dynamic_cast<CTableHM *>( pclDestinationTable ) || true == bForApplicationTypeChange )
	{
		// If we don't have destination table OR the destination is the network itself OR the user has changed application type,
		// we must take the temperatures from the general settings of the project.
		dDesignSupplyTemperature = TASApp.GetpTADS()->GetpTechParams()->GetDefaultPrjTps();
		dDesignReturnTemperature = TASApp.GetpTADS()->GetpTechParams()->GetDefaultPrjTpr();
	}
	else
	{
		pclDestinationHM = dynamic_cast<CDS_HydroMod *>( pclDestinationTable );

		if( NULL == pclDestinationHM )
		{
			ASSERT_RETURN;
		}

		if( false == pclDestinationHM->IsDesignTemperatureInterface() )
		{
			pclDestinationHM = pclDestinationHM->GetpDesignTemperatureInterface();
		}

		if( NULL == pclDestinationHM || false == pclDestinationHM->IsInjectionCircuit() )
		{
			// We can have 'pclDesignTemperatureInterfaceHM' that is NULL. That means that the destination is the root. 
			// Or we can also have the case where 'pclDesignTemperatureInterfaceHM' is not null but it is not an injection circuit (Excluded 3-way mixing).
			// In this case we are with the root.
			// So, we take the temperatures from the general settings of the project.
			dDesignSupplyTemperature = TASApp.GetpTADS()->GetpTechParams()->GetDefaultPrjTps();
			dDesignReturnTemperature = TASApp.GetpTADS()->GetpTechParams()->GetDefaultPrjTpr();
		}
		else
		{
			// We must be in an injection circuit here.
			CDS_HmInj *pclDestinationHMInj = dynamic_cast<CDS_HmInj *>( pclDestinationHM );

			if( NULL == pclDestinationHMInj )
			{
				ASSERT_RETURN;
			}

			dDesignSupplyTemperature = pclDestinationHMInj->GetDesignCircuitSupplySecondaryTemperature();
			dDesignReturnTemperature = pclDestinationHMInj->GetDesignCircuitReturnSecondaryTemperature();
		}
	}

	// We run the 'm_mapDesignTemperatureInterfaces' map going from the highest design interface to the deeper.
	for( auto &iterInterface : mapInjectionCircuits )
	{
		CDS_HmInj *pclHMInj = dynamic_cast<CDS_HmInj *>( iterInterface.second );

		if( NULL == pclHMInj )
		{
			// We must have ONLY injection circuit (Except 3-way mixing circuit) in the 'm_mapDesignTemperatureInterfaces' map.
			ASSERT_RETURN;
		}

		if( false == true == bForApplicationTypeChange )
		{
			// Compare secondary temperatures of the current injection circuit with the parent design temperature.
			double dCurrentSecondarySupplyTemperature = pclHMInj->GetDesignCircuitSupplySecondaryTemperature();
			double dCurrentSecondaryReturnTemperature = pclHMInj->GetDesignCircuitReturnSecondaryTemperature();
			double dCurrentDeltaT = abs( dCurrentSecondarySupplyTemperature - dCurrentSecondaryReturnTemperature );

			if( ProjectType::Heating == eProjectType )
			{
				if( dCurrentSecondarySupplyTemperature > dDesignSupplyTemperature )
				{
					// Temperature on the supply at the secondary side can be higher that the temperature on the supply at the primary side.
					pclHMInj->SetDesignCircuitSupplySecondaryTemperature( dDesignSupplyTemperature );

					// We keep the same DT that the one defined by the user (Or the computed one).
					// Circuit: DT is input by the user by changing the supply or return temperatures at the secondary side.
					// Module : there is no terminal unit available for user. The return temperature at the secondary side is the computed one 
					//          regaring the children. So we keep this DT. This one will be automatically recomputed and changed if needed when
					//          'CDS_HydromMod::ComputeAll' will be called.
					pclHMInj->SetDesignCircuitReturnSecondaryTemperature( dDesignSupplyTemperature - dCurrentDeltaT );
				}
				else
				{
					dDesignSupplyTemperature = dCurrentSecondarySupplyTemperature;
				}
			}
			else if( ProjectType::Cooling == eProjectType )
			{
				if( dCurrentSecondarySupplyTemperature < dDesignSupplyTemperature )
				{
					// Temperature on the supply at the secondary side can be lower that the temperature on the supply at the primary side.
					pclHMInj->SetDesignCircuitSupplySecondaryTemperature( dDesignSupplyTemperature );

					// Same remark as above.
					pclHMInj->SetDesignCircuitReturnSecondaryTemperature( dDesignSupplyTemperature + dCurrentDeltaT );
				}
				else
				{
					dDesignSupplyTemperature = dCurrentSecondarySupplyTemperature;
				}
			}
			else
			{
				ASSERT_CONTINUE;
			}
		}
		else
		{
			// When user changes the application type, we simply copy the design temperature in each secondary.
			pclHMInj->SetDesignCircuitSupplySecondaryTemperature( dDesignSupplyTemperature );
			pclHMInj->SetDesignCircuitReturnSecondaryTemperature( dDesignReturnTemperature );
		}
	}
}

void CTableHM::CorrectAllPrimaryFlow( CTable *pclParentTable )
{
	// See 'DataStruct.h' for more details.

	if( NULL == pclParentTable || NULL != dynamic_cast<CTableHM *>( pclParentTable ) )
	{
		// Do the job for each root module (*A, *B, ...).
		for( IDPTR IDPtrRootModule = this->GetFirst(); NULL != IDPtrRootModule.MP; IDPtrRootModule = this->GetNext() )
		{
			CDS_HydroMod *pclRootModule = dynamic_cast<CDS_HydroMod *>( IDPtrRootModule.MP );

			if( NULL == pclRootModule )
			{
				ASSERT_CONTINUE;
			}

			CorrectAllPrimaryFlow( pclRootModule );
		}
	}
	else
	{
		CDS_HydroMod *pclParentHM = dynamic_cast<CDS_HydroMod *>( pclParentTable );

		if( NULL == pclParentHM )
		{
			ASSERT_RETURN;
		}

		if( true == pclParentHM->IsaModule() )
		{
			// When doing a paste operation (1) or changing global temperature or application type (2), we pass as argument the parent table that
			// is either the module in which we do the paste operation (1) or parent table is NULL and we run all the root module of the hydraulic network (2).
			// In this case, we are never with a circuit in first position.
			for( IDPTR ChildIDPtr = pclParentHM->GetFirst(); NULL != ChildIDPtr.MP; ChildIDPtr = pclParentHM->GetNext() )
			{
				CDS_HydroMod *pclChildHM = dynamic_cast<CDS_HydroMod *>( (CData*)ChildIDPtr.MP );

				if( NULL == pclChildHM )
				{
					ASSERT_RETURN;
				}

				if( true == pclChildHM->IsaModule() )
				{
					// Go deeper with this new module.
					CorrectAllPrimaryFlow( pclChildHM );
				}
				else if( true == pclChildHM->IsInjectionCircuit() )
				{
					// The current child is an injection circuit.
					pclChildHM->SetHMPrimAndSecFlow( pclChildHM->GetpTermUnit()->GetQ() );
				}
			}
		}
		else
		{
			// When editing secondary temperatures at the secondary side of injection circuit, we pass as argument the current hydraulic circuit edited that 
			// can be either a module or a circuit. In case of module, it is managed with the code above. Otherwise if it's a circuit we need to verify here.
			if( true == pclParentHM->IsInjectionCircuit() )
			{
				// The current child is an injection circuit.
				pclParentHM->SetHMPrimAndSecFlow( pclParentHM->GetpTermUnit()->GetQ() );
			}
		}
	}
}

bool CTableHM::CheckIsConstantFlow( CDS_HydroMod *pPressIntHM )
{
	if( NULL == pPressIntHM )
	{
		ASSERTA_RETURN( false );
	}

	bool bConstantFlow = true;

	if( false == pPressIntHM->IsaModule() )
	{
		CDB_CircSchemeCateg *pSchCateg = pPressIntHM->GetpSchcat();

		if( pSchCateg != NULL )
		{
			bConstantFlow = ( CDB_CircSchemeCateg::eFLOWVAR::Constant == pSchCateg->GetVarSecondFlow() );
		}
	}
	else
	{
		// When we have a module w/o secondary side we have to take into account variability of flow of the module itself.
		// HYS-1969: test GetpSchcat at first.
		if(  pPressIntHM->GetpSchcat() != NULL && false == pPressIntHM->GetpSchcat()->IsSecondarySideExist()
				&& CDB_CircSchemeCateg::eFLOWVAR::Variable == pPressIntHM->GetpSchcat()->GetVarPrimFlow() )
		{
			bConstantFlow = false;
		}
		else
		{
			// When pressure interface is a module we have to scan all children.
			for( IDPTR idptr = pPressIntHM->GetFirst(); _T('\0') != *idptr.ID && true == bConstantFlow; idptr = pPressIntHM->GetNext( idptr.MP ) )
			{
				CDS_HydroMod *pCHM = static_cast<CDS_HydroMod *>( idptr.MP );
				CDB_CircSchemeCateg *pSchCateg = pCHM->GetpSchcat();

				if( pSchCateg != NULL && CDB_CircSchemeCateg::eFLOWVAR::Variable == pSchCateg->GetVarPrimFlow() )
				{
					// As soon as we find a child that has variable flow at its primary side, we consider that all children and thus output side 
					// of the parent hydraulic circuit are variable flow.
					bConstantFlow = false;
					break;
				}

				// HYS-1969: test pSchCateg
				if( NULL != pSchCateg && true == pCHM->IsaModule() && false == pCHM->IsPressureInterfaceExist() )
				{
					bConstantFlow = CheckIsConstantFlow( pCHM );
				}
			}
		}
	}

	return bConstantFlow;
}

bool CTableHM::_GetDFModuleList( CDS_HydroMod *pHMRoot, vecHydroMod &ModuleList, double &dDiversityFactor )
{
	if( NULL == pHMRoot || pHMRoot->GetLevel() != 0 )
	{
		return false;
	}

	CDS_HydroMod *pHMParent = pHMRoot;
	CDS_HydroMod *pHM = pHMRoot;
	std::vector<CDS_HydroMod *> vecTreeList;
	CDS_HydroMod *pHMDF = NULL;
	bool bGoToChildren;
	int iCurrentDeep = 0;
	bool bCanStop = false;
	bool bDiversity = false;

	do
	{
		bGoToChildren = true;

		if( pHM != NULL )
		{
			// Look only at the module (no diversity factor applied on circuit).
			if( true == pHM->IsaModule() )
			{
				// If diversity factor exist on this module...
				// Remark: -1.0 is the value to tell that there is not yet diversity factor applied.
				if( pHM->GetDiversityFactor() != -1.0 && pHM->GetDiversityFactor() < 1.0 )
				{
					// Memorize the module and set a flag.
					pHMDF = pHM;
					bDiversity = true;
				}
				else if( true == bDiversity )
				{
					// If we are on a module and there is no diversity factor applied on it BUT parent contains
					// a diversity factor (thanks to the flag) then we don't need to go deeper in the children.
					bGoToChildren = false;
				}
			}
		}

		// If current module is NULL... (next or child)
		if( NULL == pHM )
		{
			// If there is yet a parent...
			if( vecTreeList.size() > 0 )
			{
				// Decrease current deep and retrieve the current parent.
				iCurrentDeep--;
				pHMParent = vecTreeList.back();
				vecTreeList.pop_back();

				// Go next module.
				pHM = dynamic_cast<CDS_HydroMod *>( (CData *)( pHMParent->GetNext( ).MP ) );

				// If diversity flag is set ...
				if( true == bDiversity )
				{
					// We must add in module list last saved module with diversity factor.
					ModuleList.push_back( pHMDF );
					dDiversityFactor = pHMDF->GetDiversityFactor();
					pHMDF = NULL;
					bDiversity = false;
				}
			}
			else
			{
				bCanStop = true;
			}
		}
		else if( true == bGoToChildren && NULL != dynamic_cast<CDS_HydroMod *>( (CData *)( pHM->GetFirst().MP ) ) )
		{
			// If we can go deeper in the children and at least one exists...
			iCurrentDeep++;
			vecTreeList.push_back( pHMParent );
			pHMParent = pHM;
			pHM = dynamic_cast<CDS_HydroMod *>( (CData *)( pHMParent->GetFirst().MP ) );
		}
		else
		{
			// Either we CAN'T go deeper in children or there is NO children.
			if( true == pHM->IsaModule() && true == bDiversity )
			{
				ModuleList.push_back( pHMDF );
				dDiversityFactor = pHMDF->GetDiversityFactor();
				pHMDF = NULL;
				bDiversity = false;
			}

			if( pHM == pHMRoot )
			{
				bCanStop = true;
			}
			else
			{
				pHM = dynamic_cast<CDS_HydroMod *>( (CData *)( pHMParent->GetNext().MP ) );
			}
		}
	}
	while( false == bCanStop );

	return true;
}

void CTableHM::_VerifyMeasTABalDateTime( CTable *pTable )
{
	if( NULL == pTable )
	{
		return;
	}

	for( IDPTR IDPtr = pTable->GetFirst(); NULL != IDPtr.MP; IDPtr = pTable->GetNext( IDPtr.MP ) )
	{
		CDS_HydroMod *pHM = dynamic_cast<CDS_HydroMod *>( IDPtr.MP );

		if( NULL == pHM )
		{
			continue;
		}

		unsigned int uiNbrMeasData = pHM->GetMeasDataSize();

		for( unsigned int i = 0; i < uiNbrMeasData; i++ )
		{
			CDS_HydroMod::CMeasData *pMeas = pHM->GetpMeasData( i );

			if( NULL != pMeas )
			{
				// Quick measure.
				if( pMeas->GetMeasDateTime() < 0 )
				{
					if( CDS_HydroModX::QMundef != pMeas->GetQMType() )
					{
						pMeas->SetMeasDateTime( m_iResetMeasDateTimeIndex++ );
					}
					else
					{
						pMeas->SetMeasDateTime( 0 );
					}
				}

				// TA Balance.
				if( pMeas->GetTABalDateTime() < 0 )
				{
					if( true == pMeas->GetFlagTaBalMeasCompleted() || CDS_HydroModX::etabmTABalPlusStarted == pMeas->GetFlagBalanced()
						|| CDS_HydroModX::etabmTABalPlus == pMeas->GetFlagBalanced() )
					{
						pMeas->SetTABalDateTime( m_iResetTABalDateTimeIndex++ );
					}
					else
					{
						pMeas->SetTABalDateTime( 0 );
					}
				}
			}
		}

		if( true == pHM->IsaModule() )
		{
			_VerifyMeasTABalDateTime( pHM );
		}
	}
}

bool CTableHM::IsDiversityExistSomewhere( CTable *pTab )
{
	if( NULL == pTab )
	{
		pTab = TASApp.GetpTADS()->GetpHydroModTable();
	}

	for( IDPTR IDPtr = pTab->GetFirst(); NULL != IDPtr.MP; IDPtr = pTab->GetNext( IDPtr.MP ) )
	{
		CDS_HydroMod *pHM = dynamic_cast<CDS_HydroMod *>( IDPtr.MP );

		if( true == pHM->IsaModule() )
		{
			// If diversity factor exist on this module...
			// Remark: -1.0 is the value to tell that there is not yet diversity factor applied.
			if( pHM->GetDiversityFactor() != -1.0 && pHM->GetDiversityFactor() < 1.0 )
			{
				return true;
			}

			if( true == IsDiversityExistSomewhere( pHM ) )
			{
				return true;
			}
		}
	}

	return false;
}

#endif


///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_QMTable
//
///////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DATA( CDS_QMTable )

#define CDS_QMTABLE_SHORTINFOS_VERSION	1
bool CDS_QMTable::WriteShortInfos( OUTSTREAM outf, std::map<__time32_t, uint16_t> *pMap )
{
	if( NULL == pMap )
	{
		return false;
	}

	std::map<__time32_t, uint16_t>::iterator it;
	
	// Version.
	BYTE Version = CDS_QMTABLE_SHORTINFOS_VERSION;
	WriteData<>( outf, Version );
	
	// Size.
	short size =( short )pMap->size();
	WriteData<>( outf, size );

	for( it = pMap->begin(); it != pMap->end() && size; ++it )
	{
		WriteData<>( outf, it->first );
		WriteData<>( outf, it->second );
	}

	return true;
}

bool CDS_QMTable::WriteShortInfos( OUTSTREAM outf )
{
	struct tm *timeinfo = NULL;
	std::map<__time32_t, uint16_t> Map;
	std::map<__time32_t, uint16_t>::iterator it;
	Map.clear();

	// Scan all Quick Measurement, only one level of the tree view.
	// Sort measurement by date.
	for( IDPTR IDPtr = GetFirst(); NULL != IDPtr.MP; IDPtr = GetNext( IDPtr.MP ) )
	{
		CDS_HydroModX *pHM = dynamic_cast<CDS_HydroModX *>( IDPtr.MP );

		if( NULL != pHM )
		{
			__time32_t date = pHM->GetMeasDateTime( CDS_HydroModX::InPrimary );

#ifndef TACBX
#pragma warning ( disable : 4996)
#endif

			timeinfo = localtime( ( const time_t * )&date );

#ifndef TACBX
#pragma warning ( default : 4996)
#pragma warning ( disable : 4244)
#endif

			date = mktime( timeinfo );

#ifndef TACBX
#pragma warning ( default : 4244)
#endif

			it = Map.find( date );
			uint16_t val = pHM->GetQMType( CDS_HydroModX::InPrimary );

			// Add it if doesn't exist
			if( it == Map.end() )
			{
				Map[date] = val;
			}
		}
	}

	bool bRet = WriteShortInfos( outf, &Map );
	return bRet;
}

bool CDS_QMTable::ReadShortInfos( INPSTREAM  inpf, std::map<__time32_t, uint16_t> *pMap )
{
	if( NULL == pMap )
	{
		return false;
	}

	// Version.
	BYTE Version = CDS_QMTABLE_SHORTINFOS_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	// Sanity test.
	if( Version < 1 || Version > CDS_QMTABLE_SHORTINFOS_VERSION )
	{
		return false;
	}

	// Base class.
	pMap->clear();
	short size = 0;
	inpf.read( (char *)&size, sizeof( size ) );
	__time32_t date;
	uint16_t type;

	for( ; size; size-- )
	{
		inpf.read( (char *)&date, sizeof( __time32_t ) );
		inpf.read( (char *)&type, sizeof( uint16_t ) );
		( *pMap )[date] = type;
	}

	return true;
}

bool CDS_QMTable::VerifyQMExist( CDS_HydroModX *pQM, IDPTR *pIDPtr )
{
	// Variables
	__time32_t StartingDateTime;
	__time32_t CurrentStartingDateTime;


	// Make the verification with the name and the Date
	std::wstring *pName = pQM->GetHMName();
	StartingDateTime = pQM->GetMeasDateTime( CDS_HydroModX::InPrimary );

	// Do a loop on the table to verify the existence of the object
	for( IDPTR IDPtr = GetFirst( CLASS( CDS_HydroModX ) ); _T('\0') != *IDPtr.ID; IDPtr = GetNext( IDPtr.MP ) )
	{
		CDS_HydroModX *pQMX = dynamic_cast<CDS_HydroModX *>( IDPtr.MP );
		ASSERT( NULL != pQMX );

		if( NULL != pQMX )
		{
			// Verify if QM found is not the associated measurement
			// If yes skip it
			if( pQM->GetAssociatedHMXID() == pQMX->GetAssociatedHMXID() )
			{
				continue;
			}

			if( *pName == *pQMX->GetHMName() )
			{
				CurrentStartingDateTime = pQMX->GetMeasDateTime( CDS_HydroModX::InPrimary );

				if( StartingDateTime == CurrentStartingDateTime )
				{
					*pIDPtr = IDPtr;
					return true;
				}
			}
		}
	}

	return false;
}

#define CDS_QMTABLE_VERSION	1
void CDS_QMTable::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_QMTABLE_VERSION;
	WriteData<>( outf, Version );
	
	// Base class.
	CTable::Write( outf );
}

bool CDS_QMTable::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_QMTABLE_VERSION;

	// Manage old version of TAScope where CDS_LogTable was not written.
	if( _ttoi( GetIDPtr().DB->GetVersion() ) > _ttoi( TASCOPE_BASE_FORMAT_VERSION ) )
	{
		inpf.read( (char *)&Version, sizeof( Version ) );
	}

	if( Version < 1 || Version > CDS_QMTABLE_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CTable::Read( inpf ) )
	{
		return false;
	}

	return true;
}

#ifndef TACBX
void CDS_QMTable::GetLowerUpperDataTime( COleDateTime &clLowerDateTime, COleDateTime &clUpperDateTime )
{
	clLowerDateTime.SetDateTime( 9999, 1, 1, 0, 0, 0 );
	clUpperDateTime.SetDateTime( 100, 1, 1, 0, 0, 0 );
	CDS_QMTable *pclQMTable = dynamic_cast<CDS_QMTable *>( TASApp.GetpTADS()->GetpQuickMeasureTable() );

	if( NULL == pclQMTable || 0 == pclQMTable->GetItemCount() )
	{
		return;
	}

	_GetLowerUpperDataTime( pclQMTable, clLowerDateTime, clUpperDateTime );

	if( clLowerDateTime == COleDateTime( 9999, 1, 1, 0, 0, 0 ) )
	{
		clLowerDateTime = clUpperDateTime;
	}
	else if( clUpperDateTime == COleDateTime( 100, 1, 1, 0, 0, 0 ) )
	{
		clUpperDateTime = clLowerDateTime;
	}
}

void CDS_QMTable::_GetLowerUpperDataTime( CTable *pclQMTable, COleDateTime &clLowerDateTime, COleDateTime &clUpperDateTime )
{
	if( NULL == pclQMTable )
	{
		return;
	}

	for( IDPTR IDPtr = pclQMTable->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pclQMTable->GetNext( IDPtr.MP ) )
	{
		CDS_HydroModX *pHMX = dynamic_cast<CDS_HydroModX *>( IDPtr.MP );

		if( NULL == pHMX )
		{
			continue;
		}

		// Remark: for the minimum, we try to take min but not 0 (if possible).
		__time32_t time32Min = min( ( 0 == pHMX->GetMeasDateTime() ) ? LONG_MAX : pHMX->GetMeasDateTime(),
				( 0 == pHMX->GetTABalDateTime() ) ? LONG_MAX : pHMX->GetTABalDateTime() );

		__time32_t time32Max = max( pHMX->GetMeasDateTime(), pHMX->GetTABalDateTime() );

		if( time32Min == LONG_MAX && time32Max <= 0 )
		{
			continue;
		}

		COleDateTime timMin;

		if( time32Min > 0 )
		{
			tm dt;

			if( 0 != _gmtime32_s( &dt, &time32Min ) )
			{
				memset( &dt, 0, sizeof( dt ) );
				dt.tm_year = 70;
				dt.tm_mday = 1;
			}

			timMin.SetDateTime( dt.tm_year + 1900, dt.tm_mon + 1, dt.tm_mday, dt.tm_hour, dt.tm_min, dt.tm_sec );
		}

		COleDateTime timMax;

		if( time32Max > 0 )
		{
			tm dt;

			if( 0 != _gmtime32_s( &dt, &time32Max ) )
			{
				memset( &dt, 0, sizeof( dt ) );
				dt.tm_year = 70;
				dt.tm_mday = 1;
			}

			timMax.SetDateTime( dt.tm_year + 1900, dt.tm_mon + 1, dt.tm_mday, dt.tm_hour, dt.tm_min, dt.tm_sec );
		}

		if( timMin > 0 && timMin < clLowerDateTime )
		{
			clLowerDateTime = timMin;
		}

		if( timMax > 0 && timMax > clUpperDateTime )
		{
			clUpperDateTime = timMax;
		}

		if( true == pHMX->IsaModule() )
		{
			_GetLowerUpperDataTime( pHMX, clLowerDateTime, clUpperDateTime );
		}
	}
}
#endif

CDS_HydroModX *CDS_QMTable::GetAssociatedHM( CDS_HydroModX *pQM, int iBeforePos )
{
	if( NULL == pQM )
	{
		return NULL;
	}

	if( _T("") == pQM->GetAssociatedHMXID() )
	{
		return NULL;
	}

	int iCount = 0;

	for( IDPTR idptr = GetFirst( CLASS( CDS_HydroModX ) ); _T('\0') != *idptr.ID && ( iCount < iBeforePos ); idptr = GetNext( idptr.MP ) )
	{
		iCount++;
		CDS_HydroModX *pHMX = dynamic_cast<CDS_HydroModX *>( idptr.MP );

		if( pHMX == pQM )
		{
			continue;
		}

		if( pHMX->GetAssociatedHMXID() == pQM->GetAssociatedHMXID() )
		{
			return pHMX;
		}
	}

	return NULL;
}


///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_HydroModX
//
///////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DATA( CDS_HydroModX )

CDS_HydroModX::CDS_HydroModX( CDataBase *pDataBase, LPCTSTR ID )
	: CTable( pDataBase, ID )
{
	m_Pos = 0;					// Circuit position in his parent
	m_bIndexCircuit = false;		// True if ths circuit is the index circuit
	m_bModule = false;			// True if this circuit is a module
	m_Uid = 0;
	m_SchemeIDPtr = _NULL_IDPTR;
	m_eReturnType = Direct;

	m_pDpC = NULL;
	m_pCv = NULL;
	m_pShutoffValveSupply = NULL;
	m_pShutoffValveReturn = NULL;
	m_pSmartControlValve = NULL;
	m_pSmartDpC = NULL;

	for( int i = 0; i < CHMXPipe::epipeLast; i++ )
	{
		m_pPipe[i] = NULL;
	}

	m_pTU = NULL;
	m_bReadyForBalancing = false;
	m_bNonMeasurablePoint = false;
	m_usZeroPointOffsetRaw = 0;
	m_dTABalValMinDp = 3000;
	
#ifdef TACBX
	m_dTABalValMinDp = CBXDataStruct::GetpTechParam()->GetValvMinDp();
#endif

	m_dDesignFlow = 0.0;

	m_dDesignFlow_Sec = 0.0;
	m_dTempSecondary = 0.0;
	m_dTempReturn = 0.0;

	m_ModuleStatus = 0;
	AddMeasData( InPrimary );
	ResetMeasurements( true, InPrimary );
	m_pCM = NULL;
	m_pTAW = NULL;
	m_dQMNote = L"";
}

CDS_HydroModX::~CDS_HydroModX()
{
	RelaxComputerMethod();
	RelaxTAWirelessMethod();

	if( NULL != GetpDpC() )
	{
		RemoveDpC();
	}

	for( int iLocation = InPrimary; iLocation < LastItem; iLocation = iLocation + 1 )
	{
		if( NULL != GetpBV( ( eLocate )iLocation ) )
		{
			RemoveBv( ( eLocate )iLocation );
		}
	}

	if( NULL != GetpCv() )
	{
		RemoveCv();
	}

	for( int i = 0; i < CHMXPipe::epipeLast; i++ )
	{
		RemovePipe( ( CHMXPipe::ePipeLoc )i );
	}

	if( NULL != GetpTU() )
	{
		RemoveTU();
	}

	if( NULL != GetpShutoffValve( ShutoffValveLocSupply ) )
	{
		RemoveShutoffValve( ShutoffValveLocSupply );
	}

	if( NULL != GetpShutoffValve( ShutoffValveLocReturn ) )
	{
		RemoveShutoffValve( ShutoffValveLocReturn );
	}

	if( NULL != GetpSmartControlValve() )
	{
		RemoveSmartControlValve();
	}

	if( NULL != GetpSmartDpC() )
	{
		RemoveSmartDpC();
	}
}

CDS_HydroModX::ReturnType CDS_HydroModX::GetChildrenReturnType()
{
	// Scan all children.
	for( IDPTR idptr = GetFirst(); NULL != idptr.MP; idptr = GetNext( idptr.MP ) )
	{
		CDS_HydroModX *pHM = dynamic_cast<CDS_HydroModX *>( idptr.MP );
		return pHM->GetReturnType();
	}

	return Direct;
}

CDS_HydroModX *CDS_HydroModX::GetNextValveToBalance()
{
	// Sort circuits.
	std::map<int, CDS_HydroModX *> MapHMX;
	std::map<int, CDS_HydroModX *>::reverse_iterator rIt;
	int iCount = GetOrdered( &MapHMX );

	if( 0 == iCount )
	{
		return NULL;
	}

	for( rIt = MapHMX.rbegin(); rIt != MapHMX.rend(); ++rIt )
	{
		CDS_HydroModX *pHM = dynamic_cast<CDS_HydroModX *>( rIt->second );

		if( false == pHM->IsTABalMeasCompleted( InPrimary ) )
		{
			return pHM;
		}
	}

	return NULL;
}

void CDS_HydroModX::ResetTABalanceMode( eTABalanceMethod TABalMethod, bool bReset )
{
	eLocate locate = InPrimary;

	// If module and 2wInj circuit, use secondary.
	if( true == IsaModule() && true == GetpSch()->GetpSchCateg()->IsSecondarySideExist() )
	{
		locate = InSecondary;
	}

	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		if( pMD->GetBalanced() == TABalMethod && !bReset )
		{
			return;
		}

		pMD->SetBalanced( TABalMethod );

		// If we start a balancing operation reset all children MeasCompleted to NoMeas
		if( etabmNoBalancing == pMD->GetBalanced() ||	etabmTABalPlusStarted == pMD->GetBalanced() ||	etabmTABalWirelessStarted == pMD->GetBalanced() )
		{
			SetTABalMeasCompleted( emcNoMeas, 0, locate );

			for( IDPTR idptr = GetFirst(); NULL != idptr.MP; idptr = GetNext( idptr.MP ) )
			{
				CDS_HydroModX *pHM = dynamic_cast<CDS_HydroModX *>( idptr.MP );

				if( NULL != pHM )
				{
					pHM->SetTABalMeasCompleted( emcNoMeas, 0, InPrimary );
				}
			}
		}
	}
}

void CDS_HydroModX::SetTABalanceMode( eTABalanceMethod TABalMethod )
{
	eLocate locate = InPrimary;

	// If module and 2wInj circuit, use secondary
	if( true == IsaModule() && true == GetpSch()->GetpSchCateg()->IsSecondarySideExist() )
	{
		locate = InSecondary;
	}

	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		pMD->SetBalanced( TABalMethod );
	}
}

CDS_HydroModX::eTABalanceMethod CDS_HydroModX::GetTABalanceMode()
{
	eLocate locate = InPrimary;

	// If module and 2wInj circuit, use secondary
	if( true == IsaModule() && true == GetpSch()->GetpSchCateg()->IsSecondarySideExist() )
	{
		locate = InSecondary;
	}

	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		return pMD->GetBalanced();
	}

	return etabmLast;
}

bool CDS_HydroModX::IsBalanced()
{
	eLocate locate = InPrimary;

	// If module and 2wInj circuit, use secondary
	if( true == IsaModule() && true == GetpSch()->GetpSchCateg()->IsSecondarySideExist() )
	{
		locate = InSecondary;
	}

	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		return ( etabmTABalPlus == pMD->GetBalanced() || etabmTABalWireless == pMD->GetBalanced() || etabmForced == pMD->GetBalanced() );
	}

	return false;
}

double CDS_HydroModX::GetTABalMeasDp_2( eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		return pMD->GetTaBalMeasDp_2();
	}

	return 0;
}

void CDS_HydroModX::SetTABalMeasDp_2( double dVal, eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		pMD->SetTaBalMeasDp_2( dVal );
	}
}


bool CDS_HydroModX::IsTABalMeasCompleted( eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		return ( emcNoMeas != pMD->GetTaBalMeasCompleted() ) ? true : false;
	}

	return false;
}

void CDS_HydroModX::SetTABalMeasCompleted( eTABalMeasCompleted BalMeasCompleted, __time32_t time, eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		if( pMD->GetTaBalMeasCompleted() != BalMeasCompleted )
		{
			Modified();
		}

		pMD->SetTaBalMeasCompleted( emcNoMeas );

		if( emcAsTAWManual != BalMeasCompleted )
		{
			if( emcNoMeas != BalMeasCompleted )
			{
				CDS_HydroModX::CBase *pMV = GetpMeasValve( locate );

				if( NULL != pMV && GetTABalMeasDp_2( locate ) > 0.0 )
				{
					if( CDS_HydroModX::emcAsCircuit == pMD->GetTaBalMeasCompleted() )
					{
						if( pMV->GetTABalMeasDp_1() > 0.0 )
						{
							pMD->SetTaBalMeasCompleted( BalMeasCompleted );    // Circuit Dp1 && Dp2  must be present
						}
					}
					else
					{
						pMD->SetTaBalMeasCompleted( BalMeasCompleted );    // Circuit Dp1 && Dp2  must be present
					}
				}
			}
		}
		else 	// In manual mode verify nothing
		{
			pMD->SetTaBalMeasCompleted( emcAsTAWManual );
		}

		if( emcNoMeas != pMD->GetTaBalMeasCompleted() )
		{
			pMD->SetTABalDateTime( time );
		}
		else
		{
			pMD->SetTABalDateTime( 0 );
		}
	}
}

CDS_HydroModX::eTABalMeasCompleted	CDS_HydroModX::GetTABalMeasCompleted( eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		return pMD->GetTaBalMeasCompleted();
	}

	return emcLastMeasCompleted;
}

void  CDS_HydroModX::ResetTaBalMeasforChildrenModule()
{
	// Scan all children.
	// Reset flag m_eTaBalMeasCompleted when it was done on a PV
	// useful when the HM is balanced inside his parent
	for( IDPTR idptr = GetFirst(); NULL != idptr.MP; idptr = GetNext( idptr.MP ) )
	{
		CDS_HydroModX *pHM = dynamic_cast<CDS_HydroModX *>( idptr.MP );

		if( emcAsPV == pHM->GetTABalMeasCompleted( InPrimary ) )
		{
			pHM->SetTABalMeasCompleted( CDS_HydroModX::emcNoMeas, 0, InPrimary );
		}
	}
}

double	CDS_HydroModX::GetTaBalPipeDp( eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		return pMD->GetTaBalPipeDp();
	}

	return 0;
}

double CDS_HydroModX::GetTaBalUnitDp( eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		return pMD->GetTaBalUnitDp();
	}

	return 0;
}

void CDS_HydroModX::SetTaBalPipeDp( double m_dDp, eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		pMD->SetTaBalPipeDp( m_dDp );
	}
}

void CDS_HydroModX::SetTaBalUnitDp( double m_dDp, eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		pMD->SetTaBalUnitDp( m_dDp );
	}
}

CDS_HydroModX::eHMXBalType CDS_HydroModX::GetHMXBalType( )
{
	// Balancing type.
	CDB_CircuitScheme *pSch = dynamic_cast<CDB_CircuitScheme *>( GetSchemeIDPtr().MP );

	if( NULL == pSch )
	{
		return NOBalancing;
	}

	// Valve defined by his KV?
	// Remark: valve defined by Kv are always saved in a 'CDS_HydroModX::CBV' object.
	if( NULL != GetpBV( InPrimary ) && CDS_HydroModX::Kvmode == GetpBV( InPrimary )->GetMode() )
	{
		return BV;
	}
	else
	{
		switch( pSch->GetBalType() )
		{
			case CDB_CircuitScheme::BV:

				// Test first the combined balancing and control valve.
				if( NULL == GetpBV( InPrimary ) && NULL != GetpCv() && CDB_ControlProperties::PresetPT == pSch->GetCvFunc() )
				{
					// Example: TBV-C & TBV-CM (combined balancing and control valve).
					// Remark: Normally the simple fact to have #eBALTYPE_BV and #eCVFUNC_Presettable or #eCVFUNC_PresetPT in the 'CDB_CircuitScheme'
					//         object can allow us to tell that is a combined balancing and control valve. To be sure, we add a test to check if
					//         there is no balancing valve in the circuit scheme.
					//         We can balancing with balancing and control valve only if this valve is presettable with point test function.
					return BVCV;
				}
				else if( NULL == GetpBV( InPrimary ) )
				{
					// Special case (ex: PUMP with no BV - no valve container).
					return NOBalancing;
				}
				else if( _NULL_IDPTR == GetpBV( InPrimary )->GetValveIDPtr() )
				{
					// Special case (ex: PUMP with no BV - valve not defined).
					return NOBalancing;
				}
				else
				{
					return BV;
				}

				break;

			case CDB_CircuitScheme::DPC:

				if( CDB_CircuitScheme::eDpCTypePICV == pSch->GetDpCType() )
				{
					return PICV;
				}
				else if( CDB_CircuitScheme::eDpCTypeDPCBCV == pSch->GetDpCType() )
				{
					return DPC_BCV;
				}
				else if( CDB_ControlProperties::PresetPT == pSch->GetCvFunc() ||
						 CDB_ControlProperties::Presettable == pSch->GetCvFunc() )
				{
					return DPC_CV;
				}
				else
				{
					return DPC;
				}

				break;

			default:
			case CDB_CircuitScheme::SP:
				return NOBalancing;
		}
	}
}

CDB_TAProduct *CDS_HydroModX::GetpTAP( eLocate locate )
{
	CDB_TAProduct *pTAP = NULL;

	if( NULL != GetpMeasValve( locate ) )
	{
		pTAP = dynamic_cast<CDB_TAProduct *>( GetpMeasValve( locate )->GetValveIDPtr().MP );
	}

	return pTAP;
}

CDB_AlienRegValve *CDS_HydroModX::GetpALIENP( eLocate locate )
{
	CDB_AlienRegValve *pALIENP = NULL;

	if( NULL != GetpMeasValve( locate ) )
	{
		pALIENP = dynamic_cast<CDB_AlienRegValve *>( GetpMeasValve( locate )->GetValveIDPtr().MP );
	}

	return pALIENP;
}

CDB_Thing *CDS_HydroModX::GetpAnyProduct( eLocate locate )
{
	CDB_Thing *pAnyP = NULL;

	if( NULL != GetpMeasValve( locate ) )
	{
		// Try TA.
		pAnyP = dynamic_cast<CDB_TAProduct *>( GetpMeasValve( locate )->GetValveIDPtr().MP );

		// Try ALIEN.
		if( NULL == pAnyP )
		{
			pAnyP = dynamic_cast<CDB_AlienRegValve *>( GetpMeasValve( locate )->GetValveIDPtr().MP );
		}
	}

	return pAnyP;
}

// Return true when circuit is OK for specified measuring method
/*
									|	TAmode	| emdNone	|	emdDp	|	emdQ	|	emdDpCAlwaysOn
-------------------------------------------------------------------------------------------------------
etammQM_Dp											0
etammQM_Q																	1
etammTAD,								1						1			1				0
etammTAW_RefValve						1									1				0
etammTAW_OtherValve						1						1			1				0
etammComputerMethod						1						1			1				0
etammTroubleShooting					1
etammTrbl_ReqDp							1			 						1				0
etammTrbl_AvailDp_RefValve				1									1				0
etammTrbl_AvailDp_OtherValve			1						1							0
etammTrbl_AvailDp_IntermediateValve		1													0
etammVSP_Optimize						1						1			1				0
etammBAL_VerifyFlow						1									1				0

*/
bool CDS_HydroModX::CircuitFitForMethod( eTAMeasureMethod eTaMeasMethod, eLocate locate )
{
	CDB_TAProduct *pTAP = NULL;
	CDB_TAProduct::eMeasurableData eMeasData = CDB_TAProduct::emdNone;
	eMode Mode;

	// No valve.
	if( false == GetpMeasValve( locate ) )
	{
		return false;
	}

	Mode = GetpMeasValve( locate )->GetMode();

	if( CDS_HydroModX::TAmode == Mode )
	{
		pTAP = GetpTAP( locate );

		if( NULL != pTAP )
		{
			eMeasData = ( CDB_TAProduct::eMeasurableData ) pTAP->GetMeasurableData();
		}
		else
		{
			return false;
		}
	}

	switch( eTaMeasMethod )
	{
		case etammQM_Dp:

			if( CDS_HydroModX::Kvmode == Mode || CDS_HydroModX::ALIENmode == Mode )
			{
				return true;
			}

			if( CDS_HydroModX::TAmode == Mode && CDB_TAProduct::emdNone != eMeasData )
			{
				return true;
			}

			break;

		case etammQM_Q:

			if( CDS_HydroModX::Kvmode == Mode || CDS_HydroModX::ALIENmode == Mode )
			{
				return true;
			}

			if( CDS_HydroModX::TAmode == Mode
					&&	CDB_TAProduct::emdQ == ( eMeasData & CDB_TAProduct::emdQ ) )
			{
				return true;
			}

			break;

		case etammTAD:

			if( CDS_HydroModX::TAmode == Mode
					&&	( CDB_TAProduct::emdDp | CDB_TAProduct::emdQ ) == ( eMeasData & ( CDB_TAProduct::emdDp | CDB_TAProduct::emdQ ) )
					&& 0 == ( eMeasData & CDB_TAProduct::emdDpCAlwaysOn ) )
			{
				return true;
			}

			break;

		case etammTAW_RefValve:

			if( CDS_HydroModX::TAmode == Mode
					&&	CDB_TAProduct::emdQ == ( eMeasData & CDB_TAProduct::emdQ )
			#ifdef HIDE_FUNCTIONS
					&&	CDB_TAProduct::emdDp == ( eMeasData & CDB_TAProduct::emdDp )	// Does not allow FO and CS
			#endif
					&&  NULL != pTAP->GetValveCharacteristic()		// Need an adjustable valve
					&& 0 == ( eMeasData & CDB_TAProduct::emdDpCAlwaysOn ) )
			{
				return true;
			}

			break;

		case etammTAW_OtherValve:

			if( CDS_HydroModX::TAmode == Mode && 0 == ( eMeasData & CDB_TAProduct::emdDpCAlwaysOn ) )
			{
				if( ( CDB_TAProduct::emdDp | CDB_TAProduct::emdQ ) == ( eMeasData & ( CDB_TAProduct::emdDp | CDB_TAProduct::emdQ ) ) )
				{
					return true;
				}

#ifndef HIDE_FUNCTIONS
				if( CDB_TAProduct::emdQ == ( eMeasData & CDB_TAProduct::emdQ ) &&  NULL != pTAP->GetValveCharacteristic() )		// Need an adjustable valve, accept FO and CS
				{
					return true;
				}
#endif
			}

			break;

		case etammComputerMethod:

			if( CDS_HydroModX::TAmode == Mode
					&&	( CDB_TAProduct::emdDp | CDB_TAProduct::emdQ ) == ( eMeasData & ( CDB_TAProduct::emdDp | CDB_TAProduct::emdQ ) )
					&& 0 == ( eMeasData & CDB_TAProduct::emdDpCAlwaysOn ) )
			{
				return true;
			}

			break;

		case etammTroubleShooting:

			if( CDS_HydroModX::TAmode == Mode )
			{
				return true;
			}

			break;

		case etammTrbl_ReqDp:

			if( CDS_HydroModX::TAmode == Mode
					&&	CDB_TAProduct::emdQ == ( eMeasData & CDB_TAProduct::emdQ )
					&& 0 == ( eMeasData & CDB_TAProduct::emdDpCAlwaysOn ) )
			{
				return true;
			}

			break;

		case etammTrbl_AvailDp_RefValve:

			if( CDS_HydroModX::TAmode == Mode
					&&	CDB_TAProduct::emdQ == ( eMeasData & CDB_TAProduct::emdQ )
					&& 0 == ( eMeasData & CDB_TAProduct::emdDpCAlwaysOn ) )
			{
				return true;
			}

			break;

		case etammTrbl_AvailDp_OtherValve:

			if( CDS_HydroModX::TAmode == Mode
					&&	CDB_TAProduct::emdDp == ( eMeasData & CDB_TAProduct::emdDp )
					&& 0 == ( eMeasData & CDB_TAProduct::emdDpCAlwaysOn ) )
			{
				return true;
			}

			break;

		case etammTrbl_AvailDp_IntermediateValve:

			if( CDS_HydroModX::TAmode == Mode
					&& 0 == ( eMeasData & CDB_TAProduct::emdDpCAlwaysOn ) )
			{
				return true;
			}

			break;

		case etammVSP_Optimize:

			if( CDS_HydroModX::TAmode == Mode
					&&	( CDB_TAProduct::emdDp | CDB_TAProduct::emdQ ) == ( eMeasData & ( CDB_TAProduct::emdDp | CDB_TAProduct::emdQ ) )
					&& 0 == ( eMeasData & CDB_TAProduct::emdDpCAlwaysOn ) )
			{
				return true;
			}

			break;

		case etammBAL_VerifyFlow:

			if( CDS_HydroModX::TAmode == Mode
					&&	CDB_TAProduct::emdQ == ( eMeasData & CDB_TAProduct::emdQ )
					&& 0 == ( eMeasData & CDB_TAProduct::emdDpCAlwaysOn ) )
			{
				return true;
			}

			break;

		default:
			return false;
			break;
	}

	return false;
}

// Return true when measurable points exist on TA product or when valve is defined in Kv mode.
bool CDS_HydroModX::MeasurableDeviceExist( CDB_TAProduct::eMeasurableData eMeasData, eLocate locate )
{
	if( NULL != GetpMeasValve( locate ) )
	{
		if( CDS_HydroModX::TAmode == GetpMeasValve( locate )->GetMode() )
		{
			if( eMeasData != CDB_TAProduct::emdNone )
			{
				if( NULL != GetpTAP( locate ) && eMeasData == ( ( int )GetpTAP( locate )->GetMeasurableData() & eMeasData ) )
				{
					return true;    // TA Valve with specific measuring capacity
				}
				else
				{
					return false;
				}
			}
			else if( NULL != GetpTAP( locate ) && CDB_TAProduct::emdNone != GetpTAP( locate )->GetMeasurableData() )
			{
				return true;    // TA Valve with measuring points
			}
			else
			{
				return false;    // No measuring point!
			}
		}

		return true;				// Kv mode!
	}

	return false;					// NO Valve
}

// Define sensor used as temperature reference
void CDS_HydroModX::SetWaterTempRef( eDTS TRef, eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		if( TRef < LastDTS )
		{
			pMD->SetWaterTempRef( TRef );
		}
	}
}

CDS_HydroModX::eDTS CDS_HydroModX::GetWaterTempRef( eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		return pMD->GetWaterTempRef();
	}

	return DTSUndef;
}

// Circuit temperatures
void CDS_HydroModX::SetWaterTemp( int i, double dTemp, eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		if( i < LastDTS )
		{
			pMD->SetMeasTemp( ( eDTS ) i, dTemp );
		}
	}
}

double CDS_HydroModX::GetWaterTemp( int i, eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		if( i >= 0 && i < LastDTS )
		{
			return pMD->GetMeasTemp( ( eDTS ) i );
		}
	}

	return -273.15;
}

// Measured DP (only used for a fast dp measure without valve)
void CDS_HydroModX::SetMeasDp( double dQMMeas, eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		pMD->SetMeasDp( dQMMeas );
	}
}

double CDS_HydroModX::GetMeasDp( eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		return pMD->GetMeasDp();
	}

	return 0.0;
}

// Measured DPL (only used for DpC circuit)
void CDS_HydroModX::SetMeasDpL( double dQMMeas, eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		pMD->SetMeasDpL( dQMMeas );
	}
}

double CDS_HydroModX::GetMeasDpL( eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		return pMD->GetMeasDpL();
	}

	return 0.0;
}

// Add a balancing valve at a specific position (eLocate), return BV pointer in case of success null otherwise
// only one Bv could exist at a certain position
CDS_HydroModX::CBV *CDS_HydroModX::AddBv( eLocate loc, eMode mode )
{
	std::pair<mapBV::iterator, bool> ret;

	// Verify that BV is not already existing.
	mapBV::iterator it;
	it = m_mapBV.find( loc );

	if( it != m_mapBV.end() )
	{
		return &it->second;
	}

	CBV Bv( this, mode );
	Bv.SetLocate( loc );
	ret = m_mapBV.insert( pairBV( loc, Bv ) );

	if( false == ret.second )
	{
		return NULL;
	}

	return &ret.first->second;
}

// Remove balancing valve from a position.
bool CDS_HydroModX::RemoveBv( eLocate loc )
{
	mapBV::iterator it;
	it = m_mapBV.find( loc );

	if( it != m_mapBV.end() )
	{
		m_mapBV.erase( it );
		return true;
	}

	return false;
}

// Return localized balancing valve pointer if exist, null pointer otherwise.
CDS_HydroModX::CBV *CDS_HydroModX::GetpBV( eLocate loc )
{
	mapBV::iterator it;
	it = m_mapBV.find( loc );

	if( it != m_mapBV.end() )
	{
		return &it->second;
	}

	return NULL;
}

// Add a measuring structure at a specific position (eLocate), return CMeasData pointer in case of success null otherwise.
// Only one CMeasData could exist at a certain position.
CDS_HydroModX::CMeasData *CDS_HydroModX::AddMeasData( eLocate loc )
{
	std::pair<mapMeasData::iterator, bool> ret;
	
	// Verify that BV is not already existing
	mapMeasData::iterator it;
	it = m_mapMeasData.find( loc );

	if( it != m_mapMeasData.end() )
	{
		return &it->second;
	}

	CMeasData MD( this );
	MD.SetLocate( loc );
	ret = m_mapMeasData.insert( pairMeasData( loc, MD ) );

	if( ret.second == false )
	{
		return NULL;
	}

	return &ret.first->second;
}

// Remove Measuring data from a position.
bool CDS_HydroModX::RemoveMeasData( eLocate loc )
{
	mapMeasData::iterator it;
	it = m_mapMeasData.find( loc );

	if( it != m_mapMeasData.end() )
	{
		m_mapMeasData.erase( it );
		return true;
	}

	return false;
}

// Return localized balancing valve pointer if exist, null pointer otherwise.
CDS_HydroModX::CMeasData *CDS_HydroModX::GetpMeasData( eLocate loc )
{
	mapMeasData::iterator it;
	it = m_mapMeasData.find( loc );

	if( it != m_mapMeasData.end() )
	{
		return &it->second;
	}

	return NULL;
}

CDS_HydroModX::CDpC *CDS_HydroModX::AddDpC( eDpStab StabOn )
{
	if( NULL != m_pDpC )
	{
		return m_pDpC;
	}

	m_pDpC = new CDpC( this, StabOn );
	return m_pDpC;
}

bool CDS_HydroModX::RemoveDpC()
{
	if( NULL != m_pDpC )
	{
		delete m_pDpC;
	}

	m_pDpC = NULL;
	return true;
}

// Return DpC pointer if exist, null pointer otherwise.
CDS_HydroModX::CDpC *CDS_HydroModX::GetpDpC()
{
	return m_pDpC;
}

CDS_HydroModX::CCv *CDS_HydroModX::AddCv( CvLocation eCvLocate )
{
	if( NULL != m_pCv )
	{
		return m_pCv;
	}

	m_pCv = new CCv( this );

	if( NULL == m_pCv )
	{
		return NULL;
	}

	m_pCv->SetCvLocate( eCvLocate );

	return m_pCv;
}

bool CDS_HydroModX::RemoveCv()
{
	if( NULL != m_pCv )
	{
		delete m_pCv;
	}

	m_pCv = NULL;
	return true;
}

// Return DpC pointer if exist, null pointer otherwise.
CDS_HydroModX::CCv *CDS_HydroModX::GetpCv()
{
	return m_pCv;
}

CDS_HydroModX::CShutoffValve *CDS_HydroModX::AddShutoffValve( ShutoffValveLoc eShutoffValveLocation )
{
	CShutoffValve **ppShutoffValve = NULL;

	switch( eShutoffValveLocation )
	{
		case ShutoffValveLocSupply:
			ppShutoffValve = &m_pShutoffValveSupply;
			break;

		case ShutoffValveLocReturn:
			ppShutoffValve = &m_pShutoffValveReturn;
			break;

		case ShutoffValveLocNone:
		default:
			return NULL;
	}

	if( NULL != *ppShutoffValve )
	{
		return *ppShutoffValve;
	}

	*ppShutoffValve = new CShutoffValve( this );
	return *ppShutoffValve;
}

bool CDS_HydroModX::RemoveShutoffValve( ShutoffValveLoc eShutoffValveLocation )
{
	switch( eShutoffValveLocation )
	{
		case ShutoffValveLocSupply:

			if( NULL != m_pShutoffValveSupply )
			{
				delete m_pShutoffValveSupply;
				m_pShutoffValveSupply = NULL;
			}

			break;

		case ShutoffValveLocReturn:

			if( NULL != m_pShutoffValveReturn )
			{
				delete m_pShutoffValveReturn;
				m_pShutoffValveReturn = NULL;
			}

			break;

		case ShutoffValveLocNone:
		default:
			break;
	}

	return true;
}

CDS_HydroModX::CShutoffValve *CDS_HydroModX::GetpShutoffValve( ShutoffValveLoc eShutoffValveLocation )
{
	CShutoffValve *pShutoffValve = NULL;

	switch( eShutoffValveLocation )
	{
		case ShutoffValveLocSupply:
			pShutoffValve = m_pShutoffValveSupply;
			break;

		case ShutoffValveLocReturn:
			pShutoffValve = m_pShutoffValveReturn;
			break;

		case ShutoffValveLocNone:
		default:
			break;
	}

	return pShutoffValve;
}

CDS_HydroModX::CSmartControlValve *CDS_HydroModX::AddSmartControlValve()
{
	if( NULL != m_pSmartControlValve )
	{
		return m_pSmartControlValve;
	}

	m_pSmartControlValve = new CSmartControlValve( this );

	if( NULL == m_pSmartControlValve )
	{
		return NULL;
	}

	return m_pSmartControlValve;
}

bool CDS_HydroModX::RemoveSmartControlValve()
{
	if( NULL != m_pSmartControlValve )
	{
		delete m_pSmartControlValve;
	}

	m_pSmartControlValve = NULL;
	return true;
}

// Return smart control valve pointer if exist, null pointer otherwise.
CDS_HydroModX::CSmartControlValve *CDS_HydroModX::GetpSmartControlValve()
{
	return m_pSmartControlValve;
}

CDS_HydroModX::CSmartDpC *CDS_HydroModX::AddSmartDpC()
{
	if( NULL != m_pSmartDpC )
	{
		return m_pSmartDpC;
	}

	m_pSmartDpC = new CSmartDpC( this );

	if( NULL == m_pSmartDpC )
	{
		return NULL;
	}

	return m_pSmartDpC;
}

bool CDS_HydroModX::RemoveSmartDpC()
{
	if( NULL != m_pSmartDpC )
	{
		delete m_pSmartDpC;
	}

	m_pSmartDpC = NULL;
	return true;
}

// Return smart differential pressure controller pointer if exist, null pointer otherwise.
CDS_HydroModX::CSmartDpC *CDS_HydroModX::GetpSmartDpC()
{
	return m_pSmartDpC;
}

CHMXPipe *CDS_HydroModX::AddPipe( CHMXPipe::ePipeLoc PipeLoc )
{
	if( PipeLoc >= CHMXPipe::epipeLast )
	{
		return NULL;
	}

	if( NULL != m_pPipe[PipeLoc] )
	{
		return m_pPipe[PipeLoc];
	}

	m_pPipe[PipeLoc] = new CHMXPipe( this, PipeLoc );
	return m_pPipe[PipeLoc];
}

bool CDS_HydroModX::RemovePipe( CHMXPipe::ePipeLoc PipeLoc )
{
	if( PipeLoc >= CHMXPipe::epipeLast )
	{
		return false;
	}

	if( NULL != m_pPipe[PipeLoc] )
	{
		delete m_pPipe[PipeLoc];
	}

	m_pPipe[PipeLoc] = NULL;
	return true;
}

// return Pipe pointer if exist, null pointer otherwise
CHMXPipe *CDS_HydroModX::GetpPipe( CHMXPipe::ePipeLoc PipeLoc )
{
	if( PipeLoc >= CHMXPipe::epipeLast )
	{
		return false;
	}

	return m_pPipe[PipeLoc];
}

CHMXTU *CDS_HydroModX::AddTU()
{
	if( m_pTU )
	{
		return m_pTU;
	}

	m_pTU = new CHMXTU( this );
	return m_pTU;
}

bool CDS_HydroModX::RemoveTU()
{
	if( m_pTU )
	{
		delete m_pTU;
	}

	m_pTU = NULL;
	return true;
}

// return TU pointer if exist, null pointer otherwise
CHMXTU *CDS_HydroModX::GetpTU()
{
	return m_pTU;
}

CDB_CircSchemeCateg *CDS_HydroModX::GetpSchcat()
{
	CDB_CircSchemeCateg *pReturn = ( GetpSch() != NULL ) ? static_cast< CDB_CircSchemeCateg * >( GetpSch()->GetSchemeCategIDPtr().MP ) : NULL;
	return pReturn;
}

// Scan all selected products and return a 'OR' flag of Hidden/Deleted
void CDS_HydroModX::CheckValveStatus( bool *pbHidden, bool *pbDeleted )
{
	if( NULL != GetpDpC() && NULL != GetpDpC()->GetValveIDPtr().MP )
	{
		if( NULL != pbHidden )
		{
			if( true == GetpDpC()->GetValveIDPtr().MP->IsHidden() )
			{
				*pbHidden = true;
			}
		}

		if( NULL != pbDeleted )
		{
			if( true == GetpDpC()->GetValveIDPtr().MP->IsDeleted() )
			{
				*pbDeleted = true;
			}
		}
	}

	if( NULL != GetpCv() && NULL != GetpCv()->GetValveIDPtr().MP )
	{
		if( NULL != pbHidden )
		{
			if( true == GetpCv()->GetValveIDPtr().MP->IsHidden() )
			{
				*pbHidden = true;
			}
		}

		if( NULL != pbDeleted )
		{
			if( true == GetpCv()->GetValveIDPtr().MP->IsDeleted() )
			{
				*pbDeleted = true;
			}
		}
	}

	for( eLocate loc = InPrimary; loc < LastItem; loc = ( eLocate )( loc + 1 ) )
	{
		if( NULL != GetpBV( loc ) && NULL != GetpBV( loc )->GetValveIDPtr().MP )
		{
			if( NULL != pbHidden )
			{
				if( true == GetpBV( loc )->GetValveIDPtr().MP->IsHidden() )
				{
					*pbHidden = true;
				}
			}

			if( NULL != pbDeleted )
			{
				if( true == GetpBV( loc )->GetValveIDPtr().MP->IsDeleted() )
				{
					*pbDeleted = true;
				}
			}
		}
	}

	if( NULL != GetpShutoffValve( ShutoffValveLocSupply ) && NULL != GetpShutoffValve( ShutoffValveLocSupply )->GetValveIDPtr().MP )
	{
		if( NULL != pbHidden )
		{
			if( true == GetpShutoffValve( ShutoffValveLocSupply )->GetValveIDPtr().MP->IsHidden() )
			{
				*pbHidden = true;
			}
		}

		if(NULL !=  pbDeleted )
		{
			if( true == GetpShutoffValve( ShutoffValveLocSupply )->GetValveIDPtr().MP->IsDeleted() )
			{
				*pbDeleted = true;
			}
		}
	}

	if( NULL != GetpShutoffValve( ShutoffValveLocReturn ) && NULL != GetpShutoffValve( ShutoffValveLocReturn )->GetValveIDPtr().MP )
	{
		if( NULL != pbHidden )
		{
			if( true == GetpShutoffValve( ShutoffValveLocReturn )->GetValveIDPtr().MP->IsHidden() )
			{
				*pbHidden = true;
			}
		}

		if( NULL != pbDeleted )
		{
			if( true == GetpShutoffValve( ShutoffValveLocReturn )->GetValveIDPtr().MP->IsDeleted() )
			{
				*pbDeleted = true;
			}
		}
	}

	if( NULL != GetpSmartControlValve() && NULL != GetpSmartControlValve()->GetValveIDPtr().MP )
	{
		if( NULL != pbHidden )
		{
			if( true == GetpSmartControlValve()->GetValveIDPtr().MP->IsHidden() )
			{
				*pbHidden = true;
			}
		}

		if( NULL != pbDeleted )
		{
			if( true == GetpSmartControlValve()->GetValveIDPtr().MP->IsDeleted() )
			{
				*pbDeleted = true;
			}
		}
	}

	if( NULL != GetpSmartDpC() && NULL != GetpSmartDpC()->GetValveIDPtr().MP )
	{
		if( NULL != pbHidden )
		{
			if( true == GetpSmartDpC()->GetValveIDPtr().MP->IsHidden() )
			{
				*pbHidden = true;
			}
		}

		if( NULL != pbDeleted )
		{
			if( true == GetpSmartDpC()->GetValveIDPtr().MP->IsDeleted() )
			{
				*pbDeleted = true;
			}
		}
	}
}

const IDPTR &CDS_HydroModX::GetPropertyIDPtr( CDataBase *pDB, IDPTR &idptr )
{
	if( NULL == pDB )
	{
		return _NULL_IDPTR;
	}

	idptr.DB = pDB;
	Extend( &idptr );
	return idptr;
}

const IDPTR	&CDS_HydroModX::GetWaterCharIDPtr()
{
	// Search into DataStructX for water char.
	return GetPropertyIDPtr( this->GetIDPtr().DB, m_WaterCharIDptr );
}

CWaterChar *CDS_HydroModX::GetpWaterChar( CWaterChar *pWCparam, eLocate locate )
{
	IDPTR idptr = GetWaterCharIDPtr();
	CDS_WaterCharacteristic *pWater = static_cast<CDS_WaterCharacteristic *>( GetWaterCharIDPtr().MP );

	if( NULL == pWater )
	{
		return NULL;
	}

	CWaterChar *pWC;

	if( NULL == pWCparam )
	{
		pWC = new CWaterChar();
	}
	else
	{
		pWC = pWCparam;
	}

	// Copy default parameters.
	*pWC = *pWater->GetpWCData();
	
	// Correct Water Char with measured circuit temp (only if initialized).
	double dWaterTemp = -273.15;

	// Measured value exist try to use it.
	if( GetWaterTempRef( locate ) <= DTSLastMeas && GetWaterTempRef( locate ) > DTSUndef )
	{
		dWaterTemp = GetWaterTemp( GetWaterTempRef( locate ), locate );
	}
	else
	{
		dWaterTemp = GetSupplyTemperature();
	}

	// Adapt fluid temperature with measured value
	if( dWaterTemp > -273.15 )
	{
		// New temp, compute new Kinematic viscosity
		// Only in case of well known fluid (included into the database
		//Check if not freezing
		if( dWaterTemp > pWC->GetTfreez() )
		{
			CDB_AdditCharacteristic *pAdditChar =  pWater->GetpAdditChar();

			if( NULL != pAdditChar )
			{
				pWC->SetTemp( dWaterTemp );
				double m_Dens = pWC->GetDens();
				double m_KinVisc = pWC->GetKinVisc();
				double m_SpecifHeat = pWC->GetSpecifHeat();
				double dVaporPressure = 0;

				enum SurfValReturn_enum SVReturn = pAdditChar->GetAdditProp( pWC->GetPcWeight(), dWaterTemp, &m_Dens, &m_KinVisc, &m_SpecifHeat, &dVaporPressure );

				switch( SVReturn )
				{
					case SV_OK:
						pWC->SetDens( m_Dens );
						pWC->SetKinVisc( m_KinVisc );
						pWC->SetSpecifHeat( m_SpecifHeat );
						break;

					case SV_OUTOFXRANGE: // Additive percentage above max. value
						break;

					case SV_OUTOFYRANGE: // Temperature above max. value
						break;

					default:
						break;
				}
			}
		}
	}

	return pWC;
}

void CDS_HydroModX::SetQMType( eQMtype QMType, eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		pMD->SetQMType( QMType );
	}
}

unsigned CDS_HydroModX::GetQMType( eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		return pMD->GetQMType();
	}

	return 0;
}

bool CDS_HydroModX::IsQMType( eQMtype QMType,  eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		return ( ( pMD->GetQMType() & ( unsigned )QMType ) == ( unsigned )QMType );
	}

	return false;
}

_string	CDS_HydroModX::GetQMstrDp( bool bWithUnit, eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		if( pMD->GetMeasDp() < 0 )
		{
			return _T("");
		}

		return( WriteCUDouble( _U_DIFFPRESS, pMD->GetMeasDp(), bWithUnit, -1, -1, false ) );
	}

	return _T("");
}

_string	CDS_HydroModX::GetQMstrDpL( bool bWithUnit, eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		if( pMD->GetMeasDpL() < 0 )
		{
			return _T("");
		}

		return WriteCUDouble( _U_DIFFPRESS, pMD->GetMeasDpL(), bWithUnit, -1, -1, false );
	}

	return _T("");
}

_string	CDS_HydroModX::GetQMstrQ( bool bWithUnit, bool *pbVisCorActing, eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		double dQ = GetMeasFlow( pbVisCorActing, locate );

		if( dQ >= 0 )
		{
			return( WriteCUDouble( _U_FLOW, dQ, bWithUnit, -1, -1, false ) );
		}
	}

	return( L"" );

}

_string	CDS_HydroModX::GetQMstrT( int i, bool bWithUnit, eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		if( i < 0 || i >= LastDTS )
		{
			return _T("");
		}

		if( pMD->GetMeasTemp( ( eDTS ) i ) <= -273.15 )
		{
			return _T("");
		}

		return ( WriteCUDouble( _U_TEMPERATURE, pMD->GetMeasTemp( ( eDTS ) i ), bWithUnit, -1, -1, false ) );
	}

	return _T("");
}

double CDS_HydroModX::GetQMDT( eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		if( DTSUndef == pMD->GetUsedDTSensor( 0 ) || LastDTS == pMD->GetUsedDTSensor( 0 ) )
		{
			return -1;
		}

		if( DTSUndef == pMD->GetUsedDTSensor( 1 ) || LastDTS == pMD->GetUsedDTSensor( 1 ) )
		{
			return -1;
		}

		if( pMD->GetMeasTemp( pMD->GetUsedDTSensor( 0 ) ) <= -273.15 )
		{
			return -1;
		}

		if( pMD->GetMeasTemp( pMD->GetUsedDTSensor( 1 ) ) <= -273.15 )
		{
			return -1;
		}

		double dVal = fabs( pMD->GetMeasTemp( pMD->GetUsedDTSensor( 0 ) ) - pMD->GetMeasTemp( pMD->GetUsedDTSensor( 1 ) ) );
		return dVal;
	}

	return -1;
}

_string	CDS_HydroModX::GetQMstrDT( bool bWithUnit, eLocate locate )
{
	double dVal = GetQMDT( locate );

	if( dVal < 0 )
	{
		return _T("");
	}

	return ( WriteCUDouble( _U_DIFFTEMP, dVal, bWithUnit, -1, -1, false ) );
}

_string	CDS_HydroModX::GetQMstrPower( bool bWithUnit, eLocate locate )
{
	double dVal = GetQMDT( locate );

	if( dVal < 0 )
	{
		return _T("");
	}

	double dQ = GetMeasFlow( NULL, locate );

	if( dQ < 0 )
	{
		return _T("");
	}

	CWaterChar *pWC = GetpWaterChar( NULL, locate );

	if( NULL == pWC )
	{
		return _T("");
	}

	double dRho = pWC->GetDens();
	double dcp = pWC->GetSpecifHeat();
	double dPower = CalcP( dQ, dVal, dRho, dcp );
	delete pWC;
	return ( WriteCUDouble( _U_TH_POWER, dPower, bWithUnit, -1, -1, false ) );
}

_string	CDS_HydroModX::GetQMstrOpening( eLocate locate )
{
	_string strOpening = _T("");
	CDB_TAProduct *pTAP = GetpTAP( locate );

	if( NULL != pTAP && NULL != pTAP->GetValveCharacteristic() && true == pTAP->GetValveCharacteristic()->HasMultiTurnProperty() )
	{
		strOpening = pTAP->GetValveCharacteristic()->GetSettingString( GetCurOpening( locate ) );
		return strOpening;
	}

	CDB_AlienRegValve *pAlien = GetpALIENP( locate );

	if( NULL != pAlien && NULL != pAlien->GetValveCharacteristic() && true == pAlien->GetValveCharacteristic()->HasMultiTurnProperty() )
	{
		strOpening = pAlien->GetValveCharacteristic()->GetSettingString( GetCurOpening( locate ) );
		return strOpening;
	}

	return strOpening;
}

_string CDS_HydroModX::GetQMstrKv( eLocate loc, bool bWithUnit )
{
	if( NULL == GetpBV( loc ) )
	{
		return _T("");
	}

	double dKv = GetpBV( loc )->GetKv();

	if( dKv <= 0.0 )
	{
		if( TAmode == GetpBV( loc )->GetMode() )
		{
			CDB_TAProduct *pTAp = dynamic_cast<CDB_TAProduct *>( GetpBV( loc )->GetValveIDPtr().MP );

			if( NULL == pTAp )
			{
				return _T("");
			}

			if( NULL == pTAp->GetValveCharacteristic() )
			{
				return _T("");
			}

			dKv = pTAp->GetValveCharacteristic()->GetKv( GetpBV( loc )->GetCurOpening() );

			if( -1.0 == dKv )
			{
				return _T("");
			}
		}
		else if( ALIENmode == GetpBV( loc )->GetMode() )
		{
			CDB_AlienRegValve *pAlien = dynamic_cast<CDB_AlienRegValve *>( GetpBV( loc )->GetValveIDPtr().MP );

			if( NULL == pAlien )
			{
				return _T("");
			}

			if( NULL == pAlien->GetValveCharacteristic() )
			{
				return _T("");
			}

			dKv = pAlien->GetValveCharacteristic()->GetKv( GetpBV( loc )->GetCurOpening() );

			if( -1.0 == dKv )
			{
				return _T("");
			}
		}
	}

	return WriteCUDouble( _C_KVCVCOEFF, dKv, bWithUnit, -1, -1, false );
}

bool CDS_HydroModX::IsTABalMeasDone( bool bAll )
{
	// Primary or secondary.
	eLocate locate = InPrimary;

	if( NULL != GetpSchcat() && true == GetpSchcat()->IsSecondarySideExist() )	// If PV in 2WInj, use secondary
	{
		locate = InSecondary;
	}

	bool bNoPV = ( GetHMXBalType() == CDS_HydroModX::NOBalancing );

	//First verify module
	if( CDS_HydroModX::BV == GetHMXBalType() )
	{
		if( NULL != GetpMeasValve( locate ) )
		{
			// Check only the current module/circuit
			if( false == bAll )
			{
				return IsTABalMeasCompleted( locate );
			}

			//else return the status of current module after all children checking
		}
		else
		{
			return false;				// No Balancing valve
		}
	}

	// Scan each children.
	for( IDPTR IDPtr = GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = GetNext( IDPtr.MP ) )
	{
		CDS_HydroModX *pHM = static_cast<CDS_HydroModX *>( IDPtr.MP );

		if( NULL != pHM->GetpMeasValve( InPrimary ) )
		{
			if( true == bAll )
			{
				if( false == pHM->IsTABalMeasCompleted( InPrimary ) )
				{
					return false;
				}
			}
			else
			{
				if( true == pHM->IsTABalMeasCompleted( InPrimary ) )
				{
					return true;
				}
			}
		}
	}

	if( true == bNoPV )
	{
		return true;    // No PV exist only children are checked
	}

	return IsTABalMeasCompleted( locate );	// PV exist test it
}

void CDS_HydroModX::ResetMeasurements( bool bResetDT, eLocate locate )	// true to reset DT
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		pMD->SetMeasDp( 0.0 );

		if( NULL != GetpMeasValve( locate ) )
		{
			GetpMeasValve( locate )->SetMeasDp( 0.0 );
		}

		for( int i = 0; i < LastDTS - 1; i++ )	// LastDTS-1 : Do not clear DT
		{
			pMD->SetMeasTemp( ( eDTS ) i, -273.15 );
		}

		if( true == bResetDT )
		{
			pMD->SetMeasTemp( DTSRef, -273.15 );
		}

		pMD->SetUsedDTSensor( 0, DTSUndef );
		pMD->SetUsedDTSensor( 1, DTSUndef );
	}
}

bool CDS_HydroModX::ContainsOnlyMeasurableDevices()
{
	for( IDPTR IDPtr = GetFirst(); NULL != IDPtr.MP; IDPtr = GetNext( IDPtr.MP ) )
	{
		CDS_HydroModX *pHMX = dynamic_cast<CDS_HydroModX *>( IDPtr.MP );

		if( NULL == pHMX )
		{
			continue;
		}

		if( NULL == pHMX->GetpMeasValve( InPrimary ) )
		{
			return false;
		}

		// Only for TA Valve.
		if( CDS_HydroModX::TAmode != pHMX->GetpMeasValve( InPrimary )->GetMode() )
		{
			return false;
		}

		// NOT allowed if there is no measuring points on any valve.
		if( false == pHMX->CircuitFitForMethod( CDS_HydroModX::etammTAW_OtherValve, InPrimary ) )
		{
			return false;
		}
	}

	return true;
}

bool CDS_HydroModX::TABalance()
{
	// First verify prerequisite.
	if( false == IsaModule() )
	{
		return false;
	}

	// Verify all children circuit have been measured CBV::IsTABalMeasDone().
	bool bRet = false;
	
#ifdef TACBX
#ifndef BOOTLOADER
	CTABalance TaBal( GetItemCount() );
	CDS_HydroModX *pHM = NULL;

	// Call Balancing, in case of error pHM is the problem.
	CTABalance::eCTABALRetCode TabalRet = TaBal.Compute( this, pHM );

	switch( TabalRet )
	{
		case CTABalance::tabalOk:
			ResetTABalanceMode( CDS_HydroModX::etabmTABalPlus );
			bRet = true;
			break;

		case CTABalance::tabalBvMissing:
		case CTABalance::tabalNotTAValve:
		case CTABalance::tabalError:
		default:
			break;
	}

#endif
#endif

	return bRet;
}

double CDS_HydroModX::GetMeasPower( eLocate locate )
{
	double dVal = GetQMDT( locate );

	if( dVal < 0.0 )
	{
		return 0.0;
	}

	double dQ = GetMeasFlow( NULL, locate );

	if( dQ < 0.0 )
	{
		return 0.0;
	}

	CWaterChar *pWC = GetpWaterChar( NULL, locate );

	if( NULL == pWC )
	{
		return 0.0;
	}

	double dRho = pWC->GetDens();
	double dcp = pWC->GetSpecifHeat();
	double dPower = CalcP( dQ, dVal, dRho, dcp );
	delete pWC;

	return dPower;
}

CDS_HydroModX::eDTS CDS_HydroModX::GetDTSensor( short i, eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		if( i >= 0 && i < 2 )
		{
			return pMD->GetUsedDTSensor( i );
		}
	}

	return LastDTS;
}

void CDS_HydroModX::SetDTSensor( short i, eDTS TSens, eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		if( i >= 0 && i < 2 && TSens < LastDTS )
		{
			pMD->SetUsedDTSensor( ( eDTS ) i, TSens );
		}
	}
}

void CDS_HydroModX::SetFlagMeasFlow( bool bFlag, eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		pMD->SetMeasFlowDone( bFlag );
	}
}

bool CDS_HydroModX::IsMeasFlowDone( eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		return pMD->GetMeasFlowDone();
	}

	return false;
}

double CDS_HydroModX::GetMeasFlow( bool *pbVisCorActing /*= NULL*/, eLocate locate )
{
	if( NULL != GetpMeasValve( locate ) )
	{
		return GetpMeasValve( locate )->GetMeasFlow( pbVisCorActing );
	}
	else
	{
		return 0.0;
	}
}

double CDS_HydroModX::GetCurOpening( eLocate locate )
{
	if( NULL != GetpMeasValve( locate ) )
	{
		return GetpMeasValve( locate )->GetCurOpening();
	}
	else
	{
		return 0.0;
	}
}

CDS_HydroModX::CBase *CDS_HydroModX::GetpMeasValve( eLocate locate )
{
	CDS_HydroModX::eHMXBalType BalWith = GetHMXBalType();

	if( BalWith == NOBalancing )
	{
		return NULL;
	}

	switch( BalWith )
	{
		case BV:
		case DPC:

			if( NULL != GetpBV( locate ) )
			{
				return GetpBV( locate );
			}

			break;

		case PICV:

			if( InPrimary == locate )
			{
				// In primary side we can have a PICV with measurable data.
				if( NULL != GetpCv() )
				{
					CDB_PIControlValve *pclPIControlValve = dynamic_cast<CDB_PIControlValve *>( GetpCv()->GetValveIDPtr().MP );

					// measurable data exist?
					if( NULL != pclPIControlValve && CDB_TAProduct::emdNone != pclPIControlValve->GetMeasurableData() )
					{
						return GetpCv();
					}
					else if( NULL != GetpBV( locate ) )
					{
						return GetpBV( locate );
					}
				}
			}
			else
			{
				// Otherwise we check if we have a normal balancing valve.
				if( NULL != GetpBV( locate ) )
				{
					return GetpBV( locate );
				}
			}

			break;

		case BVCV:
		case DPC_CV:
		case DPC_BCV:

			if( InPrimary == locate )
			{
				// In primary side we can have a control valve with measurable data.
				if( NULL != GetpCv() )
				{
					CDB_ControlValve *pclControlValve = dynamic_cast<CDB_ControlValve *>( GetpCv()->GetValveIDPtr().MP );

					// Measurable data exist?
					if( NULL != pclControlValve && CDB_TAProduct::emdNone != pclControlValve->GetMeasurableData() )
					{
						return GetpCv();
					}
				}
			}
			else
			{
				// Otherwise we check if we have a normal balancing valve.
				if( NULL != GetpBV( locate ) )
				{
					return GetpBV( locate );
				}
			}

			break;

		default:
			break;
	}

	return NULL;
}

double CDS_HydroModX::ComputePrimaryFlow( double dQsec, double dTprimary )
{
	double dqp = dQsec;

	if( true == GetpSch()->GetpSchCateg()->IsSecondarySideExist() )		// This is a 2wInj TU
	{
		if( dTprimary - m_dTempReturn != 0.0 )
		{
			dqp = dQsec * ( m_dTempSecondary - m_dTempReturn ) / ( dTprimary - m_dTempReturn );
		}
		else
		{
			dqp = dQsec;
		}
	}

	if( dqp < 0.0 )
	{
		dqp = 0.0;
	}

	return dqp;
}

double CDS_HydroModX::GetDesignFlow( eLocate locate )
{
	double dQ;
	double dTprimary = GetSupplyTemperature();

	if( false == IsaModule() )
	{
		if( NULL != GetpSch() && true == GetpSch()->GetpSchCateg()->IsInjection() )		// This is a 2wInj TU
		{
			// Calculate Primary flow according to secondary flow and temperatures
			if( NULL != GetpMeasValve( InSecondary ) )
			{
				dQ = GetpMeasValve( InSecondary )->GetDesignFlow();
			}
			else
			{
				dQ = m_dDesignFlow_Sec;
			}

			//if get primary, calculate flow
			if( InPrimary == locate )
			{
				return ComputePrimaryFlow( dQ, dTprimary );
			}
			else
			{
				return dQ;
			}
		}
		else
		{
			if( NULL != GetpMeasValve( InPrimary ) )
			{
				return GetpMeasValve( InPrimary )->GetDesignFlow();
			}
			else if( NULL != GetpCv() )			// PICV wo measuring points, without measuring valve
			{
				return GetpCv()->GetDesignFlow();
			}
			else
			{
				return 0.0;
			}
		}
	}

	// When the module is frozen, it doesn't contains children
	if( true == HasHMXStatus( sfBlackBox ) )
	{
		return m_dDesignFlow;
	}

	double dTQ = 0.0;

	for( IDPTR idptr = GetFirst(); _T('\0') != *idptr.ID; idptr = GetNext( idptr.MP ) )
	{
		CDS_HydroModX *pHM = dynamic_cast<CDS_HydroModX *>( idptr.MP );

		if( NULL == pHM )
		{
			continue;
		}

		dQ = pHM->GetDesignFlow( InPrimary );
		dTQ += dQ;
	}

	if( true == GetpSch()->GetpSchCateg()->IsInjection() )		// Parent is a 2wInj TU
	{
		//if get primary, calculate flow
		if( InPrimary == locate )
		{
			dTQ = ComputePrimaryFlow( dTQ, dTprimary );
		}
	}

	return dTQ;
}

void CDS_HydroModX::SetDesignFlow( double dDesignFlow )
{
	if( true == GetpSch()->GetpSchCateg()->IsInjection() )		// 2wInj: always update secondary first with value, then calculate and update primary
	{
		double dTprimary = GetSupplyTemperature();

		m_dDesignFlow_Sec = dDesignFlow;

		// Same flow for all devices when exist
		if( GetpBV( InSecondary ) )
		{
			GetpBV( InSecondary )->SetDesignFlow( dDesignFlow );
		}

		// Compute primary flow
		m_dDesignFlow = ComputePrimaryFlow( dDesignFlow, dTprimary );
	}
	else
	{
		m_dDesignFlow = dDesignFlow;
	}

	// Same flow for all devices when exist
	if( NULL != GetpBV( InPrimary ) )
	{
		GetpBV( InPrimary )->SetDesignFlow( m_dDesignFlow );
	}

	if( NULL != GetpCv() )
	{
		GetpCv()->SetDesignFlow( m_dDesignFlow );
	}

	if( NULL != GetpDpC() )
	{
		GetpDpC()->SetDesignFlow( m_dDesignFlow );
	}

	if( NULL != GetpPipe( CHMXPipe::epipeOnCircuit ) )
	{
		GetpPipe( CHMXPipe::epipeOnCircuit )->SetFlow( m_dDesignFlow );
	}

	if( NULL != GetpShutoffValve( ShutoffValveLocSupply ) )
	{
		GetpShutoffValve( ShutoffValveLocSupply )->SetDesignFlow( m_dDesignFlow );
	}

	if( NULL != GetpShutoffValve( ShutoffValveLocReturn ) )
	{
		GetpShutoffValve( ShutoffValveLocReturn )->SetDesignFlow( m_dDesignFlow );
	}
}

// fill map with ordered children hydromod by position
// return 0 if it's not a module, otherwise number of children ordered
unsigned short CDS_HydroModX::GetOrdered( std::map<int, CDS_HydroModX *> *pMap )
{
	unsigned short usCount = 0;

	for( IDPTR idptr = GetFirst(); NULL != idptr.MP; idptr = GetNext( idptr.MP ) )
	{
		CDS_HydroModX *pHMX = dynamic_cast<CDS_HydroModX *>( idptr.MP );

		if( NULL == pHMX )
		{
			continue;    //???????????
		}

		pMap->insert( std::pair<int, CDS_HydroModX *>( pHMX->GetPosition(), pHMX ) );
		usCount ++;
	}

	return usCount;
}

void CDS_HydroModX::ClearUnwantedCopiedParameters()
{
	m_bIndexCircuit = false;		// True if this circuit is the index circuit
	SetHMID( ( WCHAR * )_T("") );
	m_Uid = 0;
	m_bReadyForBalancing = false;
	m_bNonMeasurablePoint = false;
	m_usZeroPointOffsetRaw = 0;
	m_dTABalValMinDp = 3000.0;

	for( unsigned int i = undef; i < LastItem; i++ )
	{
		CMeasData *pMD = GetpMeasData( ( eLocate ) i );

		if( NULL != pMD )
		{
			pMD->ClearData();
		}
	}

	m_AssociatedHMXID = _T("");
	m_dQMNote = _T("");

#ifdef TACBX
	m_dTABalValMinDp = CBXDataStruct::GetpTechParam()->GetValvMinDp();

#endif

	ResetMeasurements( true, InPrimary );
	ResetMeasurements( true, InSecondary );
}

#define CDS_HYDROMODX_VERSION	20
// Version 20: 2022-07-11: Add smart differential pressure controller.
// Version 19: 2020-11-02: Add smart control valve.
// Version 18: 2018-08-21: Add a note.
// Version 17: 2017-01-17: Add secondary circuit pipe.
// Version 16: 2016-10-17: Add distribution return pipe.
// Version 15: 2016-10-13: TBV-C saved now in 'CDS_HydroModX::CCv' and no more 'CDS_HydroModX::CBV'.
// Version 14: 2016-07-15: Shut-off valves added.
void CDS_HydroModX::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_HYDROMODX_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CTable::Write( outf );

	// Info.
	WriteString( outf, m_HMName.c_str() );
	WriteString( outf, m_Description.c_str() );
	eHMXBalType BalWith = GetHMXBalType();
	WriteData<>( outf, BalWith );
	WriteData<>( outf, m_Pos );
	WriteString( outf, m_WaterCharIDptr.ID );
	WriteString( outf, m_HMID );
	WriteData<>( outf, m_bIndexCircuit );
	WriteData<>( outf, m_bModule );

	// Version 10:
	// Measurements.
	int iMapSize = ( int )m_mapMeasData.size();
	WriteData<>( outf, iMapSize );
	mapMeasData::iterator itMD;

	for( itMD = m_mapMeasData.begin(); itMD != m_mapMeasData.end(); ++itMD )
	{
		// Write key.
		eLocate loc = itMD->first;
		WriteData<>( outf, loc );
		
		// Write mapMeasData items.
		itMD->second.Write( outf );
	}

	// Version 2.
	WriteData<>( outf, m_usZeroPointOffsetRaw );

	// Version 3.
	WriteDouble( outf, m_dTABalValMinDp );

	// Version 4.
	WriteData<>( outf, m_ModuleStatus );
	WriteDouble( outf, m_dDesignFlow );

	// Version 5.
	WriteData<>( outf, m_Uid );

	// BV information.
	iMapSize = ( int )m_mapBV.size();
	WriteData<>( outf, iMapSize );
	mapBV::iterator it;

	for( it = m_mapBV.begin(); it != m_mapBV.end(); ++it )
	{
		// Write key.
		eLocate loc = it->first;
		WriteData<>( outf, loc );
		
		// Write mapBV items.
		it->second.Write( outf );
	}

	// DpC information.
	bool bDpC = false;

	if( NULL != m_pDpC )
	{
		bDpC = true;
		WriteData<>( outf, bDpC );
		m_pDpC->Write( outf );
	}
	else
	{
		WriteData<>( outf, bDpC );
	}

	// Cv information.
	bool bCv = false;

	if( NULL != m_pCv )
	{
		bCv = true;
		WriteData<>( outf, bCv );
		m_pCv->Write( outf );
	}
	else
	{
		WriteData<>( outf, bCv );
	}

	// Pipe information.
	// Remark: Write only distribution supply and circuit pipe here. The distribution return pipe is now read at the end since version 16.
	for( int i = 0; i < CHMXPipe::epipeOnDistributionReturn; i++ )
	{
		bool bPipe = false;

		if( NULL != m_pPipe[i] )
		{
			bPipe = true;
			WriteData<>( outf, bPipe );
			m_pPipe[i]->Write( outf );
		}
		else
		{
			WriteData<>( outf, bPipe );
		}
	}

	// Version 7.
	// Terminal unit info.
	bool bTU = false;

	if( NULL != m_pTU )
	{
		bTU = true;
		WriteData<>( outf, bTU );
		m_pTU->Write( outf );
	}
	else
	{
		WriteData<>( outf, bTU );
	}

	// Version 9.
	WriteString( outf, m_SchemeIDPtr.ID );
	WriteData<>( outf, m_eReturnType );

	// Version 12.
	WriteDouble( outf, m_dDesignFlow_Sec );
	WriteDouble( outf, m_dTempSecondary );
	WriteDouble( outf, m_dTempReturn );

	// Version 13.
	WriteString( outf, m_AssociatedHMXID.c_str() );

	// Version 14.
	// Shut-off valves information.
	bool bSVSupply = false;

	if( NULL != m_pShutoffValveSupply )
	{
		bSVSupply = true;
		WriteData<>( outf, bSVSupply );
		m_pShutoffValveSupply->Write( outf );
	}
	else
	{
		WriteData<>( outf, bSVSupply );
	}

	bool bSVReturn = false;

	if( NULL != m_pShutoffValveReturn )
	{
		bSVReturn = true;
		WriteData<>( outf, bSVReturn );
		m_pShutoffValveReturn->Write( outf );
	}
	else
	{
		WriteData<>( outf, bSVReturn );
	}

	// Version 16.
	// Distribution return pipe.
	bool bPipe = false;

	if( NULL != m_pPipe[CHMXPipe::epipeOnDistributionReturn] )
	{
		bPipe = true;
		WriteData<>( outf, bPipe );
		m_pPipe[CHMXPipe::epipeOnDistributionReturn]->Write( outf );
	}
	else
	{
		WriteData<>( outf, bPipe );
	}

	// Version 17.
	// Secondary circuit pipe.
	bPipe = false;

	if( NULL != m_pPipe[CHMXPipe::epipeOnSecondaryCircuit] )
	{
		bPipe = true;
		WriteData<>( outf, bPipe );
		m_pPipe[CHMXPipe::epipeOnSecondaryCircuit]->Write( outf );
	}
	else
	{
		WriteData<>( outf, bPipe );
	}
	// Version 18.
	// Add a note.
	WriteString(outf, m_dQMNote.c_str());

	// Version 19.
	// Smart control valve control information.
	bool bSmartControlValve = false;

	if( NULL != m_pSmartControlValve )
	{
		bSmartControlValve = true;
		WriteData<>( outf, bSmartControlValve );
		m_pSmartControlValve->Write( outf );
	}
	else
	{
		WriteData<>( outf, bSmartControlValve );
	}

	// Version 20.
	// Smart differential pressure controller control information.
	bool bSmartDpC = false;

	if( NULL != m_pSmartDpC )
	{
		bSmartDpC = true;
		WriteData<>( outf, bSmartDpC );
		m_pSmartDpC->Write( outf );
	}
	else
	{
		WriteData<>( outf, bSmartDpC );
	}
}

bool CDS_HydroModX::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_HYDROMODX_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_HYDROMODX_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CTable::Read( inpf ) )
	{
		return false;
	}

	// Info.
	if( false == ReadString( inpf, m_HMName ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_Description ) )
	{
		return false;
	}

	eHMXBalType BalWith;
	inpf.read( (char *)&BalWith, sizeof( BalWith ) );
	inpf.read( (char *)&m_Pos, sizeof( m_Pos ) );

	if( false == ReadString( inpf, m_WaterCharIDptr.ID, sizeof( m_WaterCharIDptr.ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_HMID, sizeof( m_HMID ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_bIndexCircuit, sizeof( m_bIndexCircuit ) );
	inpf.read( (char *)&m_bModule, sizeof( m_bModule ) );

	if( Version > 9 )
	{
		// Version 10: Measurable data
		// Clear map MeasData.
		m_mapMeasData.clear();
		
		// Read map BV size.
		int iSize = 0;
		inpf.read( (char *)&iSize, sizeof( iSize ) );

		for( ; iSize > 0; iSize-- )
		{
			// Read key.
			eLocate loc = undef;
			inpf.read( (char *)&loc, sizeof( loc ) );
			
			// Read BV.
			CMeasData MD( this );

			if( false == MD.Read( inpf ) )
			{
				return false;
			}

			// Add BV into map.
			m_mapMeasData.insert( pairMeasData( loc, MD ) );
		}
	}
	else
	{
		CMeasData *pMD = AddMeasData( InPrimary );

		if( NULL == pMD )
		{
			return false;
		}

		eDTS DtsRef;
		inpf.read( (char *)&DtsRef, sizeof( DtsRef ) );
		pMD->SetWaterTempRef( DtsRef );

		double dValue;
		int iNumOfDTS;
		inpf.read( (char *)&iNumOfDTS, sizeof( iNumOfDTS ) );

		for( int i = 0; i < iNumOfDTS; i++ )
		{
			dValue = ReadDouble( inpf );
			pMD->SetMeasTemp( ( eDTS )i, dValue );
		}

		for( int i = 0; i < 2; i++ )
		{
			eDTS dts[2];
			inpf.read( (char *)&dts, sizeof( dts ) );	// For compatibility
			pMD->SetUsedDTSensor( ( UINT )i, dts[0] );
		}

		dValue = ReadDouble( inpf );
		pMD->SetMeasDp( dValue );

		if( Version > 6 )
		{
			dValue = ReadDouble( inpf );
			pMD->SetMeasDpL( dValue );
		}

		bool bValue;
		inpf.read( (char *)&bValue, sizeof( bValue ) );
		pMD->SetMeasFlowDone( bValue );

		__time32_t time;
		inpf.read( (char *)&time, sizeof( time ) );
		pMD->SetMeasDateTime( time );

		inpf.read( (char *)&time, sizeof( time ) );
		pMD->SetTABalDateTime( time );

		unsigned int uiValue;
		inpf.read( (char *)&uiValue, sizeof( uiValue ) );
		pMD->SetQMType( uiValue );

		dValue = ReadDouble( inpf );
		pMD->SetTaBalMeasDp_2( dValue );

		if( Version > 7 )
		{
			// Version 8.
			eTABalMeasCompleted TABalMeasCompleted = emcNoMeas;	// Set when measuring step 1 & 2 are done
			inpf.read( (char *)&TABalMeasCompleted, sizeof( TABalMeasCompleted ) );
			pMD->SetTaBalMeasCompleted( TABalMeasCompleted );
			eTABalanceMethod TABalancedMethod;
			inpf.read( (char *)&TABalancedMethod, sizeof( TABalancedMethod ) );
			pMD->SetBalanced( TABalancedMethod );
		}
		else
		{
			unsigned char ucTemp;
			inpf.read( (char *)&ucTemp, sizeof( ucTemp ) );
			pMD->SetTaBalMeasCompleted( ( eTABalMeasCompleted )ucTemp );
			inpf.read( (char *)&ucTemp, sizeof( ucTemp ) );
			pMD->SetBalanced( ( eTABalanceMethod )ucTemp );
		}
	}

	if( Version > 1 )
	{
		inpf.read( (char *)&m_usZeroPointOffsetRaw, sizeof( m_usZeroPointOffsetRaw ) );
	}

	if( Version > 2 )
	{
		m_dTABalValMinDp = ReadDouble( inpf );
	}

	if( Version > 3 )
	{
		inpf.read( (char *)&m_ModuleStatus, sizeof( m_ModuleStatus ) );
		m_dDesignFlow = ReadDouble( inpf );
	}

	if( Version > 4 )
	{
		inpf.read( (char *)&m_Uid, sizeof( m_Uid ) );
	}

	if( Version > 5 && Version < 10 )
	{
		CMeasData *pMD = GetpMeasData( InPrimary );

		if( NULL == pMD )
		{
			return false;
		}

		double dValue = ReadDouble( inpf );
		pMD->SetTaBalPipeDp( dValue );
		
		dValue = ReadDouble( inpf );
		pMD->SetTaBalUnitDp( dValue );
	}

	// Clear map BV.
	m_mapBV.clear();

	// Read map BV size.
	int iSize = 0;
	inpf.read( (char *)&iSize, sizeof( iSize ) );

	for( ; iSize > 0; iSize-- )
	{
		// Read key.
		eLocate loc = undef;
		inpf.read( (char *)&loc, sizeof( loc ) );

		// Read BV.
		CBV Bv( this );

		if( false == Bv.Read( inpf ) )
		{
			return false;
		}

		// Add BV into map.
		m_mapBV.insert( pairBV( loc, Bv ) );
	}

	// DpC information.
	bool bDpC = false;
	inpf.read( (char *)&bDpC, sizeof( bDpC ) );

	if( true == bDpC )
	{
		m_pDpC = new CDpC( this );

		if( false == m_pDpC->Read( inpf ) )
		{
			delete m_pDpC;
			m_pDpC = NULL;
			return false;
		}
	}

	// Cv information.
	bool bCv = false;
	inpf.read( (char *)&bCv, sizeof( bCv ) );

	if( true == bCv )
	{
		m_pCv = new CCv( this );

		if( false == m_pCv->Read( inpf ) )
		{
			delete m_pCv;
			m_pCv = NULL;
			return false;
		}
	}

	// Pipe information.
	bool bPipe = false;

	// Remark: Read only distribution supply and circuit pipe here. The distribution return pipe is now read at the end since version 16.
	for( int i = 0; i < CHMXPipe::epipeOnDistributionReturn; i++ )
	{
		inpf.read( (char *)&bPipe, sizeof( bPipe ) );

		if( true == bPipe )
		{
			m_pPipe[i] = new CHMXPipe( this, ( CHMXPipe::ePipeLoc )i );

			if( !m_pPipe[i]->Read( inpf ) )
			{
				delete m_pPipe[i];
				m_pPipe[i] = NULL;
				return false;
			}
		}
	}

	if( Version > 6 )
	{
		// Terminal unit information.
		bool bTU = false;
		inpf.read( (char *)&bTU, sizeof( bTU ) );

		if( true == bTU )
		{
			m_pTU = new CHMXTU( this );

			if( !m_pTU->Read( inpf ) )
			{
				delete m_pTU;
				m_pTU = NULL;
				return false;
			}
		}
	}

	if( Version > 8 )
	{
		// Version 9.
		m_SchemeIDPtr = _NULL_IDPTR;
		ReadString( inpf, m_SchemeIDPtr.ID, sizeof( m_SchemeIDPtr.ID ) );

		// TASCOPE-90: now that he have read BV map and the 'CDB_CircuitScheme' ID, we can correct.
		if( 0 == _tcscmp( m_SchemeIDPtr.ID, _T("PUMP") ) )
		{
			if( NULL != GetpBV( InPrimary ) )
			{
				wcscpy( m_SchemeIDPtr.ID, _T("PUMP_BV") );
			}
		}

		inpf.read( (char *)&m_eReturnType, sizeof( m_eReturnType ) );
	}

	if( Version > 11 )
	{
		// Version 12.
		m_dDesignFlow_Sec = ReadDouble( inpf );
		m_dTempSecondary = ReadDouble( inpf );
		m_dTempReturn = ReadDouble( inpf );
	}

	m_AssociatedHMXID = _T("");

	if( Version > 12 )
	{
		// Version 13.
		ReadString( inpf,  m_AssociatedHMXID );
	}

	if( Version > 13 )
	{
		// Shut-off valves information.
		bool bSVSupply = false;
		inpf.read( (char *)&bSVSupply, sizeof( bSVSupply ) );

		if( true == bSVSupply )
		{
			m_pShutoffValveSupply = new CShutoffValve( this );

			if( !m_pShutoffValveSupply->Read( inpf ) )
			{
				delete m_pShutoffValveSupply;
				m_pShutoffValveSupply = NULL;
				return false;
			}
		}

		bool bSVReturn = false;
		inpf.read( (char *)&bSVReturn, sizeof( bSVReturn ) );

		if( true == bSVReturn )
		{
			m_pShutoffValveReturn = new CShutoffValve( this );

			if( !m_pShutoffValveReturn->Read( inpf ) )
			{
				delete m_pShutoffValveReturn;
				m_pShutoffValveReturn = NULL;
				return false;
			}
		}
	}

	if( Version < 15 )
	{
		// For older version we saved TBV-C and TBV-CM in a 'CDS_HydroModX::CBV' object. Now, because it is finally a control
		// valve, we save it in a 'CDS_HydroModX::CCv'. We have thus to convert for old projects.

		if( NULL != GetpBV( InPrimary ) )
		{
			CDS_HydroModX::CBV *pHMXBv = GetpBV( InPrimary );
			IDPTR BVIdptr = pHMXBv->GetValveIDPtr();
			CDB_ControlValve *pCv = dynamic_cast<CDB_ControlValve *>( BVIdptr.MP );

			if( NULL != pCv && true == pCv->IsaBCV() )
			{
				// In case it is a control valve.
				AddCv( CvLocPrimSide );

				CDS_HydroModX::CCv *pHMXCv = GetpCv();
				ASSERT( NULL != pHMXCv );

				if( NULL != pHMXCv )
				{
					// Complete information for the newly created control valve.
					pHMXCv->SetValveID( pHMXBv->GetValveIDPtr().ID );
					pHMXCv->SetDesignFlow( pHMXBv->GetDesignFlow() );
					pHMXCv->SetMeasDp( pHMXBv->GetMeasDp() );
					pHMXCv->SetDesignOpening( pHMXBv->GetDesignOpening() );
					pHMXCv->SetCurOpening( pHMXBv->GetCurOpening() );
					pHMXCv->SetMeasDateTime( pHMXBv->GetMeasDateTime() );
					pHMXCv->SetTABalOpening_1( pHMXBv->GetTABalOpening_1() );
					pHMXCv->SetTABalMeasDp_1( pHMXBv->GetTABalMeasDp_1() );
					pHMXCv->SetTABalResultOpening( pHMXBv->GetTABalResultOpening() );
					pHMXCv->SetTABalWRatioFactor( pHMXBv->GetTABalWRatioFactor() );
					pHMXCv->SetUseProduct( pHMXBv->GetUseProduct() );
				}

				RemoveBv( InPrimary );
			}
		}
	}

	if( Version > 15 )
	{
		inpf.read( (char *)&bPipe, sizeof( bPipe ) );

		if( true == bPipe )
		{
			m_pPipe[CHMXPipe::epipeOnDistributionReturn] = new CHMXPipe( this, ( CHMXPipe::ePipeLoc )CHMXPipe::epipeOnDistributionReturn );

			if( false == m_pPipe[CHMXPipe::epipeOnDistributionReturn]->Read( inpf ) )
			{
				delete m_pPipe[CHMXPipe::epipeOnDistributionReturn];
				m_pPipe[CHMXPipe::epipeOnDistributionReturn] = NULL;
				return false;
			}
		}
	}

	// Version 17: secondary circuit pipe added.
	if( Version > 16 )
	{
		inpf.read( (char *)&bPipe, sizeof( bPipe ) );

		if( true == bPipe )
		{
			m_pPipe[CHMXPipe::epipeOnSecondaryCircuit] = new CHMXPipe( this, ( CHMXPipe::ePipeLoc )CHMXPipe::epipeOnSecondaryCircuit );

			if( false == m_pPipe[CHMXPipe::epipeOnSecondaryCircuit]->Read( inpf ) )
			{
				delete m_pPipe[CHMXPipe::epipeOnSecondaryCircuit];
				m_pPipe[CHMXPipe::epipeOnSecondaryCircuit] = NULL;
				return false;
			}
		}
	}

	// Version 18: Add a note.
	m_dQMNote = _T("");

	if( Version > 17 )
	{
		ReadString( inpf, m_dQMNote );
	}
	
	if( NULL == GetSchemeIDPtr().MP )
	{
		// Build but do not destroy existing valves and data.
		BuildCircuit( NULL, BalWith, ( NULL != GetpDpC() ) ? GetpDpC()->GetStabilizedOn() : DpStabOnBranch,
				( NULL != GetpDpC() ) ? GetpDpC()->GetMvLoc() : MvLocPrimary, false, false, false );
	}

	if( Version < 19 )
	{
		return true;
	}

	// Version 19.

	// Smart control valve information.
	bool bSmartControlValve = false;
	inpf.read( (char *)&bSmartControlValve, sizeof( bSmartControlValve ) );

	if( true == bSmartControlValve )
	{
		m_pSmartControlValve = new CSmartControlValve( this );

		if( false == m_pSmartControlValve->Read( inpf ) )
		{
			delete m_pSmartControlValve;
			m_pSmartControlValve = NULL;
			return false;
		}
	}

	if( Version < 20 )
	{
		return true;
	}

	// Version 20.

	// Smart differential pressure controller information.
	bool bSmartDpC = false;
	inpf.read( (char *)&bSmartDpC, sizeof( bSmartDpC ) );

	if( true == bSmartDpC )
	{
		m_pSmartDpC = new CSmartDpC( this );

		if( false == m_pSmartDpC->Read( inpf ) )
		{
			delete m_pSmartDpC;
			m_pSmartDpC = NULL;
			return false;
		}
	}

	return true;
}

void CDS_HydroModX::Copy( CData *pclDestination )
{
	CDS_HydroModX *pclDestinationHydroModX = dynamic_cast<CDS_HydroModX *>( pclDestination );

	if( NULL == pclDestinationHydroModX )
	{
		return;
	}

	pclDestinationHydroModX->SetHMName( m_HMName );
	pclDestinationHydroModX->SetDescription( m_Description );
	pclDestinationHydroModX->SetPosition( m_Pos );
	pclDestinationHydroModX->SetWaterCharIDPtr( m_WaterCharIDptr );
	pclDestinationHydroModX->SetHMID( m_HMID );
	pclDestinationHydroModX->SetSchemeIDPtr( m_SchemeIDPtr );
	pclDestinationHydroModX->SetReturnType( m_eReturnType );

	// When Frozen.
	pclDestinationHydroModX->SetHMXStatus( m_ModuleStatus );
	pclDestinationHydroModX->SetFrozenDesignFlow( m_dDesignFlow );
	pclDestinationHydroModX->SetFrozenDesignFlow_Sec( m_dDesignFlow_Sec );

	// Temperature.
	pclDestinationHydroModX->SetTempSecondary( m_dTempSecondary );
	pclDestinationHydroModX->SetTempReturn( m_dTempReturn );

	// Reset Uid.
	pclDestinationHydroModX->SetUid( GetUid() );

	pclDestinationHydroModX->SetFlagModule( m_bModule );
	pclDestinationHydroModX->SetZeroPointOffsetRaw( m_usZeroPointOffsetRaw );
	pclDestinationHydroModX->SetTABalValMinDp( m_dTABalValMinDp );

	// QM cross reference measurements.
	pclDestinationHydroModX->SetAssociatedHMXID( m_AssociatedHMXID );

	mapBV::iterator it;

	// Clean un-needed component into the target.
	for( int loc = InPrimary; loc < LastItem; loc = loc + 1 )
	{
		pclDestinationHydroModX->RemoveBv( ( eLocate )loc );
		pclDestinationHydroModX->RemoveMeasData( ( eLocate )loc );
	}

	pclDestinationHydroModX->RemoveDpC();
	pclDestinationHydroModX->RemoveCv();
	pclDestinationHydroModX->RemoveShutoffValve( ShutoffValveLocSupply );
	pclDestinationHydroModX->RemoveShutoffValve( ShutoffValveLocReturn );
	pclDestinationHydroModX->RemoveSmartControlValve();

	for( it = m_mapBV.begin(); it != m_mapBV.end(); ++it )
	{
		CDS_HydroModX::CBV *pBv = pclDestinationHydroModX->AddBv( it->first, TAmode );
		it->second.Copy( pBv );
	}

	if( NULL != m_pDpC )
	{
		pclDestinationHydroModX->AddDpC( m_pDpC->GetStabilizedOn() );
		m_pDpC->Copy( pclDestinationHydroModX->GetpDpC() );
	}

	// Cv Information.
	if( NULL != m_pCv )
	{
		pclDestinationHydroModX->AddCv( m_pCv->GetCvLocate() );
		m_pCv->Copy( pclDestinationHydroModX->GetpCv() );
	}

	// Shut-off valves information.
	if( NULL != m_pShutoffValveSupply )
	{
		pclDestinationHydroModX->AddShutoffValve( ShutoffValveLocSupply );
		m_pShutoffValveSupply->Copy( pclDestinationHydroModX->GetpShutoffValve( ShutoffValveLocSupply ) );
	}

	if( NULL != m_pShutoffValveReturn )
	{
		pclDestinationHydroModX->AddShutoffValve( ShutoffValveLocReturn );
		m_pShutoffValveReturn->Copy( pclDestinationHydroModX->GetpShutoffValve( ShutoffValveLocReturn ) );
	}

	// Smart control valve information.
	if( NULL != m_pSmartControlValve )
	{
		pclDestinationHydroModX->AddSmartControlValve();
		m_pSmartControlValve->Copy( pclDestinationHydroModX->GetpSmartControlValve() );
	}

	// Smart differential pressure controller information.
	if( NULL != m_pSmartDpC )
	{
		pclDestinationHydroModX->AddSmartDpC();
		m_pSmartDpC->Copy( pclDestinationHydroModX->GetpSmartDpC() );
	}

	// Pipe Information.
	for( int i = 0; i < CHMXPipe::epipeLast; i++ )
	{
		if( m_pPipe[i] )
		{
			pclDestinationHydroModX->AddPipe( ( CHMXPipe::ePipeLoc )i );
			m_pPipe[i]->Copy( pclDestinationHydroModX->GetpPipe( ( CHMXPipe::ePipeLoc )i ) );
		}
	}

	if( NULL != m_pTU )
	{
		pclDestinationHydroModX->AddTU();
		m_pTU->Copy( pclDestinationHydroModX->GetpTU() );
	}

	// MeasData.
	mapMeasData::iterator itMD;

	for( itMD = m_mapMeasData.begin(); itMD != m_mapMeasData.end(); ++itMD )
	{
		CDS_HydroModX::CMeasData *pMD = pclDestinationHydroModX->AddMeasData( itMD->first );
		itMD->second.Copy( pMD );
	}

	pclDestinationHydroModX->SetQMNote( m_dQMNote);
}

void CDS_HydroModX::CopyWithChildrens( CDS_HydroModX *pTarget, bool bEraseData )
{
	HYSELECT_TRY
	{
		// Copy top node.
		Copy( pTarget );

		// Clear and remove all unwanted informations.
		if( true == bEraseData )
		{
			pTarget->ClearUnwantedCopiedParameters();
		}

		// Copy children.
		for( IDPTR idptr = GetFirst(); _T('\0') != *idptr.ID; idptr = GetNext( idptr.MP ) )
		{
			CDS_HydroModX *pHM = dynamic_cast<CDS_HydroModX *>( idptr.MP );

			if( NULL != pHM )
			{
				IDPTR IDPtr;
				
				// Create object into the same DB.
				GetIDPtr().DB->CreateObject( IDPtr, CLASS( CDS_HydroModX ) );
				pTarget->Insert( IDPtr );

				CDS_HydroModX *pCopiedHM = static_cast<CDS_HydroModX *>( IDPtr.MP );
				pHM->CopyWithChildrens( pCopiedHM, bEraseData );
			}
		}
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CDS_HydroModX::CopyWithChildrens'.") )
}

void CDS_HydroModX::SetMeasDateTime( __time32_t dt, eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		pMD->SetMeasDateTime( dt );

		if( GetpMeasValve( locate ) )
		{
			GetpMeasValve( locate )->SetMeasDateTime( dt );
		}
	}
}

__time32_t CDS_HydroModX::GetMeasDateTime( eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		return pMD->GetMeasDateTime();
	}

	return 0;
}

bool CDS_HydroModX::MeasExist()
{
	return ( 0 != GetMeasDateTime( InPrimary ) || 0 != GetMeasDateTime( InSecondary ) );
}

// Reset meas in primary and secondary if exist
void CDS_HydroModX::ResetMeasDateTime( bool bAlsoChildren )
{
	SetMeasDateTime( 0, InPrimary );
	SetMeasDateTime( 0, InSecondary );

	if( true == bAlsoChildren )
	{
		for( IDPTR idptr = GetFirst(); NULL != idptr.MP; idptr = GetNext( idptr.MP ) )
		{
			CDS_HydroModX *pHM = dynamic_cast<CDS_HydroModX *>( idptr.MP );

			if( NULL != pHM )
			{
				pHM->SetMeasDateTime( 0, InPrimary );
				pHM->SetMeasDateTime( 0, InSecondary );
			}
		}
	}
}

// TA Balance Date/time
void CDS_HydroModX::SetTABalDateTime( __time32_t dt,  eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		pMD->SetTABalDateTime( dt );
	}
}

__time32_t CDS_HydroModX::GetTABalDateTime( eLocate locate )
{
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		return pMD->GetTABalDateTime();
	}

	return 0;
}

void CDS_HydroModX::ResetReadyForBalancing( bool bAlsoChildren )
{
	SetReadyForBalancing( false );
	SetFlagIndexCircuit( false );

	if( true == bAlsoChildren )
	{
		for( IDPTR idptr = GetFirst(); NULL != idptr.MP; idptr = GetNext( idptr.MP ) )
		{
			CDS_HydroModX *pHM = dynamic_cast<CDS_HydroModX *>( idptr.MP );

			if( NULL != pHM )
			{
				pHM->SetReadyForBalancing( false );
				pHM->SetFlagIndexCircuit( false );
			}
		}
	}
}

// Computer Method
#ifdef TACBX
CComputerMethod::eCCMRetCode CDS_HydroModX::ComputerMethod( double dReqFlow, double &dComputedOpening, bool bFirst, eLocate locate )
{
	CComputerMethod::eCCMRetCode RetC = CComputerMethod::ccmNotInit;
	CMeasData *pMD = GetpMeasData( locate );

	if( NULL != pMD )
	{
		if( !m_pCM )
		{
			m_pCM = new CComputerMethod();
		}

		if( !m_pCM )
		{
			return RetC;
		}

		if( bFirst )
		{
			RetC = m_pCM->Init( dReqFlow, GetMeasFlow( NULL, locate ), pMD->GetMeasDp() );
		}
		else
		{
			double dDp = pMD->GetMeasDp();
			RetC =  m_pCM->Compute( GetMeasFlow( NULL, locate ), dDp );

			// Compute new valve position
			if( GetpMeasValve( locate ) )
			{
				dComputedOpening = GetpMeasValve( locate )->GetOpening( dReqFlow, dDp );
			}

			// Check if valve opening is possible, or if no solution was found
			if( dComputedOpening == -1 || CComputerMethod::ccmTooLargeQ == RetC )
			{
				CDB_TAProduct *pTAP = GetpTAP( locate );

				if( pTAP )
				{
					dComputedOpening = pTAP->GetValveCharacteristic()->GetOpeningMax();
				}
			}

			return CComputerMethod::ccmOK;
			//return CComputerMethod::ccmTooLargeQ;
		}
	}

	return RetC;
}
#endif

void CDS_HydroModX::RelaxComputerMethod()
{
	if( NULL != m_pCM )
	{
		delete m_pCM;
		m_pCM = NULL;
	}
}

bool CDS_HydroModX::GetBalancingIndex( double *pdBalIndex )
{
	int iCount = 0;
	double dSumMeas = 0.0;
	double dSumDesign = 0.0;
	IDPTR IDPtr = _NULL_IDPTR;
	bool bMeasureExist = false;

	for( IDPtr = GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = GetNext( IDPtr.MP ) )
	{
		CDS_HydroModX *pHM = static_cast<CDS_HydroModX *>( IDPtr.MP );

		if( NULL == pHM )
		{
			continue;
		}

		// Flow has been verified?
		if( 0 == pHM->GetMeasDateTime( CDS_HydroModX::InPrimary ) )
		{
			continue;
		}

		bMeasureExist = true;
		double dQf = pHM->GetMeasFlow( NULL, CDS_HydroModX::InPrimary );

		if( NULL != pHM && dQf > 0.0 && pHM->GetDesignFlow( CDS_HydroModX::InPrimary ) > 0.0 )
		{
			iCount++;
			dSumMeas += dQf;
			dSumDesign += pHM->GetDesignFlow( CDS_HydroModX::InPrimary );
		}
	}

	// Flow was not verified.
	if( false == bMeasureExist )
	{
		return false;
	}

	// The balancing index has no meaning when there is only one valve that
	// is measured in the module
	if( iCount <= 1 )
	{
		return false;
	}

	double dDelta = dSumMeas / dSumDesign;
	double dTemp;

	*pdBalIndex = 0.0;

	for( IDPtr = GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = GetNext( IDPtr.MP ) )
	{
		CDS_HydroModX *pHM = static_cast<CDS_HydroModX *>( IDPtr.MP );

		// flow has been verified?
		if( 0 == pHM->GetMeasDateTime( CDS_HydroModX::InPrimary ) )
		{
			continue;
		}

		double dQf = pHM->GetMeasFlow( NULL, CDS_HydroModX::InPrimary );

		if( pHM && dQf > 0.0 && pHM->GetDesignFlow( CDS_HydroModX::InPrimary ) > 0.0 )
		{
			dTemp = dQf / ( dDelta * pHM->GetDesignFlow( CDS_HydroModX::InPrimary ) ) - 1.0;
			*pdBalIndex += dTemp * dTemp;
		}
	}

	*pdBalIndex = sqrt( *pdBalIndex / iCount );

	return true;
}

CDS_HydroModX *CDS_HydroModX::GetpRefValve()
{
	CDS_HydroModX *pHMXref = NULL;

	for( IDPTR idptr = GetFirst(); NULL != idptr.MP; idptr = GetNext( idptr.MP ) )
	{
		CDS_HydroModX *pHM = dynamic_cast<CDS_HydroModX *>( idptr.MP );

		if( NULL == pHM )
		{
			continue;
		}

		if( pHMXref && pHMXref->GetPosition() > pHM->GetPosition() )
		{
			continue;
		}

		pHMXref = pHM;
	}

	return pHMXref;
}

// TA Wireless method
#ifdef TACBX
CTABalWireless::eCTABALWrlssRtc CDS_HydroModX::TAWirelessMethod( CDS_HydroModX *pHMXtobalance, CTABalWireless::eCTABALWrlssMode tabalwrlssMode )
{
	if( NULL == m_pTAW )
	{
		// Initialize reference valve.
		CDS_HydroModX *pHMXref = GetpRefValve();

		if( NULL == pHMXref )
		{
			return CTABalWireless::tblwrlssErr;
		}

		m_pTAW = new CTABalWireless( pHMXref );

		if( NULL == m_pTAW )
		{
			return CTABalWireless::tblwrlssErr;
		}

		// Reference valve set we are ready to proceed
		if( !pHMXtobalance )
		{
			return CTABalWireless::tblwrlssOk;
		}
	}

	m_pTAW->SetMode( tabalwrlssMode );

	if( CTABalWireless::tblwrlssBV == tabalwrlssMode )
	{
		return CTABalWireless::tblwrlssOk;
	}
	else if( CTABalWireless::tblwrlssVENTURI == tabalwrlssMode )
	{
		return CTABalWireless::tblwrlssOk;
	}
	else
	{
		return CTABalWireless::tblwrlssErr;
	}
}
#endif

void CDS_HydroModX::RelaxTAWirelessMethod()
{
	if( NULL != m_pTAW )
	{
		delete m_pTAW;
		m_pTAW = NULL;
	}
}

IDPTR CDS_HydroModX::GetSchemeIDPtr()
{
	if( _T('\0') != *m_SchemeIDPtr.ID )
	{
		m_SchemeIDPtr.DB = GetpTADB();
		Extend( &m_SchemeIDPtr );
	}

	return m_SchemeIDPtr;
}

void CDS_HydroModX::SetSchemeIDPtr( IDPTR val )
{
	m_SchemeIDPtr = val;
}

_string CDS_HydroModX::GetAssociatedHMXID()
{
	return m_AssociatedHMXID;
}

bool CDS_HydroModX::BuildCircuit( CDB_CircuitScheme *pSch, bool bSecondaryBvNeeded, bool bShutoffValveNeeded, bool bCleanValvesAndData )
{
	if( true == bCleanValvesAndData )
	{
		// Clean all valves
		//When the user change Balancing all will be reset
		if( NULL != GetpDpC() )
		{
			RemoveDpC();
		}

		for( int iLocation = InPrimary; iLocation < LastItem; iLocation = iLocation + 1 )
		{
			if( NULL != GetpBV( ( eLocate )iLocation ) )
			{
				RemoveBv( ( eLocate )iLocation );
			}
		}

		if( NULL != GetpCv() )
		{
			RemoveCv();
		}

		if( NULL != GetpShutoffValve( ShutoffValveLocSupply ) )
		{
			RemoveShutoffValve( ShutoffValveLocSupply );
		}

		if( NULL != GetpShutoffValve( ShutoffValveLocReturn ) )
		{
			RemoveShutoffValve( ShutoffValveLocReturn );
		}

		if( NULL != GetpSmartControlValve() )
		{
			RemoveSmartControlValve();
		}

		if( NULL != GetpSmartDpC() )
		{
			RemoveSmartDpC();
		}

		// Clean all measurement data.
		for( int iLocation = InPrimary; iLocation > InSecondary; iLocation ++ )
		{
			SetMeasDateTime( 0, ( eLocate ) iLocation );
			SetTABalDateTime( 0, ( eLocate ) iLocation );
			SetTABalMeasCompleted( CDS_HydroModX::emcNoMeas, 0, ( eLocate ) iLocation );
			ResetTABalanceMode( CDS_HydroModX::etabmNoBalancing, 0 );
		}
	}

	if( true == pSch->IsAnchorPtExist( CAnchorPt::BV_P ) && false == pSch->IsAnchorPtOptional( CAnchorPt::BV_P ) )
	{
		AddBv( InPrimary );
	}

	if( true == pSch->IsAnchorPtExist( CAnchorPt::BV_Byp ) && false == pSch->IsAnchorPtOptional( CAnchorPt::BV_Byp ) )
	{
		AddBv( InBypass );
	}

	// If manual balancing valve exists in the circuit scheme AND either this one is not optional or if optional and
	// user has asked to get one then we add this valve.
	if( true == pSch->IsAnchorPtExist( CAnchorPt::BV_S )
			&& ( false == pSch->IsAnchorPtOptional( CAnchorPt::BV_S ) || true == bSecondaryBvNeeded ) )
	{
		{
			AddBv( InSecondary );
			AddMeasData( InSecondary );
		}
	}

	if( ( true == pSch->IsAnchorPtExist( CAnchorPt::ControlValve ) && false == pSch->IsAnchorPtOptional( CAnchorPt::ControlValve ) )
			|| ( true == pSch->IsAnchorPtExist( CAnchorPt::PICV ) && false == pSch->IsAnchorPtOptional( CAnchorPt::PICV ) )
			|| ( true == pSch->IsAnchorPtExist( CAnchorPt::DPCBCV ) && false == pSch->IsAnchorPtOptional( CAnchorPt::DPCBCV ) ) )
	{
		AddCv( pSch->GetCvLoc() );
	}

	if( true == pSch->IsAnchorPtExist( CAnchorPt::DpC ) && false == pSch->IsAnchorPtOptional( CAnchorPt::DpC ) )
	{
		AddDpC( pSch->GetDpStab() );
		GetpDpC()->SetMvLoc( pSch->GetMvLoc() );
	}

	// If shutoff valve exists in the circuit scheme AND either this one is not optional or if optional and
	// user has asked to get one then we add this valve.
	if( true == pSch->IsAnchorPtExist( CAnchorPt::ShutoffValve )
			&& ( false == pSch->IsAnchorPtOptional( CAnchorPt::ShutoffValve ) || true == bShutoffValveNeeded ) )
	{
		AddShutoffValve( pSch->GetShutoffValveLoc() );
	}

	if( true == pSch->IsAnchorPtExist( CAnchorPt::SmartControlValve ) && false == pSch->IsAnchorPtOptional( CAnchorPt::SmartControlValve ) )
	{
		AddSmartControlValve();
	}

	if( true == pSch->IsAnchorPtExist( CAnchorPt::SmartDpC ) && false == pSch->IsAnchorPtOptional( CAnchorPt::SmartDpC ) )
	{
		AddSmartDpC();
	}

	if( false == pSch->GetpSchCateg()->IsInjection() || false == bSecondaryBvNeeded )
	{
		RemoveMeasData( InSecondary );
	}

	Modified();
	return true;
}

bool CDS_HydroModX::BuildCircuit( CDB_CircSchemeCateg *pSchCat, eHMXBalType HMXBalType, eDpStab DpStab, eMvLoc MvLoc, bool bSecondaryBvNeeded,
		bool bShutoffValveNeeded, bool bCleanValvesAndData )
{
	// Not specified category return to a default category based on other parameters.
	if( NULL == pSchCat )
	{
		_string ID;

		if( BV == HMXBalType )
		{
			ID = _T("SCHCATEG_DC");
		}
		else if( DPC == HMXBalType && DpStabOnBranch == DpStab )
		{
			ID = _T("SCHCATEG_DC");
		}
		else  if( DPC == HMXBalType && DpStabOnCV == DpStab )
		{
			ID = _T("SCHCATEG_2WD");
		}
		else if( BVCV == HMXBalType || PICV == HMXBalType ||  DPC_CV == HMXBalType || DPC_BCV == HMXBalType || SmartControlValve == HMXBalType )
		{
			ID = _T("SCHCATEG_2WD");
		}
		else
		{
			ID = _T("SCHCATEG_SP");
		}

		pSchCat = static_cast<CDB_CircSchemeCateg *>( GetpTADB()->Get( ID.c_str() ).MP );
	}

	// Identify circuit scheme.
	CDB_CircuitScheme *pSch = NULL;
	CDB_CircuitScheme *pSchSave = NULL;

	CTable *pTab = static_cast<CTable *>( GetpTADB()->Get( _T("CIRCSCHEME_TAB") ).MP );

	if( NULL == pTab )
	{
		return false;
	}

	for( IDPTR idptr = pTab->GetFirst(); NULL != idptr.MP; idptr = pTab->GetNext( idptr.MP ), pSch = NULL )
	{
		pSch = static_cast<CDB_CircuitScheme *>( idptr.MP );

		if( pSch->GetSchemeCategIDPtr().MP != pSchCat->GetIDPtr().MP )
		{
			continue;
		}

		pSchSave = pSch;

		// Verify BalType (BV/DPC/SP with BalWith BV/BVCV/DPC/PICV/NoBalancing)
		if( CDB_CircuitScheme::BV == pSch->GetBalType() )
		{
			if( BVCV != HMXBalType )
			{
				if( BV != HMXBalType )
				{
					continue;
				}
			}
			else
			{
				// Here we are in the case of combined balancing and control valve.
				if( CDB_ControlProperties::PresetPT != pSch->GetCvFunc() )
				{
					continue;
				}
			}
		}
		else if( CDB_CircuitScheme::DPC == pSch->GetBalType() )
		{
			if( PICV == HMXBalType )
			{
				if( pSch->GetDpCType() != CDB_CircuitScheme::eDpCTypePICV )
				{
					continue;
				}

				if( CDB_ControlProperties::PresetPT != pSch->GetCvFunc() )		//Only PressetPT allowed in TA-SCOPE
				{
					continue;
				}
			}
			else if( DPC_BCV == HMXBalType )
			{
				if( pSch->GetDpCType() != CDB_CircuitScheme::eDpCTypeDPCBCV )
				{
					continue;
				}

				if( CDB_ControlProperties::PresetPT != pSch->GetCvFunc() )		//Only PressetPT allowed in TA-SCOPE
				{
					continue;
				}
			}
			else // Verify DpStab and MvLoc
			{
				if( DPC != HMXBalType && DPC_CV != HMXBalType )
				{
					continue;
				}

				if( DPC_CV == HMXBalType )
				{
					if( CDB_ControlProperties::PresetPT != pSch->GetCvFunc() )
					{
						continue;
					}
				}

				if( pSch->GetDpCType() != CDB_CircuitScheme::eDpCTypeDPC )
				{
					continue;
				}

				if( pSch->GetMvLoc() != MvLoc )
				{
					continue;
				}

				if( pSch->GetDpStab() != DpStab )
				{
					continue;
				}
			}
		}
		else if( CDB_CircuitScheme::SP == pSch->GetBalType() )
		{
			if( NOBalancing != HMXBalType )
			{
				continue;
			}
		}

		// Scheme found !
		SetSchemeIDPtr( pSch->GetIDPtr() );
		break;
	}

	if( NULL == pSch )
	{
		// Special treatment for SCHCATEG_PUMP
		// Fall here if "No balancing device" selected
		// If one scheme of selected category was found, but balancing type was not OK, try it !
		if( NULL != pSchSave )
		{
			pSch = pSchSave;
			SetSchemeIDPtr( pSch->GetIDPtr() );
			BuildCircuit( pSch, bSecondaryBvNeeded, bShutoffValveNeeded, bCleanValvesAndData );
			RemoveBv( InPrimary );	// Remove valve
			return true;
		}
		else
		{
			return false;
		}
	}

	return BuildCircuit( pSch, bSecondaryBvNeeded, bShutoffValveNeeded, bCleanValvesAndData );
}

// Used to change a valve in an existing circuit
bool CDS_HydroModX::ChangeSelectedValve( CDB_TAProduct *pTap, eLocate locate )
{
	if( NULL == pTap )
	{
		return false;
	}

	CDB_CircuitScheme *pSch = GetpSch();

	if( NULL == pSch )
	{
		return false;
	}

	if( InSecondary == locate && false == pSch->GetpSchCateg()->IsInjection() )
	{
		return false;
	}

	// Verify if circuit is compliant
	// identify product
	CDB_ControlValve *pCV = dynamic_cast<CDB_ControlValve *>( pTap );
	CDB_PIControlValve *pPICV = dynamic_cast<CDB_PIControlValve *>( pTap );
	CDB_DpCBCValve *pDpCBCValve = dynamic_cast<CDB_DpCBCValve *>( pTap );

	if( InSecondary == locate )
	{
		// Only BV are allowed in secondary.
		if( NULL != pCV || NULL != pPICV || NULL != pDpCBCValve )
		{
			return false;
		}

		if( NULL != GetpBV( locate ) )
		{
			GetpBV( locate )->SetValveID( pTap->GetIDPtr().ID );
			return true;
		}

		return false;
	}
	else			// In primary, all valves allowed
	{
		if( NULL != pPICV )	// PICV
		{
			if( CDB_CircuitScheme::eDpCTypePICV == pSch->GetDpCType() )
			{
				if( NULL != GetpCv() )
				{
					GetpCv()->SetValveID( pTap->GetIDPtr().ID );
					return true;
				}
			}
		}
		else if( NULL != pDpCBCValve )	// Combined Dp controller, balancing and control valve.
		{
			if( CDB_CircuitScheme::eDpCTypeDPCBCV == pSch->GetDpCType() )
			{
				if( NULL != GetpCv() )
				{
					GetpCv()->SetValveID( pTap->GetIDPtr().ID );
					return true;
				}
			}
		}
		else if( NULL != pCV )	//BVCV
		{
			// 2016-10-10: From new, all the control valve are saved in a 'CDS_HydroModX::CCv' object (Before TBV-C & TBV-CM were saved
			//             in a 'CDS_HydroModX::CBV').
			if( NULL != GetpCv() && CDB_CircuitScheme::eDpCTypePICV != pSch->GetDpCType() && CDB_CircuitScheme::eDpCTypeDPCBCV != pSch->GetDpCType() )
			{
				GetpCv()->SetValveID( pTap->GetIDPtr().ID );
				return true;
			}
		}
		else		// BV
		{
			if( CDB_ControlProperties::NoControl == pSch->GetCvFunc()
				|| CDB_ControlProperties::ControlOnly == pSch->GetCvFunc()
				|| CDB_ControlProperties::Presettable == pSch->GetCvFunc() )
			{
				if( NULL != GetpBV( locate ) )
				{
					GetpBV( locate )->SetValveID( pTap->GetIDPtr().ID );
					return true;
				}
			}
		}
	}

	// Circuit not compliant, set default (simple) configuration
	eHMXBalType balwith = BV;

	if( NULL != pPICV )
	{
		balwith = PICV;
	}
	else if( NULL != pDpCBCValve )
	{
		balwith = DPC_BCV;
	}
	else if( NULL != pCV )
	{
		balwith = BVCV;
	}

	BuildCircuit( NULL, balwith, DpStabOnBranch, MvLocPrimary, false, false, true );

	if( PICV == balwith || DPC_BCV == balwith || BVCV == balwith )
	{
		if( NULL != GetpCv() )
		{
			GetpCv()->SetValveID( pTap->GetIDPtr().ID );
			return true;
		}
	}
	else
	{
		if( NULL != GetpBV( locate ) )
		{
			GetpBV( locate )->SetValveID( pTap->GetIDPtr().ID );
			return true;
		}
	}

	return false;
}

// Used to change a circuit to fit a new valve
// Try to match the new circuit with the old one
bool CDS_HydroModX::UpdateCircuitForNewValve( CDB_TAProduct *pTap, eLocate locate )
{
	if( NULL == pTap )
	{
		return false;
	}

	CDB_CircuitScheme *pSch = GetpSch();

	if( NULL == pSch )
	{
		return false;
	}

	if( InSecondary == locate && false == pSch->GetpSchCateg()->IsInjection() )
	{
		return false;
	}

	// Verify if circuit is compliant.
	// identify product
	CDB_ControlValve *pCV = dynamic_cast<CDB_ControlValve *>( pTap );
	CDB_PIControlValve *pPICV = dynamic_cast<CDB_PIControlValve *>( pTap );
	CDB_DpCBCValve *pDpCBCValve = dynamic_cast<CDB_DpCBCValve *>( pTap );

	if( InSecondary == locate )
	{
		// Only BV are allowed in secondary.
		if( NULL != pCV || NULL != pPICV || NULL != pDpCBCValve )
		{
			return false;
		}

		if( NULL != GetpBV( locate ) )
		{
			GetpBV( locate )->SetValveID( pTap->GetIDPtr().ID );
			return true;
		}

		return false;
	}
	else			// In primary, all valves allowed, fit new valve if valve typoe has not changed
	{
		if( NULL != pPICV )	// PICV
		{
			if( NULL != GetpCv() && NULL != dynamic_cast<CDB_PIControlValve *>( GetpTAP( locate ) ) )
			{
				GetpCv()->SetValveID( pTap->GetIDPtr().ID );
				return true;
			}
		}
		else if( NULL != pDpCBCValve )	// Combined Dp controller, balancing and control valve.
		{
			if( NULL != GetpCv() && NULL != dynamic_cast<CDB_DpCBCValve *>( GetpTAP( locate ) ) )
			{
				GetpCv()->SetValveID( pTap->GetIDPtr().ID );
				return true;
			}
		}
		else if( NULL != pCV )	//BVCV
		{
			// 2016-10-10: From now the combined balancing and control valve are saved in a 'CDS_HydroModX::CCv' instead of a
			//             'CDS_HydroModX::CBV'.
			if( NULL != GetpCv() && NULL != dynamic_cast<CDB_ControlValve *>( GetpTAP( locate ) )
				&& NULL == dynamic_cast<CDB_PIControlValve *>( GetpTAP( locate ) )
				&& NULL == dynamic_cast<CDB_DpCBCValve *>( GetpTAP( locate ) ) )
			{
				GetpCv()->SetValveID( pTap->GetIDPtr().ID );
				return true;
			}
		}
		else		// BV
		{
			if( NULL != GetpBV( locate ) && NULL == dynamic_cast<CDB_ControlValve *>( GetpTAP( locate ) ) )
			{
				GetpBV( locate )->SetValveID( pTap->GetIDPtr().ID );
				return true;
			}
		}
	}

	// Circuit not compliant, Search for best choice in circuits type.

	// Identify circuit scheme.
	pSch = NULL;
	CTable *pTab = static_cast<CTable *>( GetpTADB()->Get( L"CIRCSCHEME_TAB" ).MP );

	if( NULL == pTab )
	{
		return false;
	}

	bool bSchemeFound = false;

	for( IDPTR idptr = pTab->GetFirst(); NULL != idptr.MP; idptr = pTab->GetNext( idptr.MP ), pSch = NULL )
	{
		pSch = static_cast<CDB_CircuitScheme *>( idptr.MP );

		// Check for secondary side present.
		if( pSch->GetpSchCateg()->IsSecondarySideExist() != GetpSch()->GetpSchCateg()->IsSecondarySideExist() )
		{
			continue;
		}

		// If CV replaced by CV, Check for 2/3 way
		if( NULL != pCV && NULL == pPICV && NULL == pDpCBCValve )	//BVCV
		{
			if( NULL != GetpTAP( locate ) && NULL != dynamic_cast<CDB_ControlValve *>( GetpTAP( locate ) )
					&& NULL == dynamic_cast<CDB_PIControlValve *>( GetpTAP( locate ) )
					&& NULL == dynamic_cast<CDB_DpCBCValve *>( GetpTAP( locate ) ) )
			{
				if( pSch->GetpSchCateg()->Is2W() != GetpSch()->GetpSchCateg()->Is2W() )
				{
					continue;
				}
			}
		}

		// For PICV, check if DPC type is PICV
		if( NULL != pPICV )
		{
			if( CDB_CircuitScheme::eDpCTypePICV == pSch->GetDpCType() && CDB_ControlProperties::PresetPT == pSch->GetCvFunc() )
			{
				bSchemeFound = true;
				break;
			}
			else
			{
				continue;
			}
		}
		else if( NULL != pDpCBCValve )
		{
			if( CDB_CircuitScheme::eDpCTypeDPCBCV == pSch->GetDpCType() && CDB_ControlProperties::PresetPT == pSch->GetCvFunc() )
			{
				bSchemeFound = true;
				break;
			}
			else
			{
				continue;
			}
		}
		else if( pSch->GetBalType() == GetpSch()->GetBalType() )		// Not a PICV
		{
			// For BCV, check if CV func is PRESET PT
			if( NULL != pCV )
			{
				if( CDB_ControlProperties::PresetPT == pSch->GetCvFunc() )
				{
					bSchemeFound = true;
					break;
				}
				else
				{
					continue;
				}
			}
			// For BV
			else
			{
				if( CDB_ControlProperties::NoControl == pSch->GetCvFunc() )
				{
					bSchemeFound = true;
					break;
				}
				else
				{
					continue;
				}

			}
		}
	}

	if( false == bSchemeFound )	// No matching scheme found
	{
		return false;
	}

	// Set valve in structure.
	if( NULL != pPICV || NULL != pDpCBCValve || NULL != pCV )
	{
		RemoveBv( locate );
		AddCv( pSch->GetCvLoc() );
		SetSchemeIDPtr( pSch->GetIDPtr() );
		GetpCv()->SetValveID( pTap->GetIDPtr().ID );
		return true;
	}
	else
	{
		RemoveCv();
		AddBv( locate );
		SetSchemeIDPtr( pSch->GetIDPtr() );
		GetpBV( locate )->SetValveID( pTap->GetIDPtr().ID );
		return true;
	}

	return false;
}

bool CDS_HydroModX::SwitchToKvMode( double dKv )
{
	// Return to simple BV

	BuildCircuit( NULL, BV, DpStabOnBranch, MvLocPrimary, false, false, true );

	if( NULL != GetpBV( InPrimary ) )
	{
		GetpBV( InPrimary )->SetMode( Kvmode );
		GetpBV( InPrimary )->SetKv( dKv );
		return true;
	}

	return true;
}

bool CDS_HydroModX::SwitchToAlienMode()
{
	// Return to simple BV

	BuildCircuit( NULL, BV, DpStabOnBranch, MvLocPrimary, false, false, true );

	if( NULL != GetpBV( InPrimary ) )
	{
		GetpBV( InPrimary )->SetMode( ALIENmode );
		return true;
	}

	return true;
}

double CDS_HydroModX::GetSupplyTemperature()
{
	double dSupplyTemp = -273.15;
	CDS_WaterCharacteristic *pWC  = static_cast<CDS_WaterCharacteristic *>( GetWaterCharIDPtr().MP );
	CDS_HydroModX *pPHMX = dynamic_cast<CDS_HydroModX *>( GetIDPtr().PP );

	if( NULL != pWC )
	{
		dSupplyTemp = pWC->GetTemp();
	}

	// Verify if parent HMX don't contains a temperature interface as 2Winj circuit
	while( NULL != pPHMX )
	{
		if( NULL != pPHMX->GetpSchcat() && true == pPHMX->GetpSchcat()->IsInjection() )
		{
			dSupplyTemp = pPHMX->GetTempSecondary();
			break;
		}

		pPHMX = dynamic_cast<CDS_HydroModX *>( pPHMX->GetIDPtr().PP );
	}

	return dSupplyTemp;
}

// ---------------------------------------------------
// ------------------Nested class---------------------
// ---------------------------------------------------

// ------------------CBase---------------------

CDS_HydroModX::CBase::CBase( CDS_HydroModX *pParent )
{
	m_pParent = pParent;			// Circuit parent pointer
	m_ValveIDPtr = _NULL_IDPTR;		// TADB Valve IDPTR
	m_dDesignQ = 0.0;				// Design flow
	m_dDesignOpening = 0.0;			// Design opening
	m_dMeasDp = 0.0;				// Measured Dp
	m_dCurOpening = 0.0;			// Valve Opening for current measure
	m_MeasDateTime = 0;
	m_dTaBalOpening_1 = 0.0;	    // Current Valve Opening
	m_dTaBalMeasDp_1 = 0.0;			// Measured Dp
	m_dTaBalOpeningResult = 0.0;
	m_dTaBalWRatioFactor = 0.0;		// Used to store the flow ratio factor Q%i/Q%n
	m_eUseProduct = CDS_HydroModX::Last;
	m_iHySelectExchangeDataSize = 0;
	m_pHySelectExchangeData = NULL;
}

CDS_HydroModX::CBase::~CBase()
{
	if( NULL != m_pHySelectExchangeData )
	{
		free( m_pHySelectExchangeData );
	}
}

#define CDS_HYDROMODX_BASE_VERSION	4
// Version 4: 2016-09-19: 'm_eUseProduct' added.
void CDS_HydroModX::CBase::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_HYDROMODX_BASE_VERSION;
	WriteData<>( outf, Version );

	// Info.
	WriteString( outf, m_ValveIDPtr.ID );
	WriteDouble( outf, m_dDesignQ );
	WriteDouble( outf, m_dDesignOpening );
	WriteDouble( outf, m_dCurOpening );
	WriteDouble( outf, m_dMeasDp );
	WriteData<>( outf, m_MeasDateTime );
	WriteDouble( outf, m_dTaBalOpening_1 );
	WriteDouble( outf, m_dTaBalMeasDp_1 );
	WriteDouble( outf, m_dTaBalOpeningResult );
	WriteDouble( outf, m_dTaBalWRatioFactor );

	// Version 4.
	WriteData<>( outf, m_eUseProduct );

	WriteData<>( outf, m_iHySelectExchangeDataSize );

	if( m_iHySelectExchangeDataSize > 0 )
	{
		// Write data.
		unsigned char *pucData = m_pHySelectExchangeData;

		for( int iLoop = 0; iLoop < m_iHySelectExchangeDataSize; iLoop++ )
		{
			char cData = *pucData;
			WriteData<>( outf, cData );
			pucData++;
		}
	}
}

bool CDS_HydroModX::CBase::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_HYDROMODX_BASE_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_HYDROMODX_BASE_VERSION )
	{
		return false;
	}

	// Info.
	m_ValveIDPtr = _NULL_IDPTR;

	if( false == ReadString( inpf, m_ValveIDPtr.ID, sizeof( m_ValveIDPtr.ID ) ) )
	{
		return false;
	}

	m_dDesignQ = ReadDouble( inpf );
	m_dDesignOpening = ReadDouble( inpf );
	m_dCurOpening = ReadDouble( inpf );
	m_dMeasDp = ReadDouble( inpf );

	if( Version > 1 )
	{
		inpf.read( (char *)&m_MeasDateTime, sizeof( m_MeasDateTime ) );
	}
	else
	{
		m_MeasDateTime = m_pParent->GetMeasDateTime( CDS_HydroModX::InPrimary );
	}

	if( Version > 2 )
	{
		m_dTaBalOpening_1 = ReadDouble( inpf );
		m_dTaBalMeasDp_1 = ReadDouble( inpf );
		m_dTaBalOpeningResult = ReadDouble( inpf );
		m_dTaBalWRatioFactor = ReadDouble( inpf );
	}

	if( Version < 4 )
	{
		return true;
	}

	// Version 4.
	inpf.read( (char *)&m_eUseProduct, sizeof( m_eUseProduct ) );
	inpf.read( (char *)&m_iHySelectExchangeDataSize, sizeof( m_iHySelectExchangeDataSize ) );

	if( m_iHySelectExchangeDataSize > 0 )
	{
		m_pHySelectExchangeData = ( unsigned char * )malloc( m_iHySelectExchangeDataSize );

		if( NULL == m_pHySelectExchangeData )
		{
			return false;
		}

		// Read data.
		unsigned char *pData = m_pHySelectExchangeData;

		for( int iLoop = 0; iLoop < m_iHySelectExchangeDataSize; iLoop++ )
		{
			char cData;
			inpf.read( (char *)&cData, sizeof( cData ) );
			*pData = cData;
			pData++;
		}
	}

	return true;
}

void CDS_HydroModX::CBase::Copy( CDS_HydroModX::CBase *pTo )
{
	pTo->SetValveID( m_ValveIDPtr.ID );
	pTo->SetDesignFlow( m_dDesignQ );
	pTo->SetDesignOpening( m_dDesignOpening );
	pTo->SetCurOpening( m_dCurOpening );
	pTo->SetMeasDp( m_dMeasDp );
	pTo->SetMeasDateTime( m_MeasDateTime );
	pTo->SetTABalOpening_1( m_dTaBalOpening_1 );
	pTo->SetTABalMeasDp_1( m_dTaBalMeasDp_1 );
	pTo->SetTABalResultOpening( m_dTaBalOpeningResult );
	pTo->SetTABalWRatioFactor( m_dTaBalWRatioFactor );
	pTo->SetUseProduct( m_eUseProduct );

	// 2017-11-17: For big project it is becoming to big for the 'tsc' file.
	// pDestinationIndSelParameter->SaveHySelectExchangeData( m_pHySelectExchangeData, m_iHySelectExchangeDataSize );
}

void CDS_HydroModX::CBase::SaveHySelectExchangeData( unsigned char *pHySelectExchangeData, int iBufferSize )
{
	if( NULL == pHySelectExchangeData || iBufferSize <= 0 )
	{
		return;
	}

	m_iHySelectExchangeDataSize = 0;

	if( NULL != m_pHySelectExchangeData )
	{
		free( m_pHySelectExchangeData );
		m_pHySelectExchangeData = NULL;
	}

	m_pHySelectExchangeData = ( unsigned char * )malloc( iBufferSize );

	if( NULL == m_pHySelectExchangeData )
	{
		return;
	}

	memcpy( m_pHySelectExchangeData, pHySelectExchangeData, iBufferSize );
	m_iHySelectExchangeDataSize = iBufferSize;
}

IDPTR CDS_HydroModX::CBase::GetValveIDPtr()
{
	if( _T('\0') == *m_ValveIDPtr.ID )
	{
		return _NULL_IDPTR;
	}

	m_ValveIDPtr.DB = GetpTADB();
	Extend( &m_ValveIDPtr );
	return m_ValveIDPtr;
}

LPCTSTR CDS_HydroModX::CBase::GetValveName()
{
	if( _T('\0') == *m_ValveIDPtr.ID )
	{
		return _T("");
	}

	CDB_TAProduct *pTAP = dynamic_cast<CDB_TAProduct *>( GetValveIDPtr().MP );

	if( NULL != pTAP )
	{
		return pTAP->GetName();
	}

	CDB_AlienRegValve *pALIENP = dynamic_cast<CDB_AlienRegValve *>( GetValveIDPtr().MP );

	if( NULL != pALIENP )
	{
		return pALIENP->GetName();
	}

	return NULL;
}

bool CDS_HydroModX::CBase::IsKvSignalEquipped()
{
	if( _T('\0') == *m_ValveIDPtr.ID )
	{
		return false;
	}

	CDB_TAProduct *pTAP = dynamic_cast<CDB_TAProduct *>( GetValveIDPtr().MP );

	if( NULL != pTAP )
	{
		return ( pTAP->IsKvSignalEquipped() );
	}

	return false;
}

double CDS_HydroModX::CBase::GetFlow( double dOpening, double dDp, bool *pbVisCorActing )
{
	if( dDp <= 0.0 )
	{
		return 0.0;
	}

	// Get Water Characteristics
	CWaterChar *pWC = new CWaterChar;
	m_pParent->GetpWaterChar( pWC, GetLocate() );

	if( NULL == pWC )
	{
		return 0.0;    // Not initialised!
	}

	double dRho = pWC->GetDens();
	double dNu = pWC->GetKinVisc();
	delete pWC;

	CDB_TAProduct *pTAP = dynamic_cast<CDB_TAProduct *>( GetValveIDPtr().MP );
	CDB_AlienRegValve *pALIENP = dynamic_cast<CDB_AlienRegValve *>( GetValveIDPtr().MP );

	// Valve not found!
	if( NULL == pTAP &&  NULL == pALIENP )
	{
		return 0.0;
	}

	if( NULL != pbVisCorActing )
	{
		*pbVisCorActing = false;
	}

	if( NULL != pTAP && true == pTAP->IsKvSignalEquipped() )
	{
		double dKv = 0.0;
		dKv = pTAP->GetKvSignal();

		if( -1.0 == dKv )
		{
			return 0.0;
		}

		double dQ = CalcqT( dKv, dDp, dRho );
		return dQ;
	}

	// ALIEN fixed orifice
	if( NULL != pALIENP && true == pALIENP->IsKvSignalEquipped() )
	{
		double dKv = 0.0;
		dKv = pALIENP->GetKvSignal();

		if( -1.0 == dKv )
		{
			return 0.0;
		}

		double dQ = CalcqT( dKv, dDp, dRho );
		return dQ;
	}


	CDB_ValveCharacteristic *pValveCharacteristic = NULL;

	if( NULL != pTAP )
	{
		pValveCharacteristic = pTAP->GetValveCharacteristic();
	}
	else if( NULL != pALIENP )
	{
		pValveCharacteristic = pALIENP->GetValveCharacteristic();
	}

	if( NULL == pValveCharacteristic )
	{
		return 0.0;
	}

	//	Allow 0 opening (leakage flow)
	if( dOpening < 0.0 )
	{
		return 0.0;
	}

	double dQ = 0.0;

	if( true == pValveCharacteristic->GetValveQ( &dQ, dDp, dOpening, dRho, dNu ) )
	{
		// Compute not corrected flow.
		double dNotCorrectedQ = dQ;

		if( NULL != pbVisCorActing )
		{
			double dKv = pValveCharacteristic->GetKv( dOpening );

			if( -1.0 != dKv )
			{
				dNotCorrectedQ = CalcqT( dKv, dDp, dRho );
				double dViscCorPercent = fabs( 100 * ( dNotCorrectedQ - dQ ) / dNotCorrectedQ );
				*pbVisCorActing = ( dViscCorPercent > 0.5 );
			}
		}
	}

	return dQ;
}

double	CDS_HydroModX::CBase::GetDpFullOpening( double dQ )
{
	if( dQ <= 0 )
	{
		return 0.0;
	}

	CDB_TAProduct *pTAP = dynamic_cast<CDB_TAProduct *>( GetValveIDPtr().MP );
	CDB_AlienRegValve *pALIENP = dynamic_cast<CDB_AlienRegValve *>( GetValveIDPtr().MP );

	if( NULL == pTAP &&  NULL == pALIENP )
	{
		return 0.0;
	}

	CDB_ValveCharacteristic *pValveCharacteristic = NULL;

	if( NULL != pTAP )
	{
		pValveCharacteristic = pTAP->GetValveCharacteristic();
	}
	else if( NULL != pALIENP )
	{
		pValveCharacteristic = pALIENP->GetValveCharacteristic();
	}

	if( NULL == pValveCharacteristic )
	{
		return 0.0;
	}

	double dDp = 0.0;
	CWaterChar *pWC = m_pParent->GetpWaterChar( NULL, GetLocate() );

	if( NULL != pWC )
	{
		double dRho = pWC->GetDens();
		double dNu = pWC->GetKinVisc();
		dDp = pValveCharacteristic->GetDpFullOpening( dQ, dRho, dNu );
		delete pWC;
	}

	if( -1.0 == dDp )
	{
		dDp = 0.0;
	}

	return dDp;
}

double	CDS_HydroModX::CBase::GetOpening( double dQ, double dDp )
{
	if( dQ <= 0 )
	{
		return 0.0;
	}

	if( dDp <= 0 )
	{
		return 0.0;
	}

	CDB_TAProduct *pTAP = dynamic_cast<CDB_TAProduct *>( GetValveIDPtr().MP );
	CDB_AlienRegValve *pALIENP = dynamic_cast<CDB_AlienRegValve *>( GetValveIDPtr().MP );

	if( NULL == pTAP &&  NULL == pALIENP )
	{
		return 0.0;
	}

	CDB_ValveCharacteristic *pValveCharacteristic = NULL;

	if( NULL != pTAP )
	{
		pValveCharacteristic = pTAP->GetValveCharacteristic();
	}
	else if( NULL != pALIENP )
	{
		pValveCharacteristic = pALIENP->GetValveCharacteristic();
	}

	if( NULL == pValveCharacteristic )
	{
		return 0.0;
	}

	bool b = false;
	double dH = 0.0;
	CWaterChar *pWC = m_pParent->GetpWaterChar( NULL, GetLocate() );

	if( NULL != pWC )
	{
		double dRho = pWC->GetDens();
		double dNu = pWC->GetKinVisc();
		b = CalcValvh( dQ, dDp, &dH, dRho, dNu, pValveCharacteristic, ( eb3True == pValveCharacteristic->IsMultiTurn() ) ? 0 : 1 );
		delete pWC;
	}

	if( false == b )
	{
		return -1.0;
	}

	return dH;
}

double CDS_HydroModX::CBase::GetDesignOpening()
{
	CDB_TAProduct *pTAP = dynamic_cast<CDB_TAProduct *>( GetValveIDPtr().MP );
	CDB_AlienRegValve *pALIENP = dynamic_cast<CDB_AlienRegValve *>( GetValveIDPtr().MP );

	if( NULL == pTAP &&  NULL == pALIENP )
	{
		return 0.0;
	}

	CDB_ValveCharacteristic *pValveCharacteristic = NULL;

	if( NULL != pTAP )
	{
		pValveCharacteristic = pTAP->GetValveCharacteristic();
	}
	else if( NULL != pALIENP )
	{
		pValveCharacteristic = pALIENP->GetValveCharacteristic();
	}

	if( NULL == pValveCharacteristic )
	{
		return 0.0;
	}

	m_dDesignOpening = min( pValveCharacteristic->GetOpeningMax(), m_dDesignOpening );
	m_dDesignOpening = max( 0, m_dDesignOpening );
	return m_dDesignOpening;
}

double CDS_HydroModX::CBase::GetCurOpening()
{
	CDB_TAProduct *pTAP = dynamic_cast<CDB_TAProduct *>( GetValveIDPtr().MP );
	CDB_AlienRegValve *pALIENP = dynamic_cast<CDB_AlienRegValve *>( GetValveIDPtr().MP );

	if( NULL == pTAP &&  NULL == pALIENP )
	{
		return 0.0;
	}

	CDB_ValveCharacteristic *pValveCharacteristic = NULL;

	if( NULL != pTAP )
	{
		pValveCharacteristic = pTAP->GetValveCharacteristic();
	}
	else if( NULL != pALIENP )
	{
		pValveCharacteristic = pALIENP->GetValveCharacteristic();
	}

	if( NULL == pValveCharacteristic )
	{
		return 0.0;
	}

	m_dCurOpening = min( pValveCharacteristic->GetOpeningMax(), m_dCurOpening );
	m_dCurOpening = max( 0, m_dCurOpening );
	return m_dCurOpening;
}

void CDS_HydroModX::CBase::SetDesignOpening( double dOpening )
{
	if( m_dDesignOpening == dOpening )
	{
		return;
	}

	m_dDesignOpening = max( 0, dOpening );
	m_pParent->Modified();
}

// ------------------CCv---------------------
CDS_HydroModX::CCv::CCv( CDS_HydroModX *pParent ) : CDS_HydroModX::CBase( pParent )
{
	m_eCvLocate = CvLocNone;					// Define where is located the control valve.
}

#define CDS_HYDROMODX_CCV_VERSION	2
// 2016-10-10: add 'm_Locate' variable.
void CDS_HydroModX::CCv::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_HYDROMODX_CCV_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CBase::Write( outf );

	// Info.
	WriteData<>( outf, m_eCvLocate );
}

bool CDS_HydroModX::CCv::Read( INPSTREAM inpf )
{
	// Version
	BYTE Version = CDS_HYDROMODX_CCV_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_HYDROMODX_CCV_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CBase::Read( inpf ) )
	{
		return false;
	}

	// Info.
	if( Version < 2 )
	{
		return true;
	}

	inpf.read( (char *)&m_eCvLocate, sizeof( m_eCvLocate ) );

	return true;
}

void CDS_HydroModX::CCv::Copy( CDS_HydroModX::CBase *pTo )
{
	CDS_HydroModX::CCv *pHMXCVTo = dynamic_cast<CDS_HydroModX::CCv *>( pTo );

	if( NULL == pHMXCVTo )
	{
		return;
	}

	CBase::Copy( pHMXCVTo );

	pHMXCVTo->SetCvLocate( m_eCvLocate );
}


// ------------------CShutoffValve ---------------------
CDS_HydroModX::CShutoffValve::CShutoffValve( CDS_HydroModX *pParent ) 
	: CDS_HydroModX::CBase( pParent )
{
}

#define CDS_HYDROMODX_CSHUTOFFVALVE_VERSION		1
void CDS_HydroModX::CShutoffValve::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_HYDROMODX_CSHUTOFFVALVE_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CBase::Write( outf );
}

bool CDS_HydroModX::CShutoffValve::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_HYDROMODX_CSHUTOFFVALVE_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_HYDROMODX_CSHUTOFFVALVE_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CBase::Read( inpf ) )
	{
		return false;
	}

	return true;
}

void CDS_HydroModX::CShutoffValve::Copy( CDS_HydroModX::CBase *pTo )
{
	CDS_HydroModX::CShutoffValve *pHMXSVTo = dynamic_cast<CDS_HydroModX::CShutoffValve *>( pTo );

	if( NULL == pHMXSVTo )
	{
		return;
	}

	CBase::Copy( pHMXSVTo );
}

// ------------------ CSmartControlValve ---------------------
CDS_HydroModX::CSmartControlValve::CSmartControlValve( CDS_HydroModX *pParent ) 
	: CDS_HydroModX::CBase( pParent )
{
}

#define CDS_HYDROMODX_CSMARTCONTROLVALVE_VERSION		1
void CDS_HydroModX::CSmartControlValve::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_HYDROMODX_CSMARTCONTROLVALVE_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CBase::Write( outf );
}

bool CDS_HydroModX::CSmartControlValve::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_HYDROMODX_CSMARTCONTROLVALVE_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_HYDROMODX_CSMARTCONTROLVALVE_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CBase::Read( inpf ) )
	{
		return false;
	}

	return true;
}

void CDS_HydroModX::CSmartControlValve::Copy( CDS_HydroModX::CBase *pTo )
{
	CDS_HydroModX::CSmartControlValve *pHMXSmartControlValveTo = dynamic_cast<CDS_HydroModX::CSmartControlValve *>( pTo );

	if( NULL == pHMXSmartControlValveTo )
	{
		return;
	}

	CBase::Copy( pHMXSmartControlValveTo );
}

// ------------------ CSmartDpC ---------------------
CDS_HydroModX::CSmartDpC::CSmartDpC( CDS_HydroModX *pParent ) 
	: CDS_HydroModX::CBase( pParent )
{
}

#define CDS_HYDROMODX_CSMARTDPC_VERSION		1
void CDS_HydroModX::CSmartDpC::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_HYDROMODX_CSMARTDPC_VERSION;
	WriteData<>( outf, Version );

	// Base class.
	CBase::Write( outf );
}

bool CDS_HydroModX::CSmartDpC::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_HYDROMODX_CSMARTDPC_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_HYDROMODX_CSMARTDPC_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CBase::Read( inpf ) )
	{
		return false;
	}

	return true;
}

void CDS_HydroModX::CSmartDpC::Copy( CDS_HydroModX::CBase *pTo )
{
	CDS_HydroModX::CSmartDpC *pHMXSmartDpCTo = dynamic_cast<CDS_HydroModX::CSmartDpC *>( pTo );

	if( NULL == pHMXSmartDpCTo )
	{
		return;
	}

	CBase::Copy( pHMXSmartDpCTo );
}

// ------------------CDPC---------------------
CDS_HydroModX::CDpC::CDpC( CDS_HydroModX *pParent, eDpStab StabOn ) : CDS_HydroModX::CBase( pParent )
{
	m_StabilizeOn = StabOn;
	m_MvLoc = MvLocPrimary;
}

#define CDS_HYDROMODX_CDPC_VERSION	1
void CDS_HydroModX::CDpC::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_HYDROMODX_CDPC_VERSION;
	WriteData<>( outf, Version );
	
	// Base class.
	CBase::Write( outf );
	
	// Info.
	WriteData<>( outf, m_StabilizeOn );
	WriteData<>( outf, m_MvLoc );
}

bool CDS_HydroModX::CDpC::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_HYDROMODX_CDPC_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_HYDROMODX_CDPC_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CBase::Read( inpf ) )
	{
		return false;
	}

	// Info.
	inpf.read( (char *)&m_StabilizeOn, sizeof( m_StabilizeOn ) );
	inpf.read( (char *)&m_MvLoc, sizeof( m_MvLoc ) );
	return true;
}

void CDS_HydroModX::CDpC::Copy( CDS_HydroModX::CBase *pTo )
{
	CDS_HydroModX::CDpC *pHMXDpCTo = dynamic_cast<CDS_HydroModX::CDpC *>( pTo );

	if( NULL == pHMXDpCTo )
	{
		return;
	}

	CBase::Copy( pHMXDpCTo );

	pHMXDpCTo->SetStabilizedOn( m_StabilizeOn );
	pHMXDpCTo->SetMvLoc( m_MvLoc );
}


// ------------------CMeasData---------------------
CDS_HydroModX::CMeasData::CMeasData( CDS_HydroModX *pParent )
{
	m_pParent = pParent;
	ClearData();
}

void CDS_HydroModX::CMeasData::ClearData()
{
	m_Locate = undef;					// Define where is located the balancing valve
	m_eBalanced = etabmNoBalancing;
	m_MeasDateTime = 0;
	m_TABalDateTime = 0;
	m_QMType = QMundef;
	m_MeasFlowDone = false;
	memset( &m_dMeasTemp, 0, LastDTS * sizeof( double ) );
	m_dMeasDp = 0.0;
	m_dMeasDpL = 0.0;
	m_dTaBalMeasDp_2 = 0.0;
	m_dTaBalPipeDp = 0.0;
	m_dTaBalUnitDp = 0.0;
	m_eTaBalMeasCompleted = emcNoMeas;	// Set when measuring step 1 & 2 are done
	memset( &m_UsedDTSensor, 0, 2 * sizeof( CDS_HydroModX::eDTS ) );
	m_WaterTempRef = CDS_HydroModX::DTSUndef;
}

void CDS_HydroModX::CMeasData::Copy( CDS_HydroModX::CMeasData *pTo )
{
	if(  NULL == pTo )
	{
		return;
	}

	pTo->SetLocate( m_Locate );
	pTo->SetWaterTempRef( m_WaterTempRef );
	pTo->SetMeasDateTime( m_MeasDateTime );
	pTo->SetTABalDateTime( m_TABalDateTime );
	pTo->SetQMType( ( CDS_HydroModX::eQMtype ) m_QMType );

	for( UINT i = 0; i < LastDTS; i++ )
	{
		pTo->SetMeasTemp( ( CDS_HydroModX::eDTS ) i, m_dMeasTemp[i] );
	}

	for( UINT i = 0; i < 2; i++ )
	{
		pTo->SetUsedDTSensor( i, m_UsedDTSensor[i] );
	}

	pTo->SetMeasDp( m_dMeasDp );
	pTo->SetMeasDpL( m_dMeasDpL );
	pTo->SetMeasFlowDone( m_MeasFlowDone );
	pTo->SetTaBalMeasDp_2( m_dTaBalMeasDp_2 );
	pTo->SetTaBalPipeDp( m_dTaBalPipeDp );
	pTo->SetTaBalUnitDp( m_dTaBalUnitDp );
	pTo->SetBalanced( m_eBalanced );
	pTo->SetTaBalMeasCompleted( m_eTaBalMeasCompleted );
}

#define CDS_HYDROMODX_CMEASDATA_VERSION	2
void CDS_HydroModX::CMeasData::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_HYDROMODX_CMEASDATA_VERSION;
	WriteData<>( outf, Version );

	// Info.
	WriteData<>( outf, m_Locate );
	WriteData<>( outf, m_WaterTempRef );
	WriteData<>( outf, m_MeasDateTime );
	WriteData<>( outf, m_TABalDateTime );
	WriteData<>( outf,  m_QMType );

	for( UINT i = 0; i < LastDTS; i++ )
	{
		WriteDouble( outf, m_dMeasTemp[i] );
	}

	for( UINT i = 0; i < 2; i++ )
	{
		WriteData<>( outf, m_UsedDTSensor[i] );
	}

	WriteDouble( outf, m_dMeasDp );
	WriteDouble( outf, m_dMeasDpL );
	WriteData<>( outf, m_MeasFlowDone );
	WriteDouble( outf, m_dTaBalMeasDp_2 );
	WriteDouble( outf, m_dTaBalPipeDp );
	WriteDouble( outf, m_dTaBalUnitDp );
	WriteData<>( outf, m_eBalanced );
	WriteData<>( outf, m_eTaBalMeasCompleted );
}

bool CDS_HydroModX::CMeasData::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_HYDROMODX_CMEASDATA_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_HYDROMODX_CMEASDATA_VERSION )
	{
		return false;
	}

	// Info.
	inpf.read( (char *)&m_Locate, sizeof( m_Locate ) );
	inpf.read( (char *)&m_WaterTempRef, sizeof( m_WaterTempRef ) );
	inpf.read( (char *)&m_MeasDateTime, sizeof( m_MeasDateTime ) );
	inpf.read( (char *)&m_TABalDateTime, sizeof( m_TABalDateTime ) );
	inpf.read( (char *)& m_QMType, sizeof( m_QMType ) );

	if( Version == 1 )
	{
		for( UINT i = 0; i < LastDTS; i++ )
		{
			inpf.read( (char *)&m_dMeasTemp[i], sizeof( m_dMeasTemp[i] ) );
		}

		for( UINT i = 0; i < 2; i++ )
		{
			inpf.read( (char *)&m_UsedDTSensor[i], sizeof( m_UsedDTSensor[i] ) );
		}

		inpf.read( (char *)&m_dMeasDp, sizeof( m_dMeasDp ) );
		inpf.read( (char *)&m_dMeasDpL, sizeof( m_dMeasDpL ) );
		inpf.read( (char *)&m_MeasFlowDone, sizeof( m_MeasFlowDone ) );
		inpf.read( (char *)&m_dTaBalMeasDp_2, sizeof( m_dTaBalMeasDp_2 ) );
		inpf.read( (char *)&m_dTaBalPipeDp, sizeof( m_dTaBalPipeDp ) );
		inpf.read( (char *)&m_dTaBalUnitDp, sizeof( m_dTaBalUnitDp ) );
	}
	else
	{
		for( UINT i = 0; i < LastDTS; i++ )
		{
			m_dMeasTemp[i] = ReadDouble( inpf );
		}

		for( UINT i = 0; i < 2; i++ )
		{
			inpf.read( (char *)&m_UsedDTSensor[i], sizeof( m_UsedDTSensor[i] ) );
		}

		m_dMeasDp = ReadDouble( inpf );
		m_dMeasDpL = ReadDouble( inpf );
		inpf.read( (char *)&m_MeasFlowDone, sizeof( m_MeasFlowDone ) );
		m_dTaBalMeasDp_2 = ReadDouble( inpf );
		m_dTaBalPipeDp = ReadDouble( inpf );
		m_dTaBalUnitDp = ReadDouble( inpf );
	}

	inpf.read( (char *)&m_eBalanced, sizeof( m_eBalanced ) );
	inpf.read( (char *)&m_eTaBalMeasCompleted, sizeof( m_eTaBalMeasCompleted ) );

	return true;
}

// ------------------CBV---------------------
CDS_HydroModX::CBV::CBV( CDS_HydroModX *pParent, eMode mode ) 
	: CDS_HydroModX::CBase( pParent )
{
	m_Locate = undef;					// Define where is located the balancing valve
	m_Mode = mode;					// TA valve IDPtr exist, Kv Mode only Kv exist
	m_dKv = 0.0;
}

double CDS_HydroModX::CBV::GetFlow( double dOpening, double dDp, bool *pbVisCorActing )
{
	if( dDp <= 0 )
	{
		return 0.0;
	}

	bool bForceKvMode = false;

	if( ALIENmode == GetMode() && NULL == m_pParent->GetpALIENP() )
	{
		bForceKvMode = true;
	}

	if( Kvmode != GetMode() && false == bForceKvMode )
	{
		return CBase::GetFlow( dOpening, dDp, pbVisCorActing );
	}

	double dKv = GetKv();
	
	// Get water characteristics.
	CWaterChar *pWC = m_pParent->GetpWaterChar( NULL, GetLocate() );

	if( NULL == pWC )
	{
		return 0.0;    // Not initialized!
	}

	double dRho = pWC->GetDens();
	delete( pWC );
	
	double dQ = CalcqT( dKv, dDp, dRho );
	
	return dQ;
}

double CDS_HydroModX::CBase::GetDesignDp( bool bVerifyIndex )
{
	CDB_TAProduct *pTAP = dynamic_cast<CDB_TAProduct *>( GetValveIDPtr().MP );
	CDB_AlienRegValve *pALIENP = dynamic_cast<CDB_AlienRegValve *>( GetValveIDPtr().MP );

	if( NULL == pTAP &&  NULL == pALIENP )
	{
		return 0.0;
	}

	CDB_ValveCharacteristic *pValveCharacteristic = NULL;

	if( NULL != pTAP )
	{
		pValveCharacteristic = pTAP->GetValveCharacteristic();
	}
	else if( NULL != pALIENP )
	{
		pValveCharacteristic = pALIENP->GetValveCharacteristic();
	}

	if( NULL == pValveCharacteristic )
	{
		return 0.0;
	}

	// Get Water Characteristics.
	CWaterChar *pWC = m_pParent->GetpWaterChar( NULL, GetLocate() );

	if( NULL == pWC )
	{
		return 0.0;
	}

	double dRho = pWC->GetDens();
	double dNu = pWC->GetKinVisc();
	delete pWC;
	double dDp;
	double dH = GetDesignOpening();
	double dQ = m_pParent->GetDesignFlow( InPrimary );

	if( false == pValveCharacteristic->GetValveDp( dQ, &dDp, dH, dRho, dNu ) )
	{
		return 0.0;
	}

	if( true == bVerifyIndex )
	{
		// VerifyIndex. If the current valve is the index (dDp = 3kPa or dDp>3kPa && FO) then return MinValvDp (3kPa).
		CDS_TechnicalParameter *pTech = static_cast<CDS_TechnicalParameter *>( m_pParent->GetIDPtr().DB->Get( _T("PARAM_TECH") ).MP );
		double dMinDp = max( m_pParent->GetTABalValMinDp(), pTech->GetValvMinDp() );
		double dHMax = pValveCharacteristic->GetOpeningMax();

		if( dDp <= ( dMinDp * 1.1 ) || ( dDp > dMinDp && dH == dHMax ) )	// Index valve return ValveMinDp
		{
			return dMinDp;
		}
	}

	return dDp;
}

#define CDS_HYDROMODX_CBV_VERSION	3
void CDS_HydroModX::CBV::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_HYDROMODX_CBV_VERSION;
	WriteData<>( outf, Version );

	// Base.
	CBase::Write( outf );

	// Info.
	WriteData<>( outf, m_Locate );
	WriteData<>( outf, m_Mode );
	WriteDouble( outf, m_dKv );
}

bool CDS_HydroModX::CBV::Read( INPSTREAM inpf )
{
	// Version
	BYTE Version = CDS_HYDROMODX_CBV_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_HYDROMODX_CBV_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CBase::Read( inpf ) )
	{
		return false;
	}

	// Info.
	inpf.read( (char *)&m_Locate, sizeof( m_Locate ) );
	inpf.read( (char *)&m_Mode, sizeof( m_Mode ) );
	m_dKv = ReadDouble( inpf );

	if( Version < 3 )
	{
		m_dTaBalOpening_1 = ReadDouble( inpf );
		m_dTaBalMeasDp_1 = ReadDouble( inpf );
		m_dTaBalOpeningResult = ReadDouble( inpf );

		if( Version > 1 )
		{
			m_dTaBalWRatioFactor = ReadDouble( inpf );
		}
	}

	return true;
}

void CDS_HydroModX::CBV::Copy( CDS_HydroModX::CBase *pTo )
{
	CDS_HydroModX::CBV *pHMXBVTo = dynamic_cast<CDS_HydroModX::CBV *>( pTo );

	if( NULL == pHMXBVTo )
	{
		return;
	}

	CBase::Copy( pHMXBVTo );

	pHMXBVTo->SetKv( m_dKv );					// Be careful SetKv change m_Mode to Kv mode
	pHMXBVTo->SetMode( m_Mode );				// SetMode must be executed after
	pHMXBVTo->SetLocate( m_Locate );
}

CHMXPipe::CHMXPipe( CWaterChar *pWC, ePipeLoc PipeLoc )
{
	m_pHMXParent = NULL;
	m_eOwner = eMeasDataOwner;
	m_pWC = pWC;
	m_PipeLoc = ( ePipeLoc ) - 1;
	m_tcPipeID[0]= _T('\0');		// Used when the pipe comes from TADB
	m_RLin = 0.0;					// Linear resistance, used with unknown pipe
	m_KvFix = 0.0;					// Kv of fixed device as tee, angle, ...
	m_Length = 0.0;					// Pipe length
	m_dQ = 0.0;						// Flow
	m_iHySelectExchangeDataSize = 0;
	m_pHySelectExchangeData = NULL;
}

CHMXPipe::CHMXPipe( CDS_HydroModX *pHMXParent, ePipeLoc PipeLoc )
{
	m_pHMXParent = pHMXParent;		// Circuit parent pointer
	m_eOwner = eHMXOwner;
	m_pWC = NULL;
	m_PipeLoc = PipeLoc;
	m_tcPipeID[0]= _T('\0');		// Used when the pipe comes from TADB
	m_RLin = 0.0;					// Linear resistance, used with unknown pipe
	m_KvFix = 0.0;					// Kv of fixed device as tee, angle, ...
	m_Length = 0.0;					// Pipe length
	m_dQ = 0.0;						// Flow
	m_iHySelectExchangeDataSize = 0;
	m_pHySelectExchangeData = NULL;
}

CHMXPipe::~CHMXPipe()
{
	if( NULL != m_pHySelectExchangeData )
	{
		free( m_pHySelectExchangeData );
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// theses functions can't be set in .h because there is a problem with undefined type 'CDS_HydroModX' even with
// forward declaration.
void CHMXPipe::SetPipeLoc( ePipeLoc PipeLoc )
{
	if( m_PipeLoc == PipeLoc )
	{
		return;
	}

	m_PipeLoc = PipeLoc;

	if( eHMXOwner == m_eOwner )
	{
		m_pHMXParent->Modified();
	}
}

void CHMXPipe::SetPipeID( _string ID )
{
	if( 0 == IDcmp( ID.c_str(), m_tcPipeID ) )
	{
		return;
	}

	wcscpy( m_tcPipeID, ID.c_str() );

	if( eHMXOwner == m_eOwner )
	{
		m_pHMXParent->Modified();
	}
}

void CHMXPipe::SetRLin( double rlin )
{
	if( m_RLin == rlin )
	{
		return;
	}

	m_RLin = rlin;

	if( eHMXOwner == m_eOwner )
	{
		m_pHMXParent->Modified();
	}
}

void CHMXPipe::SetKvFix( double KvFix )
{
	if( m_KvFix == KvFix )
	{
		return;
	}

	m_KvFix = KvFix;

	if( eHMXOwner == m_eOwner )
	{
		m_pHMXParent->Modified();
	}
}

void CHMXPipe::SetLength( double Length )
{
	if( m_Length == Length )
	{
		return;
	}

	m_Length = Length;

	if( eHMXOwner == m_eOwner )
	{
		m_pHMXParent->Modified();
	}
}

void CHMXPipe::SetFlow( double dflow )
{
	if( m_dQ == dflow )
	{
		return;
	}

	m_dQ = dflow;

	if( eHMXOwner == m_eOwner )
	{
		m_pHMXParent->Modified();
	}
}

void CHMXPipe::SetpParentHMX( CDS_HydroModX *pHMXParent )
{
	m_pHMXParent = pHMXParent;
}

//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

CDB_Pipe *CHMXPipe::GetpPipe()
{
	if( _T('\0') == *m_tcPipeID )
	{
		return NULL;
	}

	IDPTR PipeIDPtr = _NULL_IDPTR;
	wcscpy( PipeIDPtr.ID, m_tcPipeID );

#ifdef TACBX
	PipeIDPtr.DB = GetpTADB();
#else
	PipeIDPtr.DB = TASApp.GetpPipeDB();
#endif

	Extend( &PipeIDPtr );
	return dynamic_cast<CDB_Pipe*>( PipeIDPtr.MP );
}

double CHMXPipe::GetTotalDp()
{
	double dPipeDp = 0.0;
	CWaterChar WC;
	CWaterChar *pWC;

	if( eHMXOwner == m_eOwner )
	{
		m_pHMXParent->GetpWaterChar( &WC, CDS_HydroModX::InPrimary );
		pWC = &WC;
	}
	else
	{
		pWC = m_pWC;
	}

	CDB_Pipe *pPipeDB = GetpPipe();

	if( NULL != pPipeDB )			// Pipe exist, use it
	{
		dPipeDp = pPipeDB->GetLinearDp( GetFlow(), pWC->GetDens(), pWC->GetKinVisc() ) * m_Length;
	}
	else							// Pipe IDPTR doesn't exist use Rlin
	{
		double dRtot = m_RLin * m_Length;
		double dKvTot = 0.0;

		if( dRtot != 0.0 )
		{
			dKvTot = CalcKv( dRtot, pWC->GetDens() );
		}

		dPipeDp = CalcDp( GetFlow(), dKvTot, pWC->GetDens() );
	}

	// Add the Dp due to accessories.
	double dAccDp = CalcDp( GetFlow(), m_KvFix, pWC->GetDens() );

	return ( dPipeDp + dAccDp );
}

#define CHMXPIPE_VERSION	4
// Version 4: 2021-07-01: Remove the saving of additional data.
// Version 3: 2016-10-17: Singularities added (raw buffer invisible for TA-Scope).
void CHMXPipe::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CHMXPIPE_VERSION;
	WriteData<>( outf, Version );

	// Info.
	WriteData<>( outf, m_PipeLoc );
	WriteString( outf, m_tcPipeID );		// Used when the pipe comes from TADB
	WriteDouble( outf, m_RLin );
	WriteDouble( outf, m_KvFix );
	WriteDouble( outf, m_Length );
	WriteDouble( outf, m_dQ );

	// Version 3.
	// Version 4: Remove the saving of additional data.
}

bool CHMXPipe::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CHMXPIPE_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CHMXPIPE_VERSION )
	{
		return false;
	}

	// Info.
	inpf.read( (char *)&m_PipeLoc, sizeof( m_PipeLoc ) );

	if( false == ReadString( inpf, m_tcPipeID, sizeof( m_tcPipeID ) ) )
	{
		return false;
	}

	m_RLin = ReadDouble( inpf );
	m_KvFix = ReadDouble( inpf );
	m_Length = ReadDouble( inpf );

	if( Version > 1 )
	{
		m_dQ = ReadDouble( inpf );
	}

	if( Version < 3 )
	{
		return true;
	}

	// Version 3.
	if( 3 == Version )
	{
		inpf.read( (char *)&m_iHySelectExchangeDataSize, sizeof( m_iHySelectExchangeDataSize ) );

		if( m_iHySelectExchangeDataSize > 0 )
		{
			m_pHySelectExchangeData = (unsigned char *)malloc( m_iHySelectExchangeDataSize );

			if( NULL == m_pHySelectExchangeData )
			{
				return false;
			}

			// Read data.
			unsigned char *pData = m_pHySelectExchangeData;

			for( int iLoop = 0; iLoop < m_iHySelectExchangeDataSize; iLoop++ )
			{
				char cData;
				inpf.read( (char *)&cData, sizeof( cData ) );
				*pData = cData;
				pData++;
			}
		}
	}

	// Version 4:Remove the saving of additional data.

	return true;
}

void CHMXPipe::Copy( CHMXPipe *pTo )
{
	// Set parent must be placed in first position because some functions below
	// call m_pParent.
	if( eHMXOwner == m_eOwner )
	{
		pTo->SetpParentHMX( m_pHMXParent );
	}

	pTo->SetKvFix( m_KvFix );
	pTo->SetLength( m_Length );
	pTo->SetPipeID( m_tcPipeID );
	pTo->SetPipeLoc( m_PipeLoc );
	pTo->SetRLin( m_RLin );
	pTo->SetFlow( m_dQ );

	// Version 3.
	// Version 4:Remove the saving of additional data.
}

///////////////////////////////////////////////////////////////////////////////////
//
// CTU neested class
CHMXTU::CHMXTU()
{
	m_pHMXParent = NULL;
	m_dDp = 0.0;
	m_dQ = 0.0;
	m_eOwner = eMeasDataOwner;
	m_iTermUnitDataSize = 0;
	m_pTermUnitData = NULL;
}

CHMXTU::CHMXTU( CDS_HydroModX *pHMXParent )
{
	m_pHMXParent = pHMXParent;
	m_dDp = 0.0;
	m_dQ = 0.0;
	m_eOwner = eHMXOwner;
	m_iTermUnitDataSize = 0;
	m_pTermUnitData = NULL;
}

CHMXTU::~CHMXTU()
{
	if( NULL != m_pTermUnitData )
	{
		free( m_pTermUnitData );
		m_pTermUnitData = NULL;
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// theses functions can't be set in .h because there is a problem with undefined type 'CDS_HydroModX' even with
// forward declaration.
void CHMXTU::SetDp( double dDp )
{
	if( m_dDp == dDp )
	{
		return;
	}

	m_dDp = dDp;

	if( eHMXOwner == m_eOwner )
	{
		m_pHMXParent->Modified();
	}
}

void CHMXTU::SetDesignFlow( double dQ )
{
	if( m_dQ == dQ )
	{
		return;
	}

	m_dQ = dQ;

	if( eHMXOwner == m_eOwner )
	{
		m_pHMXParent->Modified();
	}
}

void CHMXTU::SetpParentHMX( CDS_HydroModX *pHMXParent )
{
	m_pHMXParent = pHMXParent;
}

void CHMXTU::SaveTermUnitData( unsigned char *pucTermUnitData, int iBufferSize )
{
	if( NULL == pucTermUnitData || iBufferSize <= 0 )
	{
		return;
	}

	m_iTermUnitDataSize = 0;

	if( NULL != m_pTermUnitData )
	{
		free( m_pTermUnitData );
		m_pTermUnitData = NULL;
	}

	m_pTermUnitData = ( unsigned char * )malloc( iBufferSize );

	if( NULL == m_pTermUnitData )
	{
		return;
	}

	memcpy( m_pTermUnitData, pucTermUnitData, iBufferSize );
	m_iTermUnitDataSize = iBufferSize;
}

//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define CHMXTU_VERSION	2
// Version 2: 2016-09-22: add 'm_pTermUnitData' buffer.
void CHMXTU::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CHMXTU_VERSION;
	WriteData<>( outf, Version );

	// Info.
	WriteDouble( outf, m_dDp );
	WriteDouble( outf, m_dQ );

	// Version 2.
	WriteData<>( outf, m_iTermUnitDataSize );

	if( m_iTermUnitDataSize > 0 )
	{
		// Write data.
		unsigned char *pData = m_pTermUnitData;

		for( int iLoop = 0; iLoop < m_iTermUnitDataSize; iLoop++ )
		{
			char cData = *pData;
			WriteData<>( outf, cData );
			pData++;
		}
	}
}

bool CHMXTU::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CHMXTU_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CHMXTU_VERSION )
	{
		return false;
	}

	// Info.
	m_dDp = ReadDouble( inpf );
	m_dQ = ReadDouble( inpf );

	if( Version < 2 )
	{
		return true;
	}

	// Version 2.
	if( NULL != m_pTermUnitData )
	{
		free( m_pTermUnitData );
		m_pTermUnitData = NULL;
	}

	inpf.read( (char *)&m_iTermUnitDataSize, sizeof( m_iTermUnitDataSize ) );

	if( m_iTermUnitDataSize > 0 )
	{
		m_pTermUnitData = ( unsigned char * )malloc( m_iTermUnitDataSize );

		if( NULL == m_pTermUnitData )
		{
			return false;
		}

		// Read data.
		unsigned char *pData = m_pTermUnitData;

		for( int iLoop = 0; iLoop < m_iTermUnitDataSize; iLoop++ )
		{
			char cData;
			inpf.read( (char *)&cData, sizeof( cData ) );
			*pData = cData;
			pData++;
		}
	}

	return true;
}

void CHMXTU::Copy( CHMXTU *pTo )
{
	// Set parent must be placed in first position because some functions below
	// call m_pParent.
	if( eHMXOwner == m_eOwner )
	{
		pTo->SetpParentHMX( m_pHMXParent );
	}

	pTo->SetDp( m_dDp );
	pTo->SetDesignFlow( m_dQ );

	// Version 2.
	pTo->SaveTermUnitData( m_pTermUnitData, m_iTermUnitDataSize );
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDS_LogDataX
//
///////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DATA( CDS_LogDataX )

////////////////////////////////////////////////////////////
//	Nested Class  -> CDS_LogDataX::CChan
////////////////////////////////////////////////////////////
CDS_LogDataX::CChan::CChan( CDS_LogDataX *pP )
{
	m_ChanType = ect_LastChannelType;					// Type of entry
	m_uKey = 0;
	m_pParent = pP;
}

void CDS_LogDataX::CChan::Copy( CChan *pChan )
{
	if( NULL != pChan )
	{
		pChan->SetChanType( GetChanType() );
		pChan->SetKey( GetKey() );
	}
}

#define CDS_LOGDATAX_CCHAN_VERSION	1
void CDS_LogDataX::CChan::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_LOGDATAX_CCHAN_VERSION;
	WriteData<>( outf, Version );
	
	// Info.
	WriteData<>( outf, m_ChanType );
	WriteData<>( outf, m_uKey );
}

bool CDS_LogDataX::CChan::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_LOGDATAX_CCHAN_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_LOGDATAX_CCHAN_VERSION )
	{
		return false;
	}

	// Info.
	inpf.read( (char *)&m_ChanType, sizeof( m_ChanType ) );
	inpf.read( (char *)&m_uKey, sizeof( m_uKey ) );
	
	return true;
}

////////////////////////////////////////////////////////////
//	Nested Class  -> CDS_LogDataX::CPhysChan
////////////////////////////////////////////////////////////
CDS_LogDataX::CPhysChan::CPhysChan( CDS_LogDataX *pP ): CChan( pP )
{
	m_uPos = 0;
	m_RawData.clear();							// Raw Datas
	m_SensorNum = 0;							// Sensor number into the sensor unit
	m_sOffset = 0;
}

void CDS_LogDataX::CPhysChan::SetPhysicalChan( unsigned char ucSensorNum, CDS_LogDataX::CLog::eChannelType ChanType )
{
	m_SensorNum = ucSensorNum;
	m_ChanType = ChanType;						// Type of entry
}

CDS_LogDataX::CLog::eChannelType CDS_LogDataX::CPhysChan::GetPhysicalChan( unsigned char *pucSensorNum )
{
	*pucSensorNum = m_SensorNum;
	return ( m_ChanType );
}

void CDS_LogDataX::CPhysChan::AddRawData( short usVal )
{
	if( m_RawData.size() <= m_uPos )
	{
		m_RawData.push_back( usVal );
	}
	else
	{
		m_RawData[m_uPos] = usVal;
	}

	m_uPos++;
	m_pParent->Modified();
}

bool CDS_LogDataX::CPhysChan::GetRawData( unsigned uIndex, int &RawData )
{
	if( uIndex >= m_uPos )
	{
		return false;
	}

	RawData = ( int )m_RawData[uIndex];

	if( CEquation::EqT_Ntc == m_Equation.GetEquationType() && RawData < 0 )
	{
		RawData += 65536;
	}
	else if( CEquation::EqT_Linear_Unsigned == m_Equation.GetEquationType() && RawData < 0 )
	{
		RawData += 65536;
	}

	return true;
}

void CDS_LogDataX::CPhysChan::AddValidationData( unsigned char ucValue )
{
	if( m_ValidationData.size() <= m_uPos )
	{
		m_ValidationData.push_back( ucValue );
	}
	else
	{
		m_ValidationData[m_uPos] = ucValue;
	}

	m_pParent->Modified();
}

bool CDS_LogDataX::CPhysChan::GetValidationData( unsigned uIndex, unsigned char &ucValidationData )
{
	if( uIndex >= m_uPos )
	{
		return false;
	}

	ucValidationData = ( unsigned char )m_ValidationData[uIndex];
	return true;
}


double CDS_LogDataX::CPhysChan::GetOffset()
{
	if( 0.0 == m_sOffset )
	{
		return 0.0;
	}

	return m_Equation.Solve( m_sOffset );
}

bool CDS_LogDataX::CPhysChan::GetData( unsigned uIndex, double &dValue )
{
	int iRawData;
	dValue = 0.0;

	if( false == GetRawData( uIndex, iRawData ) )
	{
		return false;
	}

#ifndef TACBX
	if( true == TASApp.IsLogRawData() )
	{
		if( CLog::ect_Temp2 == GetChanType() || CLog::ect_Temp1 == GetChanType() || CLog::ect_Dp == GetChanType() )
		{
			dValue = iRawData;
			return true;
		}
	}
#endif

	// Be carefull offset should be discounted in Dp and not in Raw; equation takes already count of an offset
	if( CEquation::EqT_Ntc == m_Equation.GetEquationType() )
	{
		if( 0 == iRawData )		// Negatif Overflow (below -20)
		{
			dValue = -25.0;			// TODO should return -273 but need to properly manage data displaying
			return true;
		}
	}
	else if( CEquation::EqT_Linear_Unsigned != m_Equation.GetEquationType() )
	{
		// DTS && Dp (not for Dps-Visio)
		if( 0x8000 == iRawData )	// Overflow
		{
			iRawData = 0x7FFF;
		}
	}

	dValue = m_Equation.Solve( ( double )iRawData );

	if( CLog::ect_Dp == GetChanType() )
	{
		dValue -= GetOffset();
		
		// HYS-1017: Allow negative Dp for TA-Scope log.
		// dVal = max( 0, dVal );
	}

	return true;
}

bool CDS_LogDataX::CPhysChan::ScanForErrors()	// Return true of error found
{
	unsigned char ucVal;
	unsigned uArraySize = GetDataArraySize();

	for( unsigned uiIndex = 0; uiIndex < uArraySize; uiIndex++ )
	{
		GetValidationData( uiIndex, ucVal );		// Validation code is 0 if no error

		if( ucVal != 0 )
		{
			return true;
		}
	}

	return false;
}

bool CDS_LogDataX::CPhysChan::GetMinValue( double *pdMinValue, unsigned *puIndex )
{
	if( NULL == pdMinValue )
	{
		return false;
	}

	int iMinValue = INT_MAX;
	int iValue;
	unsigned uiMinIndex;
	unsigned uArraySize = GetDataArraySize();

	for( unsigned uiIndex = 0; uiIndex < uArraySize; uiIndex++ )
	{
		GetRawData( uiIndex, iValue );

		// In case of NTC reverse test
		if( CEquation::EqT_Ntc == m_Equation.GetEquationType() )
		{
			if( iValue == 0 )		//RawData is invalid skip this value
			{
				continue;
			}

			iValue = 65536 - iValue;
		}

		if( iMinValue > iValue )
		{
			iMinValue = iValue;
			uiMinIndex = uiIndex;
		}
	}

	if( iMinValue == INT_MAX )
	{
		return false;
	}

	GetData( uiMinIndex, *pdMinValue );

	if( puIndex )
	{
		*puIndex = uiMinIndex;
	}

	return true;
}

bool CDS_LogDataX::CPhysChan::GetMaxValue( double *pdMaxValue, unsigned *puIndex )
{
	if( NULL == pdMaxValue )
	{
		return false;
	}

	int iMaxValue = INT_MIN;
	int iValue;
	unsigned uiMaxIndex;
	unsigned uArraySize = GetDataArraySize();

	for( unsigned uiIndex = 0; uiIndex < uArraySize; uiIndex++ )
	{
		GetRawData( uiIndex, iValue );

		// In case of NTC reverse test
		if( CEquation::EqT_Ntc == m_Equation.GetEquationType() )
		{
			if( iValue == 0 )		//RawData is invalid skip this value
			{
				continue;
			}

			iValue = 65536 - iValue;
		}

		if( iMaxValue < iValue )
		{
			iMaxValue = iValue;
			uiMaxIndex = uiIndex;
		}
	}

	if( iMaxValue == INT_MIN )
	{
		return false;
	}

	GetData( uiMaxIndex, *pdMaxValue );

	if( NULL != puIndex )
	{
		*puIndex = uiMaxIndex;
	}

	return true;
}

bool CDS_LogDataX::CPhysChan::GetMinMaxValues( double *pdMinValue, double *pdMaxValue, unsigned *puMinIndex, unsigned *puMaxIndex )
{
	if( NULL == pdMinValue || NULL == pdMaxValue )
	{
		return false;
	}

	int iMinValue = INT_MAX;
	int iMaxValue = INT_MIN;
	int iValue;
	unsigned uiMinIndex;
	unsigned uiMaxIndex;
	unsigned uArraySize = GetDataArraySize();

	for( unsigned uiIndex = 0; uiIndex < uArraySize; uiIndex++ )
	{
		GetRawData( uiIndex, iValue );

		// In case of NTC reverse test
		if( CEquation::EqT_Ntc == m_Equation.GetEquationType() )
		{
			if( iValue == 0 )		//RawData is invalid skip this value
			{
				continue;
			}

			iValue = 65536 - iValue;
		}

		if( iMinValue > iValue )
		{
			iMinValue = iValue;
			uiMinIndex = uiIndex;
		}

		if( iMaxValue < iValue )
		{
			iMaxValue = iValue;
			uiMaxIndex = uiIndex;
		}
	}

	if( iMinValue == INT_MAX || iMaxValue == INT_MIN )
	{
		return false;
	}

	GetData( uiMinIndex, *pdMinValue );

	if( NULL != puMinIndex )
	{
		*puMinIndex = uiMinIndex;
	}

	GetData( uiMaxIndex, *pdMaxValue );

	if( NULL != puMaxIndex )
	{
		*puMaxIndex = uiMaxIndex;
	}

	return true;
}

void CDS_LogDataX::CPhysChan::Copy( CPhysChan *pPhysChan )
{
	if( NULL != pPhysChan )
	{
		CDS_LogDataX::CChan::Copy( static_cast<CChan *>( pPhysChan ) );
		pPhysChan->SetSensorNumber( m_SensorNum );
		pPhysChan->SetOffset( GetRawOffset() );
		m_Equation.Copy( &pPhysChan->m_Equation );

		// Raw data.
		for( unsigned i = 0; i < m_uPos; i++ )
		{
			int iRawData;
			GetRawData( i, iRawData );
			pPhysChan->AddRawData( ( short )iRawData );
		}

		// Validation data.
		for( unsigned i = 0; i < m_uPos; i++ )
		{
			unsigned char ucValidationData;
			GetValidationData( i, ucValidationData );
			pPhysChan->AddValidationData( ( unsigned char )ucValidationData );
		}
	}
}

#define CDS_LOGDATAX_CPHYSCHAN_VERSION	2
void CDS_LogDataX::CPhysChan::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_LOGDATAX_CPHYSCHAN_VERSION;
	WriteData<>( outf, Version );
	
	// Base.
	CChan::Write( outf );
	
	// Info.
	WriteData<>( outf, m_uPos );
	WriteData<>( outf, m_SensorNum );
	WriteData<>( outf, m_sOffset );
	m_Equation.Write( outf );
	int iSize = m_RawData.size();
	WriteData<>( outf, iSize );

	for( unsigned i = 0; i < m_uPos; i++ )
	{
		WriteData<>( outf, m_RawData[i] );
	}

	// From Version 2: Validation data.
	for( unsigned i = 0; i < m_uPos; i++ )
	{
		WriteData<>( outf, m_ValidationData[i] );
	}
}

bool CDS_LogDataX::CPhysChan::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_LOGDATAX_CPHYSCHAN_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_LOGDATAX_CPHYSCHAN_VERSION )
	{
		return false;
	}

	// Base.
	if( false == CChan::Read( inpf ) )
	{
		return false;
	}

	// Info.
	inpf.read( (char *)&m_uPos, sizeof( m_uPos ) );
	inpf.read( (char *)&m_SensorNum, sizeof( m_SensorNum ) );
	inpf.read( (char *)&m_sOffset, sizeof( m_sOffset ) );
	m_Equation.Read( inpf );
	
	int iSize = 0;
	inpf.read( (char *)&iSize, sizeof( iSize ) );
	m_RawData.resize( iSize );

	for( unsigned i = 0; i < m_uPos; i++ )
	{
		unsigned short usRD = 0;
		inpf.read( (char *)&usRD, sizeof( usRD ) );
		m_RawData[i] = usRD;
	}

	// From Version 2: validation data
	m_ValidationData.resize( iSize );

	if( Version >= 2 )
	{
		for( unsigned i = 0; i < m_uPos; i++ )
		{
			unsigned char ucVD = 0;
			inpf.read( (char *)&ucVD, sizeof( ucVD ) );
			m_ValidationData[i] = ucVD;
		}
	}
	else
	{
		// Only for Dp, check raw value != -32768
		if( CLog::ect_Dp == GetChanType() )
		{
			for( unsigned i = 0; i < m_uPos; i++ )
			{
				if( m_RawData[i] == -32768 )
				{
					m_ValidationData[i] = 1;
				}
				else
				{
					m_ValidationData[i] = 0;
				}
			}
		}
	}

	return true;
}

////////////////////////////////////////////////////////////
//	Nested Class  -> CDS_LogDataX::CLogChan
////////////////////////////////////////////////////////////
CDS_LogDataX::CLogChan::CLogChan( CDS_LogDataX *pP )
	: CChan( pP )
{
}

unsigned CDS_LogDataX::CLogChan::AttachPhysChan( unsigned uPhysChanNum )
{
	m_PhysChanNum.push_back( uPhysChanNum );
	return ( m_PhysChanNum.size() - 1 );
}

int CDS_LogDataX::CLogChan::GetPhysicalChanArray( std::vector<unsigned> *pAr )
{
	unsigned uSize = m_PhysChanNum.size();

	if( pAr->size() < uSize )
	{
		pAr->resize( uSize );
	}

	std::copy( m_PhysChanNum.begin(), m_PhysChanNum.end(), pAr->begin() );
	return m_PhysChanNum.size();
}

bool CDS_LogDataX::CLogChan::GetDeltaTData( unsigned uIndex, double &dVal )
{
	dVal = 0.0;
	double dT[2];

	if( m_PhysChanNum.size() < 2 )
	{
		return false;    //number of physical channel doesn't match
	}

	int j = 0;

	for( unsigned uEco = ect_Temp1; uEco <= ect_Temp2; uEco++ )
	{
		CPhysChan *pPhysChan = dynamic_cast<CPhysChan *>( m_pParent->GetpChannel( uEco ) );

		if( NULL == pPhysChan )
		{
			return false;    // Something wrong!
		}

		if( pPhysChan->GetChanType() != CLog::ect_Temp1 && pPhysChan->GetChanType() != CLog::ect_Temp2 )
		{
			return false;    // Not correct type
		}

		if( false == pPhysChan->GetData( uIndex, dT[j] ) )
		{
			return false;    // Incorrect Index?
		}

		j++;
	}

	dVal = fabs( dT[1] - dT[0] );
	return true;
}

bool CDS_LogDataX::CLogChan::GetFlowData( unsigned uIndex, double &dVal )
{
	double dDp = 0.0;
	CPhysChan *pPhysChan = dynamic_cast<CPhysChan *>( m_pParent->GetpChannel( ect_Dp ) );

	if( NULL == pPhysChan )
	{
		return false;    // Something wrong!
	}

	if( CLog::ect_Dp != pPhysChan->GetChanType() )
	{
		return false;    // Not correct type
	}

	if( false == pPhysChan->GetData( uIndex, dDp ) )
	{
		return false;    // Incorrect Index?
	}

	if( NULL == GetpTADB() )
	{
		return false;
	}

	IDPTR idptr = m_pParent->GetValveIDPtr();

	if( NULL == m_pParent->GetWaterChar( uIndex ) )
	{
		return false;
	}

	double dKv = 0.0;
	double dRho = m_pParent->GetWaterChar()->GetDens();
	double dNu = m_pParent->GetWaterChar()->GetKinVisc();

	if( 0.0 == dRho )
	{
		return false;
	}

	if( true == m_pParent->IsTAMode() && NULL != dynamic_cast<CDB_TAProduct *>( idptr.MP ) )
	{
		CDB_TAProduct *pTAP = static_cast<CDB_TAProduct *>( idptr.MP );

		if( true == pTAP->IsKvSignalEquipped() )
		{
			dKv = pTAP->GetKvSignal();
		}
		else
		{
			double dh = max( m_pParent->GetOpening(), 0.0 );

			if( 0.0 == dh )
			{
				return false;
			}

			CDB_ValveCharacteristic *pValveCharacteristic = pTAP->GetValveCharacteristic();

			if( NULL != pValveCharacteristic )
			{
				double dOpeningMax = pValveCharacteristic->GetOpeningMax();

				if( -1.0 == dOpeningMax )
				{
					return false;
				}

				dh = min( dOpeningMax, dh );
				dVal = 0.0;

				if( true == pValveCharacteristic->IsViscCorrExist() )
				{
					// SPTP exist use the logged temperature to correct fluid density and viscosity
					CWaterChar *pWC = m_pParent->GetWaterChar( uIndex );

					if( NULL != pWC )
					{
						dRho = pWC->GetDens();
						dNu = pWC->GetKinVisc();
					}
				}

				if( true == pValveCharacteristic->GetValveQ( &dVal, dDp, dh, dRho, dNu ) )
				{
					return true;
				}
				else
				{
					return false;
				}
			}
		}
	}
	else	// Valve defined on his Kv
	{
		dKv = m_pParent->GetKv();
	}

	if( dKv <= 0.0 )
	{
		return false;
	}

	if( dDp < 0.0 )
	{
		return false;
	}

	dVal = CalcqT( dKv, dDp, dRho );
	return true;
}

bool CDS_LogDataX::CLogChan::GetPowerData( unsigned uIndex, double &dVal )
{
	dVal = 0.0;
	double dQ, dDT;
	dQ = dDT = 0.0;

	if( false == GetDeltaTData( uIndex, dDT ) )
	{
		return false;
	}

	if( m_PhysChanNum.size() < 3 )
	{
		return false;    //number of physical channel doesn't match
	}

	CLogChan *pLogChan = dynamic_cast<CLogChan *>( m_pParent->GetpChannel( ect_Flow ) );

	if(  NULL == pLogChan )
	{
		return false;    // Something wrong!
	}

	if( pLogChan->GetChanType() != CLog::ect_Flow )
	{
		return false;    // Not correct type
	}

	if( false == pLogChan->GetData( uIndex, dQ ) )
	{
		return false;    // Incorrect Index?
	}

	double dRho = m_pParent->GetWaterChar()->GetDens();
	double dCp	= m_pParent->GetWaterChar()->GetSpecifHeat();
	dVal = CalcP( dQ, dDT, dRho, dCp );
	return true;
}

unsigned CDS_LogDataX::CLogChan::GetDataArraySize()
{
	std::vector<unsigned> Ar;
	GetPhysicalChanArray( &Ar );

	if( 0 == Ar.size() )
	{
		return 0;
	}

	return ( m_pParent->GetpChannel( Ar[0] )->GetDataArraySize() );
}

// Retrieve a value and compute it (data in array are in a raw mode!!).
bool CDS_LogDataX::CLogChan::GetData( unsigned uIndex, double &dVal )
{
	dVal = 0.0;

	// Verify each associated physical channel.
	for( unsigned i = 0; i < m_PhysChanNum.size(); i++ )
	{
		CChan *pChan = m_pParent->GetpChannel( m_PhysChanNum[i] );

		if( NULL == pChan )
		{
			return false;
		}
	}

	switch( GetChanType() )
	{
		case CLog::ect_DeltaT:
			return GetDeltaTData( uIndex, dVal );
			break;

		case CLog::ect_Power:
			return GetPowerData( uIndex, dVal );
			break;

		case CLog::ect_Flow:
			return GetFlowData( uIndex, dVal );
			break;

		default:
			break;
	}

	return false;
}

// Retrieve the minimun value of a log.
bool CDS_LogDataX::CLogChan::GetMinValue( double *pdMinValue, unsigned *puIndex )
{
	if( NULL == pdMinValue )
	{
		return false;
	}

	unsigned uiMinIndex;
	unsigned uArraySize = GetDataArraySize();

	switch( m_ChanType )
	{
		// ect_Dp, ect_Temp1, ect_Temp2 & ect_Flow
		// These data are linear, we can determine min value directly in array!
		case ect_Dp:
		case ect_Temp1:
		case ect_Temp2:
		{
			// Retrieve first physical channel (no matters channel type, we need only to access to raw datas).
			// Pay attention: don't use 'm_pParent->GetFirstpChan()' because this function will change iteration
			// if already running!!!
			// CPhysChan *pPhysChan = dynamic_cast<CPhysChan *>( m_pParent->GetFirstpChan() );
			std::map<unsigned, CChan *> *pChannelList = m_pParent->GetChannelList();

			if( NULL == pChannelList || true == pChannelList->empty() )
			{
				return false;
			}

			CPhysChan *pPhysChan = dynamic_cast<CPhysChan *>( pChannelList->begin()->second );

			if( !pPhysChan )
			{
				return false;
			}

			if( false == pPhysChan->GetMinValue( pdMinValue, puIndex ) )
			{
				return false;
			}

			break;
		}

		case ect_DeltaT:
		{
			// To determine minimum value, we have to do difference between two channels.
			CPhysChan *pPhysChanT1 = dynamic_cast<CPhysChan *>( m_pParent->GetpChannel( ect_Temp1 ) );

			if( NULL == pPhysChanT1 )
			{
				return false;
			}

			CPhysChan *pPhysChanT2 = dynamic_cast<CPhysChan *>( m_pParent->GetpChannel( ect_Temp2 ) );

			if( NULL == pPhysChanT2 )
			{
				return false;
			}

			double dValT1, dValT2;
			double dMinValue = DBL_MAX;

			for( unsigned uiIndex = 0; uiIndex < uArraySize; uiIndex++ )
			{
				if( false == pPhysChanT1->GetData( uiIndex, dValT1 ) )
				{
					return false;
				}

				if( false == pPhysChanT2->GetData( uiIndex, dValT2 ) )
				{
					return false;    // Incorrect Index?
				}

				double dVal = fabs( dValT1 - dValT2 );

				if( dMinValue > dVal )
				{
					dMinValue = dVal;
					uiMinIndex = uiIndex;
				}
			}

			if( DBL_MAX == dMinValue )
			{
				return false;
			}

			break;
		}

		case ect_Flow:
		{
			CPhysChan *pPhysChanDp = dynamic_cast<CPhysChan *>( m_pParent->GetpChannel( ect_Dp ) );

			if( NULL == pPhysChanDp )
			{
				return false;
			}

			double dMinValue = DBL_MAX;

			for( unsigned uiIndex = 0; uiIndex < uArraySize; uiIndex++ )
			{
				double dValP = 0.0;

				if( false == pPhysChanDp->GetData( uiIndex, dValP ) )
				{
					return false;
				}

				// Flow is % to sqrt(Dp)
				dValP = sqrt( dValP );

				if( dMinValue > dValP )
				{
					dMinValue = dValP;
					uiMinIndex = uiIndex;
				}
			}

			if( DBL_MAX == dMinValue )
			{
				return false;
			}

			break;
		}
		break;

		case ect_Power:
		{
			// Case of power. We need to compute abs(T1-T2) * Dp to determine which index will be
			// used to compute minimum value.
			// To determine minimum value, we have to do difference between two channels.
			CPhysChan *pPhysChanT1 = dynamic_cast<CPhysChan *>( m_pParent->GetpChannel( ect_Temp1 ) );

			if( NULL == pPhysChanT1 )
			{
				return false;
			}

			CPhysChan *pPhysChanT2 = dynamic_cast<CPhysChan *>( m_pParent->GetpChannel( ect_Temp2 ) );

			if( NULL == pPhysChanT2 )
			{
				return false;
			}

			CPhysChan *pPhysChanDp = dynamic_cast<CPhysChan *>( m_pParent->GetpChannel( ect_Dp ) );

			if( NULL == pPhysChanDp )
			{
				return false;
			}

			double dValT1, dValT2;
			double dMinValue = DBL_MAX;

			for( unsigned uiIndex = 0; uiIndex < uArraySize; uiIndex++ )
			{
				if( false == pPhysChanT1->GetData( uiIndex, dValT1 ) )
				{
					return false;
				}

				if( false == pPhysChanT2->GetData( uiIndex, dValT2 ) )
				{
					return false;    // Incorrect Index?
				}

				double dValP = 0.0;

				if( false == pPhysChanDp->GetData( uiIndex, dValP ) )
				{
					return false;
				}

				// Power is % to dT and sqrt(Dp)
				dValP = sqrt( dValP );
				dValP *= fabs( dValT1 - dValT2 );

				if( dMinValue > dValP )
				{
					dMinValue = dValP;
					uiMinIndex = uiIndex;
				}
			}

			if( DBL_MAX == dMinValue )
			{
				return false;
			}

			break;
		}

		default:
			return false;
			break;
	}

	// Compute value.
	double dValue;
	GetData( uiMinIndex, dValue );
	*pdMinValue = dValue;

	if( NULL != puIndex )
	{
		*puIndex = uiMinIndex;
	}

	return true;
}

bool CDS_LogDataX::CLogChan::GetMaxValue( double *pdMaxValue, unsigned *puIndex )
{
	if( NULL == pdMaxValue || GetNumberOfPhysChan() == 0 )
	{
		return false;
	}

	unsigned uiMaxIndex;
	unsigned uArraySize = GetDataArraySize();

	switch( m_ChanType )
	{
		// ect_Dp, ect_Temp1, ect_Temp2 & ect_Flow
		// These data are linear, we can determine min value directly in array!
		case ect_Dp:
		case ect_Temp1:
		case ect_Temp2:
		{
			// Retrieve first physical channel (no matters channel type, we need only to access to raw datas).
			// Pay attention: don't use 'm_pParent->GetFirstpChan()' because this function will change iteration
			// if already running!!!
			// CPhysChan *pPhysChan = dynamic_cast<CPhysChan *>( m_pParent->GetFirstpChan() );
			std::map<unsigned, CChan *> *pChannelList = m_pParent->GetChannelList();

			if( NULL == pChannelList )
			{
				return false;
			}

			CPhysChan *pPhysChan = dynamic_cast<CPhysChan *>( pChannelList->begin()->second );

			if( NULL == pPhysChan )
			{
				return false;
			}

			double dMaxValue = DBL_MIN;

			if( false == pPhysChan->GetMaxValue( &dMaxValue, &uiMaxIndex ) )
			{
				return false;
			}

			break;
		}

		case ect_DeltaT:
		{
			// To determine minimum value, we have to do difference between two channels.
			CPhysChan *pPhysChanT1 = dynamic_cast<CPhysChan *>( m_pParent->GetpChannel( ect_Temp1 ) );

			if( NULL == pPhysChanT1 )
			{
				return false;
			}

			CPhysChan *pPhysChanT2 = dynamic_cast<CPhysChan *>( m_pParent->GetpChannel( ect_Temp2 ) );

			if( NULL == pPhysChanT2 )
			{
				return false;
			}

			double dValT1;
			double dValT2;
			double dMaxValue = DBL_MIN;

			for( unsigned uiIndex = 0; uiIndex < uArraySize; uiIndex++ )
			{
				if( false == pPhysChanT1->GetData( uiIndex, dValT1 ) )
				{
					return false;
				}

				if( false == pPhysChanT2->GetData( uiIndex, dValT2 ) )
				{
					return false;    // Incorrect Index?
				}

				double dVal = fabs( dValT1 - dValT2 );

				if( dMaxValue < dVal )
				{
					dMaxValue = dVal;
					uiMaxIndex = uiIndex;
				}
			}

			if( DBL_MIN == dMaxValue )
			{
				return false;
			}

			break;
		}

		case ect_Flow:
		{
			CPhysChan *pPhysChanDp = dynamic_cast<CPhysChan *>( m_pParent->GetpChannel( ect_Dp ) );

			if( NULL == pPhysChanDp )
			{
				return false;
			}

			double dMaxValue = DBL_MIN;

			for( unsigned uiIndex = 0; uiIndex < uArraySize; uiIndex++ )
			{
				double dValP = 0.0;

				if( false == pPhysChanDp->GetData( uiIndex, dValP ) )
				{
					return false;
				}

				// Power is % to dT and sqrt(Dp)
				dValP = sqrt( dValP );

				if( dMaxValue < dValP )
				{
					dMaxValue = dValP;
					uiMaxIndex = uiIndex;
				}
			}

			if( DBL_MIN == dMaxValue )
			{
				return false;
			}

			break;
		}

		case ect_Power:
		{
			// We need to compute abs(T1-T2) * Dp to determine which index will be
			// used to compute minimum value.
			// To determine minimum value, we have to do difference between two channels.
			CPhysChan *pPhysChanT1 = dynamic_cast<CPhysChan *>( m_pParent->GetpChannel( ect_Temp1 ) );

			if( NULL == pPhysChanT1 )
			{
				return false;
			}

			CPhysChan *pPhysChanT2 = dynamic_cast<CPhysChan *>( m_pParent->GetpChannel( ect_Temp2 ) );

			if( NULL == pPhysChanT2 )
			{
				return false;
			}

			CPhysChan *pPhysChanDp = dynamic_cast<CPhysChan *>( m_pParent->GetpChannel( ect_Dp ) );

			if( NULL == pPhysChanDp )
			{
				return false;
			}

			double dValT1;
			double dValT2;
			double dMaxValue = DBL_MIN;

			for( unsigned uiIndex = 0; uiIndex < uArraySize; uiIndex++ )
			{
				if( false == pPhysChanT1->GetData( uiIndex, dValT1 ) )
				{
					return false;
				}

				if( false == pPhysChanT2->GetData( uiIndex, dValT2 ) )
				{
					return false;    // Incorrect Index?
				}

				double dValP = 0.0;

				if( false == pPhysChanDp->GetData( uiIndex, dValP ) )
				{
					return false;
				}

				// Power is % to dT and sqrt(Dp)

				dValP = sqrt( dValP );
				dValP *= fabs( dValT1 - dValT2 );

				if( dMaxValue < dValP )
				{
					dMaxValue = dValP;
					uiMaxIndex = uiIndex;
				}
			}

			if( DBL_MIN == dMaxValue )
			{
				return false;
			}

			break;
		}

		default:
			return false;
			break;
	}

	// Compute value.
	double dValue;
	GetData( uiMaxIndex, dValue );
	*pdMaxValue = dValue;

	if( NULL != puIndex )
	{
		*puIndex = uiMaxIndex;
	}

	return true;
}

bool CDS_LogDataX::CLogChan::GetMinMaxValues( double *pdMinValue, double *pdMaxValue, unsigned *puMinIndex, unsigned *puMaxIndex )
{
	if( NULL == pdMinValue || NULL == pdMaxValue )
	{
		return false;
	}

	double dValue;
	unsigned iIndex;

	if( false == GetMinValue( &dValue, &iIndex ) )
	{
		return false;
	}

	*pdMinValue = dValue;

	if( puMinIndex )
	{
		*puMinIndex = iIndex;
	}

	if( false == GetMaxValue( &dValue, &iIndex ) )
	{
		return false;
	}

	*pdMaxValue = dValue;

	if( NULL != puMaxIndex )
	{
		*puMaxIndex = iIndex;
	}

	return true;
}

void CDS_LogDataX::CLogChan::Copy( CLogChan *pLogChan )
{
	if( NULL != pLogChan )
	{
		CDS_LogDataX::CChan::Copy( static_cast<CChan *>( pLogChan ) );
		unsigned int size = GetNumberOfPhysChan();

		for( unsigned int i = 0; i < size; i++ )
		{
			pLogChan->AttachPhysChan( m_PhysChanNum[i] );
		}
	}
}

#define CDS_LOGDATAX_CLOGCHAN_VERSION	1
void CDS_LogDataX::CLogChan::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_LOGDATAX_CLOGCHAN_VERSION;
	WriteData<>( outf, Version );

	// Base.
	CChan::Write( outf );

	int size = m_PhysChanNum.size();
	WriteData<>( outf, size );

	for( int i = 0; i < size; i++ )
	{
		// HYS-916: Since HySelect v4.4.5.3 this line has been changed from: 'outf.write( (char *)&m_PhysChanNum[i], sizeof( unsigned short ) );'
		// We before force the size to 'unsigned short'. Now it is no more the case and the vector contains 'unsigned' type.
		// That means that since 4.4.5.3 we wrote 32bits instead of 16bits.
		// To gain space in TA-Scope we need to save in 16 bits.
		WriteData<>( outf, (unsigned short)m_PhysChanNum[i] );
	}
}

bool CDS_LogDataX::CLogChan::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_LOGDATAX_CLOGCHAN_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_LOGDATAX_CLOGCHAN_VERSION )
	{
		return false;
	}

	// Base.
	if( false == CChan::Read( inpf ) )
	{
		return false;
	}

	int iSize = 0;
	inpf.read( (char *)&iSize, sizeof( iSize ) );
	m_PhysChanNum.resize( iSize );

	// HYS-916: see remark in the 'Write' method above.
	// For the read method, we need to read 32 bits between HySelect version 4.4.5.3 and 4.4.5.8 included.
	// The TA-Scope version corresponding to the HySelect version 4.4.5.3 is the 2.1.0.3.
#ifndef TACBX
	CTADataStructX *pclTADataStructX = dynamic_cast<CTADataStructX *>( m_pParent->GetIDPtr().DB );
	CDatastruct *pclDatastruct = NULL;
	vector<CString> vectVersionList;

	if( NULL == pclTADataStructX )
	{
		pclDatastruct = dynamic_cast<CDatastruct *>( m_pParent->GetIDPtr().DB );
	
		if( NULL == pclDatastruct )
		{
			ASSERTA_RETURN( false );
		}
		
		vectVersionList.push_back( _T("4.4.5.3") );
		vectVersionList.push_back( _T("4.4.5.4") );
		vectVersionList.push_back( _T("4.4.5.5") );
		vectVersionList.push_back( _T("4.4.5.6") );
		vectVersionList.push_back( _T("4.4.5.7") );
		vectVersionList.push_back( _T("4.4.5.8") );
	}

	if( NULL != pclTADataStructX )
	{
		if( 2103 == pclTADataStructX->GetTAScopeVersion() )
		{
			for( int i = 0; i < iSize; i++ )
			{
				unsigned int uiRD = 0;
				inpf.read( (char *)&uiRD, sizeof( uiRD ) );
				m_PhysChanNum[i] = uiRD;
			}
		}
		else
		{
			for( int i = 0; i < iSize; i++ )
			{
				unsigned short usRD = 0;
				inpf.read( (char *)&usRD, sizeof( usRD ) );
				m_PhysChanNum[i] = usRD;
			}
		}
	}
	else if( NULL != pclDatastruct )
	{
		CDBFileHeader *pclDBFileHeader = pclDatastruct->GetDBFileHeader();
		ASSERT( NULL != pclDBFileHeader );

		vector<CString>::iterator it = find( vectVersionList.begin(), vectVersionList.end(), pclDBFileHeader->GetAppVersionStr() );
		
		if( it != vectVersionList.end() )
		{
			for( int i = 0; i < iSize; i++ )
			{
				unsigned int uiRD = 0;
				inpf.read( (char *)&uiRD, sizeof( uiRD ) );
				m_PhysChanNum[i] = uiRD;
			}
		}
		else
		{
			for( int i = 0; i < iSize; i++ )
			{
				unsigned short usRD = 0;
				inpf.read( (char *)&usRD, sizeof( usRD ) );
				m_PhysChanNum[i] = usRD;
			}
		}
	}

#else
	if( 2103 == CBXDataStruct::GetpDS( false )->GetTAScopeVersion() )
	{
		for( int i = 0; i < iSize; i++ )
		{
			unsigned int uiRD = 0;
			inpf.read( (char *)&uiRD, sizeof( uiRD ) );
			m_PhysChanNum[i] = uiRD;
		}
	}
	else
	{
		for( int i = 0; i < iSize; i++ )
		{
			unsigned short usRD = 0;
			inpf.read( (char *)&usRD, sizeof( usRD ) );
			m_PhysChanNum[i] = usRD;
		}
	}
#endif // TACBX

	return true;
}
////////////////////////////////////////////////////////////
//	Main Class  -> CDS_LogDataX
////////////////////////////////////////////////////////////
CDS_LogDataX::CDS_LogDataX( CDataBase *pDataBase, LPCTSTR ID )
	: CLog( pDataBase, ID )
{
	//m_uKey = CChan::LastChannelOrder;
	m_SensorMAC = 0;		// Sensor Identificator (MAC)
	m_LogType = LOGTYPE_UNDEF;
	m_It = m_LogChan.begin();
	m_StartingDateTime = -1;						// Measurment Starting Date-Time
	m_MeasuringStep = 0;						// Measuring step in seconds
	m_ucLogStatus = 0;
	m_SampleNumber = 0;
	m_bTAMode = true;
	m_ValveIDPtr = _NULL_IDPTR;					// In case of Q/Dp measurment Valve IDPtr in TADB
	m_dOpening = 0;								// Valve Opening
	m_dKv = 0;									// KV value for non TAValve
	m_Name[0] = '\0';
	// Variables needed for storing/retrieving tsp information
	m_HMID[0] = _T('\0');
	m_DSUID[0] = _T('\0');
	m_PlantName[0] = '\0';
	m_ModuleName[0] = '\0';
	m_ValvePosition = 1;												// Circuit position in his module
	m_ValveLoc = CDS_HydroModX::InPrimary;		// valve localisation in his circuit
	m_BalType = CDS_HydroModX::BV;				// Type of Balancing
	m_pSPTP = NULL;
	#ifndef TACBX
	m_StartDate = NULL;
	m_bStartDate = false;

	for( int i = 0; i < MAXLOGGEDCOLUMN; i++ )
	{
		m_Pos[i] = 0;
	}

	#endif
}

CDS_LogDataX::~CDS_LogDataX()
{
	ClearLogChan();
}

void CDS_LogDataX::SetWaterChar( CWaterChar *pWC )
{
	m_WaterChar = *pWC;
	m_WaterCharComputed = *pWC;
	m_pSPTP = NULL;
	Modified();
}

CWaterChar *CDS_LogDataX::GetWaterChar( int iIndex )
{
	if( NULL == m_pSPTP )
	{
		if( NULL != ( m_pSPTP = static_cast<CPhysChan *>( GetpChannel( CLog::ect_Temp1 ) ) ) )
		{
			if( CEquation::est_DPTN != m_pSPTP->GetpEquation()->GetSensorType() )
			{
				m_pSPTP = static_cast<CPhysChan *>( GetpChannel( CLog::ect_Temp2 ) );
			}
		}
		else
		{
			m_pSPTP = static_cast<CPhysChan *>( GetpChannel( CLog::ect_Temp2 ) );
		}

		if( NULL != m_pSPTP )
		{
			if( CEquation::est_DPTN != m_pSPTP->GetpEquation()->GetSensorType() )
			{
				m_pSPTP = NULL;
			}
		}
	}

	if( NULL == m_pSPTP || iIndex < 0 )
	{
		return &m_WaterChar;
	}

	double dTemp = 0.0;

	if( true != m_pSPTP->GetData( ( unsigned int )iIndex, dTemp ) )
	{
		return &m_WaterChar;
	}

	// Skip water char computing if the temperature didn't change.
	if( dTemp == m_WaterCharComputed.GetTemp() )
	{
		return &m_WaterCharComputed;
	}

	// Temperature differ, recompute a new WaterChar.
	// Sanity
	if( dTemp <= m_WaterCharComputed.GetTfreez() )
	{
		return &m_WaterCharComputed;
	}

	CWaterChar *pWC = &m_WaterCharComputed;
	CDB_StringID *pstrID = dynamic_cast<CDB_StringID *>( GetpTADB()->Get( pWC->GetAdditID() ).MP );
	CDB_AdditCharacteristic *pAdditChar =  dynamic_cast<CDB_AdditCharacteristic *>( GetpTADB()->Get( pstrID->GetIDstr() ).MP );

	if( NULL != pAdditChar )
	{
		double dDens = pWC->GetDens();
		double dKinVisc = pWC->GetKinVisc();
		double dSpecifHeat = pWC->GetSpecifHeat();
		double dVaporPressure = 0;

		enum SurfValReturn_enum SVReturn = pAdditChar->GetAdditProp( pWC->GetPcWeight(), dTemp, &dDens, &dKinVisc, &dSpecifHeat, &dVaporPressure );

		switch( SVReturn )
		{
			case SV_OK:
				pWC->SetTemp( dTemp );
				pWC->SetDens( dDens );
				pWC->SetKinVisc( dKinVisc );
				pWC->SetSpecifHeat( dSpecifHeat );
				break;

			case SV_OUTOFXRANGE: // Additive percentage above max. value
			case SV_OUTOFYRANGE: // Temperature above max. value
			default:
				break;
		}
	}

	return &m_WaterCharComputed;
}

#ifndef TACBX
LPCTSTR CDS_LogDataX::GetSite()
{
	return GetPlantName();
}

LPCTSTR CDS_LogDataX::GetRef()
{
	return GetModuleName();
}

CString CDS_LogDataX::GetValveName()
{
	CString str = _T("-");

	if( true == IsTAMode() )
	{
		CDB_TAProduct *pTAP = dynamic_cast< CDB_TAProduct * >( GetValveIDPtr().MP );

		if( NULL != pTAP )
		{
			str = pTAP->GetName();

			if( GetOpening() > 0.0 )
			{
				CDB_Characteristic *pCharacteristic = pTAP->GetValveCharacteristic();

				if( NULL != pCharacteristic )
				{
					str += CString( _T(" - ") ) + pCharacteristic->GetSettingString( GetOpening(), true );
				}
			}
		}
	}
	else
	{
		if( GetKv() > 0.0 )
		{
			str = GetKvCVString() + CString( " = " ) + WriteCUDouble( _C_KVCVCOEFF, GetKv() );
		}
	}

	return str;
}

BYTE CDS_LogDataX::GetValveIndex()
{
	return (BYTE)GetValvePosition();
}

unsigned short CDS_LogDataX::GetInterval()
{
	return (unsigned short)GetMeasuringStep();
}

// Return the logged Mode
BYTE CDS_LogDataX::GetMode()
{
	return (BYTE)GetLogType();
}

bool CDS_LogDataX::GetValue( CLog::eChannelType chan, int iRow, double &dVal )
{
	if( (int)GetSize() <= iRow )
	{
		return false;
	}

	dVal = 0.0;
	return GetData( chan, iRow, dVal );
}

// Give the value with a date time closed to dt
// Return false if dt is less than StartDateTime
// Give  the last value if dt is greater than the last DateTime
bool CDS_LogDataX::GetValue( CLog::eChannelType chan, CTime &dt, double &dVal )
{
	if( false == m_bStartDate )
	{
		if( false == InitStartDate() )
		{
			return false;
		}
	}

	if( dt < m_StartDate )
	{
		return false;
	}

	CTimeSpan ts = dt - m_StartDate;
	CTimeSpan tsi( GetInterval() );
	int iRow = ( int )( ts.GetTotalSeconds() / tsi.GetTotalSeconds() );

	if( ( int )GetSize() <= iRow )
	{
		iRow = ( int )GetSize() - 1;
	}

	GetDateTime( iRow, dt );
	return ( GetValue( chan, iRow, dVal ) );
}

// Give the value with a date time closed to StartDateTime + ts
bool CDS_LogDataX::GetValue( CLog::eChannelType chan, CTimeSpan &ts, double &dVal )
{
	if( false == m_bStartDate )
	{
		if( false == InitStartDate() )
		{
			return false;
		}
	}

	CTime dt = m_StartDate + ts;
	GetValue( chan, dt, dVal );
	ts = dt - m_StartDate;
	return true;
}

// Position iterator at the beginning of the list and give the value
// at this position in dVal
bool CDS_LogDataX::GetFirst( CLog::eChannelType chan, double &dVal, int iIndex )
{
	if( !( int )GetSize() )
	{
		return false;
	}

	if( iIndex > ( int )GetSize() )
	{
		return false;
	}

	// Variable
	m_Pos[chan] = iIndex;

	return GetNext( chan, dVal );
}

// Position iterator at next element in the list and give the value
// at this position in dVal
bool CDS_LogDataX::GetNext( CLog::eChannelType chan, double &dVal )
{
	if( 0 == ( int )GetSize() )
	{
		return false;
	}

	return GetValue( chan, m_Pos[chan]++, dVal );
}

// Return the number of logged values for this column
int CDS_LogDataX::GetLength()
{
	return GetSize();
}

bool CDS_LogDataX::InitStartDate()
{
	// Variables.
	__time32_t *pStartingDateTime = new __time32_t();
	tm *pdt = new tm();
	int iYear, iMonth, iDay, iHour, iMin, iSec;

	// Get the StartingTime.
	GetStartingDateTime( pStartingDateTime );

	if( 0 != _gmtime32_s( pdt, pStartingDateTime ) )
	{
		memset( pdt, 0, sizeof( tm ) );
		pdt->tm_year = 70;
		// Why '2'? To be sure that is not the default value (1 janvier 1970) but well a correction because
		// imported date is incorrect.
		pdt->tm_mday = 2;
	}

	iYear = pdt->tm_year + 1900;
	iMonth = pdt->tm_mon + 1;
	iDay = pdt->tm_mday;
	iHour = pdt->tm_hour;
	iMin = pdt->tm_min;
	iSec = pdt->tm_sec;

	// Delete created variables
	delete pStartingDateTime;
	delete pdt;

	// Verify the values
	if( !( iYear >= 1970 && iYear <= 2038 ) )
	{
		return false;
	}

	if( !( iMonth > 0 && iMonth <= 12 ) )
	{
		return false;
	}

	if( !( iDay > 0 && iDay <= 31 ) )
	{
		return false;
	}

	if( !( iHour >= 0 && iHour <= 23 ) )
	{
		return false;
	}

	if( !( iMin >= 0 && iMin <= 59 ) )
	{
		return false;
	}

	if( !( iSec >= 0 && iSec <= 59 ) )
	{
		return false;
	}

	CTime StartDate( iYear, iMonth, iDay, iHour, iMin, iSec );
	m_StartDate = StartDate;
	m_bStartDate = true;
	return true;
}

bool CDS_LogDataX::GetDateTime( int iRow, CTime &dt )
{
	if( ( int )GetSize() <= iRow )
	{
		return false;
	}

	if( false == m_bStartDate )
	{
		if( false == InitStartDate() )
		{
			return false;
		}
	}

	// Delta T in seconds.
	long lInterval = GetInterval() * iRow;

	CTimeSpan TimeSpan( lInterval );
	dt = m_StartDate + TimeSpan;

	return true;
}

bool CDS_LogDataX::GetOleDateTime( int iRow, COleDateTime &dt )
{
	CTime time;

	if( false == GetDateTime( iRow, time ) )
	{
		return false;
	}

	dt = COleDateTime( time.GetYear(), time.GetMonth(), time.GetDay(), time.GetHour(), time.GetMinute(), time.GetSecond() );

	return true;
}

bool CDS_LogDataX::GetHighestValue( CLog::eChannelType chan, double &dVal )
{
	if( chan >= CLog::eChannelType::ect_LastChannelType )
	{
		return false;
	}

	if( 0 == ( int )GetSize() )
	{
		return false;
	}

	// Variables.
	LogType eLogType = GetLogType();
	double val = -DBL_MAX;
	dVal = val;
	int iPos = 0;

	// Do a loop on all values and keep the highest value
	while( iPos < ( int )GetSize() )
	{
		GetData( chan, iPos++, val );

		if( val > dVal )
		{
			dVal = val;
		}
	}

	return true;
}

bool CDS_LogDataX::GetLowestValue( CLog::eChannelType chan, double &dVal )
{
	if( chan >= CLog::eChannelType::ect_LastChannelType )
	{
		return false;
	}

	if( 0 == ( int )GetSize() )
	{
		return false;
	}

	//Variables
	LogType eLogType = GetLogType();
	double val = DBL_MAX;
	dVal = val;
	int iPos = 0;

	// Do a loop on all values and keep the highest value
	while( iPos < ( int )GetSize() )
	{
		GetData( chan, iPos++, val );

		if( val < dVal )
		{
			dVal = val;
		}
	}

	return true;
}

bool CDS_LogDataX::WriteAsText( CString strPathName, bool bPointIndex, bool bHeader, CString strDelimiter )
{
	CString str, strDt, strLow, strHigh, strTxtLine;
	CFileTxt f( strPathName, CFile::modeCreate | CFile::modeWrite );

	if( (HANDLE)0 == f.m_hFile )
	{
		return false;
	}

	BYTE tmpbuf[] = {0xff, 0xfe};
	f.Write( tmpbuf, 2 );

	// Write Logged Data name.
	strTxtLine = GetName() + CString( _T("\n\n") );
	f.WriteTxtLine( (LPCTSTR)strTxtLine );

	if( true == bHeader )
	{
		// Write Logged data info block.
		str = TASApp.LoadLocalizedString( IDS_PLANT );
		str += _T(": ");
		strTxtLine = str + GetSite() + CString( _T("\n") );
		f.WriteTxtLine( (LPCTSTR)strTxtLine );
		
		str = TASApp.LoadLocalizedString( IDS_MODULE );
		str += _T(": ");
		strTxtLine = str + GetRef() + CString( _T("\n") );
		f.WriteTxtLine( (LPCTSTR)strTxtLine );
		
		str = TASApp.LoadLocalizedString( IDS_VALVEINDEX );
		str += _T(": ");
		strDt.Format( _T("%d"), GetValveIndex() );
		strTxtLine = str + strDt + CString( _T("\n") );
		f.WriteTxtLine( (LPCTSTR)strTxtLine );

		str = TASApp.LoadLocalizedString( IDS_STARTINGTIME );
		str += _T(": ");
		CTimeUnic dtu;
		GetDateTime( 0, dtu );
		strDt = dtu.Format( IDS_LOGDATETIME_FORMAT );
		strTxtLine = str + strDt + CString( _T("\n") );
		f.WriteTxtLine( (LPCTSTR)strTxtLine );
		
		str = TASApp.LoadLocalizedString( IDS_ENDINGTIME );
		str += _T(": ");
		GetDateTime( GetLength() - 1, dtu );
		strDt = dtu.Format( IDS_LOGDATETIME_FORMAT );
		strTxtLine = str + strDt + CString( _T("\n") );
		f.WriteTxtLine( (LPCTSTR)strTxtLine );

		str = TASApp.LoadLocalizedString( IDS_NBROFPOINTS );
		str += _T(": ");
		strDt.Format( _T("%d"), GetLength() );
		strTxtLine = str + strDt + CString( _T("\n") );
		f.WriteTxtLine( (LPCTSTR)strTxtLine );
		
		str = TASApp.LoadLocalizedString( IDS_DTBETWPTS );
		str += _T(": ");
		strDt.Format( _T("%d"), GetInterval() );
		CString stmp;
		stmp = TASApp.LoadLocalizedString( IDS_SEC );
		strDt += _T(" ") + stmp;
		strTxtLine = str + strDt + CString( _T("\n") );
		f.WriteTxtLine( (LPCTSTR)strTxtLine );

		double dVal;

		switch( GetMode() )
		{
			case CLog::LogType::LOGTYPE_DP:

				if( false == GetLowestValue( ect_Dp, dVal ) )
				{
					dVal = 0.0;
				}

				strLow = WriteCUDouble( _U_DIFFPRESS, dVal, true );

				if( false == GetHighestValue( ect_Dp, dVal ) )
				{
					dVal = 0.0;
				}

				strHigh = WriteCUDouble( _U_DIFFPRESS, dVal, true );
				break;

			case CLog::LogType::LOGTYPE_FLOW:

				if( false == GetLowestValue( ect_Flow, dVal ) )
				{
					dVal = 0.0;
				}

				strLow = WriteCUDouble( _U_FLOW, dVal, true );

				if( false == GetHighestValue( ect_Flow, dVal ) )
				{
					dVal = 0.0;
				}

				strHigh = WriteCUDouble( _U_FLOW, dVal, true );
				break;

			case CLog::LogType::LOGTYPE_TEMP:
			{
				// T1 &/or T2.
				if( NULL != GetpChannel( ect_Temp1 ) )
				{
					if( false == GetLowestValue( ect_Temp1, dVal ) )
					{
						dVal = 0.0;
					}

					strLow = WriteCUDouble( _U_TEMPERATURE, dVal, true );

					if( false == GetHighestValue( ect_Temp1, dVal ) )
					{
						dVal = 0.0;
					}

					strHigh = WriteCUDouble( _U_TEMPERATURE, dVal, true );

					if( NULL != GetpChannel( ect_Temp2 ) )
					{
						strLow += CString( _T("/") );
						strHigh += CString( _T("/") );
					}
				}

				if( NULL != GetpChannel( ect_Temp2 ) )
				{
					if( false == GetLowestValue( ect_Temp2, dVal ) )
					{
						dVal = 0.0;
					}

					strLow += WriteCUDouble( _U_TEMPERATURE, dVal, true );

					if( false == GetHighestValue( ect_Temp2, dVal ) )
					{
						dVal = 0.0;
					}

					strHigh += WriteCUDouble( _U_TEMPERATURE, dVal, true );
				}
			}
			break;

			case CLog::LogType::LOGTYPE_DPTEMP:

				if( false == GetLowestValue( ect_Dp, dVal ) )
				{
					dVal = 0.0;
				}

				strLow = WriteCUDouble( _U_DIFFPRESS, dVal, true );

				if( false == GetHighestValue( ect_Dp, dVal ) )
				{
					dVal = 0.0;
				}

				strHigh = WriteCUDouble( _U_DIFFPRESS, dVal, true );
				strLow += CString( _T("/") );
				strHigh += CString( _T("/") );

				// T1 &/or T2.
				if( NULL != GetpChannel( ect_Temp1 ) )
				{
					if( false == GetLowestValue( ect_Temp1, dVal ) )
					{
						dVal = 0.0;
					}

					strLow += WriteCUDouble( _U_TEMPERATURE, dVal, true );

					if( false == GetHighestValue( ect_Temp1, dVal ) )
					{
						dVal = 0.0;
					}

					strHigh += WriteCUDouble( _U_TEMPERATURE, dVal, true );

					if( NULL != GetpChannel( ect_Temp2 ) )
					{
						strLow += CString( _T("/") );
						strHigh += CString( _T("/") );
					}
				}

				if( NULL != GetpChannel( ect_Temp2 ) )
				{
					if( false == GetLowestValue( ect_Temp2, dVal ) )
					{
						dVal = 0.0;
					}

					strLow += WriteCUDouble( _U_TEMPERATURE, dVal, true );

					if( false == GetHighestValue( ect_Temp2, dVal ) )
					{
						dVal = 0.0;
					}

					strHigh += WriteCUDouble( _U_TEMPERATURE, dVal, true );
				}

				break;

			case CLog::LogType::LOGTYPE_FLOWTEMP:

				if( false == GetLowestValue( ect_Flow, dVal ) )
				{
					dVal = 0.0;
				}

				strLow = WriteCUDouble( _U_FLOW, dVal, true );

				if( false == GetHighestValue( ect_Flow, dVal ) )
				{
					dVal = 0.0;
				}

				strHigh = WriteCUDouble( _U_FLOW, dVal, true );
				strLow +=  CString( _T("/") );
				strHigh +=  CString( _T("/") );

				// T1 &/or T2.
				if( NULL != GetpChannel( ect_Temp1 ) )
				{
					if( false == GetLowestValue( ect_Temp1, dVal ) )
					{
						dVal = 0.0;
					}

					strLow += WriteCUDouble( _U_TEMPERATURE, dVal, true );

					if( false == GetHighestValue( ect_Temp1, dVal ) )
					{
						dVal = 0.0;
					}

					strHigh += WriteCUDouble( _U_TEMPERATURE, dVal, true );

					if( NULL != GetpChannel( ect_Temp2 ) )
					{
						strLow += CString( _T("/") );
						strHigh += CString( _T("/") );
					}
				}

				if( NULL != GetpChannel( ect_Temp2 ) )
				{
					if( false == GetLowestValue( ect_Temp2, dVal ) )
					{
						dVal = 0.0;
					}

					strLow += WriteCUDouble( _U_TEMPERATURE, dVal, true );

					if( false == GetHighestValue( ect_Temp2, dVal ) )
					{
						dVal = 0.0;
					}

					strHigh += WriteCUDouble( _U_TEMPERATURE, dVal, true );
				}

				break;

			case CLog::LogType::LOGTYPE_DT:
			{
				if( false == GetLowestValue( ect_DeltaT, dVal ) )
				{
					dVal = 0.0;
				}

				strLow = WriteCUDouble( _U_DIFFTEMP, dVal, true );

				if( false == GetHighestValue( ect_DeltaT, dVal ) )
				{
					dVal = 0.0;
				}

				strHigh = WriteCUDouble( _U_DIFFTEMP, dVal, true );
				strLow +=  CString( _T("/") );
				strHigh +=  CString( _T("/") );

				// T1 &/or T2.
				if( NULL != GetpChannel( ect_Temp1 ) )
				{
					if( false == GetLowestValue( ect_Temp1, dVal ) )
					{
						dVal = 0.0;
					}

					strLow += WriteCUDouble( _U_TEMPERATURE, dVal, true );

					if( false == GetHighestValue( ect_Temp1, dVal ) )
					{
						dVal = 0.0;
					}

					strHigh += WriteCUDouble( _U_TEMPERATURE, dVal, true );

					if( NULL != GetpChannel( ect_Temp2 ) )
					{
						strLow += CString( _T("/") );
						strHigh += CString( _T("/") );
					}
				}

				if( NULL != GetpChannel( ect_Temp2 ) )
				{
					if( false == GetLowestValue( ect_Temp2, dVal ) )
					{
						dVal = 0.0;
					}

					strLow += WriteCUDouble( _U_TEMPERATURE, dVal, true );

					if( false == GetHighestValue( ect_Temp2, dVal ) )
					{
						dVal = 0.0;
					}

					strHigh += WriteCUDouble( _U_TEMPERATURE, dVal, true );
				}

				break;
			}

			case CLog::LogType::LOGTYPE_POWER:
			{
				if( false == GetLowestValue( ect_Flow, dVal ) )
				{
					dVal = 0.0;
				}

				strLow = WriteCUDouble( _U_FLOW, dVal, true );

				if( false == GetHighestValue( ect_Flow, dVal ) )
				{
					dVal = 0.0;
				}

				strHigh = WriteCUDouble( _U_FLOW, dVal, true );
				strLow +=  CString( _T("/") );
				strHigh +=  CString( _T("/") );

				if( false == GetLowestValue( ect_DeltaT, dVal ) )
				{
					dVal = 0.0;
				}

				strLow += WriteCUDouble( _U_DIFFTEMP, dVal, true );

				if( false == GetHighestValue( ect_DeltaT, dVal ) )
				{
					dVal = 0.0;
				}

				strHigh += WriteCUDouble( _U_DIFFTEMP, dVal, true );
				strLow +=  CString( _T("/") );
				strHigh +=  CString( _T("/") );

				// T1 &/or T2.
				if( NULL != GetpChannel( ect_Temp1 ) )
				{
					if( false == GetLowestValue( ect_Temp1, dVal ) )
					{
						dVal = 0.0;
					}

					strLow += WriteCUDouble( _U_TEMPERATURE, dVal, true );

					if( false == GetHighestValue( ect_Temp1, dVal ) )
					{
						dVal = 0.0;
					}

					strHigh += WriteCUDouble( _U_TEMPERATURE, dVal, true );

					if( NULL != GetpChannel( ect_Temp2 ) )
					{
						strLow += CString( _T("/") );
						strHigh += CString( _T("/") );
					}
				}

				if( NULL != GetpChannel( ect_Temp2 ) )
				{
					if( false == GetLowestValue( ect_Temp2, dVal ) )
					{
						dVal = 0.0;
					}

					strLow += WriteCUDouble( _U_TEMPERATURE, dVal, true );

					if( false == GetHighestValue( ect_Temp2, dVal ) )
					{
						dVal = 0.0;
					}

					strHigh += WriteCUDouble( _U_TEMPERATURE, dVal, true );
				}

				break;
			}

		}

		str = TASApp.LoadLocalizedString( IDS_LOWSAMPLEDVAL );
		str += _T(": ");
		strTxtLine = str + strLow + CString( _T("\n") );
		f.WriteTxtLine( (LPCTSTR)strTxtLine );
		
		str = TASApp.LoadLocalizedString( IDS_HIGHSAMPLEDVAL );
		str += _T(": ");
		strTxtLine = str + strHigh + CString( _T("\n\n") );
		f.WriteTxtLine( (LPCTSTR)strTxtLine );

		if( true == bPointIndex )
		{
			str = TASApp.LoadLocalizedString( IDS_INDEX );
			strTxtLine = str + strDelimiter;
			f.WriteTxtLine( (LPCTSTR)strTxtLine );
		}

		str = TASApp.LoadLocalizedString( IDS_DATE );
		strTxtLine = str + strDelimiter;
		f.WriteTxtLine( (LPCTSTR)strTxtLine );
		
		str = TASApp.LoadLocalizedString( IDS_TIME );
		strTxtLine = str + strDelimiter;
		f.WriteTxtLine( (LPCTSTR)strTxtLine );

		switch( GetMode() )
		{
			case CLog::LogType::LOGTYPE_DP:
				str = TASApp.LoadLocalizedString( IDS_DP );
				strTxtLine = str  + CString( _T("\n") );
				f.WriteTxtLine( (LPCTSTR)strTxtLine );
				break;

			case CLog::LogType::LOGTYPE_FLOW:
				str = TASApp.LoadLocalizedString( IDS_FLOW );
				strTxtLine = str  + CString( _T("\n") );
				f.WriteTxtLine( (LPCTSTR)strTxtLine );
				break;

			case CLog::LogType::LOGTYPE_TEMP:

				// T1 &/or T2.
				if( NULL != GetpChannel( ect_Temp1 ) )
				{
					strTxtLine = TASApp.LoadLocalizedString( IDS_CHART_T1 );

					if( NULL != GetpChannel( ect_Temp2 ) )
					{
						strTxtLine += strDelimiter;
					}

					f.WriteTxtLine( (LPCTSTR)strTxtLine );
				}

				if( NULL != GetpChannel( ect_Temp2 ) )
				{
					strTxtLine = TASApp.LoadLocalizedString( IDS_CHART_T2 );
				}

				strTxtLine += CString( _T("\n") );
				f.WriteTxtLine( (LPCTSTR)strTxtLine );
				break;

			case CLog::LogType::LOGTYPE_DPTEMP:
				str = TASApp.LoadLocalizedString( IDS_DP );
				strTxtLine = str + strDelimiter;
				f.WriteTxtLine( (LPCTSTR)strTxtLine );
				str = TASApp.LoadLocalizedString( IDS_TEMPERATURE );

				// T1 &/or T2.
				if( NULL != GetpChannel( ect_Temp1 ) )
				{
					strTxtLine = TASApp.LoadLocalizedString( IDS_CHART_T1 );

					if( NULL != GetpChannel( ect_Temp2 ) )
					{
						strTxtLine += strDelimiter;
					}

					f.WriteTxtLine( (LPCTSTR)strTxtLine );
				}

				if( NULL != GetpChannel( ect_Temp2 ) )
				{
					strTxtLine = TASApp.LoadLocalizedString( IDS_CHART_T2 );
				}

				strTxtLine += CString( _T("\n") );
				f.WriteTxtLine( (LPCTSTR)strTxtLine );
				break;

			case CLog::LogType::LOGTYPE_FLOWTEMP:
				str = TASApp.LoadLocalizedString( IDS_FLOW );
				strTxtLine = str + strDelimiter;
				f.WriteTxtLine( (LPCTSTR)strTxtLine );
				str = TASApp.LoadLocalizedString( IDS_TEMPERATURE );

				// T1 &/or T2.
				if( NULL != GetpChannel( ect_Temp1 ) )
				{
					strTxtLine = TASApp.LoadLocalizedString( IDS_CHART_T1 );

					if( NULL != GetpChannel( ect_Temp2 ) )
					{
						strTxtLine += strDelimiter;
					}

					f.WriteTxtLine( (LPCTSTR)strTxtLine );
				}

				if( NULL != GetpChannel( ect_Temp2 ) )
				{
					strTxtLine = TASApp.LoadLocalizedString( IDS_CHART_T2 );
				}

				strTxtLine += CString( _T("\n") );
				f.WriteTxtLine( (LPCTSTR)strTxtLine );
				break;

			case CLog::LogType::LOGTYPE_DT:
				str = TASApp.LoadLocalizedString( IDS_CHART_DIFFTEMP );
				strTxtLine = str + strDelimiter;
				f.WriteTxtLine( (LPCTSTR)strTxtLine );
				str = TASApp.LoadLocalizedString( IDS_TEMPERATURE );

				// T1 &/or T2.
				if( NULL != GetpChannel( ect_Temp1 ) )
				{
					strTxtLine = TASApp.LoadLocalizedString( IDS_CHART_T1 );

					if( NULL != GetpChannel( ect_Temp2 ) )
					{
						strTxtLine += strDelimiter;
					}

					f.WriteTxtLine( (LPCTSTR)strTxtLine );
				}

				if( NULL != GetpChannel( ect_Temp2 ) )
				{
					strTxtLine = TASApp.LoadLocalizedString( IDS_CHART_T2 );
				}

				strTxtLine += CString( _T("\n") );
				f.WriteTxtLine( (LPCTSTR)strTxtLine );
				break;

			case CLog::LogType::LOGTYPE_POWER:
				str = TASApp.LoadLocalizedString( IDS_CHART_POWER );
				strTxtLine = str + strDelimiter;
				f.WriteTxtLine( (LPCTSTR)strTxtLine );
				
				str = TASApp.LoadLocalizedString( IDS_FLOW );
				strTxtLine = str + strDelimiter;
				f.WriteTxtLine( (LPCTSTR)strTxtLine );
				
				str = TASApp.LoadLocalizedString( IDS_CHART_DIFFTEMP );
				strTxtLine = str + strDelimiter;
				f.WriteTxtLine( (LPCTSTR)strTxtLine );
				
				str = TASApp.LoadLocalizedString( IDS_TEMPERATURE );

				// T1 &/or T2.
				if( NULL != GetpChannel( ect_Temp1 ) )
				{
					strTxtLine = TASApp.LoadLocalizedString( IDS_CHART_T1 );

					if( NULL != GetpChannel( ect_Temp2 ) )
					{
						strTxtLine += strDelimiter;
					}

					f.WriteTxtLine( (LPCTSTR)strTxtLine );
				}

				if( NULL != GetpChannel( ect_Temp2 ) )
				{
					strTxtLine = TASApp.LoadLocalizedString( IDS_CHART_T2 );
				}

				strTxtLine += CString( _T("\n") );
				f.WriteTxtLine( (LPCTSTR)strTxtLine );
				break;

		}
	}

	for( int iIndex = 0; iIndex < GetLength(); iIndex++ )
	{
		if( true == bPointIndex )
		{
			strTxtLine.Format( _T("%d"), iIndex + 1 );
			strTxtLine += strDelimiter;
			f.WriteTxtLine( (LPCTSTR)strTxtLine );
		}

		// Write Date and Time.
		CTimeUnic dtu;
		GetDateTime( iIndex, dtu );
		strTxtLine = dtu.Format( IDS_DATE_FORMAT ) + strDelimiter;
		f.WriteTxtLine( (LPCTSTR)strTxtLine );
		
		strTxtLine = dtu.Format( IDS_TIME_FORMAT ) + strDelimiter;
		f.WriteTxtLine( (LPCTSTR)strTxtLine );

		// Write Dp, flow and temperature.
		double dValue;

		switch( GetMode() )
		{
			case CLog::LogType::LOGTYPE_DP:
				( iIndex == 0 ) ? GetFirst( ect_Dp, dValue ) : GetNext( ect_Dp, dValue );
				str = WriteCUDouble( _U_DIFFPRESS, dValue, false );
				strTxtLine = str  + CString( _T("\n") );
				f.WriteTxtLine( (LPCTSTR)strTxtLine );
				break;

			case CLog::LogType::LOGTYPE_FLOW:
				( iIndex == 0 ) ? GetFirst( ect_Flow, dValue ) : GetNext( ect_Flow, dValue );
				str = WriteCUDouble( _U_FLOW, dValue, false );
				
				strTxtLine = str  + CString( _T("\n") );
				f.WriteTxtLine( (LPCTSTR)strTxtLine );
				break;

			case CLog::LogType::LOGTYPE_DT:
				( iIndex == 0 ) ? GetFirst( ect_DeltaT, dValue ) : GetNext( ect_DeltaT, dValue );
				str = WriteCUDouble( _U_DIFFTEMP, dValue, false );
				strTxtLine = str   + strDelimiter;
				GetTempString( iIndex, strTxtLine, strDelimiter );
				strTxtLine += CString( _T("\n") );
				f.WriteTxtLine( (LPCTSTR)strTxtLine );
				break;

			case CLog::LogType::LOGTYPE_TEMP:
				GetTempString( iIndex, strTxtLine, strDelimiter );
				strTxtLine += CString( _T("\n") );
				f.WriteTxtLine( (LPCTSTR)strTxtLine );
				break;

			case CLog::LogType::LOGTYPE_DPTEMP:
				( iIndex == 0 ) ? GetFirst( ect_Dp, dValue ) : GetNext( ect_Dp, dValue );
				str = WriteCUDouble( _U_DIFFPRESS, dValue, false );
				strTxtLine = str  + strDelimiter;
				GetTempString( iIndex, strTxtLine, strDelimiter );
				strTxtLine += CString( _T("\n") );
				f.WriteTxtLine( (LPCTSTR)strTxtLine );
				break;

			case CLog::LogType::LOGTYPE_POWER:
				( iIndex == 0 ) ? GetFirst( ect_Power, dValue ) : GetNext( ect_Power, dValue );
				str = WriteCUDouble( _U_TH_POWER, dValue, false );
				strTxtLine = str   + strDelimiter;
				( iIndex == 0 ) ? GetFirst( ect_Flow, dValue ) : GetNext( ect_Flow, dValue );
				str = WriteCUDouble( _U_FLOW, dValue, false );
				strTxtLine += str   + strDelimiter;
				( iIndex == 0 ) ? GetFirst( ect_DeltaT, dValue ) : GetNext( ect_DeltaT, dValue );
				str = WriteCUDouble( _U_DIFFTEMP, dValue, false );
				strTxtLine += str   + strDelimiter;
				GetTempString( iIndex, strTxtLine, strDelimiter );
				strTxtLine += CString( _T("\n") );
				f.WriteTxtLine( (LPCTSTR)strTxtLine );
				break;

			case CLog::LogType::LOGTYPE_FLOWTEMP:
				( iIndex == 0 ) ? GetFirst( ect_Flow, dValue ) : GetNext( ect_Flow, dValue );
				str = WriteCUDouble( _U_FLOW, dValue, false );
				strTxtLine = str   + strDelimiter;
				GetTempString( iIndex, strTxtLine, strDelimiter );
				strTxtLine += CString( _T("\n") );
				f.WriteTxtLine( (LPCTSTR)strTxtLine );
				break;
		}
	}

	f.Close();

	return true;
}

void CDS_LogDataX::GetTempString( int iIndex, CString &TxtLine, CString Delimiter )
{
	double dValue = 0.0;
	CString str;
	bool bChan1 = GetpChannel( ect_Temp1 ) ? true : false;
	bool bChan2 = GetpChannel( ect_Temp2 ) ? true : false;

	// T1 or T2.
	if( true == bChan1 )
	{
		( iIndex ) ? GetNext( ect_Temp1, dValue ) : GetFirst( ect_Temp1, dValue );
		str = WriteCUDouble( _U_TEMPERATURE, dValue, false );
		TxtLine += str;

		if( true == bChan2 )
		{
			TxtLine += Delimiter;
		}
	}

	if( true == bChan2 )
	{
		( iIndex ) ? GetNext( ect_Temp2, dValue ) : GetFirst( ect_Temp2, dValue );
		str = WriteCUDouble( _U_TEMPERATURE, dValue, false );
		TxtLine += str;
	}
}

// Function used only for TA-SCOPE: Return true if T1 is used, false for T2
// Used for Dp-Temp log, Flow-Temp log or Temp log only
bool CDS_LogDataX::IsT1SensorUsed()
{
	m_map::iterator It;

	for( It = m_LogChan.begin(); It != m_LogChan.end(); ++It )
	{
		if( CLog::ect_Temp1 == It->second->GetChanType() )
		{
			return true;
		}
	}

	return false;
}
#endif //TACBX

void CDS_LogDataX::OnDatabaseDestroy()
{
	ClearLogChan();
}

bool CDS_LogDataX::SetStartingDateTime( __time32_t StartDT, unsigned short usMesuringStep )
{
	m_StartingDateTime = StartDT;
	m_MeasuringStep = usMesuringStep;
	Modified();
	return	true;
}

unsigned short CDS_LogDataX::GetStartingDateTime( __time32_t *pStartingDateTime )
{
	if( NULL != pStartingDateTime )
	{
		*pStartingDateTime = m_StartingDateTime;
	}

	return m_MeasuringStep;
}

void CDS_LogDataX::GetStopDateTime( __time32_t *pStopDateTime )
{
	if( NULL != pStopDateTime )
	{
		*pStopDateTime = m_StartingDateTime + GetSize() * m_MeasuringStep;
	}
}

bool CDS_LogDataX::GetDataDateTime( unsigned uIndex, __time32_t *pDataTime )
{
	bool bRet = false;

	if( NULL != pDataTime )
	{
		*pDataTime = m_StartingDateTime + uIndex * m_MeasuringStep;
		bRet = true;
	}

	return bRet;
}

void CDS_LogDataX::ClearLogChan()
{
	m_LogType = LOGTYPE_UNDEF;
	m_map::iterator It;

	for( It = m_LogChan.begin(); It != m_LogChan.end(); ++It )
	{
		if( It->second )
		{
			delete It->second;
		}

		It->second = NULL;
	}

	Modified();
	m_LogChan.clear();
}

CDS_LogDataX::CChan *CDS_LogDataX::GetpChannel( unsigned uLogChannelKey )
{
	m_map::iterator It = m_LogChan.find( uLogChannelKey );

	if( It == m_LogChan.end() )
	{
		return NULL;    // Cannot find it
	}

	return ( It->second );
}

CDS_LogDataX::CPhysChan *CDS_LogDataX::AddPhysicalChan( CDS_LogDataX::CLog::eChannelType ChanType, unsigned char ucSensorNum )
{
	CPhysChan *pChan = new CPhysChan( this );
	pChan->SetPhysicalChan( ucSensorNum, ChanType );
	pChan->SetKey( ucSensorNum );
	m_LogChan.insert( std::pair<unsigned, CChan *>( ucSensorNum, pChan ) );
	Modified();
	return ( pChan );
}

// Logical channels use existing physical channels.
int CDS_LogDataX::AddFlowChan( unsigned usDp )
{
	m_map::iterator It =	m_LogChan.find( usDp );

	if( It == m_LogChan.end() )
	{
		return -1;    // Cannot find it
	}

	if( It->second->GetChanType() != CLog::ect_Dp )
	{
		return -1;    // Not a correct type
	}

	CLogChan *pChan = new CLogChan( this );
	pChan->SetKey( CLog::ect_Flow );
	pChan->SetChanType( CLog::ect_Flow );
	pChan->AttachPhysChan( usDp );
	m_LogChan.insert( std::pair<unsigned, CChan *>( CLog::ect_Flow, pChan ) );
	Modified();

	return ( CLog::ect_Flow );
}

int CDS_LogDataX::AddDeltaTChan( unsigned usT1, unsigned usT2 )
{
	// First verify physical channels existence.
	for( int i = 0; i < 2; i++ )
	{
		m_map::iterator It =	m_LogChan.find( usT1 );

		if( It == m_LogChan.end() )
		{
			return -1;    // Cannot find it
		}

		if( It->second->GetChanType() != CLog::ect_Temp1 && It->second->GetChanType() != CLog::ect_Temp2 )
		{
			return -1;    // Not a correct type
		}
	}

	CLogChan *pChan = new CLogChan( this );
	pChan->SetKey( CLog::ect_DeltaT );
	pChan->SetChanType( CLog::ect_DeltaT );
	pChan->AttachPhysChan( usT1 );
	pChan->AttachPhysChan( usT2 );
	m_LogChan.insert( std::pair<unsigned, CChan *>( CLog::ect_DeltaT, pChan ) );
	Modified();

	return ( CLog::ect_DeltaT );
}

int CDS_LogDataX::AddPowerChan( unsigned usDp, unsigned usT1, unsigned usT2 )
{
	// First verify physical channels existence
	m_map::iterator It =	m_LogChan.find( usDp );

	if( It == m_LogChan.end() )
	{
		return -1;    // Cannot find it
	}

	if( It->second->GetChanType() != CLog::ect_Flow )
	{
		return -1;    // Not a correct type
	}

	// First verify physical channels existence
	for( int i = 0; i < 2; i++ )
	{
		m_map::iterator It =	m_LogChan.find( usT1 );

		if( It == m_LogChan.end() )
		{
			return -1;    // Cannot find it
		}

		if( It->second->GetChanType() != CLog::ect_Temp1 && It->second->GetChanType() != CLog::ect_Temp2 )
		{
			return -1;    // Not a correct type
		}
	}

	CLogChan *pChan = new CLogChan( this );
	pChan->SetKey( CLog::ect_Power );
	pChan->SetChanType( CLog::ect_Power );
	pChan->AttachPhysChan( usT1 );
	pChan->AttachPhysChan( usT2 );
	pChan->AttachPhysChan( usDp );
	m_LogChan.insert( std::pair<unsigned, CChan *>( CLog::ect_Power, pChan ) );
	Modified();

	return ( CLog::ect_Power );
}

bool CDS_LogDataX::GetData( unsigned uKey, unsigned uIndex, double &dVal )
{
	dVal = 0.0;
	CChan *pChan = GetpChannel( uKey );

	if( NULL == pChan )
	{
		return false;
	}

	if( pChan->GetChanType() < CLog::ect_FirstLogicalChan )
	{
		CPhysChan *pPhysChan = dynamic_cast<CPhysChan *>( pChan );

		if( NULL == pPhysChan )
		{
			return false;    // Something wrong!
		}

		return ( pPhysChan->GetData( uIndex, dVal ) );
	}
	else
	{
		CLogChan *pLogChan = dynamic_cast<CLogChan *>( pChan );

		if( NULL == pLogChan )
		{
			return false;    // Something wrong!
		}

		return( pLogChan->GetData( uIndex, dVal ) );
	}
}

CDS_LogDataX::CChan *CDS_LogDataX::GetFirstpChan()
{
	m_It = m_LogChan.begin();

	if( m_It != m_LogChan.end() )
	{
		return ( m_It->second );
	}

	return NULL;
}

CDS_LogDataX::CChan *CDS_LogDataX::GetNextpChan()
{
	++m_It;

	if( m_It != m_LogChan.end() )
	{
		return ( m_It->second );
	}

	return NULL;
}

bool CDS_LogDataX::DeleteChan( unsigned uLogChannelKey )
{
	m_map::iterator It = m_LogChan.find( uLogChannelKey );

	if( It == m_LogChan.end() )
	{
		return false;    // Cannot find it
	}

	if( It->second )
	{
		delete It->second;
	}

	It->second = NULL;
	m_LogChan.erase( It );
	Modified();
	return true;
}

bool CDS_LogDataX::SetLogType( LogType logtype, uint8_t TempSensorUsed, _string Valveid, double dOpening, CWaterChar *pWC )
{
	ClearLogChan();
	ASSERT( m_LogType < LOGTYPE_LAST );

	SetValveID( Valveid );
	SetOpening( dOpening );
	SetWaterChar( pWC );
	// To be sure!!
	SetKv( 0 );

	// Pay attention: '_SetLogTypeTerminate()' call 'ClearLogChan'. This functio ncleans all logical channels and reset
	// 'm_LogType'. This is the reason why we must set 'm_LogType' after this call.
	bool bReturnValue = _SetLogTypeTerminate( logtype, TempSensorUsed );

	m_LogType = logtype;
	Modified();
	
	return bReturnValue;
}

bool CDS_LogDataX::SetLogType( LogType logtype, uint8_t uiTempSensorUsed, double dKV, CWaterChar *pWC )
{
	ClearLogChan();
	ASSERT( m_LogType < LOGTYPE_LAST );

	SetKv( dKV );
	SetWaterChar( pWC );
	SetOpening( 0 );

	// Pay attention: '_SetLogTypeTerminate()' call 'ClearLogChan'. This functio ncleans all logical channels and reset
	// 'm_LogType'. This is the reason why we must set 'm_LogType' after this call.
	bool bReturnValue = _SetLogTypeTerminate( logtype, uiTempSensorUsed );

	m_LogType = logtype;
	Modified();
	
	return bReturnValue;
}

// For 'TempSensorUsed', bit 0 is for Temp1 and bit 1 is for Temp2
bool CDS_LogDataX::SetLogType( LogType logtype, uint8_t uiTempSensorUsed )
{
	ClearLogChan();
	ASSERT( m_LogType < LOGTYPE_LAST );

	// Pay attention: '_SetLogTypeTerminate()' call 'ClearLogChan'. This functio ncleans all logical channels and reset
	// 'm_LogType'. This is the reason why we must set 'm_LogType' after this call.
	bool bReturnValue = _SetLogTypeTerminate( logtype, uiTempSensorUsed );

	m_LogType = logtype;
	Modified();
	
	return bReturnValue;
}

void CDS_LogDataX::SetSize( unsigned usSize )
{
	for( CChan *p = GetFirstpChan(); p; p = GetNextpChan() )
	{
		CPhysChan *pPC = dynamic_cast<CPhysChan *>( p );

		if( NULL != pPC )
		{
			pPC->SetSize( usSize );
		}
	}

	Modified();
}

unsigned CDS_LogDataX::GetSize()
{
	for( CChan *p = GetFirstpChan(); p; p = GetNextpChan() )
	{
		if( NULL != p )
		{
			return p->GetDataArraySize();
		}
	}

	return 0;
}

void CDS_LogDataX::SetValveID( _string id )
{
	m_ValveIDPtr = _NULL_IDPTR;				// In case of Q/Dp measurment Valve IDPtr in TADB
	m_ValveIDPtr.SetID( id );
	Modified();
}

IDPTR CDS_LogDataX::GetValveIDPtr()
{
	CTADatabase *pDB = GetpTADB();

	if( NULL == pDB || _T('\0') == *m_ValveIDPtr.ID )
	{
		return _NULL_IDPTR;
	}

	m_ValveIDPtr.DB = pDB;
	Extend( &m_ValveIDPtr );
	return m_ValveIDPtr;
}

#define CDS_LOGDATAX_VERSION	4
void CDS_LogDataX::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDS_LOGDATAX_VERSION;
	WriteData<>( outf, Version );
	
	// Base class.
	CData::Write( outf );

	// Info.
	WriteData<>( outf, m_LogType );
	WriteData<>( outf, m_SensorMAC );
	WriteString( outf, m_Name );
	WriteString( outf, m_Description.c_str() );
	WriteData<>( outf, m_StartingDateTime );
	WriteData<>( outf, m_MeasuringStep );
	WriteData<>( outf, m_ucLogStatus );

	WriteString( outf, m_HMID );
	WriteString( outf, m_DSUID );
	WriteString( outf, m_PlantName );
	WriteString( outf, m_ModuleName );
	WriteData<>( outf, m_ValvePosition );
	WriteData<>( outf, m_ValveLoc );
	WriteData<>( outf, m_BalType );

	WriteString( outf, GetValveIDPtr().ID );
	WriteDouble( outf, m_dOpening );
	WriteDouble( outf, m_dKv );
	m_WaterChar.Write( outf );
	WriteData<>( outf, m_bTAMode );

	unsigned size = m_LogChan.size();
	WriteData<>( outf, size );

	for( m_map::iterator It = m_LogChan.begin(); It != m_LogChan.end(); ++It )
	{
		unsigned uKey = It->first;
		WriteData<>( outf, uKey );
		CLog::eChannelType ChanType = It->second->GetChanType();
		WriteData<>( outf, ChanType );
		It->second->Write( outf );
	}

	WriteData<>( outf, m_SampleNumber );
}

bool CDS_LogDataX::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDS_LOGDATAX_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDS_LOGDATAX_VERSION )
	{
		return false;
	}

	// Base.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Info.
	ClearLogChan();
	inpf.read( (char *)&m_LogType, sizeof( m_LogType ) );
	inpf.read( (char *)&m_SensorMAC, sizeof( m_SensorMAC ) );

	if( false == ReadString( inpf, m_Name, sizeof( m_Name ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_Description ) )
	{
		return false;
	}

	inpf.read( (char *)&m_StartingDateTime, sizeof( m_StartingDateTime ) );

	// if date is not valid use 'now' instead
#ifndef TACBX
	tm *pdt = _gmtime32( &m_StartingDateTime );
#else
	tm *pdt = gmtime( &m_StartingDateTime );
#endif

	if( 0 == pdt )
	{
		ASSERT( 0 );

#ifdef WIN32
#ifndef TACBX
		// For HySelect.
		m_StartingDateTime = _time32( NULL );
#else
		// For TAScope running on Windows.
		m_StartingDateTime = time( NULL );
#endif
#else
		// For TAScope running on the device.
		m_StartingDateTime = SystemTime::getUTCTime();
#endif

	}

	inpf.read( (char *)&m_MeasuringStep, sizeof( m_MeasuringStep ) );
	inpf.read( (char *)&m_ucLogStatus, sizeof( m_ucLogStatus ) );

	if( false == ReadString( inpf, m_HMID, sizeof( m_HMID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_DSUID, sizeof( m_DSUID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_PlantName, sizeof( m_PlantName ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_ModuleName, sizeof( m_ModuleName ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_ValvePosition, sizeof( m_ValvePosition ) );
	inpf.read( (char *)&m_ValveLoc, sizeof( m_ValveLoc ) );
	inpf.read( (char *)&m_BalType, sizeof( m_BalType ) );

	m_ValveIDPtr = _NULL_IDPTR;
	m_dOpening = 0.0;
	m_dKv = 0.0;
	CWaterChar WC;

	if( false == ReadString( inpf, m_ValveIDPtr.ID, sizeof( m_ValveIDPtr.ID ) ) )
	{
		return false;
	}

	if( Version >= 2 || *m_ValveIDPtr.ID )
	{
		m_dOpening = ReadDouble( inpf );
		m_dKv = ReadDouble( inpf );
		WC.Read( inpf );
	}

	if( Version >= 3 )
	{
		inpf.read( (char *)&m_bTAMode, sizeof( m_bTAMode ) );
	}
	else if( *m_ValveIDPtr.ID )
	{
		m_bTAMode = true;
	}

	unsigned uSize = 0;
	inpf.read( (char *)&uSize, sizeof( uSize ) );

	for( unsigned u = 0; u < uSize; u++ )
	{
		unsigned uKey;
		inpf.read( (char *)&uKey, sizeof( uKey ) );

		CLog::eChannelType ChanType = CLog::ect_LastChannelType;
		inpf.read( (char *)&ChanType, sizeof( ChanType ) );
		CChan *pChan = NULL;

		if( ChanType < CLog::ect_FirstLogicalChan )
		{
			pChan = new CPhysChan( this );
		}
		else
		{
			pChan = new CLogChan( this );
		}

		ASSERT( NULL != pChan );

		if( NULL != pChan )
		{
			if( false == pChan->Read( inpf ) )
			{
				return false;
			}
		}

		m_LogChan.insert( std::pair<unsigned, CChan *>( uKey, pChan ) );
	}

	if( Version < 4 )
	{
		return true;
	}

	inpf.read( (char *)&m_SampleNumber, sizeof( m_SampleNumber ) );
	
	// Init Water char here after downloading channel definition.
	// Needed to known if a SPTP exist and could be used to correct fluid.
	SetWaterChar( &WC );
	return true;
}

void CDS_LogDataX::Copy( CData *pclDestination )
{
	CDS_LogDataX *pclDestinationLogDataX = dynamic_cast<CDS_LogDataX *>( pclDestination );
	ASSERT( NULL != pclDestinationLogDataX );

	if( NULL != pclDestinationLogDataX )
	{
		CData::Copy( pclDestination );

		pclDestinationLogDataX->ClearLogChan();
		pclDestinationLogDataX->SetLogType( GetLogType() );
		pclDestinationLogDataX->SetSensorMac( m_SensorMAC );
		pclDestinationLogDataX->SetName( GetName() );
		pclDestinationLogDataX->SetDescription( m_Description );
		pclDestinationLogDataX->SetStartingDateTime( m_StartingDateTime, GetMeasuringStep() );
		pclDestinationLogDataX->SetLogStatus( GetLogStatus() );
		pclDestinationLogDataX->SetHMID( GetHMID() );
		pclDestinationLogDataX->SetDSUID( GetDSUID() );
		pclDestinationLogDataX->SetPlantName( GetPlantName() );
		pclDestinationLogDataX->SetModuleName( GetModuleName() );
		pclDestinationLogDataX->SetValvePosition( GetValvePosition() );
		pclDestinationLogDataX->SetValveLocation( GetValveLocation() );
		pclDestinationLogDataX->SetBalType( GetBalType() );
		pclDestinationLogDataX->SetValveID( GetValveIDPtr().ID );
		pclDestinationLogDataX->SetTAMode( m_bTAMode );
		pclDestinationLogDataX->SetKv( GetKv() );
		pclDestinationLogDataX->SetWaterChar( GetWaterChar() );
		pclDestinationLogDataX->SetOpening( GetOpening() );
		pclDestinationLogDataX->SetSampleNumber( GetSampleNumber() );

		for( CDS_LogDataX::CChan *pChan = GetFirstpChan(); pChan; pChan = GetNextpChan() )
		{
			CChan *pChannel = NULL;

			if( pChan->GetChanType() < CLog::ect_FirstLogicalChan )
			{
				pChannel = new CPhysChan( pclDestinationLogDataX );
				( static_cast<CPhysChan *>( pChan ) )->Copy( static_cast<CPhysChan *>( pChannel ) );
			}
			else
			{
				pChannel = new CLogChan( pclDestinationLogDataX );
				( static_cast<CLogChan *>( pChan ) )->Copy( static_cast<CLogChan *>( pChannel ) );
			}

			pclDestinationLogDataX->m_LogChan.insert( std::pair<unsigned, CChan *>( pChannel->GetKey(), pChannel ) );
		}
	}
}

#ifdef TACBX
void CDS_LogDataX::SaveLogData( void *pVoidSensor, void *pVoidLog )
{
	Sensor *pSensor = ( Sensor * )pVoidSensor;
	SensorLog_t *pLog = ( SensorLog_t * )pVoidLog;
	CDS_LogDataX *pLDX = this;

	if( NULL == pSensor || NULL == pLog )
	{
		return;
	}

	pLDX->SetSensorMac( pSensor->getMacAddress() );
	pLDX->SetName( pLog->shortInfo.log_refname );
	pLDX->SetStartingDateTime( pLog->shortInfo.logStartUTC, pLog->shortInfo.samplePeriod );

	// Fill hyronic network information
	pLDX->SetHMID( pLog->HMID );
	pLDX->SetDSUID( pLog->DSUID );
	pLDX->SetPlantName( pLog->Plant_Name );
	pLDX->SetModuleName( pLog->Module_Name );
	pLDX->SetValvePosition( pLog->ValvePosition );
	pLDX->SetValveLocation( ( CDS_HydroModX::eLocate )pLog->ValveLoc );
	pLDX->SetBalType( ( CDS_HydroModX::eHMXBalType )pLog->BalType );
	pLDX->SetSampleNumber( pLog->shortInfo.numberOfSamples );
	// Fill water characteristic
	CWaterChar WC;
	CDB_StringID *pAdditstrID = dynamic_cast<CDB_StringID *>( GetpTADB()->Get( pLog->wc_additive_ID ).MP );

	if( pAdditstrID )
	{
		WC.SetAdditFamID( pAdditstrID->GetIDPtr().PP->GetIDPtr().ID );
		WC.SetAdditID( pAdditstrID->GetIDPtr().ID );
		WC.SetTemp( pLog->wc_fluid_temp );
		WC.SetPcWeight( pLog->wc_additive_concentration );
		WC.SetDens( pLog->wc_fluid_density );
		WC.SetKinVisc( pLog->wc_fluid_kinvisc );
		WC.SetSpecifHeat( pLog->wc_fluid_specheat );

		CDB_AdditCharacteristic *pChar = dynamic_cast<CDB_AdditCharacteristic *>( GetpTADB()->Get( pAdditstrID->GetIDstr() ).MP );
		WC.SetTfreez( pChar->GetTfreez( pLog->wc_additive_concentration ) );
	}

	// Set log type.
	CDS_LogDataX::LogType logType = static_cast<CDS_LogDataX::LogType>( pLog->shortInfo.logType );

	if( pAdditstrID )
	{
		if( GetpTADB()->Get( pLog->valve_ID ).MP )
		{
			pLDX->SetLogType( logType, pLog->log_usedtempsensors, pLog->valve_ID, pLog->valve_opening, &WC );
		}
		else
		{
			pLDX->SetLogType( logType, pLog->log_usedtempsensors, pLog->valve_opening, &WC );
		}
	}
	else
	{
		pLDX->SetLogType( logType, pLog->log_usedtempsensors );
	}

	// Fill equations & datas
	for( CDS_LogDataX::CChan *pChan = pLDX->GetFirstpChan(); pChan; pChan = pLDX->GetNextpChan() )
	{
		// If it's a physical channel...
		CDS_LogDataX::CPhysChan *pPhysChan = dynamic_cast<CDS_LogDataX::CPhysChan *>( pChan );

		if( pPhysChan != NULL )
		{
			// Fill equation
			switch( pPhysChan->GetChanType() )
			{
				case CLog::ect_Dp:
				{
					CEquation Eq = CEquation( CEquation::EqT_Linear, 6 );

					if( true == pSensor->isDpsVisio() )
					{
						Eq.SetEquationType( CEquation::EqT_Linear_Unsigned );
					}

					Eq.SetSensorType( CEquation::est_Dp );
					Eq.SetEquationCoefs( 0, ( short unsigned int ) pLog->dpCalibrationImage.calibrationCurveX0, ( double ) pLog->dpCalibrationImage.calibrationCurveY0 );
					Eq.SetEquationCoefs( 1, ( short unsigned int ) pLog->dpCalibrationImage.calibrationCurveX1, ( double ) pLog->dpCalibrationImage.calibrationCurveY1 );
					Eq.SetEquationCoefs( 2, ( short unsigned int ) pLog->dpCalibrationImage.calibrationCurveX2, ( double ) pLog->dpCalibrationImage.calibrationCurveY2 );
					Eq.SetEquationCoefs( 3, ( short unsigned int ) pLog->dpCalibrationImage.calibrationCurveX3, ( double ) pLog->dpCalibrationImage.calibrationCurveY3 );
					Eq.SetEquationCoefs( 4, ( short unsigned int ) pLog->dpCalibrationImage.calibrationCurveX4, ( double ) pLog->dpCalibrationImage.calibrationCurveY4 );
					Eq.SetEquationCoefs( 5, ( short unsigned int ) pLog->dpCalibrationImage.calibrationCurveX5, ( double ) pLog->dpCalibrationImage.calibrationCurveY5 );

					// set calibration date
					Eq.SetCalibrationDate( ( time_t )pLog->dpCalibrationImage.calibrationUTC );

					pPhysChan->SetEquation( Eq ); //	{m_Equation = Eq;}

					// set zero point offset
					pPhysChan->SetOffset( pLog->zero_point_offset );
					break;
				}

				case CLog::ect_Temp1:
				{
					CEquation Eq;
					Eq.SetSensorType( ( CEquation::eSensorType )pLog->temp1SensorCalibrationImage.type );
					Eq.SetSensorMac( pLog->temp1SensorCalibrationImage.macAdress );
					Eq.SetSensorVersion( pLog->temp1SensorCalibrationImage.version );
					
					Eq.PatchEquation( pLog->temp1SensorCalibrationImage );
					
					Eq.SetEquationCoefs( 0, pLog->temp1SensorCalibrationImage.equationVariableK );
					Eq.SetEquationCoefs( 1, pLog->temp1SensorCalibrationImage.equationVariableA );
					Eq.SetEquationCoefs( 2, pLog->temp1SensorCalibrationImage.equationVariableB );
					Eq.SetEquationCoefs( 3, pLog->temp1SensorCalibrationImage.equationVariableC );
					Eq.SetEquationCoefs( 4, pLog->temp1SensorCalibrationImage.equationVariableD );

					// set calibration date
					Eq.SetCalibrationDate( ( time_t )pLog->temp1SensorCalibrationImage.calibrationUTC );

					pPhysChan->SetEquation( Eq ); //	{m_Equation = Eq;}

					// set zero point offset
					pPhysChan->SetOffset( 0 );
					break;
				}

				case CLog::ect_Temp2:
				{
					CEquation Eq;

					Eq.SetSensorType( ( CEquation::eSensorType )pLog->temp1SensorCalibrationImage.type );
					Eq.SetSensorMac( pLog->temp1SensorCalibrationImage.macAdress );
					Eq.SetSensorVersion( pLog->temp1SensorCalibrationImage.version );
					
					Eq.PatchEquation( pLog->temp2SensorCalibrationImage );
					
					Eq.SetEquationCoefs( 0, pLog->temp2SensorCalibrationImage.equationVariableK );
					Eq.SetEquationCoefs( 1, pLog->temp2SensorCalibrationImage.equationVariableA );
					Eq.SetEquationCoefs( 2, pLog->temp2SensorCalibrationImage.equationVariableB );
					Eq.SetEquationCoefs( 3, pLog->temp2SensorCalibrationImage.equationVariableC );
					Eq.SetEquationCoefs( 4, pLog->temp2SensorCalibrationImage.equationVariableD );

					// set calibration date
					Eq.SetCalibrationDate( ( time_t )pLog->temp2SensorCalibrationImage.calibrationUTC );

					pPhysChan->SetEquation( Eq ); //	{m_Equation = Eq;}

					// set zero point offset
					pPhysChan->SetOffset( 0 );
					break;
				}

				default:
					break;
			}

			// Fill data

			pPhysChan->SetSize( pLog->shortInfo.numberOfSamples );
			uint16_t i;
			unsigned char ucValid;

			for( i = 0; i < pLog->shortInfo.numberOfSamples; i++ )
			{
				switch( pPhysChan->GetChanType() )
				{
					case CLog::ect_Dp:
						pPhysChan->AddRawData( pLog->firstSample[i].dpRawValue );

						if( ( DP_VALID & pLog->firstSample[i].validate ) == 0 )
						{
							ucValid = 1;    // Data Error
						}
						else
						{
							ucValid = 0;    // Data OK
						}

						pPhysChan->AddValidationData( ucValid );
						break;

					case CLog::ect_Temp1:
						pPhysChan->AddRawData( pLog->firstSample[i].temp1RawValue );

						if( ( DTS1_VALID & pLog->firstSample[i].validate ) == 0 )
						{
							ucValid = 1;    // Data Error
						}
						else
						{
							ucValid = 0;    // Data OK
						}

						pPhysChan->AddValidationData( ucValid );
						break;

					case CLog::ect_Temp2:
						pPhysChan->AddRawData( pLog->firstSample[i].temp2RawValue );

						if( ( DTS2_VALID & pLog->firstSample[i].validate ) == 0 )
						{
							ucValid = 1;    // Data Error
						}
						else
						{
							ucValid = 0;    // Data OK
						}

						pPhysChan->AddValidationData( ucValid );
						break;

					default:
						break;
				}

				// Pay attention: we must check status to see if log has not been stopped. In this
				// case, we must stop reading.
				// Remarks: when a log is running, last packet after the valid one will have a status set to -1 (and all other data to -1).
				// For all other cases, status will be set to 'NORMAL_END', 'STOP_BY_OPERATOR', 'STOP_BAT_LOW' or 'STOP_POWER_OFF' and
				// datas with this packet are valid.
				if( pLog->firstSample[i].status != IN_COURSE )
				{
					break;
				}
			}

			/*
						// If log is already running, the last packet added in "for" above must be deleted.
						if(i < pLog->shortInfo.numberOfSamples && pLog->firstSample[i].status != IN_COURSE)
						{
							// In this case, if we have received 10 packets (i = 9), the last one is not correct. If we set size to i (9) we delete
							// the last packet.
							//int j = pPhysChan->GetDataArraySize();
							pPhysChan->SetNewSize(i);
							//j = pPhysChan->GetDataArraySize();
							// The correc t status is in the ninth packet (i-1 because 0-indexed).
							pclDestinationLogDataX->SetLogStatus(pLog->firstSample[i - 1].status);
						}
						else
							pclDestinationLogDataX->SetLogStatus(pLog->firstSample[i].status);
			*/
			switch( pLog->firstSample[i].status )
			{
				case FF_PADDING:	// Log is still running
				{
					if( 0 == i )		// Not yet any sample stored
					{
						pLDX->SetLogStatus( EMPTY_LOG );
						pPhysChan->SetNewSize( 0 );
					}
					else if( i < pLog->shortInfo.numberOfSamples )	// Normal case
					{
						pLDX->SetLogStatus( IN_COURSE );
						pPhysChan->SetNewSize( i );
					}
					else	// Abnormal, end of log but no status found
					{
						pLDX->SetLogStatus( NORMAL_END );
					}

				}
				break;

				case NORMAL_END:	// Log finished normaly, last sample is valid
				{
					pLDX->SetLogStatus( NORMAL_END );
				}
				break;

				case STOP_BY_OPERATOR:	// Log finished before normal end, last sample is not valid
				case STOP_BAT_LOW:
				case STOP_POWER_OFF:
				{
					pLDX->SetLogStatus( pLog->firstSample[i].status );
					pPhysChan->SetNewSize( i );
				}
				break;

				default:	// Abnormal, end of log but no known status found, last sample is not valid
				{
					pLDX->SetLogStatus( UNKNOWN_LOG );
					pPhysChan->SetNewSize( i );
				}
				break;
			}
		}
	}

}
#endif

bool CDS_LogDataX::_SetLogTypeTerminate( LogType logtype, uint8_t uiTempSensorUsed )
{
	switch( logtype )
	{
		case LOGTYPE_DP:
		{
			CChan *pChanDp = AddPhysicalChan( CLog::ect_Dp, CLog::ect_Dp );

			if( NULL != pChanDp )
			{
				return true;
			}
		}
		break;

		case LOGTYPE_TEMP:
		{
			CChan *pChanT = NULL;

			if( uiTempSensorUsed & 0x01 )
			{
				pChanT = AddPhysicalChan( CLog::ect_Temp1, CLog::ect_Temp1 );
			}
			else if( uiTempSensorUsed & 0x02 )
			{
				pChanT = AddPhysicalChan( CLog::ect_Temp2, CLog::ect_Temp2 );
			}

			if( pChanT )
			{
				return true;
			}
		}
		break;

		case LOGTYPE_DPTEMP:
		{
			CChan *pChanDp = AddPhysicalChan( CLog::ect_Dp, CLog::ect_Dp );

			CChan *pChanT = NULL;

			if( uiTempSensorUsed & 0x01 )
			{
				pChanT = AddPhysicalChan( CLog::ect_Temp1, CLog::ect_Temp1 );
			}
			else if( uiTempSensorUsed & 0x02 )
			{
				pChanT = AddPhysicalChan( CLog::ect_Temp2, CLog::ect_Temp2 );
			}

			if( NULL != pChanT && NULL != pChanDp )
			{
				return true;
			}
		}
		break;

		case LOGTYPE_DT:
		{
			CChan *pChanT1 = AddPhysicalChan( CLog::ect_Temp1, CLog::ect_Temp1 );
			CChan *pChanT2 = AddPhysicalChan( CLog::ect_Temp2, CLog::ect_Temp2 );

			if( NULL != pChanT1 && NULL != pChanT2 )
			{
				if( AddDeltaTChan( pChanT1->GetKey(), pChanT2->GetKey() ) )
				{
					return true;
				}
			}
		}
		break;

		case LOGTYPE_FLOW:
		{
			CChan *pChan = AddPhysicalChan( CLog::ect_Dp, CLog::ect_Dp );

			if( NULL != pChan )
			{
				if( AddFlowChan( pChan->GetKey() ) > -1 )
				{
					return true;
				}
			}
		}
		break;

		case LOGTYPE_POWER:
		{
			CChan *pChanDp = AddPhysicalChan( CLog::ect_Dp, CLog::ect_Dp );
			CChan *pChanT1 = AddPhysicalChan( CLog::ect_Temp1, CLog::ect_Temp1 );
			CChan *pChanT2 = AddPhysicalChan( CLog::ect_Temp2, CLog::ect_Temp2 );

			if( NULL != pChanDp && NULL != pChanT1 && NULL != pChanT2 )
			{
				AddDeltaTChan( pChanT1->GetKey(), pChanT2->GetKey() );
				int QKey = AddFlowChan( pChanDp->GetKey() );

				if( QKey > 0 )
				{
					AddPowerChan( QKey, pChanT1->GetKey(), pChanT2->GetKey() );
					return true;
				}
			}
		}
		break;

		case LOGTYPE_FLOWTEMP:
		{
			CChan *pChan = AddPhysicalChan( CLog::ect_Dp, CLog::ect_Dp );
			CChan *pChanT = NULL;

			if( uiTempSensorUsed & 0x01 )
			{
				pChanT = AddPhysicalChan( CLog::ect_Temp1, CLog::ect_Temp1 );
			}
			else if( uiTempSensorUsed & 0x02 )
			{
				pChanT = AddPhysicalChan( CLog::ect_Temp2, CLog::ect_Temp2 );
			}

			if( NULL != pChan && NULL != pChanT )
			{
				if( AddFlowChan( pChan->GetKey() ) > -1 )
				{
					return true;
				}
			}
		}
		break;

		default:
			break;
	}

	ClearLogChan();
	return false;
}
#endif //ifndef PRODUCTION
