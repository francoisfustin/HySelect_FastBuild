////////////////////////////////////////////////////////////////////////// 
//  DataBObj.cpp : implementation file
//	Version: 1.0							Date: 10/04/08
//  Version: 1.1								  30/04/08
//////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#ifdef TACBX
#include "peg.hpp"
#include "cbx_res.hpp"
#endif

#include "global.h"			// needed for TA-CBX

#include <math.h>
#include <float.h>
#include <cwchar>
#include <sstream>
#include "stdarg.h"
#ifndef TACBX
#include "HiPerfTimer.h"
#include "TASelect.h"
#endif
#include "Units.h"
#include "Utilities.h"
#include "DataBase.h"
#include "Hydronic.h"
#include "DataBObj.h"
#ifdef TACBX
#include "TADBAccess.hpp"
#include "TAPersist.hpp"
#endif
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_DblInt
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_DblInt)

CDB_DblInt::CDB_DblInt( CDataBase *pDataBase, LPCTSTR ID )
	:CData( pDataBase, ID )
{
	m_iValue1 = 0;
	m_iValue2 = 0;
}

void CDB_DblInt::SetVal1( int iValue ) 
{
	if( m_iValue1 != iValue )
	{
		m_iValue1 = iValue;
		Modified();
	}
}

void CDB_DblInt::SetVal2( int iValue ) 
{
	if( m_iValue2 != iValue )
	{
		m_iValue2 = iValue;
		Modified();
	}
}

void CDB_DblInt::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = 1;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CData::Write( outf );
	
	// Info.
	outf.write( (char *)&m_iValue1, sizeof( m_iValue1 ) );
	outf.write( (char *)&m_iValue2, sizeof( m_iValue2 ) );
}

bool CDB_DblInt::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > 1 )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Info.
	inpf.read( (char *)&m_iValue1, sizeof( m_iValue1 ) );
	inpf.read( (char *)&m_iValue2, sizeof( m_iValue2 ) );
	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_String
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_String)

CDB_String::CDB_String( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
	m_pStr = NULL;
}

LPCTSTR CDB_String::GetString() 
{ 
	m_pStr = GetpXmlStrTab()->GetIDSStr( m_String );

	if( NULL != m_pStr )
	{
		return m_pStr->c_str();
	}
	else
	{
		return m_String.c_str();
	}
}

void CDB_String::SetString( const TCHAR *ptcString ) 
{
	if( 0 != m_String.compare( ptcString ) )
	{
		m_String = ptcString;
		Modified();
	}
}

void CDB_String::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_String *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_String' object!") );
		}

		// Base class.
		CData::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_String" class.
		CDB_String *pclDestinationString = (CDB_String *)pclDestination;
		
		pclDestinationString->SetString( m_String.c_str() );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_String::Copy' method with the object '%s'."), GetIDPtr().ID )
}

void CDB_String::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = 1;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CData::Write( outf );

	// Info.
	WriteString( outf, m_String.c_str() );
}

bool CDB_String::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > 1 )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Info.
	if( false == ReadString( inpf, m_String ) )
	{
		return false;
	}

	return true;
}

#ifndef TACBX 
void CDB_String::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_String format
		// line 0 : open curve bracket and call base class.
		// line 1 : size name
		// line 2 : close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Read base.
		CData::ReadText( inpf, pusLineCount );
	
		ptcLine = ReadTextLine( inpf, pusLineCount );
		
		if( _T('"') != *ptcLine )
		{
			HYSELECT_THROW( _T("'m_String' variable must start with \" (pos: %i)."), *pusLineCount );
		}

		int iLength = _tcslen( ptcLine );

		if( _T('"') != ptcLine[iLength - 1] )
		{
			HYSELECT_THROW( _T("'m_String' variable must end with \" (pos: %i)."), *pusLineCount );
		}
	
		if( iLength > ( 50 + 2 ) )
		{
			HYSELECT_THROW( _T("'m_String' variable length is too long (%i > %i) (pos: %i)."), iLength, ( 50 + 2 ), *pusLineCount );
		}

		ptcLine[iLength - 1] = _T('\0');
		SetString(ptcLine + 1);

		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_String::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

const IDPTR &ScanStringTable( CTable *pTable, LPCTSTR str )
{
	for( IDPTR idptr = pTable->GetFirst( CLASS(CDB_String) ); _T('\0') != *idptr.ID; idptr = pTable->GetNext() )
	{
		if( 0 == _tcscmp( ( (CDB_String *)idptr.MP )->GetString(), str ) )
		{
			return idptr.MP->GetIDPtr();
		}
	}

	return _NULL_IDPTR;
}

const IDPTR &ScanStringTable(const IDPTR &TabIDPtr, LPCTSTR str)
{
	ASSERT( NULL != TabIDPtr.MP && true == TabIDPtr.MP->IsClass( CLASS( CTable ) ) );
	return ScanStringTable((CTable*)TabIDPtr.MP, str);
}
#endif 

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_DblString
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_DblString)

CDB_DblString::CDB_DblString( CDataBase *pDataBase, LPCTSTR ID )
	:CData( pDataBase, ID )
{
	*m_String1 = _T('\0');
	*m_String2 = _T('\0');
}

void CDB_DblString::OnDatabaseDestroy()
{
	CData::OnDatabaseDestroy();
}

void CDB_DblString::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = 1;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CData::Write( outf );

	// Info.
	WriteString( outf, m_String1 );
	WriteString( outf, m_String2 );

}

bool CDB_DblString::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > 1 )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Info.
	if( false == ReadString( inpf, m_String1, sizeof( m_String1 ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_String2, sizeof( m_String2 ) ) )
	{
		return false;
	}

	return true;
}

#ifndef TACBX 
void CDB_DblString::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_DblString format
		// line 0 : open curve bracket and call base class.
		// line 1 : string 1
		// line 2 : string 2
		// line 3 : close curve bracket

		// Skip the open curve bracket
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Read base.
		CData::ReadText( inpf, pusLineCount );
	
		// String 1.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('"') != *ptcLine )
		{
			HYSELECT_THROW( _T("'m_String1' variable must start with \" (pos: %i)."), *pusLineCount );
		}

		int iLength = _tcslen( ptcLine );

		if( _T('"') != ptcLine[iLength - 1] )
		{
			HYSELECT_THROW( _T("'m_String1' variable must end with \" (pos: %i)."), *pusLineCount );
		}

		if( iLength > ( _DBLSTRING_LENGTHSTR1 + 2 ) )
		{
			HYSELECT_THROW( _T("'m_String1' variable length is too long (%i > %i) (pos: %i)."), iLength, (  _DBLSTRING_LENGTHSTR1 + 2 ), *pusLineCount );
		}

		ptcLine[iLength - 1] = _T('\0');
		_tcsncpy_s( m_String1, SIZEOFINTCHAR( m_String1 ), ptcLine + 1, SIZEOFINTCHAR( m_String1 ) - 1 );

		// String 2.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('"') != *ptcLine )
		{
			HYSELECT_THROW( _T("'m_String2' variable must start with \" (pos: %i)."), *pusLineCount );
		}

		iLength = _tcslen( ptcLine );

		if( _T('"') != ptcLine[iLength - 1] )
		{
			HYSELECT_THROW( _T("'m_String2' variable must end with \" (pos: %i)."), *pusLineCount );
		}

		if( iLength > ( _DBLSTRING_LENGTHSTR2 + 2 ) )
		{
			HYSELECT_THROW( _T("'m_String2' variable length is too long (%i > %i) (pos: %i)."), iLength, (  _DBLSTRING_LENGTHSTR2 + 2 ), *pusLineCount );
		}

		ptcLine[iLength - 1] = _T('\0');
		_tcsncpy_s( m_String2, SIZEOFINTCHAR( m_String2 ), ptcLine + 1, SIZEOFINTCHAR( m_String2) - 1 );
	
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_DblString::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif
///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_StringID
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_StringID)

CDB_StringID::CDB_StringID( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_String( pDataBase, ID )
{
	*m_IDstr = _T('\0');
	*m_IDstr2 = _T('\0');
}

void CDB_StringID::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = 1;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CDB_String::Write( outf );

	// Info.
	WriteString( outf, m_IDstr );
	WriteString( outf, m_IDstr2 );
}

bool CDB_StringID::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > 1 )
	{
		return false;
	}

	// Base class.
	if( false == CDB_String::Read( inpf ) )
	{
		return false;
	}

	// Info.
	if( false == ReadString( inpf, m_IDstr, _ID_LENGTH + 1 ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_IDstr2, _ID_LENGTH + 1 ) )
	{
		return false;
	}

	return true;
}

#ifndef TACBX 
void CDB_StringID::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_StringID format
		// line 0 : open curve bracket and call base class.
		// line 1 : 'm_IDstr'
		// line 2 : 'm_IDstr2'
		// line 3 : close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Read base.
		CDB_String::ReadText( inpf, pusLineCount );

		// Read 'm_IDstr'.
		ptcLine = ReadTextLine( inpf, pusLineCount );
	
		// If first character is '#' the string must be interpreted as a enum.
		if( _T('#') == *ptcLine )
		{
			CString str = ptcLine;
			int iValue = ReadEnum( str );

			if( INT_MAX == iValue )
			{
				HYSELECT_THROW( _T("Enum value for 'm_IDstr' variable is incorrect (pos: %i)."), str, *pusLineCount );
			}

			str.Format( _T("%d"), iValue );
			_tcsncpy_s( m_IDstr, SIZEOFINTCHAR( m_IDstr),(LPCTSTR) str, SIZEOFINTCHAR( m_IDstr) - 1 );
		}
		else
		{
			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("'m_IDstr' variable length is too long (%i > %i) (pos: %i)."), _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			if( _T('+') == ptcLine[0] && _T('+') == ptcLine[1] )
			{
				int iCount = GetIDPtr().PP->GetItemCount();
				// HYS-883: iCount has the good value not need to be increment
				swprintf( m_IDstr, SIZEOFINTCHAR( m_IDstr ), _T("%d"), iCount );
			}
			else
			{
				_tcsncpy_s( m_IDstr, SIZEOFINTCHAR( m_IDstr ), ptcLine, SIZEOFINTCHAR( m_IDstr ) - 1 );
			}
		}
	
		// Read 'm_IDstr2'.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		// If first character is '#' the string must be interpreted as a enum.
		if( _T('#') == *ptcLine )
		{
			CString str = ptcLine;
			int iValue = ReadEnum( str );

			if( INT_MAX == iValue )
			{
				HYSELECT_THROW( _T("Enum value for 'm_IDstr2' variable is incorrect (pos: %i)."), str, *pusLineCount );
			}

			str.Format( _T("%d"), iValue );
			_tcsncpy_s( m_IDstr2, SIZEOFINTCHAR( m_IDstr),(LPCTSTR) str, SIZEOFINTCHAR( m_IDstr) - 1 );
		}
		else
		{
			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("'m_IDstr2' variable length is too long (%i > %i) (pos: %i)."), _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}
		
			if( _T('+') == ptcLine[0] && _T('+') == ptcLine[1] )
			{
				int iCount = GetIDPtr().PP->GetItemCount();
				// HYS-883: iCount has the good value not need to be increment
				swprintf( m_IDstr, SIZEOFINTCHAR( m_IDstr ), _T("%d"), iCount );
			}
			else
			{
				_tcsncpy_s( m_IDstr2, SIZEOFINTCHAR( m_IDstr2 ), ptcLine, SIZEOFINTCHAR( m_IDstr2 ) - 1 );
			}
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		
		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_StringID::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

const IDPTR &ScanStringIDTable(CTable *pTable, LPCTSTR str )
{
	for( IDPTR idptr = pTable->GetFirst( CLASS( CDB_StringID ) ); _T('\0') != *idptr.ID; idptr = pTable->GetNext() )
	{
		if( 0 == _tcscmp( ( (CDB_StringID *)idptr.MP )->GetString(), str ) )
		{
			return idptr.MP->GetIDPtr();
		}
	}

	return _NULL_IDPTR;
}

const IDPTR &ScanStringIDTable(const IDPTR &TabIDPtr, LPCTSTR str )
{
	ASSERT( NULL != TabIDPtr.MP && true == TabIDPtr.MP->IsClass( CLASS( CTable ) ) );
	return ScanStringIDTable( (CTable *)TabIDPtr.MP, str );
}
#endif 

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_Connect
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_Connect)

CDB_Connect::CDB_Connect( CDataBase *pDataBase, LPCTSTR ID )
	:CDB_StringID( pDataBase, ID )
{
	m_DNMinIDPtr = _NULL_IDPTR;
	m_DNMaxIDPtr = _NULL_IDPTR;
}

void CDB_Connect::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = 1;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CDB_StringID::Write( outf );

	// Info.
	WriteString( outf, m_DNMinIDPtr.ID );
	WriteString( outf, m_DNMaxIDPtr.ID );
}

bool CDB_Connect::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > 1 )
	{
		return false;
	}

	// Base class.
	if( false == CDB_StringID::Read( inpf ) )
	{
		return false;
	}

	// Info.
	m_DNMinIDPtr = _NULL_IDPTR;
	m_DNMaxIDPtr = _NULL_IDPTR;

	if( false == ReadString( inpf,m_DNMinIDPtr.ID, sizeof( m_DNMinIDPtr.ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf,m_DNMaxIDPtr.ID, sizeof( m_DNMaxIDPtr.ID ) ) )
	{
		return false;
	}

	if( _T('\0') != *m_DNMinIDPtr.ID )
	{
		m_DNMinIDPtr.DB = GetDB();
	}

	if( _T('\0') != *m_DNMaxIDPtr.ID )
	{
		m_DNMaxIDPtr.DB = GetDB();
	}

	return true;
}

void CDB_Connect::CrossVerifyID() 
{ 
	HYSELECT_TRY
	{
		CDB_StringID::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( _T('\0') != *m_DNMinIDPtr.ID && 0 != _tcscmp( _NO_ID, m_DNMinIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_DNMinIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("DN min ID (%s) is defined but not found in the database."), m_DNMinIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("DN min ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_DNMinIDPtr.ID );
			}
		}
	
		if( _T('\0') != *m_DNMaxIDPtr.ID && 0 != _tcscmp( _NO_ID, m_DNMaxIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_DNMaxIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("DN max ID (%s) is defined but not found in the database."), m_DNMaxIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("DN max ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_DNMaxIDPtr.ID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_Connect::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

#ifndef TACBX 
void CDB_Connect::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_Connect format
		// line 0 : open curve bracket and call base class.
		// line 1 : ID 
		// line 2 : close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Read base.
		CDB_StringID::ReadText( inpf, pusLineCount );
	
		// Read m_DNMinIDPtr.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _tcslen( ptcLine ) > _ID_LENGTH )
		{
			HYSELECT_THROW( _T("'m_DNMinIDPtr' variable length is too long (%i > %i) (pos: %i)."), _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
		}

		_tcsncpy_s( m_DNMinIDPtr.ID, SIZEOFINTCHAR( m_DNMinIDPtr.ID ), ptcLine, SIZEOFINTCHAR( m_DNMinIDPtr.ID ) - 1 );
		m_DNMinIDPtr.DB = GetDB();
	
		// Read m_DNMaxIDPtr.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _tcslen( ptcLine ) > _ID_LENGTH )
		{
			HYSELECT_THROW( _T("'m_DNMaxIDPtr' variable length is too long (%i > %i) (pos: %i)."), _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
		}

		_tcsncpy_s( m_DNMaxIDPtr.ID, SIZEOFINTCHAR( m_DNMaxIDPtr.ID ), ptcLine, SIZEOFINTCHAR( m_DNMaxIDPtr.ID ) - 1 );
		m_DNMaxIDPtr.DB = GetDB();

		// Close bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Connect::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif 

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_MultiString
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_MultiString )

CDB_MultiString::CDB_MultiString( CDataBase *pDataBase, LPCTSTR ID )
	:CData( pDataBase, ID )
{
	m_pStr = NULL;
}

void CDB_MultiString::RemoveKey( int iKey )
{
	m_MapList.erase( iKey );
}

void CDB_MultiString::AddKey( int iKey, _string strValue )
{
	if( m_MapList.size() > 0 )
	{
		_StrMap::iterator it = m_MapList.find( iKey );

		if( it == m_MapList.end() )
		{
			m_MapList.insert( std::pair<int, _string>( iKey, strValue) );
		}
		else
		{
			SetString( iKey, strValue );
		}
	}
	else
	{
		SetString( iKey, strValue );
	}
}

LPCTSTR CDB_MultiString::GetString( int iKey )
{
	_StrMap::iterator it;
	m_pStr = NULL;
	
	if( m_MapList.size() > 0 )
	{
		it = m_MapList.find( iKey );

		if( it != m_MapList.end() )
		{
			m_pStr = GetpXmlStrTab()->GetIDSStr( it->second );

			if( NULL != m_pStr )
			{
				return m_pStr->c_str();
			}
			else
			{
				return it->second.c_str();
			}
		}
	}

	return _T("");
}

#ifndef TACBX //TACBX////////////////////////////////////////////////////////
bool CDB_MultiString::IsStrIndexTrue( int iIndex )
{
	CString str = GetString( iIndex );
	str.MakeLower();
	return ( str == _T("true") );
}
#endif

//	Search into the string list a string that contains SubString, return a string with the found string.
//	if RemoveSubString is true remove characters from 0 to separator ("=;,:") from the found string, return the new string.
_string CDB_MultiString::SearchSubString( _string SubStr, bool bRemoveSubString )
{
	_StrMap::iterator it;

	for( it = m_MapList.begin(); it != m_MapList.end(); ++it )
	{
		_string str = it->second;
		unsigned int iPos = str.find(SubStr);

		if( _string::npos != iPos )
		{	
			if( true == bRemoveSubString )
			{
				iPos = str.find_first_of( _T("=;,:") );
				str.erase( 0, iPos + 1 );
				
				// Trim left.
				iPos = (int)str.find_first_not_of( _T(" ") );

				if( 0 != iPos && _string::npos != iPos )
				{
					str.erase( 0, iPos );
				}
			}
			
			return str;
		}
	}
	
	return( _T("") );
}

bool CDB_MultiString::SetString( int iKey, _string str )
{
	m_MapList.erase( iKey );
	m_MapList[iKey] = str;	
	return true;
}

void CDB_MultiString::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = 2;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CData::Write( outf );
	
	// Info.
	int j = m_MapList.size();
	outf.write( (char *)&j, sizeof( j ) );

	// Each line.
	for(_StrMap::iterator it = m_MapList.begin(); it != m_MapList.end(); ++it )
	{
		outf.write( (char *)&it->first, sizeof( it->first ) );
		WriteString( outf, (LPCTSTR)it->second.c_str() );
	}
}

bool CDB_MultiString::Read( INPSTREAM inpf )
{
	m_MapList.clear();
	
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > 2 )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Infos.
	// Number of lines.
	int j;
	inpf.read( (char *)&j, sizeof( j ) );

	// m_bExt set to bool for version above 1 or for reading CDB_MultiString
	bool m_bExt = ( Version > 1 || (dynamic_cast<CDB_MultiStringExt *>( this ) != 0 ) );
	
	// Each line.
	_string str;

	for( int i = 0; i < j; i++ )
	{
		int iKey = i;

		if( true == m_bExt )
		{
			inpf.read( (char *)&iKey, sizeof( iKey ) );
		}
		
		if( false == ReadString( inpf, str ) )
		{
			return false;
		}

		bool bRet = SetString( iKey, str );
		ASSERT( true == bRet );
	}
	
	return true;
}

void CDB_MultiString::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_MultiString *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pToData' argument is not a 'CDB_MultiString' object!") );
		}

		// Base class.
		CData::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_MultiString" class.
		CDB_MultiString *pclDestinationMultiString = (CDB_MultiString *)pclDestination;

		// Each line.
		for( _StrMap::iterator it = m_MapList.begin(); it != m_MapList.end(); ++it )
		{
			pclDestinationMultiString->SetString( it->first, it->second.c_str() );
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_MultiString::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#ifndef TACBX 
void CDB_MultiString::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_MultiString format
		// line 0 : open curve bracket and call base class.
		// line 1 : first text line
		// line 2 : second text line
		// line ..
		// line 1+nline : last text line
		// line 2+nline : close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Read base.
		CData::ReadText( inpf, pusLineCount );

		m_MapList.clear();
		int iLength;	

		for( int i = 0; i < 100; i++ )					// Maximum 100 lines
		{
			ptcLine = ReadTextLine( inpf, pusLineCount );		

			if( _T('}') == *ptcLine )
			{
				break;
			}
		
			if( _T('"') != *ptcLine )
			{
				HYSELECT_THROW( _T("String must start with \" (pos: %i)."), *pusLineCount );
			}
		
			iLength = _tcslen( ptcLine );

			if( _T('"') != ptcLine[iLength - 1] )
			{
				HYSELECT_THROW( _T("String must end with \" (pos: %i)."), *pusLineCount );
			}

			ptcLine[iLength - 1] = _T('\0');
			SetString(i, ptcLine + 1 );
		}
		
		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_MultiString::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif 

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_MultiStringExt
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_MultiStringExt)

CDB_MultiStringExt::CDB_MultiStringExt( CDataBase *pDataBase, LPCTSTR ID )
	:CDB_MultiString( pDataBase, ID )
{
}

#ifndef TACBX 
void CDB_MultiStringExt::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_MultiStringExt format
		// line 0 : open curve bracket and call base class.
		// line 1 : ##TADB_Enum "text line"
		// line 2 : ##TADB_Enum "text line"
		// line ..
		// line 1+nline : ##TADB_Enum "text line"
		// line 2+nline : close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Read base.; into Txt file CDB_MultistringExt is readed as a CDB_MultiString with a parsing function 
		CData::ReadText( inpf, pusLineCount );

		m_MapList.clear();

		int iLength;	
		int	iKey;
		CString str;
	
		for( int i = 0; i < 100; i++ )					// Maximum 100 lines
		{
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _T('}') == *ptcLine )
			{
				break;
			}

			ParseEnumStrLine( inpf, CString( ptcLine ), iKey, str );

			iLength = _tcslen( ptcLine );

			if( _T('"') != ptcLine[iLength - 1] )
			{
				HYSELECT_THROW( _T("String must end with \" (pos: %i)."), *pusLineCount );
			}

			SetString( iKey, (LPCTSTR)str );
		}

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_MultiStringExt::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_MultiStringOrdered
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_MultiStringOrdered)

CDB_MultiStringOrdered::CDB_MultiStringOrdered( CDataBase *pDataBase, LPCTSTR ID )
	:CDB_MultiString( pDataBase, ID )
{
	m_iKeyOrder = -1;
}

void CDB_MultiStringOrdered::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = 1;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CDB_MultiString::Write( outf );

	// Info.
	outf.write( (char *)&m_iKeyOrder, sizeof( m_iKeyOrder ) );
}

bool CDB_MultiStringOrdered::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > 1 )
	{
		return false;
	}

	// Base class.
	if( false == CDB_MultiString::Read( inpf ) )
	{
		return false;
	}

	// Info
	m_iKeyOrder = 0;
	inpf.read( (char *)&m_iKeyOrder, sizeof( m_iKeyOrder ) );
	return true;
}

#ifndef TACBX 
void CDB_MultiStringOrdered::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_MultiString format
		// line 0 : open curve bracket and call CDB_MultiString base class.
		// line 1 : first text line
		// line 2 : second text line
		// line ..
		// line 1+nline : last text line
		// line 2+nline : close curve bracket
		// line 3+nline : Key number.
		// line 4+nline : close curve bracket.

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Read base.; into Txt file CDB_MultiStringOrdered is readed as a CDB_MultiStringExt with a Key for sorting.
		CDB_MultiString::ReadText( inpf, pusLineCount );

		// Read the Key Order.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( 0 == _ttoi( ptcLine ) )
		{
			HYSELECT_THROW( _T("'m_iKeyOrder' variable can't bet 0 (pos: %i)."), *pusLineCount );
		}

		SetKeyOrder( _ttoi( ptcLine ) );

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_MultiStringOrdered::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif


///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_Doc
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_Doc)

CDB_Doc::CDB_Doc( CDataBase *pDataBase, LPCTSTR ID )
	:CDB_MultiStringOrdered( pDataBase, ID )
{
}

bool CDB_Doc::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > 1 )
	{
		return false;
	}

	//----------------------
	// CDB_MultiString
	//----------------------
	m_MapList.clear();
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > 2 )		// CDB_MultiString
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Number of lines.
	int j;
	inpf.read( (char *)&j, sizeof( j ) );

	// Each line.
	_string str;
	
	// m_bExt set to bool for version above 1 or for reading CDB_MultiString
	bool m_bExt = ( Version > 1 || ( dynamic_cast<CDB_MultiStringExt *>( this ) != 0 ) );
	
	for( int i = 0; i < j; i++ )
	{
		int iKey = i;

		if( true == m_bExt )
		{
			inpf.read( (char *)&iKey, sizeof( iKey ) );
		}
		
		if( false == ReadString( inpf, str ) )
		{
			return false;
		}

#ifndef TACBX 
		if( 1 == i )
		{
			// The doc extension is unknown because not always the same language  as the trigram
			// The extension is replace by "???" that will be skip in the comparison task
			int iPos = str.rfind(L".pdf");

			if( iPos > 0 )
			{
				str.erase( iPos );
				str += _T("???.pdf");
			}
		}			
		
		bool bRet = SetString( iKey, str );
		ASSERT( true == bRet );
#endif
	}

	// Info.
	m_iKeyOrder=0;
	inpf.read( (char *)&m_iKeyOrder, sizeof( m_iKeyOrder ) );
	return true;
}

#ifndef TACBX 
void CDB_Doc::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_MultiString format
		// line 0 : open curve bracket and call CDB_MultiString base class.
		// line 1 : first text line
		// line 2 : second text line
		// line ..
		// line 1+nline : last text line
		// line 2+nline : close curve bracket
		// line 3+nline : Key number.
		// line 4+nline : close curve bracket.

		//const static CDB_MultiString* pExtParam = (CDB_MultiString*)GetDB()->Get(_T("DOCEXT_PARAM")).MP;

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Skip the open curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("Second line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Read base.
		CData::ReadText( inpf, pusLineCount );

		m_MapList.clear();

		int iLength;

		for( int i = 0; i < 4; i++ )
		{
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _T('}') == *ptcLine )
			{
				break;
			}
		
			if( _T('"') != *ptcLine )
			{
				HYSELECT_THROW( _T("String must start with \" (pos: %i)."), *pusLineCount );
			}

			iLength = _tcslen( ptcLine );

			{
				HYSELECT_THROW( _T("String must end with \" (pos: %i)."), *pusLineCount );
			}

			ptcLine[iLength - 1] = _T('\0');
			CString str = ptcLine;
			str.Remove('"');

#ifdef _DEBUG
			if( 1 == i )
			{
				// The doc extension is unknown because not always the same language  as the trigram
				// The extension is replace by "???" that will be skip in the comparison task
				int iPos = str.ReverseFind( '.' );

				if( iPos > 0 )
				{
					str.Delete(iPos,str.GetLength()-iPos);
					str += _T("???.pdf");
				}
			}			
#endif
			SetString( i, (_string)str );
		}

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}

		// Read the Key Order.
		ptcLine = ReadTextLine( inpf, pusLineCount ); 
		
		int iCount = 0;

		if( _T('+') == ptcLine[0] && _T('+') == ptcLine[1] )
		{
			iCount = GetIDPtr().PP->GetItemCount();
			iCount++;
		}
		else
		{
			if( 0 == _ttoi( ptcLine ) )
			{
				HYSELECT_THROW( _T("'m_iKeyOrder' variable can't be 0 (pos: %i)."), *pusLineCount );
			}

			iCount = _ttoi( ptcLine );
		}

		SetKeyOrder(iCount);
	
		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		
		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Doc::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_DefaultUnits
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_DefaultUnits)

CDB_DefaultUnits::CDB_DefaultUnits( CDataBase *pDataBase, LPCTSTR ID )
	:CDB_MultiString( pDataBase, ID )
{
}

int CDB_DefaultUnits::GetLocalizedDefaultUnits( int i )
{
	CUnitDatabase *pDB = CDimValue::AccessUDB();
	ASSERT( NULL != pDB );

	_string str = SearchSubString( _string( _UNIT_STRING_ID[i]), true );
	
	if( true == str.empty() )
	{
		return 0;
	}
	
	StrTrimRight( str );
	
	// Find the number associate to the unit dimension written in the TADB file.
	for( int k = 0; k < pDB->GetLength( i ); k++ ) 
	{
		const UnitDesign_struct &sUD = pDB->GetUnit( i, k );
		
		if( 0 == str.compare( sUD.Name ) )
		{
			return k;
		}
	}

#ifndef TACBX
	// Return 0 if the physical dimension doesn't match.
	CString strOut;
	
	// String below are only used into DataBase compilation.
	strOut.Format( _T("Unit dimension : %s for type %s in localDB.txt is not correctly written."), str.c_str(), CString( _UNIT_STRING_ID[i] ) );
	AfxMessageBox( strOut );
	AfxAbort();
#endif

	return 0;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_Curve
//
///////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DATA( CDB_Curve )
#define MAX_FUNC_INCURVE	5
CDB_Curve::CDB_Curve( CDataBase *pDataBase, LPCTSTR ID )
:CData( pDataBase, ID )
{
	m_pCurve = NULL;
}

CDB_Curve::~CDB_Curve()
{
	if( m_pCurve != NULL )
	{
		delete m_pCurve;
		m_pCurve = NULL;
	}
}

#define CDB_CURVE_VERSION	1
void CDB_Curve::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_CURVE_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CData::Write( outf );

	int nCurve = 0;
	int nSize = 0;

	if( NULL != m_pCurve )
	{
		nCurve = m_pCurve->GetFuncNumber();
		nSize = m_pCurve->GetSize();
	}
	
	outf.write( (char *)&nSize, sizeof( nSize ) );
	outf.write( (char *)&nCurve, sizeof( nCurve ) );

	if( 0 == nCurve || 0 == nSize )
	{
		return;
	}
	
	for( int i = 0; i < nSize; i++ )
	{
		double dX = m_pCurve->GetPointX( i );
		WriteDouble( outf, dX );

		for( int j = 0; j < nCurve; j++ )
		{
			double dY = m_pCurve->GetPointF( i, j );
			WriteDouble( outf, dY );
		}
	}
}

bool CDB_Curve::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_CURVE_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	if( NULL != m_pCurve )
	{
		delete m_pCurve;
		m_pCurve = NULL;
	}

	int nSize = -1;
	inpf.read( (char *)&nSize, sizeof( nSize ) );

	if( nSize < 2 )						// at least 2 points
	{
		return false;
	}

	int nCurve = -1;
	inpf.read( (char *)&nCurve, sizeof( nCurve ) );

	if( nCurve <= 0 || nCurve > MAX_FUNC_INCURVE )
	{
		return false;
	}

	m_pCurve = new CCurveFitter( nCurve );
	double *pdY = new double[nCurve];

	for( int i = 0; i < nSize; i++ )
	{
		double dX = ReadDouble( inpf );

		for( int j = 0; j < nCurve; j++ )
		{
			pdY[j] = ReadDouble( inpf );
		}

		// Add data to the "curve".
		m_pCurve->AddPoint( dX, pdY );
	}

	delete[] pdY;
	return true;
}

double CDB_Curve::GetXmin()
{
	if( NULL == m_pCurve )
	{
		ASSERTA_RETURN( DBL_MIN );
	}

	return m_pCurve->GetMinX();
}

double CDB_Curve::GetYmin( int iFunction )
{
	if( NULL == m_pCurve )
	{
		ASSERTA_RETURN( DBL_MIN );
	}
	
	return m_pCurve->GetMinFX( iFunction );
}

double CDB_Curve::GetXmax()
{
	if( NULL == m_pCurve )
	{
		ASSERTA_RETURN( DBL_MIN );
	}

	return m_pCurve->GetMaxX();

}

double CDB_Curve::GetBoundedY( double dX, int iFunction )
{
	if( NULL == m_pCurve )
	{
		ASSERTA_RETURN( DBL_MIN );
	}

	if( dX > GetXmax() )
	{
		dX = GetXmax();
	}

	if( dX < GetXmin() )
	{
		dX = GetXmin();
	}

	return m_pCurve->GetValue( dX, iFunction );
}

double CDB_Curve::GetYmax( int iFunction )
{
	if( NULL == m_pCurve )
	{
		ASSERT( 0 );
		return DBL_MIN;
	}
	
	return m_pCurve->GetMaxFX( iFunction );
}

#ifndef TACBX
void CDB_Curve::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		TCHAR *ptcEndPtr;

		// Read number of functions associated to the abscissa.	
		int iNFunc = 1;
	
		ReadIntFromTextLine( inpf, iNFunc, pusLineCount );

		if( iNFunc < 0 )
		{
			HYSELECT_THROW( _T("Number of functions (%i) can't be lower than 0 (pos: %i)."), iNFunc, *pusLineCount );
		}

		if( iNFunc > MAX_FUNC_INCURVE )
		{
			HYSELECT_THROW( _T("Number of functions (%i) can't be higher than %i (pos: %i)."), iNFunc, MAX_FUNC_INCURVE, *pusLineCount );
		}

		if( m_pCurve != NULL )
		{
			delete m_pCurve;
			m_pCurve = NULL;
		}

		m_pCurve = new CCurveFitter( iNFunc );

		if( NULL == m_pCurve )
		{
			HYSELECT_THROW( _T("Internal error: 'm_pCurve' instantiation error.") );
		}

		double *pdY = new double[iNFunc];

		if( NULL == pdY )
		{
			HYSELECT_THROW( _T("Internal error: 'pdY' instantiation error.") );
		}

		TCHAR **pptcField;

		do 
		{
			// Start the loop on lines.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _T('}') == *ptcLine )
			{
				break;
			}

			int nCheck = 0;
			pptcField = ParseTextLine( ptcLine, &nCheck );

			if( ( iNFunc + 1 ) != nCheck )
			{
				HYSELECT_THROW( _T("Number of fields in line is not correct (%i != %i) (pos: %i)."), nCheck, ( iNFunc + 1), *pusLineCount );
			}
		
			double dX = _tcstod( pptcField[0], &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't convert '%s' in double (pos: %i)."), pptcField[0], *pusLineCount );
			}

			for( int i = 1; i < nCheck; i++ )
			{
				pdY[i-1] = _tcstod( pptcField[i], &ptcEndPtr );
			
				if( _T('\0') != *ptcEndPtr )
				{
					HYSELECT_THROW( _T("Can't convert '%s' in double (pos: %i)."), pptcField[i], *pusLineCount );
				}
			}

			// Add data to the "curve".
			m_pCurve->AddPoint( dX, pdY );

		}while ( 1 );

		delete[] pdY;
	
		int nCurve = 0;
		int nSize = 0;
	
		if( NULL != m_pCurve )
		{
			nCurve = m_pCurve->GetFuncNumber();
			nSize = m_pCurve->GetSize();
		}
	
		if( 0 == nCurve )
		{
			HYSELECT_THROW( _T("Final check: number of function can't be 0.") );
		}

		if( 0 == nSize )
		{
			HYSELECT_THROW( _T("Final check: number of stored points can't be 0.") );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Curve::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif

void CDB_Curve::DeleteCurve()
{
	if( NULL != m_pCurve )
	{
		delete m_pCurve;
		m_pCurve = NULL;
	}
}

CCurveFitter *CDB_Curve::CreateNewCurve( int iCurve )
{
	HYSELECT_TRY
	{
		DeleteCurve();

		m_pCurve = new CCurveFitter( iCurve );

		if( NULL == m_pCurve )
		{
			HYSELECT_THROW_RETURNARG( _T("Internal error: 'm_pCurve' instantiation error."), NULL );
		}

		return m_pCurve;
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_Curve::CreateNewCurve' method with the object '%s'."), GetIDPtr().ID )
}

void CDB_Curve::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_Curve *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_Curve' object!") );
		}

		if( NULL == m_pCurve )
		{
			HYSELECT_THROW( _T("'m_pCurve' doesn't exist!") );
		}

		// Base class.
		CData::Copy( pclDestination );

		// Copy now what it is common to the "CDB_Curve".
		CDB_Curve *pclDestinationCurve = (CDB_Curve *)pclDestination;

		pclDestinationCurve->DeleteCurve();
		CCurveFitter *pclDestinationCurveFitter = pclDestinationCurve->CreateNewCurve( m_pCurve->GetFuncNumber() );

		if( NULL == pclDestinationCurveFitter )
		{
			HYSELECT_THROW( _T("Can't instantiate the 'pclDestinationCurveFitter' variable!") );
		}

		m_pCurve->Copy( pclDestinationCurveFitter );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_Curve::Copy' method with the object '%s'."), GetIDPtr().ID )
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_TBCurve
//
///////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DATA( CDB_TBCurve )
#define MAX_FUNC_INCURVE	5
CDB_TBCurve::CDB_TBCurve( CDataBase *pDataBase, LPCTSTR ID )
:CDB_Curve( pDataBase, ID )
{
	m_dqNmin = 0.0;
	m_dqNmax = 0.0;
	m_dPmin = 0.0;
	m_dPmax = 0.0;
	m_strCurveName = L"";
	m_pStr = NULL;
}

LPCTSTR CDB_TBCurve::GetCurveName()
{
	m_pStr = GetpXmlStrTab()->GetIDSStr( m_strCurveName );

	if( NULL != m_pStr )
	{
		return m_pStr->c_str();
	}
	else
	{
		return m_strCurveName.c_str();
	}
}

#define CDB_TBCURVE_VERSION	2
// Version 2: add 'm_iCurveNameIDS'.
void CDB_TBCurve::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_TBCURVE_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CDB_Curve::Write( outf );

	WriteDouble( outf, m_dqNmin );
	WriteDouble( outf, m_dqNmax );
	WriteDouble( outf, m_dPmin );
	WriteDouble( outf, m_dPmax );
	WriteString( outf, GetCurveName() );
}

bool CDB_TBCurve::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );
	
	if( Version < 1 || Version > CDB_TBCURVE_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDB_Curve::Read( inpf ) )
	{
		return false;
	}

	m_dqNmin = ReadDouble( inpf );
	m_dqNmax = ReadDouble( inpf );
	m_dPmin = ReadDouble( inpf );
	m_dPmax = ReadDouble( inpf );

	if( Version < 2 )
	{
		return true;
	}

	if( false == ReadString( inpf, m_strCurveName ) )
	{
		return false;
	}

	return true;
}

void CDB_TBCurve::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_TBCurve *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_TBCurve' object!") );
		}

		// Base class.
		CDB_Curve::Copy( pclDestination );

		// Copy now what it is common to the "CDB_TBCurve" class.
		CDB_TBCurve *pclDestinationTBCurve = (CDB_TBCurve *)pclDestination;

		pclDestinationTBCurve->SetqNmin( m_dqNmin );
		pclDestinationTBCurve->SetqNmax( m_dqNmax );
		pclDestinationTBCurve->SetPmin( m_dPmin );
		pclDestinationTBCurve->SetPmax( m_dPmax );
		pclDestinationTBCurve->SetCurveName( m_strCurveName );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_TBCurve::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#ifndef TACBX
#define TBCURVE_QNMINQNMAX		_T("::qNminqNmax=")
#define TBCURVE_PMINPMAX		_T("::PminPmax=")
#define TBCURVE_CURVENAME		_T("::CurveName=")
void CDB_TBCurve::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int ipos = pStr->Find( CLASS( CDB_TBCurve ) );

		if( _T("::") != pStr->Left( 2 ) && ipos < 0 )
		{
			CDB_Curve::InterpretInheritedData( pStr );
		}
		else
		{
			if( ipos >= 0 )
			{
				pStr->Delete( ipos, _tcsclen( CLASS( CDB_TBCurve ) ) );
			}

			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable must be preceeded by '='.") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( TBCURVE_QNMINQNMAX ) > -1 )
			{
				CArray<double> Ar;

				ParseDoubleList( &Ar, strField );

				m_dqNmin = Ar[0];
				m_dqNmax = Ar[1];
			}
			else if( pStr->Find( TBCURVE_PMINPMAX ) > -1 )
			{
				CArray<double> Ar;

				ParseDoubleList( &Ar, strField );

				m_dPmin = Ar[0];
				m_dPmax = Ar[1];
			}
			else if( pStr->Find( TBCURVE_CURVENAME ) > -1 )
			{
				if( _T('\"') == strField.GetAt( 0 ) )
				{
					strField.Delete( 0 );
				}
			
				if( _T('\"') == strField.GetAt( strField.GetLength() - 1 ) )
				{
					strField.Delete( strField.GetLength() - 1 );
				}

				SetCurveName( (LPCTSTR)strField );
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_TBCurve::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_TBCurve::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_TBCurve *)idptr.MP )->Copy( this );
			CStringArray ar;
		
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );
			
				CDB_TBCurve::InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_Curve::ReadText( inpf, pusLineCount );

			CStringArray TxtHdr;
			TxtHdr.Add( TBCURVE_QNMINQNMAX );
			TxtHdr.Add( TBCURVE_PMINPMAX );
			TxtHdr.Add( TBCURVE_CURVENAME );

			for( int i = 0; i < TxtHdr.GetSize(); i++ )
			{
				ptcLine = ReadTextLine( inpf, pusLineCount );
				CString str = TxtHdr[i] + CString( ptcLine );

				CDB_TBCurve::InterpretInheritedData( &str );
			}
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_TBCurve::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif


///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_Characteristic
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_Characteristic)

CDB_Characteristic::CDB_Characteristic( CDataBase *pDataBase, LPCTSTR ID )
	:CData( pDataBase, ID )
{
	// TODO: For now we set only in characteristic if product is discrete or not and if it is multi or single turn.
	// In case of discrete false (we can set intermediate position between two integers), we have decimal steps 
	// between two integers. This increment must be also set in the characteristic. For the moment, we consider
	// a step of 0.05 for multi turn and a step of 0.5 for single turn.

	m_eDISCRETE = LastDISCRETE;
	m_eTURN = LastTURN;
	m_dSettingRounding = 0.0;
}

eBool3 CDB_Characteristic::IsDiscrete()
{
	eBool3 eDiscrete;

	switch( m_eDISCRETE )
	{
		case CDB_Characteristic::DUndefined:
		case CDB_Characteristic::LastDISCRETE:
			eDiscrete = eb3Undef;
			break;

		case CDB_Characteristic::False:
			eDiscrete = eb3False;
			break;

		case CDB_Characteristic::True:
			eDiscrete = eb3True;
			break;
	}
	return eDiscrete;
}

bool CDB_Characteristic::HasDiscreteProperty()
{
	return ( m_eDISCRETE > CDB_Characteristic::DUndefined && m_eDISCRETE < CDB_Characteristic::LastDISCRETE ) ? true : false;
}

eBool3 CDB_Characteristic::IsMultiTurn()
{
	eBool3 eMultiTurn;

	switch( m_eTURN )
	{
		case CDB_Characteristic::TUndefined:
		case CDB_Characteristic::LastTURN:
			eMultiTurn = eb3Undef;
			break;

		case CDB_Characteristic::Multi:
			eMultiTurn = eb3True;
			break;

		case CDB_Characteristic::Single:
			eMultiTurn = eb3False;
			break;

		case CDB_Characteristic::Electronic:
			eMultiTurn = eb3False;
			break;
	}

	return eMultiTurn;
}

bool CDB_Characteristic::HasMultiTurnProperty()
{
	return ( m_eTURN > CDB_Characteristic::TUndefined && m_eTURN < CDB_Characteristic::LastTURN ) ? true : false;
}

// HYS-1861: these 2 methods will be removed for the next sprint when we will change for the TA-Scope.
#ifdef TACBX
int CDB_Characteristic::GetOpeningMinDec()
{
	int iMinDec  = 0;

	if( eb3True != IsDiscrete() )
	{
		iMinDec = ( eb3True == IsMultiTurn() ) ? 2 : 1;
	}

	return iMinDec;
}

bool CDB_Characteristic::GetOpeningMantisseClean()
{
	return ( eb3True == IsDiscrete() ) ? true : false;
}
#endif

#ifndef TACBX
CString CDB_Characteristic::GetSettingString( double dSetting, bool bWithUnits, bool *pfFullSetting )
{
	if( NULL != pfFullSetting )
	{
		*pfFullSetting = false;
	}

	// Variable.
	CString str = _T("");
	CString str1 = _T("");
	double dOpeningMax = 0.0;
	
	dOpeningMax = GetOpeningMax();
	
	if( -1.0 == dOpeningMax )
	{
		return _T("");
	}

	// Sanitary test.
	dSetting = max( dSetting, 0.0 );

	// Add "*" if the opening is at maximum.
	if( dSetting > dOpeningMax * 0.98 )
	{
		str1 = _T("*");

		if( NULL != pfFullSetting )
		{
			*pfFullSetting = true;
		}
	}

	// Accept a setting of 0 for DpC
	if( NULL == dynamic_cast<CDB_DpCCharacteristic *>( this ) )
	{
		if( dSetting <= 0.0 )
		{
			return _T("");
		}
	}

	double dRoundedSetting = floor( ( dSetting / GetSettingRounding() ) + 0.5 ) * GetSettingRounding();

	// Return the value without units.
	if( false == bWithUnits )
	{
		str.Format( _T("%g%s"), dRoundedSetting, (LPCTSTR)str1 );
	}
	else
	{
		// Add "Pos." or "turns" depending on the number of the product' turns.
		if( eb3True == IsMultiTurn() )
		{
			str.Format( _T("%g%s "), dRoundedSetting, (LPCTSTR)str1 );

			_string *_str = GetpXmlStrTab()->GetIDSStr( L"IDS_SHEETHDR_TURNS" );
			
			if( NULL != _str )
			{
				str += _str->c_str();
			}
		}
		else
		{
			_string *_str = GetpXmlStrTab()->GetIDSStr( L"IDS_SHEETHDR_POS" );

			if( NULL != _str )
			{
				str = _str->c_str();
				str += _T(" ");
			}

			str.Format( _T("%s%g%s"), (LPCTSTR)str, dRoundedSetting, (LPCTSTR)str1 );
		}
	}

	return str;
}
#else
_string CDB_Characteristic::GetSettingString( double dSetting, bool bWithUnits, bool bWithFullSetting, bool *pfFullSetting )
{
	if( NULL != pfFullSetting )
	{
		*pfFullSetting = false;
	}

	// Variable.
	_string str = _T("");
	_string str1 = _T("");
	double dOpeningMax = 0.0;
	
	dOpeningMax = GetOpeningMax();
	
	if( -1.0 == dOpeningMax )
	{
		return _T("");
	}

	// Sanitary test.
	dSetting = max( dSetting, 0.0 );

	// Add "*" if the opening is at maximum.
	if( true == bWithFullSetting && ( dSetting > dOpeningMax * 0.98 ) )
	{
		str1 = _T("*");

		if( NULL != pfFullSetting )
		{
			*pfFullSetting = true;
		}
	}

	// Accept a setting of 0 for DpC
	if( NULL == dynamic_cast<CDB_DpCCharacteristic *>( this ) )
	{
		if( dSetting <= 0.0 )
		{
			return _T("");
		}
	}

	double dRoundedSetting = floor( ( dSetting / GetSettingRounding() ) + 0.5 ) * GetSettingRounding();

	// Return the value without units.
	// std::basic_ostringstream<wchar_t> strostream;
	// wchar_t tcBuffer[256];
	_string strBuffer;

	if( false == bWithUnits )
	{
		// strostream << dRoundedSetting << str1;
		// swprintf ( tcBuffer, L"%g%s", dRoundedSetting, str1 );
		strBuffer += to_string<double>(dRoundedSetting);
		strBuffer += str1;
	}
	else
	{
		// Add "Pos." or "turns" depending on the number of the product' turns.
		if( eb3True == IsMultiTurn() )
		{
			// strostream << dRoundedSetting << str1;
			// swprintf( tcBuffer, L"%g%s", dRoundedSetting, str1 );
			strBuffer += to_string<double>(dRoundedSetting);
			strBuffer += str1;

			std::wstring strUnit = std::wstring( PegResourceManager::LookupString( SID_UNIT_TURNS ) );
			
			if( false == strUnit.empty() )
			{
				//strostream << _T(" ") << strUnit;
				// wcscat( tcBuffer, L" ");
				// wcscat( tcBuffer, strUnit.c_str() );
				strBuffer += L" ";
				strBuffer += strUnit;
			}
		}
		else
		{
			std::wstring strUnit = std::wstring( PegResourceManager::LookupString( SID_UNIT_POSITION ) );

			if( false == strUnit.empty() )
			{
				// strostream << strUnit << _T(" ");
				// wcscat( tcBuffer, strUnit.c_str() );
				// wcscat( tcBuffer, L" " );
				strBuffer += strUnit;
				strBuffer += L" ";
			}

			// strostream << dRoundedSetting << str1;
			// swprintf( tcBuffer, L"%s%g%s", tcBuffer, dRoundedSetting, str1 );
			strBuffer += to_string<double>(dRoundedSetting);
			strBuffer += str1;
		}
	}

	// return strostream.str();
	// return tcBuffer;
	return strBuffer;
}
#endif 	// TACBX

void CDB_Characteristic::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_Characteristic *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pToData' argument is not a 'CDB_Characteristic' object!") );
		}
	
		// Base class.
		CData::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_Characteristic" class.
		CDB_Characteristic *pclDestinationCharacteristic = (CDB_Characteristic *)pclDestination;

		pclDestinationCharacteristic->SetDiscrete( m_eDISCRETE );
		pclDestinationCharacteristic->SetMultiTurn( m_eTURN );
		pclDestinationCharacteristic->SetSettingRounding( m_dSettingRounding );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_Characteristic::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_CHARACTERISTIC_VERSION	3
// Version 3: 2022-01-31: HYS-1861: add the "m_dSettingRounding" variable.
// Version 2: 2021-01-11: HYS-1503: '#eTURN_Electronic'.
void CDB_Characteristic::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_CHARACTERISTIC_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CData::Write( outf );
	
	// Characteristic type.
	outf.write( (char *)&m_eDISCRETE, sizeof( m_eDISCRETE ) );
	
	// Turn type.
	outf.write( (char *)&m_eTURN, sizeof( m_eTURN ) );

	// Version 2: setting rounding.
	WriteDouble( outf, m_dSettingRounding );
}

bool CDB_Characteristic::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_CHARACTERISTIC_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}
	
	// Characteristic type.
	inpf.read( (char *)&m_eDISCRETE, sizeof( m_eDISCRETE ) );
	
	// Turn type.
	inpf.read( (char *)&m_eTURN, sizeof( m_eTURN ) );

	if( Version < 2 )
	{
		return true;
	}

	// Version 2: setting rounding.
	m_dSettingRounding = ReadDouble( inpf );

	return true;
}

#ifndef TACBX 
void CDB_Characteristic::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int ipos = pStr->Find( CLASS( CDB_Characteristic ) );

		if( _T("::") != pStr->Left( 2 ) && ipos < 0 )
		{
			CData::InterpretInheritedData( pStr );
		}
		else
		{
			if( ipos >= 0 )
			{
				pStr->Delete( ipos, _tcsclen( _T("CDB_Characteristic") ) );
			}

			int iEq = pStr->Find( _T("=") );
	
			if( iEq <= 0 )
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}
	
			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( _T("::Discrete=") ) > -1 )
			{
				int iValue = ReadEnum( strField );

				if( iValue >= 99 )
				{
					HYSELECT_THROW( _T("'CDB_Characteristic::Discrete' is too high (%i >= 99)."), iValue );
				}

				m_eDISCRETE = (eDISCRETE)iValue;
			}
			else if( pStr->Find( _T("::MultiTurn=") ) > -1 )
			{
				int iValue = ReadEnum( strField );

				if( iValue != TUndefined && iValue != Multi && iValue != Single && iValue != Electronic )
				{
					HYSELECT_THROW( _T("'CDB_Characteristic::MultiTurn' must be one of these values: '#eTURN_Undefined', '#eTURN_Single', '#eTURN_Multi' or '#eTURN_Electronic'."), iValue );
				}

				m_eTURN = (eTURN)iValue;
			}
			else if( pStr->Find( _T("::SettingRounding=") ) > -1 )
			{
				double d;
			
				if( RD_OK != ReadDouble( strField, &d ) )
				{
					HYSELECT_THROW( _T("'CDB_Characteristic::SettingRounding' must be a double (%s)."), strField );
				}
			
				m_dSettingRounding = d;

				if( m_dSettingRounding < 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_Characteristic::SettingRounding' (%f) can't be lower than 0.0."), m_dSettingRounding );
				}
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Characteristic::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_Characteristic::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_Characteristic format
		// line 0 : open curve bracket and call base class
		// line 1 : discrete/continuous characteristics
		// line 2 : Turn type
		// line 3 : Setting rounding.
		// line 4 : close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Inherited ?
		CString ihID;
	
		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_Characteristic *)idptr.MP)->Copy( this );
		
			CStringArray ar;
		
			GetInheritedModifiedData( inpf, pusLineCount, &ar, 50 );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				InterpretInheritedData( &str );
			}

			// Read the close curve bracket
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _T('}') != *ptcLine )
			{
				HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
			}
		}
		else
		{
			// Read base.
			CData::ReadText( inpf, pusLineCount );

			// Read the characteristic type.
			int iValue = ReadEnumLine( inpf, pusLineCount );
		
			if( iValue >= 99 )
			{
				HYSELECT_THROW( _T("The 'CDB_Characteristic::Discrete' variable value is too long (%i > 99) (pos: %i)."), iValue, *pusLineCount );
			}
		
			m_eDISCRETE = (eDISCRETE)iValue;

			// Read the turn type.
			iValue = ReadEnumLine( inpf, pusLineCount );

			if( iValue != TUndefined && iValue != Multi && iValue != Single && iValue != Electronic )
			{
				HYSELECT_THROW( _T("The 'CDB_Characteristic::MultiTurn' variable value must be one of this variable: '#eTURN_Undefined', '#eTURN_Single', '#eTURN_Multi' or '#eTURN_Electronic' (pos: %i)."), iValue, *pusLineCount );
			}

			m_eTURN = (eTURN)iValue;

			// Read the setting rounding.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			TCHAR *ptcEndPtr;
			m_dSettingRounding = _tcstod( ptcLine, &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Cant read 'CDB_Characteristic::SettingRounding' (%s) (pos: %i)."), ptcLine, *pusLineCount );
			}

			if( m_dSettingRounding < 0.0 )
			{
				HYSELECT_THROW( _T("'CDB_Characteristic::SettingRounding' (%f) can't be lower than 0.0 (pos: %i)."), m_dSettingRounding, *pusLineCount );
			}
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Characteristic::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif


///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_ValveCharacteristic
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_ValveCharacteristic)

CDB_ValveCharacteristic::CDB_ValveCharacteristic( CDataBase *pDataBase, LPCTSTR ID )
	:CDB_Characteristic( pDataBase, ID )
{
	m_nNumberOfCurves = 0;
	m_dMinMeasSetting = 0.0;
	m_dMinRecSetting = 0.0;
	m_pKvCurve = NULL;
}

CDB_ValveCharacteristic::~CDB_ValveCharacteristic()
{
	if( NULL != m_pKvCurve )
	{
		delete m_pKvCurve;
		m_pKvCurve = NULL;
	}
}

double CDB_ValveCharacteristic::GetKvMax( int iDeltaT )
{
	double dKvMax = -1.0;

	if( NULL != m_pKvCurve )
	{
		dKvMax = m_pKvCurve->GetMaxFX();
	}

	return dKvMax;
}

double CDB_ValveCharacteristic::GetKvMin( int iDeltaT )
{
	double dKvMin = -1.0;

	if( NULL != m_pKvCurve )
	{
		dKvMin = m_pKvCurve->GetMinFX();
	}

	return dKvMin;
}

double CDB_ValveCharacteristic::GetKv( double dOpening, int iDeltaT )
{
	if( NULL == m_pKvCurve || ( dOpening < m_pKvCurve->GetMinX() ) || ( dOpening > m_pKvCurve->GetMaxX() ) )
	{
		return -1.0;
	}

	if( eb3True == IsDiscrete() && dOpening != floor( dOpening ) )
	{
		return -1.0;
	}

	return m_pKvCurve->GetValue( dOpening );
}

double CDB_ValveCharacteristic::GetLambda( double dOpening )
{
	double dLambda = -1.0;

	if( NULL != m_pKvCurve )
	{
		dLambda = m_pKvCurve->GetValue( dOpening, 1 );
	}

	return dLambda;
}
	
double CDB_ValveCharacteristic::GetReStar( double dOpening )
{
	double dReStar = -1.0;

	if( NULL != m_pKvCurve )
	{
		dReStar = m_pKvCurve->GetValue( dOpening, 2 );
	}

	return dReStar;
}
	
double CDB_ValveCharacteristic::GetKvTst( double dOpening )
{
	double dKvTst = -1.0;

	if( NULL != m_pKvCurve )
	{
		dKvTst = m_pKvCurve->GetValue( dOpening, 3 );
	}

	return dKvTst;
}

double CDB_ValveCharacteristic::GetOpeningMax()
{
	double dOpeningMax = -1.0;

	if( NULL != m_pKvCurve )
	{
		dOpeningMax = m_pKvCurve->GetMaxX();
	}

	return dOpeningMax;
}

double CDB_ValveCharacteristic::GetOpeningMin()
{
	double dOpeningMin = -1.0;

	if( NULL != m_pKvCurve )
	{
		dOpeningMin = m_pKvCurve->GetMinX();
	}

	return dOpeningMin;
}

double CDB_ValveCharacteristic::GetMinMeasSetting()
{
	double dMinOpening = GetOpeningMin();

	if( m_dMinMeasSetting >= dMinOpening )
	{
		dMinOpening = m_dMinMeasSetting;
	}

	return dMinOpening;
}

double CDB_ValveCharacteristic::GetMinRecSetting()
{
	double dMinOpening = GetOpeningMin();

	if( m_dMinRecSetting >= dMinOpening )
	{
		dMinOpening = m_dMinRecSetting;
	}

	return dMinOpening;
}

double CDB_ValveCharacteristic::GetOpening( double dKv, int iDeltaT )
{
	if( NULL == m_pKvCurve || ( dKv < m_pKvCurve->GetMinFX() ) || ( dKv > m_pKvCurve->GetMaxFX() ) )
	{
		return -1.0;
	}

	double dOpening = -1.0;

	if( false == m_pKvCurve->GetRoot( dKv, &dOpening ) )
	{
		if( ( ( dKv < m_pKvCurve->GetMinFX() ) &&
			  ( m_pKvCurve->GetValue( m_pKvCurve->GetMaxX() ) > m_pKvCurve->GetValue( m_pKvCurve->GetMinX() ) ) ) ||
			( ( dKv>m_pKvCurve->GetMaxFX() ) &&
			  ( m_pKvCurve->GetValue( m_pKvCurve->GetMaxX() ) < m_pKvCurve->GetValue( m_pKvCurve->GetMinX() ) ) ) )
		{
			return m_pKvCurve->GetMinX();
		}
		else
		{
			return m_pKvCurve->GetMaxX();
		}
	}
	
	if( eb3True == IsDiscrete() )
	{
		// Rounding the value.
		dOpening = max( 1.0, floor( dOpening + 0.5 ) );
	}

	return dOpening;
}

bool CDB_ValveCharacteristic::GetOpening( double dKv, double *pdOpening, int iDeltaT )
{
	if( NULL == m_pKvCurve || NULL == pdOpening )
	{
		return false;
	}

	*pdOpening = -1.0;
	return m_pKvCurve->GetRoot( dKv, pdOpening );
}

double CDB_ValveCharacteristic::GetDpFullOpening( double dFlow, double dRho, double dNu, int iDeltaT )
{
	if( NULL == m_pKvCurve )
	{
		return -1.0;
	}

	double dDpFullyOpen = -1.0;
	double dOpeningMax = GetOpeningMax();
	
	if( dFlow > 0.0 && dOpeningMax > 0.0 )
	{
		if( false == GetValveDp( dFlow, &dDpFullyOpen, dOpeningMax, dRho, dNu ) )
		{
			dDpFullyOpen = -1.0;
		}
	}
	
	return dDpFullyOpen;
}

bool CDB_ValveCharacteristic::GetValveQ( double *pdFlow, double dDp, double dOpening, double dRho, double dNu, int iDeltaT )
{
	if( NULL == m_pKvCurve || dDp <= 0.0 || NULL == pdFlow )
	{
		return false;
	}
	
	*pdFlow = -1.0;
	
	if( dOpening < m_pKvCurve->GetMinX() || dOpening > m_pKvCurve->GetMaxX() )
	{
		return false;
	}
	
	if( false == ( eb3True != IsDiscrete() || dOpening == floor( dOpening ) ) )
	{
		return false;
	}

	if( false == ( m_pKvCurve->GetMinFX() >= 0.0 ) )
	{
		return false;
	}

	if( true == IsViscCorrExist() )
	{
		if(false == ( m_pKvCurve->GetMinFX( 1 ) <= m_pKvCurve->GetMaxFX( 1 ) ) )
		{
			return false;
		}
		
		if(false == ( m_pKvCurve->GetMinFX( 2 ) <= m_pKvCurve->GetMaxFX( 2 ) ) )
		{
			return false;
		}

		if(false == ( m_pKvCurve->GetMinFX( 3 ) >= 0.0 ) )
		{
			return false;
		}

		*pdFlow = CalcValvQ( dDp, dRho, dNu, m_pKvCurve->GetValue( dOpening ), m_pKvCurve->GetValue( dOpening, 1 ),
				m_pKvCurve->GetValue( dOpening, 2 ), m_pKvCurve->GetValue( dOpening, 3 ) );
	}
	else
	{
		*pdFlow = CalcqT( m_pKvCurve->GetValue( dOpening ), dDp, dRho );
	}

	return true;
}

bool CDB_ValveCharacteristic::GetValveDp( double dFlow, double *pdDp, double dOpening, double dRho, double dNu, int iDeltaT )
{
	if( NULL == m_pKvCurve || NULL == pdDp )
	{
		return false;
	}

	if( dFlow < 0.0 )
	{
		return false;
	}

	*pdDp = -1.0;
	
	if( dOpening < m_pKvCurve->GetMinX() )
	{
		dOpening = m_pKvCurve->GetMinX();
	}
	
	if( dOpening > m_pKvCurve->GetMaxX() )
	{
		dOpening = m_pKvCurve->GetMaxX();
	}

	if( false == ( eb3True != IsDiscrete() || dOpening == floor( dOpening ) ) ) // h must be integer when valve char is discrete
	{
		return false;
	}

	if( true == IsViscCorrExist() )
	{
		*pdDp = CalcValvDp( dFlow, dRho, dNu, m_pKvCurve->GetValue( dOpening ), m_pKvCurve->GetValue( dOpening, 1 ),
				m_pKvCurve->GetValue( dOpening, 2 ), m_pKvCurve->GetValue( dOpening, 3 ) );
	}
	else
	{
		*pdDp = CalcDp( dFlow, m_pKvCurve->GetValue( dOpening ), dRho );
	}

	return true;
}

bool CDB_ValveCharacteristic::GetValveOpening( double dFlow, double dDp, double *pdOpening, double dRho, double dNu, int iRounding, int iDeltaT )
{
	if( NULL == m_pKvCurve || NULL == pdOpening || dDp < 0.0 || dFlow < 0.0 )
	{
		return false;
	}

	*pdOpening = -1.0;
	
	return CalcValvh( dFlow, dDp, pdOpening, dRho, dNu, this, iRounding );
}

void CDB_ValveCharacteristic::SetKvCurve( CCurveFitter* pKvCurve )
{
	if( NULL != m_pKvCurve )
	{
		delete m_pKvCurve;
		m_pKvCurve = NULL;
	}
	
	if( NULL == pKvCurve )
	{
		return;
	}
	
	m_pKvCurve = new CCurveFitter();
	
	if( NULL == m_pKvCurve )
	{
		return;
	}
	
	pKvCurve->Copy( m_pKvCurve );
}

void CDB_ValveCharacteristic::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_ValveCharacteristic *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_ValveCharacteristic' object!") );
		}

		// Base class.
		CDB_Characteristic::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_ValveCharacteristic" class.
		CDB_ValveCharacteristic *pclDestinationValveCharacteristic = (CDB_ValveCharacteristic *)pclDestination;

		pclDestinationValveCharacteristic->SetNumberOfCurves( m_nNumberOfCurves );
		pclDestinationValveCharacteristic->SetMinMeasSetting( m_dMinMeasSetting );
		pclDestinationValveCharacteristic->SetMinRecSetting( m_dMinRecSetting );
		pclDestinationValveCharacteristic->SetKvCurve( m_pKvCurve );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_ValveCharacteristic::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_VALVECHARACTERISTIC_VERSION		6
// Version 6: HYS-1355: Remove the minimum adjustable setting (for TA-Slider with HyTune).
// Version 5: HYS-1270: Add the minimum adjustable setting (for TA-Slider with HyTune).
// Version 4: we have now the possibility to set 'm_nNumberOfCurves' to 0.
void CDB_ValveCharacteristic::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_VALVECHARACTERISTIC_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_Characteristic::Write( outf );
	
	// Minimum measurable setting.
	outf.write( (char *)&m_dMinMeasSetting, sizeof( m_dMinMeasSetting ) );
	
	// Min recommended setting.
	outf.write( (char *)&m_dMinRecSetting, sizeof( m_dMinRecSetting ) );
	
	// Number of curves.
	outf.write( (char *)&m_nNumberOfCurves, sizeof( m_nNumberOfCurves ) );

	// The curves if exist.
	if( m_nNumberOfCurves > 0 )
	{
		int i = m_pKvCurve->GetSize();
		outf.write( (char *)&i, sizeof( i ) );

		for( i--; i >= 0; i-- )
		{
			// Position.
			double dX = m_pKvCurve->GetPointX( i );
			outf.write( (char *)&dX, sizeof( double ) );

			// Kv from catalogue, Lambda, Re* and Kv from test.
			for( int j = 0; j < m_nNumberOfCurves; j++ )
			{
				double dF = m_pKvCurve->GetPointF( i, j );
				outf.write( (char *)&dF, sizeof( double ) );
			}
		}
	}

	// Version 5: HYS-1270: minimum adjustable setting (for TA-Slider with HyTune).
	// VErsion 6: HYS-1355: removed!
}

bool CDB_ValveCharacteristic::Read( INPSTREAM  inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_VALVECHARACTERISTIC_VERSION )
	{
		return false;
	}

	if( 1 == Version )
	{
		// Base class.
		if( false == CData::Read( inpf ) )
		{
			return false;
		}
		
		// Number of data.
		inpf.read( (char *)&m_nNumberOfCurves, sizeof( int ) );
		
		if(false == ( 1 == m_nNumberOfCurves || 4 == m_nNumberOfCurves ) )
		{
			return false;
		}

		m_pKvCurve = new CCurveFitter( m_nNumberOfCurves );
		
		if( NULL == m_pKvCurve )
		{
			return false;
		}
		
		// Characteristic type.
		inpf.read( (char *)&m_eDISCRETE, sizeof( m_eDISCRETE ) );
	}
	else if( 2 == Version )
	{
		// Base class.
		if( false == CDB_Characteristic::Read( inpf ) )
		{
			return false;
		}
		
		// Number of data.
		inpf.read( (char *)&m_nNumberOfCurves, sizeof( int ) );

		if(false == ( 1 == m_nNumberOfCurves || 4 == m_nNumberOfCurves ) )
		{
			return false;
		}

		m_pKvCurve = new CCurveFitter( m_nNumberOfCurves );
		
		if( NULL == m_pKvCurve )
		{
			return false;
		}
	}
	else
	{
		// Base class.
		if( false == CDB_Characteristic::Read( inpf ) )
		{
			return false;
		}

		// Minimum measurable setting.
		m_dMinMeasSetting = ReadDouble( inpf );
		
		// Min recommended setting.
		m_dMinRecSetting = ReadDouble( inpf );
		
		// Number of data.
		inpf.read( (char *)&m_nNumberOfCurves, sizeof( int ) );
	}
	
	// The curves if exist.
	if( m_nNumberOfCurves > 0 )
	{
		m_pKvCurve = new CCurveFitter( m_nNumberOfCurves );

		if( NULL == m_pKvCurve )
		{
			return false;
		}

		int i;
		double x;
		double *f = new double[m_nNumberOfCurves];

		if( NULL == f )
		{
			return false;
		}

		for( inpf.read( (char *)&i, sizeof( i ) ); i; i-- )
		{
			x = ReadDouble( inpf );

			for( int j = 0; j < m_nNumberOfCurves; j++ )
			{
				f[j] = ReadDouble( inpf );
			}
			
			m_pKvCurve->AddPoint( x, f );
		}

		delete[] f;
	}

	if( Version < 5 )
	{
		return true;
	}
	
	// Version 5: HYS-1270: minimum adjustable setting (for TA-Slider with HyTune).
	// Version 6: HYS-1355: removed!
	if( Version < 6 )
	{
		ReadDouble( inpf );
	}

	return true;
}

#ifndef TACBX
void CDB_ValveCharacteristic::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int ipos = pStr->Find( _T("CDB_ValveCharacteristic") );

		if( ipos < 0 )
		{
			CDB_Characteristic::InterpretInheritedData( pStr );
		}
		else
		{
			pStr->Delete( ipos, _tcsclen( _T("CDB_ValveCharacteristic") ) );
			int iEq = pStr->Find( _T("=") );

			if( iEq <= 0 )
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( _T("::MinMeasSetting=") ) > -1 )
			{
				double d;
			
				if( RD_OK != ReadDouble( strField, &d ) )
				{
					HYSELECT_THROW( _T("'CDB_ValveCharacteristic::MinMeasSetting' must be a double (%s)."), strField );
				}
			
				m_dMinMeasSetting = d;
			}
			else if( pStr->Find( _T("::MinRecSetting=") ) > -1 )
			{
				double d;
			
				if( RD_OK != ReadDouble( strField, &d ) )
				{
					HYSELECT_THROW( _T("'CDB_ValveCharacteristic::MinRecSetting' must be a double (%s)."), strField );
				}
			
				m_dMinRecSetting = d;
			}
			else if( pStr->Find( _T("::NumberOfCurves=") ) > -1 )
			{
				m_nNumberOfCurves = _ttoi( (LPCTSTR)strField );

				if( m_nNumberOfCurves < 0 || m_nNumberOfCurves > 4 )
				{
					HYSELECT_THROW( _T("'CDB_Characteristic::NumberOfCurves' is incorrect (0 > %i > 4)."), m_nNumberOfCurves );
				}
			}
			else if( pStr->Find( _T("::KvCurve=") ) > -1 )
			{
				// If number of curves not yet read...
				if( 0 == m_nNumberOfCurves )
				{
					int iCurPos = 0;
					CString strToken= pStr->Tokenize( _T("\\"), iCurPos );

					while( false == strToken.IsEmpty() )
					{
						m_nNumberOfCurves++;
						strToken = pStr->Tokenize( _T("\\"), iCurPos );
					}

					if( NULL == m_pKvCurve )
					{
						m_pKvCurve = new CCurveFitter( m_nNumberOfCurves );
					}

					if( NULL == m_pKvCurve )
					{
						HYSELECT_THROW( _T("Internal error: 'm_pKvCurve' instantiation error.") );
					}
				}

				// Variables for temporary storage of data.
				double *pDouble = new double[m_nNumberOfCurves];

				if( NULL == pDouble )
				{
					HYSELECT_THROW( _T("Internal error: 'pDouble' instantiation error.") );
				}
		
				int iCurPos = 0;
				CString strToken= pStr->Tokenize( _T("\\"), iCurPos );

				// Look for position.
				TCHAR *ptcEndPtr;
				double dH = _tcstod( (LPCTSTR)strToken, &ptcEndPtr );

				if( _T('\0') != *ptcEndPtr )
				{
					HYSELECT_THROW( _T("Can't read the setting value (%s) at position 0 of the curve definition."), strToken );
				}
			
				// Look for Kv catalogue, lambda, Re*, Kv from test.
				for( int i = 1; i <= m_nNumberOfCurves; i++ )
				{
					strToken = pStr->Tokenize( _T("\\"), iCurPos );

					if( true == strToken.IsEmpty() )
					{
						delete[] pDouble;
						return;
					}

					pDouble[i - 1] = _tcstod( (LPCTSTR)strToken, &ptcEndPtr );

					if( _T('\0') != *ptcEndPtr )
					{
						HYSELECT_THROW( _T("Can't read the double value (%s) at position %i of the curve definition."), strToken, i );
					}
				}
			
				// Add data to the "curve".
				m_pKvCurve->AddPoint( dH, pDouble, true );
				delete[] pDouble;
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_ValveCharacteristic::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_ValveCharacteristic::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_ValveCharacteristic format
		// line 0: open curve bracket and call base class
		// line 1: Minimum measurable setting (for TA-Scope).
		// line 2: Minimum recommended setting (for selection).
		// line 3: Minimum setting with TA-Slider (With HyTune).
		// line 4: Numbers of curves.
		// line 5 to n-1 : Setting/Kv catalog (/lambda/Re*/Kv from test)
		// line n : close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_ValveCharacteristic *)idptr.MP)->Copy( this );
		
			CStringArray ar;

			GetInheritedModifiedData( inpf, pusLineCount, &ar, 50 );

			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				InterpretInheritedData( &str );
			}

			// Read the close curve bracket
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _T('}') != *ptcLine )
			{
				HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
			}
		}
		else
		{
			// Read base.
			CDB_Characteristic::ReadText( inpf, pusLineCount );

			TCHAR *ptcEndPtr;
			
			// Minimum measurable setting.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_dMinMeasSetting = _tcstod( ptcLine, &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Cant read 'CDB_ValveCharacteristic::MinMeasSetting' (%s) (pos: %i)."), ptcLine, *pusLineCount );
			}

			if( m_dMinMeasSetting < 0.0 )
			{
				HYSELECT_THROW( _T("'CDB_ValveCharacteristic::MinMeasSetting' (%f) can't be lower than 0.0 (pos: %i)."), m_dMinMeasSetting, *pusLineCount );
			}

			// Min recommended setting.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_dMinRecSetting = _tcstod( ptcLine, &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Cant read 'CDB_ValveCharacteristic::MinRecSetting' (%s) (pos: %i)."), ptcLine, *pusLineCount );
			}

			if( m_dMinRecSetting < 0.0 )
			{
				HYSELECT_THROW( _T("'CDB_ValveCharacteristic::MinRecSetting' (%f) can't be lower than 0.0 (pos: %i)."), m_dMinRecSetting, *pusLineCount );
			}

			// Read the characteristic curves.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_nNumberOfCurves = _ttoi( ptcLine );

			if( m_nNumberOfCurves > 0 )
			{
				m_pKvCurve = new CCurveFitter( m_nNumberOfCurves );

				if( NULL == m_pKvCurve )
				{
					HYSELECT_THROW( _T("Internal error: 'm_pKvCurve' instantiation error (pos: %i)."), *pusLineCount );
				}

				// Variables for temporary storage of data.
				int nCheck;
				double h;
				double *pDouble = new double [m_nNumberOfCurves];

				if( NULL == pDouble )
				{
					HYSELECT_THROW( _T("Internal error: 'pDouble' instantiation error (pos: %i)."), *pusLineCount );
				}

				TCHAR **pptcField;

				do 
				{
					// Start the loop on lines.
					ptcLine = ReadTextLine( inpf, pusLineCount );

					if( _T('}') == *ptcLine )
					{
						break;
					}

					nCheck = 0;
					pptcField = ParseTextLine( ptcLine, &nCheck );
			
					if( nCheck != m_nNumberOfCurves + 1 )
					{
						HYSELECT_THROW( _T("The current line has not the correct number of tokens (%i != %i) (pos: %i)."), nCheck, ( m_nNumberOfCurves + 1 ), *pusLineCount );
					}

					// Look for position.
					h = _tcstod( pptcField[0], &ptcEndPtr );

					if( _T('\0') != *ptcEndPtr )
					{
						HYSELECT_THROW( _T("Can't read the setting value (%s) at position 0 of the curve definition (pos: %i)."), pptcField[0], *pusLineCount );
					}

					// Look for Kv catalogue, lambda, Re*, Kv from test.
					for( int i = 1; i <= m_nNumberOfCurves; i++ )
					{
						pDouble[i - 1] = _tcstod( pptcField[i], &ptcEndPtr );

						if( _T('\0') != *ptcEndPtr )
						{
							HYSELECT_THROW( _T("Can't read the double value (%s) at position %i of the curve definition (pos: %i)."), pptcField[i], i, *pusLineCount );
						}
					}

					// Add data to the "curve".
					m_pKvCurve->AddPoint( h, pDouble );
					
				}while ( 1 );

				delete[] pDouble;
			}
			else
			{
				// Read the close curve bracket
				ptcLine = ReadTextLine( inpf, pusLineCount );

				if( _T('}') != *ptcLine )
				{
					HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
				}
			}
		}
	
#if defined(_DEBUG)
		// Make check on Kv. Be sure that Kv is a monotonic function of opening
		if( NULL != m_pKvCurve )
		{
			if( m_pKvCurve->GetSize() <= 1 )
			{
				HYSELECT_THROW( _T("Curve definition must have at least one y value (pos: %i)."), *pusLineCount );
			}

			for( int i = m_pKvCurve->GetSize() - 1; i > 1; i-- )
			{
				if( ( ( m_pKvCurve->GetPointF( i ) - m_pKvCurve->GetPointF( i - 1 ) ) * ( m_pKvCurve->GetPointF( i - 1 ) - m_pKvCurve->GetPointF( i - 2 ) ) ) < 0.0 )
				{
					HYSELECT_THROW( _T("Error in the curve definition (pos: %i)."), *pusLineCount );
				}
			}
		}
#endif 

	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_ValveCharacteristic::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif 


///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_FixOCharacteristic
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_FixOCharacteristic)

CDB_FixOCharacteristic::CDB_FixOCharacteristic( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
	m_dKv = -1.0;
	m_dKvSignal = -1.0;
}

void CDB_FixOCharacteristic::OnDatabaseDestroy()
{
	CData::OnDatabaseDestroy();
}

#define CDB_FIXOCHARACTERISTIC_VERSION	1
void CDB_FixOCharacteristic::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_FIXOCHARACTERISTIC_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CData::Write( outf );
	
	// Info.
	// Kv for pressure drop.
	outf.write( (char *)&m_dKv, sizeof( m_dKv ) );

	// Kv for signal.
	outf.write( (char *)&m_dKvSignal, sizeof( m_dKvSignal ) );
}

bool CDB_FixOCharacteristic::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_FIXOCHARACTERISTIC_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}
	
	// Info.
	// Kv for pressure drop.
	m_dKv = ReadDouble( inpf );
	
	// Kv for signal.
	m_dKvSignal = ReadDouble( inpf );
	return true;
}

#ifndef TACBX 
void CDB_FixOCharacteristic::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_FixOCharacteristic format.
		// line 0 : open curve bracket and call base class.
		// line 1 : Kv for pressure drop.
		// line 2 : Kv for signal.
		// line 3 : close curve bracket.

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Read base.
		CData::ReadText( inpf, pusLineCount );
	
		// Read the Kv for pressure drop.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		TCHAR *ptcEndPtr;
		m_dKv = _tcstod( ptcLine, &ptcEndPtr);

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't read the Kv value (%s) of the valve (pos: %i)."), ptcLine, *pusLineCount );
		}

		if( m_dKv <= 0.0 )
		{
			HYSELECT_THROW( _T("Kv (%f) must be greater than 0 (pos: %i)."), m_dKv, *pusLineCount );
		}
	
		// Read the Kv for signal.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		m_dKvSignal = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't read the Kv signal value (%s) of the valve (pos: %i)."), ptcLine, *pusLineCount );
		}

		if( m_dKvSignal <= 0.0 )
		{
			HYSELECT_THROW( _T("Kv signal (%f) must be greater than 0 (pos: %i)."), m_dKvSignal, *pusLineCount );
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_FixOCharacteristic::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif 

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_VenturiCharacteristic
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_VenturiCharacteristic)

CDB_VenturiCharacteristic::CDB_VenturiCharacteristic( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
	m_KvSignal = -1.0;
}

void CDB_VenturiCharacteristic::OnDatabaseDestroy()
{
	CData::OnDatabaseDestroy();
}

void CDB_VenturiCharacteristic::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = 1;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CData::Write( outf );

	// Info.
	// Kv for signal.
	outf.write( (char *)&m_KvSignal, sizeof( m_KvSignal ) );
}

bool CDB_VenturiCharacteristic::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > 1 )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Info.
	// Kv for signal.
	m_KvSignal = ReadDouble( inpf );	
	
	return true;
}

#ifndef TACBX 
void CDB_VenturiCharacteristic::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_VenturiCharacteristic format
		// line 0 : open curve bracket and call base class.
		// line 1 : Kv for signal
		// line 2 : close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Read base.
		CData::ReadText( inpf, pusLineCount );

		// Read the Kv for pressure drop.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		TCHAR *ptcEndPtr;
		m_KvSignal = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't read The Kv signal (%s) of the valve (pos: %i)."), ptcLine, *pusLineCount );
		}
	
		if( m_KvSignal <= 0.0 )
		{
			HYSELECT_THROW( _T("Kv signal (%f) must be greater than 0 (pos: %i)."), m_KvSignal, *pusLineCount );
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_VenturiCharacteristic::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif 

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_DpCCharacteristic
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_DpCCharacteristic )

CDB_DpCCharacteristic::CDB_DpCCharacteristic( CDataBase *pDataBase, LPCTSTR ID )
	:CDB_Characteristic( pDataBase, ID )
{
	m_iNumberOfCurves = 0;
	m_dKvmin = -1.0;
	m_dKvm = -1.0;
	m_dProportionalBand = -1.0;
	m_dDplmin = -1.0;
	m_dDplmax = -1.0;
	m_dQmin = -1.0;
	m_dQmax = -1.0;
	m_eProportionalBandType = epbt_Relative;
	m_pPresetChar = NULL;
	m_PBCurveIDPtr = _NULL_IDPTR;
}

CDB_DpCCharacteristic::~CDB_DpCCharacteristic()
{
	if( NULL != m_pPresetChar )
	{
		delete m_pPresetChar;
	}
}

bool CDB_DpCCharacteristic::IsProportionalBandAbsolute()
{
	if( epbt_Absolute == m_eProportionalBandType )
	{
		return true;
	}

	return false;
}

double CDB_DpCCharacteristic::GetProportionalBand( double dDpToStab )
{
	if( epbt_Absolute == m_eProportionalBandType || epbt_Relative == m_eProportionalBandType )
	{
		ASSERT( m_dProportionalBand > 0.0 ); 
		return m_dProportionalBand;
	}
	else
	{
		CDB_Curve *pCurve = GetpPBCurve();
		m_dProportionalBand = pCurve->GetBoundedY( dDpToStab );
	}

	return m_dProportionalBand;
}

IDPTR CDB_DpCCharacteristic::GetPBCurveIDPtr()
{
	m_PBCurveIDPtr.DB = GetDB();
	Extend( &m_PBCurveIDPtr );
	return m_PBCurveIDPtr;
}

CDB_Curve *CDB_DpCCharacteristic::GetpPBCurve() 
{
	return dynamic_cast<CDB_Curve *>( GetPBCurveIDPtr().MP );
}

double CDB_DpCCharacteristic::GetOpening( double dSP )
{
	if( dSP < m_pPresetChar->GetMinX() || dSP > m_pPresetChar->GetMaxX() )
	{
		return -1.0;
	}
	
	// Attention take a floor of 'GetValue' here before returning.
	return m_pPresetChar->GetValue( dSP );
}

double CDB_DpCCharacteristic::GetQmin( double dRho, double dDpToStap )
{ 
	ASSERT( m_dQmin >= 0.0 );
	
	double dQmin = m_dQmin;

	if( 0.0 == dQmin )
	{
		double dDp = ( 0.0 != dDpToStap ) ? dDpToStap : GetDplmin();
		double dKvmin = GetKvmin();

		// Qmin is defined through Kvmin.
		if( -1.0 != dDp && -1.0 != dKvmin )
		{
			dQmin = CalcqT( dKvmin, dDp, dRho );
		}
	}

	return dQmin;
}

double CDB_DpCCharacteristic::GetQmax( double dRho )
{ 
	ASSERT( m_dQmax >= 0.0 );
	
	double dQmax = m_dQmax;
	
	if( 0.0 == dQmax )
	{
		double dDplmax = GetDplmax();
		double dKvm = GetKvm();

		// Qmax is defined through Kvm.
		if( -1.0 != dDplmax && -1.0 != dKvm )
		{
			dQmax = CalcqT( dKvm, dDplmax, dRho );
		}
	}
	
	return dQmax;
}

bool CDB_DpCCharacteristic::DpCSolve( double dQ, double *pdDpC, double dRho, double dAccuracy )
{
	if( NULL == pdDpC )
	{
		return false;
	}

	ASSERT( dAccuracy >= 1.e-15 && dAccuracy < 1.0 );
	ASSERT( dQ >= 0.0 );

	// Kvs is used for calculating the min dp of the DpC.
	double dKv = GetKvm();
	
	if( -1.0 != dKv )
	{
		*pdDpC = CalcDp( dQ, dKv, dRho );
	}

	return true;
}

#define CDB_DPCCHARACTERISTIC_VERSION	3
void CDB_DpCCharacteristic::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_DPCCHARACTERISTIC_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_Characteristic::Write( outf );
	
	// Infos.
	outf.write( (char *)&m_dKvmin, sizeof( m_dKvmin ) );
	outf.write( (char *)&m_dKvm, sizeof( m_dKvm ) );
	outf.write( (char *)&m_eProportionalBandType, sizeof( m_eProportionalBandType ) );
	outf.write( (char *)&m_dProportionalBand, sizeof( m_dProportionalBand ) );
	outf.write( (char *)&m_dDplmin, sizeof( m_dDplmin ) );
	outf.write( (char *)&m_dDplmax, sizeof( m_dDplmax ) );
	outf.write( (char *)&m_dQmin, sizeof( m_dQmin ) );
	outf.write( (char *)&m_dQmax, sizeof( m_dQmax ) );
	WriteString( outf, m_PBCurveIDPtr.ID );
	
	// Number of curves.
	outf.write( (char *)&m_iNumberOfCurves, sizeof( m_iNumberOfCurves ) );
	
	// The curves.
	int i = m_pPresetChar->GetSize();
	outf.write( (char *)&i, sizeof( i ) );
	
	for( i--; i >= 0; i-- )
	{
		// SP.
		double dX = m_pPresetChar->GetPointX( i );
		outf.write( (char *)&dX, sizeof( double ) );
		
		// Position.
		for( int j = 0; j < m_iNumberOfCurves; j++ )
		{
			double dF = m_pPresetChar->GetPointF( i, j );
			outf.write( (char *)&dF, sizeof( double ) );
		}
	}
}

bool CDB_DpCCharacteristic::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );
	
	if( Version < 1 || Version > CDB_DPCCHARACTERISTIC_VERSION )
	{
		return false;
	}
	
	if( 1 == Version )
	{
		// Base class.
		if( false == CData::Read( inpf ) )
		{
			return false;
		}
	}
	else
	{
		// Base class.
		if( false == CDB_Characteristic::Read( inpf ) )
		{
			return false;
		}
	}

	// Infos.
	m_dKvmin = ReadDouble( inpf );
	m_dKvm = ReadDouble( inpf );
	
	if( Version >= 3 )
	{
		inpf.read( (char *)&m_eProportionalBandType, sizeof( m_eProportionalBandType ) );
	}
	else
	{
		bool bAbsoluteBP;
		inpf.read( (char *)&bAbsoluteBP, sizeof( bool ) );	
		m_eProportionalBandType = (PB_type)bAbsoluteBP;
	}
	
	m_dProportionalBand = ReadDouble( inpf );
	m_dDplmin = ReadDouble( inpf );
	m_dDplmax = ReadDouble( inpf );
	m_dQmin = ReadDouble( inpf );
	m_dQmax = ReadDouble( inpf );
	
	if( Version >= 3 )
	{
		m_PBCurveIDPtr.Read( inpf, (CTADatabase *)GetIDPtr().DB );
	}
	
	// Number of curves.
	inpf.read( (char *)&m_iNumberOfCurves, sizeof( int ) );
	ASSERT( 1 == m_iNumberOfCurves );

	m_pPresetChar = new CCurveFitter( m_iNumberOfCurves );

	if( NULL == m_pPresetChar )
	{
		return false;
	}
	
	if( 1 == Version )
	{
		inpf.read( (char *)&m_eDISCRETE, sizeof( m_eDISCRETE ) );
	}
	
	// The curves.
	int i;
	double x;
	double *f = new double [m_iNumberOfCurves];
	
	for( inpf.read( (char *)&i, sizeof( i ) ); i; i-- )
	{
		x = ReadDouble( inpf );
		
		for( int j = 0; j < m_iNumberOfCurves; j++ )
		{
			f[j] = ReadDouble( inpf );
		}

		m_pPresetChar->AddPoint( x, f );
	}
	
	delete[] f;
	
	return true;
}

void CDB_DpCCharacteristic::DeletePresetCharCurve()
{
	if( NULL != m_pPresetChar )
	{
		delete m_pPresetChar;
		m_pPresetChar = NULL;
	}
}

CCurveFitter *CDB_DpCCharacteristic::CreateNewPresetCharCurve( int iNumberOfCurves )
{
	HYSELECT_TRY
	{
		DeletePresetCharCurve();

		m_pPresetChar = new CCurveFitter( iNumberOfCurves );

		if( NULL == m_pPresetChar )
		{
			HYSELECT_THROW_RETURNARG( _T("Internal error: 'm_pPresetChar' instantiation error."), NULL );
		}

		return m_pPresetChar;
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CDB_DpCCharacteristic::CreatePresetCharCurve' method.") )
}

void CDB_DpCCharacteristic::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_DpCCharacteristic *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_DpCCharacteristic' object!") );
		}
	
		// Base class.
		CDB_Characteristic::Copy( pclDestination );

		// Copy now what it is common to the "CDB_DpCCharacteristic".
		CDB_DpCCharacteristic *pclDestinationDpCCharacteristic = (CDB_DpCCharacteristic *)pclDestination;

		pclDestinationDpCCharacteristic->SetNumberOfCurves( m_iNumberOfCurves );
		pclDestinationDpCCharacteristic->SetKvmin( m_dKvmin );
		pclDestinationDpCCharacteristic->SetKvm( m_dKvm );
		pclDestinationDpCCharacteristic->SetDplmin( m_dDplmin );
		pclDestinationDpCCharacteristic->SetDplmax( m_dDplmax );
		pclDestinationDpCCharacteristic->SetProportionalBand( m_dProportionalBand );
		pclDestinationDpCCharacteristic->SetQmin( m_dQmin );
		pclDestinationDpCCharacteristic->SetQmax( m_dQmax );
		pclDestinationDpCCharacteristic->SetProportionalBandType( m_eProportionalBandType );
		pclDestinationDpCCharacteristic->SetPBCurveID( m_PBCurveIDPtr.ID );

		pclDestinationDpCCharacteristic->DeletePresetCharCurve();
		CCurveFitter *pclDestinationPresetCharCurve = pclDestinationDpCCharacteristic->CreateNewPresetCharCurve( m_pPresetChar->GetFuncNumber() );

		if( NULL == pclDestinationPresetCharCurve )
		{
			HYSELECT_THROW( _T("Can't instantiate the 'pclDestinationPresetCharCurve' variable!") );
		}

		m_pPresetChar->Copy( pclDestinationPresetCharCurve );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_DpCCharacteristic::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#ifndef TACBX 
#define DPCCHAR_VKvminKvm		_T("::KvminKvm=")			                 
#define DPCCHAR_PBType			_T("::PBType=")			                 
#define DPCCHAR_PB				_T("::PB=")			                 
#define DPCCHAR_DplMinMax		_T("::DplMinMax=")			                 
#define DPCCHAR_QMinMax			_T("::QMinMax=")			                 
#define DPCCHAR_SPPoint			_T("::SPPoints=")
void CDB_DpCCharacteristic::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int ipos = pStr->Find( CLASS( CDB_DpCCharacteristic ) );
	
		if( _T("::") != pStr->Left( 2 ) && ipos < 0 )
		{
			CDB_Characteristic::InterpretInheritedData( pStr );
		}
		else
		{
			if( ipos >= 0 )
			{
				pStr->Delete( ipos, _tcsclen( CLASS( CDB_DpCCharacteristic ) ) );
			}

			int iEq = pStr->Find( _T("=") );

			if( iEq <= 0 )
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );
		
			if( pStr->Find( DPCCHAR_VKvminKvm ) > -1 )
			{
				CArray<double> Ar;
				ParseDoubleList( &Ar, strField );

				m_dKvmin = Ar[0];
				m_dKvm = Ar[1];

				if( m_dKvmin < 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_ValveCharacteristic::KvminKvm' Kvmin value (%f) can't be below 0."), m_dKvmin );
				}

				if( m_dKvm <= 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_ValveCharacteristic::KvminKvm' Kvm value (%f) can't be below 0."), m_dKvm );
				}
			}
			else if( pStr->Find( DPCCHAR_PBType ) > -1 )
			{
				// Read the BP type (1/0 : absolute/relative).
				int iValue = ReadEnum( strField );
			
				if( iValue < epbt_Relative || iValue > epbt_CurveID )
				{
					HYSELECT_THROW( _T("'CDB_ValveCharacteristic::PBType' value must be one of these values: '#eDPCPBTYPE_Relative', '#eDPCPBTYPE_Absolute' or '#eDPCPBTYPE_CurveID'.") );
				}

				m_eProportionalBandType = (PB_type)iValue;
			}
			else if( pStr->Find( DPCCHAR_PB ) > -1 )
			{
				// Read the BP.
				if( epbt_CurveID == m_eProportionalBandType )
				{
					wcscpy_s( m_PBCurveIDPtr.ID, SIZEOFINTCHAR( m_PBCurveIDPtr.ID ), (LPCTSTR)strField );
					m_PBCurveIDPtr.DB = GetIDPtr().DB;
				}
				else
				{
					if( RD_OK != ReadDoubleFromStr( (LPCTSTR)strField, &m_dProportionalBand ) )
					{
						HYSELECT_THROW( _T("'CDB_ValveCharacteristic::PB' must be a double (%s)."), strField );
					}

					if( m_dProportionalBand <= 0.0 )
					{
						HYSELECT_THROW( _T("'CDB_ValveCharacteristic::PB' (%f)) can't be below 0 (%s)."), m_dProportionalBand );
					}
				}
			}
			else if( pStr->Find( DPCCHAR_DplMinMax ) > -1 )
			{
				CArray<double> Ar;
				ParseDoubleList( &Ar, strField );

				m_dDplmin = Ar[0];
				m_dDplmax = Ar[1];

				if( m_dDplmin < 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_ValveCharacteristic::DplMinMax' Dplmin value (%f) can't be below 0."), m_dDplmin );
				}

				if( m_dDplmax <= 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_ValveCharacteristic::DplMinMax' Dplmax value (%f) can't be below 0."), m_dDplmax );
				}
			}
			else if( pStr->Find( DPCCHAR_QMinMax ) > -1 )
			{
				CArray<double> Ar;
				ParseDoubleList( &Ar, strField );
			
				m_dQmin = Ar[0];
				m_dQmax = Ar[1];

				if( m_dQmin < 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_ValveCharacteristic::QMinMax' Dplmin value (%f) can't be below 0."), m_dQmin );
				}

				if( m_dQmax <= 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_ValveCharacteristic::QMinMax' Dplmax value (%f) can't be below 0."), m_dQmax );
				}
			}
			else if( pStr->Find( DPCCHAR_SPPoint ) > -1 )
			{
				if( 0 == strField.CompareNoCase( _T("Purge") ) )
				{
					m_pPresetChar->Purge();
				}
				else
				{
					CArray<double> Ar;
					ParseDoubleList( &Ar, strField );

					if( NULL == m_pPresetChar )
					{
						HYSELECT_THROW( _T("Internal error: 'm_pPresetChar' instantiation error.") );
					}

					double df = Ar[1];
					m_pPresetChar->AddPoint( Ar[0], &df );
				}
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_DpCCharacteristic::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_DpCCharacteristic::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_DpCCharacteristic format
		// line 0 : open curve bracket and call base class.
		// line 1 : Kvmin \ Kvm
		// line 2 : BP type (1/0 : absolute/relative)
		// line 3 : BP
		// line 4 : Dplmin \ Dplmax
		// ...
		// line x : close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR IDPtr = GetDB()->Get( ihID );

			if( _T('\0') == *IDPtr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_DpCCharacteristic *)IDPtr.MP )->Copy( this );
			CStringArray ar;

			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );
			
				CDB_DpCCharacteristic::InterpretInheritedData( &str );
			}
		
			// Read closing bracket
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _T('}') != *ptcLine )
			{
				HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
			}
		}
		else
		{
			// Read base.
			CDB_Characteristic::ReadText( inpf, pusLineCount );
	
			CStringArray TxtHdr;
			TxtHdr.Add( DPCCHAR_VKvminKvm );
			TxtHdr.Add( DPCCHAR_PBType );
			TxtHdr.Add( DPCCHAR_PB );
			TxtHdr.Add( DPCCHAR_DplMinMax );
			TxtHdr.Add( DPCCHAR_QMinMax );

			for( int i = 0; i < TxtHdr.GetSize(); i++ )
			{
				ptcLine = ReadTextLine( inpf, pusLineCount );
				CString str = TxtHdr[i] + CString( ptcLine );

				CDB_DpCCharacteristic::InterpretInheritedData( &str );
			}

			TCHAR *ptcEndPtr;
			TCHAR **pptcField;
	
			// Read the curve characteristics
			// Set the number of columns (2 columns --> 1 data for each SP
			m_iNumberOfCurves = 1;
			m_pPresetChar = new CCurveFitter( m_iNumberOfCurves );
	
			if( NULL == m_pPresetChar )
			{
				HYSELECT_THROW( _T("Internal error: 'm_pPresetChar' instantiation error (pos: %i)."), *pusLineCount );
			}
	
			// Variables for temporary storage of data.
			int nCheck;
			double dSP;
			double *pardValues = new double[m_iNumberOfCurves];

			if( NULL == pardValues )
			{
				HYSELECT_THROW( _T("Internal error: 'pardValues' instantiation error (pos: %i)."), *pusLineCount );
			}
	
			do 
			{
				// Start the loop on lines.
				ptcLine = ReadTextLine( inpf, pusLineCount );

				if( _T('}') == *ptcLine )
				{
					break;
				}

				nCheck = 0;
				pptcField = ParseTextLine( ptcLine, &nCheck );

				if( nCheck != m_iNumberOfCurves + 1 )
				{
					HYSELECT_THROW( _T("The current line has not the correct number of tokens (%i != %i) (pos: %i)."), nCheck, ( m_iNumberOfCurves + 1 ), *pusLineCount );
				}

				// Look for SP.
				dSP = _tcstod( pptcField[0], &ptcEndPtr );

				if( _T('\0') != *ptcEndPtr )
				{
					HYSELECT_THROW( _T("Can't read the SP value (%s) at position 0 of the curve definition (pos: %i)."), pptcField[0], *pusLineCount );
				}
		
				// Look for opening.
				for( int i = 1; i <= m_iNumberOfCurves; i++ )
				{
					pardValues[i - 1] = _tcstod( pptcField[i], &ptcEndPtr );

					if( _T('\0') != *ptcEndPtr )
					{
						HYSELECT_THROW( _T("Can't read the double value (%s) at position %i of the curve definition (pos: %i)."), pptcField[i], i, *pusLineCount );
					}
				}
		
				// Add data to the "curve".
				m_pPresetChar->AddPoint( dSP, pardValues );

			}while( 1 );

			delete[] pardValues;
		}
	
#if defined(_DEBUG)
		// Make check on opening. Be sure that the opening is a monotonic function of SP.
		if( m_pPresetChar->GetSize() <= 1 )
		{
			HYSELECT_THROW( _T("Curve definition must have at least one y value (pos: %i)."), *pusLineCount );
		}
	
		for( int i = m_pPresetChar->GetSize() - 1; i > 1; i-- )
		{
			if( ( ( m_pPresetChar->GetPointF( i ) - m_pPresetChar->GetPointF( i - 1 ) ) * ( m_pPresetChar->GetPointF( i - 1 ) - m_pPresetChar->GetPointF( i - 2 ) ) ) < 0.0 )
			{
				HYSELECT_THROW( _T("Error in the curve definition (pos: %i)."), *pusLineCount );
			}
		}
#endif 

	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_DpCCharacteristic::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_ThermoCharacteristic
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_ThermoCharacteristic )

CDB_ThermoCharacteristic::CDB_ThermoCharacteristic( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_ValveCharacteristic( pDataBase, ID )
{
	m_pKvDTCurve = NULL;
	m_parfDTExist = NULL;
}

CDB_ThermoCharacteristic::~CDB_ThermoCharacteristic()
{
	if( NULL != m_pKvDTCurve )
	{
		delete m_pKvDTCurve;
		m_pKvDTCurve = NULL;
	}

	if( NULL != m_parfDTExist )
	{
		delete m_parfDTExist;
		m_parfDTExist = NULL;
	}
}

double CDB_ThermoCharacteristic::GetKvMax( int iDeltaT )
{
	double dKvMax = -1.0;

	// If 'iDeltaT' is set to 0 we use KvS defined in 'CDB_ValveCharacteristic::m_pKvChar'.
	// Remark: if there is no thermostatic curve, or if 'iDeltaT' is invalid or if there is no valid curve at iDeltaT Kelvin, then 
	//         we also use KvS defined in 'CDB_ValveCharacteristic::m_pKvChar'.
	if( iDeltaT <= 0 || NULL == m_pKvDTCurve || iDeltaT > m_pKvDTCurve->GetFuncNumber() || false == m_parfDTExist[iDeltaT - 1] )
	{
		dKvMax = CDB_ValveCharacteristic::GetKvMax();
	}
	else
	{
		// Remark: 'iDeltaT - 1' because curves are zero-indexed.
		dKvMax = m_pKvDTCurve->GetMaxFX( iDeltaT - 1 );
	}
	
	return dKvMax;
}

double CDB_ThermoCharacteristic::GetKvMin( int iDeltaT )
{
	double dKvMin = -1.0;
	
	// If 'iDeltaT' is set to 0 we use KvS defined in 'CDB_ValveCharacteristic::m_pKvChar'.
	// Remark: if there is no thermostatic curve, or if 'iDeltaT' is invalid or if there is no valid curve at iDeltaT Kelvin, then 
	//         we also use KvS defined in 'CDB_ValveCharacteristic::m_pKvChar'.
	if( iDeltaT <= 0 || NULL == m_pKvDTCurve || iDeltaT > m_pKvDTCurve->GetFuncNumber() || false == m_parfDTExist[iDeltaT - 1] )
	{
		dKvMin = CDB_ValveCharacteristic::GetKvMin();
	}
	else
	{
		// Remark: 'iDeltaT - 1' because curves are zero-indexed.
		dKvMin = m_pKvDTCurve->GetMinFX( iDeltaT -1 );
	}
	
	return dKvMin;
}

double CDB_ThermoCharacteristic::GetKv( double dOpening, int iDeltaT )
{
	double dKv = -1.0;

	// If 'iDeltaT' is set to 0 we use KvS defined in 'CDB_ValveCharacteristic::m_pKvChar'.
	// Remark: if there is no thermostatic curve, or if 'iDeltaT' is invalid or if there is no valid curve at iDeltaT Kelvin, then 
	//         we also use KvS defined in 'CDB_ValveCharacteristic::m_pKvChar'.
	if( iDeltaT <= 0 || NULL == m_pKvDTCurve || iDeltaT > m_pKvDTCurve->GetFuncNumber() || false == m_parfDTExist[iDeltaT - 1] )
	{
		dKv = CDB_ValveCharacteristic::GetKv( dOpening );
	}
	else
	{
		// Check if opening is valid.
		if( ( dOpening < m_pKvDTCurve->GetMinX() ) || ( dOpening > m_pKvDTCurve->GetMaxX() ) )
		{
			return -1.0;
		}
	
		// If characteristic is discrete, we reject values that are not discrete!
		if( eb3True == IsDiscrete() && dOpening != floor( dOpening ) )
		{
			return -1.0;
		}

		// Remark: 'iDeltaT - 1' because curves are zero-indexed.
		dKv = m_pKvDTCurve->GetValue( dOpening, iDeltaT - 1 );
	}
	
	return dKv;
}

double CDB_ThermoCharacteristic::GetOpening( double dKv, int iDeltaT )
{
	double dOpening = -1.0;
	
	// If 'iDeltaT' is set to 0 we use KvS defined in 'CDB_ValveCharacteristic::m_pKvChar'.
	// Remark: if there is no thermostatic curve, or if 'iDeltaT' is invalid or if there is no valid curve at iDeltaT Kelvin, then 
	//         we also use KvS defined in 'CDB_ValveCharacteristic::m_pKvChar'.
	if( iDeltaT <= 0 || NULL == m_pKvDTCurve || iDeltaT > m_pKvDTCurve->GetFuncNumber() || false == m_parfDTExist[iDeltaT - 1] )
	{
		dOpening = CDB_ValveCharacteristic::GetOpening( dKv );
	}
	else
	{
		// Ckeck if Kv is valid.
		// Remark: 'iDeltaT - 1' because curves are zero-indexed.
		if( ( dKv < m_pKvDTCurve->GetMinFX( iDeltaT - 1 ) ) || ( dKv > m_pKvDTCurve->GetMaxFX( iDeltaT - 1 ) ) )
		{
			return -1.0;
		}

		// If can't compute opening with dKv...
		if( false == m_pKvDTCurve->GetRoot( dKv, &dOpening, iDeltaT - 1 ) )
		{
			double dKvMin = m_pKvDTCurve->GetMinFX( iDeltaT - 1 );
			double dKvMax = m_pKvDTCurve->GetMaxFX( iDeltaT - 1 );
			double dHMax = m_pKvDTCurve->GetValue( m_pKvDTCurve->GetMaxX(), iDeltaT - 1 );
			double dHMin = m_pKvDTCurve->GetValue( m_pKvDTCurve->GetMinX(), iDeltaT - 1 );
			
			if( ( dKv < dKvMin && dHMax > dHMin ) || ( dKv > dKvMax && dHMax < dHMin ) )
			{				
				dOpening = m_pKvDTCurve->GetMinX();
			}
			else
			{
				dOpening = m_pKvDTCurve->GetMaxX();
			}
		}
		else if( eb3True == IsDiscrete() )
		{
			dOpening = max( GetMinRecSetting(), floor( dOpening + 0.5 ) );
		}
	}
	
	return dOpening;
}

bool CDB_ThermoCharacteristic::GetOpening( double dKv, double *pdOpening, int iDeltaT )
{
	if( NULL == pdOpening )
	{
		return false;
	}

	bool bResult = false;
	*pdOpening = -1.0;
	
	// If 'iDeltaT' is set to 0 we use KvS defined in 'CDB_ValveCharacteristic::m_pKvChar'.
	// Remark: if there is no thermostatic curve, or if 'iDeltaT' is invalid or if there is no valid curve at iDeltaT Kelvin, then 
	//         we also use KvS defined in 'CDB_ValveCharacteristic::m_pKvChar'.
	if( iDeltaT <= 0 || NULL == m_pKvDTCurve || iDeltaT > m_pKvDTCurve->GetFuncNumber() || false == m_parfDTExist[iDeltaT - 1] )
	{
		bResult = CDB_ValveCharacteristic::GetOpening( dKv, pdOpening );
	}
	else
	{
		// Remark: 'iDeltaT - 1' because curves are zero-indexed.
		bResult = m_pKvDTCurve->GetRoot( dKv, pdOpening, iDeltaT - 1 );
	}
	
	return bResult;
}

double CDB_ThermoCharacteristic::GetDpFullOpening( double dFlow, double dRho, double dNu, int iDeltaT )
{
	double dDpFullyOpen = -1.0;
	
	// If 'iDeltaT' is set to 0 we use KvS defined in 'CDB_ValveCharacteristic::m_pKvChar'.
	// Remark: if there is no thermostatic curve, or if 'iDeltaT' is invalid or if there is no valid curve at iDeltaT Kelvin, then 
	//         we also use KvS defined in 'CDB_ValveCharacteristic::m_pKvChar'.
	if( iDeltaT <= 0 || NULL == m_pKvDTCurve || iDeltaT > m_pKvDTCurve->GetFuncNumber() || false == m_parfDTExist[iDeltaT - 1] )
	{
		dDpFullyOpen = CDB_ValveCharacteristic::GetDpFullOpening( dFlow, dRho, dNu );
	}
	else
	{
		double dOpeningMax = GetOpeningMax();

		if( dFlow > 0.0 && dOpeningMax > 0.0 )
		{
			if( false == GetValveDp( dFlow, &dDpFullyOpen, dOpeningMax, dRho, dNu, iDeltaT ) )
			{
				dDpFullyOpen = -1.0;
			}
		}
	}
	
	return dDpFullyOpen;
}

bool CDB_ThermoCharacteristic::GetValveQ( double *pdFlow, double dDp, double dOpening, double dRho, double dNu, int iDeltaT )
{
	if( NULL == pdFlow )
	{
		return false;
	}
	
	bool bResult = false;
	*pdFlow = -1.0;
	
	// If 'iDeltaT' is set to 0 we use KvS defined in 'CDB_ValveCharacteristic::m_pKvChar'.
	// Remark: if there is no thermostatic curve, or if 'iDeltaT' is invalid or if there is no valid curve at iDeltaT Kelvin, then 
	//         we also use KvS defined in 'CDB_ValveCharacteristic::m_pKvChar'.
	if( iDeltaT <= 0 || NULL == m_pKvDTCurve || iDeltaT > m_pKvDTCurve->GetFuncNumber() || false == m_parfDTExist[iDeltaT - 1] )
	{
		bResult = CDB_ValveCharacteristic::GetValveQ( pdFlow, dDp, dOpening, dRho, dNu );
	}
	else
	{
		if( dDp >= 0.0 && 
			dOpening >= m_pKvCurve->GetMinX() && dOpening <= m_pKvCurve->GetMaxX() && 
			( eb3True != IsDiscrete() || dOpening == floor( dOpening ) ) )
		{
			// Remark: 'iDeltaT - 1' because curves are zero-indexed.
			*pdFlow = CalcqT( m_pKvDTCurve->GetValue( dOpening, iDeltaT - 1 ), dDp, dRho );
			bResult = true;
		}
	}
	
	return bResult;
}

bool CDB_ThermoCharacteristic::GetValveDp( double dFlow, double *pdDp, double dOpening, double dRho, double dNu, int iDeltaT )
{
	if( NULL == pdDp )
	{
		return false;
	}

	bool bResult = false;
	*pdDp = -1.0;

	// If 'iDeltaT' is set to 0 we use KvS defined in 'CDB_ValveCharacteristic::m_pKvChar'.
	// Remark: if there is no thermostatic curve, or if 'iDeltaT' is invalid or if there is no valid curve at iDeltaT Kelvin, then 
	//         we also use KvS defined in 'CDB_ValveCharacteristic::m_pKvChar'.
	if( iDeltaT <= 0 || NULL == m_pKvDTCurve || iDeltaT > m_pKvDTCurve->GetFuncNumber() || false == m_parfDTExist[iDeltaT - 1] )
	{
		bResult = CDB_ValveCharacteristic::GetValveDp( dFlow, pdDp, dOpening, dRho, dNu );
	}
	else
	{
		if( dFlow >= 0.0 )
		{
			if( dOpening < m_pKvDTCurve->GetMinX() )
			{
				dOpening = m_pKvDTCurve->GetMinX();
			}

			if( dOpening > m_pKvDTCurve->GetMaxX() )
			{
				dOpening = m_pKvDTCurve->GetMaxX();
			}

			// 'dOpening' must be integer when valve char is discrete.
			if( eb3True != IsDiscrete() || dOpening == floor( dOpening ) )
			{
				// Remark: at now, there is no viscosity correction.
				// Remark: -1 because curves are zero-indexed.
				*pdDp = CalcDp( dFlow, m_pKvDTCurve->GetValue( dOpening, iDeltaT - 1 ), dRho );
				bResult = true;
			}
		}
	}
	
	return bResult;
}

bool CDB_ThermoCharacteristic::GetValveOpening( double dFlow, double dDp, double *pdOpening, double dRho, double dNu, int iRounding, int iDeltaT )
{
	if( NULL == pdOpening )
	{
		return false;
	}

	bool bResult = false;
	*pdOpening = -1.0;

	// If 'iDeltaT' is set to 0 we use KvS defined in 'CDB_ValveCharacteristic::m_pKvChar'.
	// Remark: if there is no thermostatic curve, or if 'iDeltaT' is invalid or if there is no valid curve at iDeltaT Kelvin, then 
	//         we also use KvS defined in 'CDB_ValveCharacteristic::m_pKvChar'.
	if( iDeltaT <= 0 || NULL == m_pKvDTCurve || iDeltaT > m_pKvDTCurve->GetFuncNumber() || false == m_parfDTExist[iDeltaT - 1] )
	{
		bResult = CDB_ValveCharacteristic::GetValveOpening( dFlow, dDp, pdOpening, dRho, dNu, iRounding );
	}
	else
	{
		// Remark: at now, there is no viscosity correction.
		if( true == GetOpening( CalcKv( dFlow, dDp, dRho), pdOpening, iDeltaT ) )
		{
			bResult = true;

			if( eb3True == IsDiscrete() )
			{
				switch( iRounding )
				{
					// No rounding.
					case 1:
						break;

					// Rounding == 2 => Rounding to closest int.
					case 2:
						*pdOpening = max( GetMinRecSetting(), floor( *pdOpening + 0.5 ) );
						break;

					// Rounding == 3 => Decimal part truncation.
					case 3:

						if( *pdOpening < GetMinRecSetting() )
						{
							// Opening between 0 and 1 when rounding == 3 => reject
							bResult = false;
						}
						else
						{
							*pdOpening = floor( *pdOpening );
						}

						break;

					// Rounding == 4 => Rounding to upper int.
					case 4:
						
						if( *pdOpening < GetMinRecSetting() )
						{
							// Opening between 0 and 1 when rounding == 4 => reject.
							bResult = false;
						}
						else
						{
							*pdOpening = ceil( *pdOpening );
						}

						break;
				}
			}
		}
	}
	
	return bResult;
}

#define CDB_THERMOCHARACTERISTIC_VERSION	1
void CDB_ThermoCharacteristic::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_THERMOCHARACTERISTIC_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CDB_ValveCharacteristic::Write( outf );
	
	// Number of curves for Kv at DT Kelvin.
	// Remark: Opening/Kvs curve is defined in 'CDB_ValveCharacteristic'.
	int iCurveNumber = 0;

	if( NULL != m_pKvDTCurve )
	{
		iCurveNumber = m_pKvDTCurve->GetFuncNumber();
	}

	outf.write( (char *)&iCurveNumber, sizeof( iCurveNumber ) );

	// If there is at least two columns...
	if( iCurveNumber > 1 )
	{
		// Write the curves.
		int i = m_pKvDTCurve->GetSize();
		outf.write( (char *)&i, sizeof( i ) );
		
		for( i--; i >= 0; i-- )
		{
			// Opening.
			double dX = m_pKvDTCurve->GetPointX( i );
			outf.write( (char *)&dX, sizeof( double ) );

			// Kv at DT Kelvin if exist.
			for( int j = 0; j < iCurveNumber; j++ )
			{
				double dF = m_pKvDTCurve->GetPointF( i, j );
				outf.write( (char *)&dF, sizeof( double ) );
			}
		}
	}
}

bool CDB_ThermoCharacteristic::Read( INPSTREAM  inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );
	
	if( Version < 1 || Version > CDB_THERMOCHARACTERISTIC_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDB_ValveCharacteristic::Read( inpf ) )
	{
		return false;
	}

	// Number of curves for Kv at DT Kelvin.
	// Remark: Opening/Kvs curve is defined in 'CDB_ValveCharacteristic'.
	int iCurveNumber;
	inpf.read( (char *)&iCurveNumber, sizeof( iCurveNumber ) );
	
	// Remark: it's possible to have no curve for thermostatic characteristic, thus we return 'true'.
	if( iCurveNumber < 2 )
	{
		return true;
	}
	
	// Create curves.
	m_pKvDTCurve = new CCurveFitter( iCurveNumber );

	if( NULL == m_pKvDTCurve )
	{
		return false;
	}

	// Create array to validate or invalidate curves.
	// Remark: it's possible to introduce a curve at 2K without 1K. In this case we have to write:
	//			  Opening 1 \ -1.0 \ Kv1
	//			  Opening 2 \ -1.0 \ Kv2
	//            ...
	//         and fill the first curve will all -1.0 value.
	//         In that case, 'm_parfDTExist' will be created with two entries. First entry will be set to false to 
	//         specify that curve at 1K is not valid. And second entry will be set to true to validate curve at 2K.
	m_parfDTExist = new bool[iCurveNumber];
	
	if( NULL == m_parfDTExist )
	{
		return false;
	}

	memset( m_parfDTExist, 1, iCurveNumber * sizeof( bool ) );

	// The curves.
	int i;
	double x;
	double *pDouble = new double[iCurveNumber];

	if( NULL == pDouble )
	{
		return false;
	}

	for( inpf.read( (char *)&i, sizeof( i ) ); i; i-- )
	{
		x = ReadDouble( inpf );
		for( int j = 0; j < iCurveNumber; j++ )
		{
			pDouble[j] = ReadDouble( inpf );
			
			// As soon there is an invalid data in a column, we consider that this curve is invalid.
			if( true == m_parfDTExist[j] && pDouble[j] == -1.0 )
			{
				m_parfDTExist[j] = false;
			}
		}
		
		m_pKvDTCurve->AddPoint( x, pDouble );
	}
	
	delete[] pDouble;
	return true;
}

#ifndef TACBX 
void CDB_ThermoCharacteristic::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_ThermoCharacteristic format.
		// line 0 : open curve bracket and call base class
		// line 1 to n-1 : Kv at 1K [ / Kv at 2K / Kv at 3K /... ]
		// line n : close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Read base.
		CDB_ValveCharacteristic::ReadText( inpf, pusLineCount );

		TCHAR *ptcEndPtr;

		// Read the first line.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		// If closing bracket, there is no curve for specific Kv at DT Kelvin...
		if( _T('}') == *ptcLine )
		{
			HYSELECT_THROW( _T("Unexpected '}' (pos: %i)."), *pusLineCount );
		}

		// Count number of column.
		int iColumnNumber = 1;
		TCHAR *Itr;
	
		for( Itr = ptcLine; _T('\0') != *Itr; Itr++ )
		{	
			if( _T('\\') == *Itr )
			{
				iColumnNumber++;
			}
		}

		// If there is at least two columns...
		if( iColumnNumber > 1 )
		{
			// Create curves.
			int iCurveNumber = iColumnNumber - 1;
			m_pKvDTCurve = new CCurveFitter( iCurveNumber );

			if( NULL == m_pKvDTCurve )
			{
				HYSELECT_THROW( _T("Internal error: 'm_pKvDTCurve' instantiation error (pos: %i)."), *pusLineCount );
			}

			// Create array to validate or invalidate curves.
			// Remark: it's possible to introduce a curve at 2K without 1K. In this case we have to write:
			//			  Opening 1 \ -1.0 \ Kv1
			//			  Opening 2 \ -1.0 \ Kv2
			//            ...
			//         and fill the first curve will all -1.0 value.
			//         In that case, 'm_parfDTExist' will be created with two entries. First entry will be set to false to 
			//         specify that curve at 1K is not valid. And second entry will be set to true to validate curve at 2K.
			m_parfDTExist = new bool[iCurveNumber];

			if( NULL == m_parfDTExist )
			{
				HYSELECT_THROW( _T("Internal error: 'm_parfDTExist' instantiation error (pos: %i)."), *pusLineCount );
			}

			memset( m_parfDTExist, 1, iCurveNumber * sizeof( bool ) );
			
			// Variables for temporary storage of data.
			int nCheck;
			double h;
			double *parDouble = new double[iCurveNumber];

			if( NULL == parDouble )
			{
				HYSELECT_THROW( _T("Internal error: 'parDouble' instantiation error (pos: %i)."), *pusLineCount );
			}

			TCHAR **pptcField;

			// Start the loop on lines.
			do 
			{
				nCheck = 0;
				pptcField = ParseTextLine( ptcLine, &nCheck );

				if( nCheck != iColumnNumber )
				{
					HYSELECT_THROW( _T("The current line has not the correct number of tokens (%i != %i) (pos: %i)."), nCheck, iColumnNumber, *pusLineCount );
				}

				// Look for opening.
				h = _tcstod( pptcField[0], &ptcEndPtr );

				if( _T('\0') != *ptcEndPtr )
				{
					HYSELECT_THROW( _T("Can't read the setting value (%s) at position 0 of the curve definition (pos: %i)."), pptcField[0], *pusLineCount );
				}
		
				// Look for Kv at DT Kelvin.
				for( int i = 1; i < iColumnNumber; i++ )
				{
					parDouble[i - 1] = _tcstod( pptcField[i], &ptcEndPtr );

					if( _T('\0') != *ptcEndPtr )
					{
						HYSELECT_THROW( _T("Can't read the double value (%s) at position %i of the curve definition (pos: %i)."), pptcField[i], i, *pusLineCount );
					}

					// As soon there is an invalid data in a column, we consider that this curve is invalid.
					if( true == m_parfDTExist[i - 1] && parDouble[i - 1] == -1.0 )
					{
						m_parfDTExist[i - 1] = false;
					}
				}
		
				// Add data to the "curve".
				m_pKvDTCurve->AddPoint( h, parDouble );

				ptcLine = ReadTextLine( inpf, pusLineCount );

				if( _T('}') == *ptcLine )
				{
					break;
				}

			}while( 1 );

			delete[] parDouble;
	
#if defined(_DEBUG)
			// Make check on Kv. Be sure that Kv is a monotonic function of opening.
			if( m_pKvDTCurve->GetSize() <= 1 )
			{
				HYSELECT_THROW( _T("Curve definition must have at least one y value (pos: %i)."), *pusLineCount );
			}

			for( int i = m_pKvDTCurve->GetSize()- 1 ; i > 1; i-- )
			{
				if( ( ( m_pKvDTCurve->GetPointF( i ) - m_pKvDTCurve->GetPointF( i - 1 ) ) *
					( m_pKvDTCurve->GetPointF( i - 1 ) - m_pKvDTCurve->GetPointF( i - 2 ) ) ) < 0.0 )
				{
					HYSELECT_THROW( _T("Error in the curve definition (pos: %i)."), *pusLineCount );
				}
			}
#endif 

		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_ThermoCharacteristic::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_QDpCharacteristic
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_QDpCharacteristic )

CDB_QDpCharacteristic::CDB_QDpCharacteristic( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_Characteristic( pDataBase, ID )
{
	m_dQmin = -1.0;
	m_dQnom = -1.0;
	m_dQmax = -1.0;
	m_eQDpCharCurveType = QDpCharCurveTypeNA;
	m_dKv = -1.0;
	m_pQDpChar = NULL;
}

CDB_QDpCharacteristic::~CDB_QDpCharacteristic()
{
	if( NULL != m_pQDpChar )
	{
		delete m_pQDpChar;
		m_pQDpChar = NULL;
	}
}

double CDB_QDpCharacteristic::GetQ( double dDp, double dRho )
{
	double dFlow = -1.0;

	switch( m_eQDpCharCurveType )
	{
		case QDpCharCurveTypeNA:
			break;

		case QDpCharCurveTypeKv:

			if( -1.0 != m_dKv )
			{
				dFlow = CalcqT( m_dKv, dDp, dRho );
			}

			break;

		case QDpCharCurveTypeQDp:

			if( NULL != m_pQDpChar && dDp >= m_pQDpChar->GetMinFX() && dDp <= m_pQDpChar->GetMaxFX() )
			{
				if( false == m_pQDpChar->GetRoot( dDp, &dFlow ) )
				{
					dFlow = -1.0;
				}
			}
			
			break;
	}
	
	return dFlow;
}

double CDB_QDpCharacteristic::GetQmin()
{
	return m_dQmin;
}

double CDB_QDpCharacteristic::GetQnom()
{
	return m_dQnom;
}

double CDB_QDpCharacteristic::GetQmax()
{
	return m_dQmax;
}

double CDB_QDpCharacteristic::GetDp( double dQ, double dRho )
{
	double dDp = -1.0;

	switch( m_eQDpCharCurveType )
	{
		case QDpCharCurveTypeNA:
			break;

		case QDpCharCurveTypeKv:

			if( -1.0 != m_dKv && -1.0 != m_dQmin && dQ >= m_dQmin && -1.0 != m_dQmax && dDp <= m_dQmax && -1.0 != dRho )
			{
				dDp = CalcDp( dQ, m_dKv, dRho );
			}
			
			break;
			
		case QDpCharCurveTypeQDp:

			if( NULL != m_pQDpChar && -1.0 != m_dQmin && dQ >= m_dQmin && -1.0 != m_dQmax && dDp <= m_dQmax )
			{
				dDp = m_pQDpChar->GetValue( dQ );
			}
			
			break;
	}
	
	return dDp;
}

double CDB_QDpCharacteristic::GetDpMin( double dRho )
{
	double dDpMin = -1.0;

	switch( m_eQDpCharCurveType )
	{
		case QDpCharCurveTypeNA:
			break;

		case QDpCharCurveTypeKv:

			if( -1.0 != m_dKv && -1.0 != m_dQmin && -1.0 != dRho )
			{
				dDpMin = CalcDp( m_dQmin, m_dKv, dRho );
			}
			
			break;
			
		case QDpCharCurveTypeQDp:

			if( NULL != m_pQDpChar && -1.0 != m_dQmin )
			{
				dDpMin = m_pQDpChar->GetValue( m_dQmin );
			}
			
			break;
	}
	
	return dDpMin;
}

double CDB_QDpCharacteristic::GetDpNom( double dRho )
{
	double dDpNom = -1.0;
	
	switch( m_eQDpCharCurveType )
	{
		case QDpCharCurveTypeNA:
			break;

		case QDpCharCurveTypeKv:

			if( -1.0 != m_dKv && -1.0 != m_dQnom && -1.0 != dRho )
			{
				dDpNom = CalcDp( m_dQnom, m_dKv, dRho );
			}
			
			break;
			
		case QDpCharCurveTypeQDp:

			if( NULL != m_pQDpChar && -1.0 != m_dQnom )
			{
				dDpNom = m_pQDpChar->GetValue( m_dQnom );
			}
			
			break;
	}
	
	return dDpNom;
}

double CDB_QDpCharacteristic::GetDpMax( double dRho )
{
	double dDpMax = -1.0;

	switch( m_eQDpCharCurveType )
	{
		case QDpCharCurveTypeNA:
			break;

		case QDpCharCurveTypeKv:
	
			if( -1.0 != m_dKv && -1.0 != m_dQmax && -1.0 != dRho )
			{
				dDpMax = CalcDp( m_dQmax, m_dKv, dRho );
			}
			
			break;
			
		case QDpCharCurveTypeQDp:
			
			if( NULL != m_pQDpChar && -1.0 != m_dQmax )
			{
				dDpMax = m_pQDpChar->GetValue( m_dQmax );
			}
			
			break;
	}
	
	return dDpMax;
}

double CDB_QDpCharacteristic::GetKv( double dQ, double dRho )
{
	double dKv = -1.0;
	
	switch( m_eQDpCharCurveType )
	{
		case QDpCharCurveTypeNA:
			break;

		case QDpCharCurveTypeKv:
			dKv = m_dKv;
			break;
			
		case QDpCharCurveTypeQDp:
			
			if( NULL != m_pQDpChar && dQ >= m_pQDpChar->GetMinX() && dQ <= m_pQDpChar->GetMaxX() && -1.0 != dRho )
			{
				double dDp = m_pQDpChar->GetValue( dQ );
				dKv = CalcKv( dQ, dDp, dRho );
			}
			
			break;
	}

	return dKv;
}

double CDB_QDpCharacteristic::GetKvMin( double dRho )
{
	double dKvMin = -1.0;

	switch( m_eQDpCharCurveType )
	{
		case QDpCharCurveTypeNA:
			break;

		case QDpCharCurveTypeKv:
			dKvMin = m_dKv;
			break;
			
		case QDpCharCurveTypeQDp:

			if( NULL != m_pQDpChar && -1.0 != m_dQmin && -1.0 != dRho )
			{
				double dDpMin = m_pQDpChar->GetValue( m_dQmin );
				dKvMin = CalcKv( m_dQmin, dDpMin, dRho );
			}

			break;
	}

	return dKvMin;
}

double CDB_QDpCharacteristic::GetKvNom( double dRho )
{
	double dKvNom = -1.0;

	switch( m_eQDpCharCurveType )
	{
		case QDpCharCurveTypeNA:
			break;

		case QDpCharCurveTypeKv:
			dKvNom = m_dKv;
			break;
			
		case QDpCharCurveTypeQDp:

			if( NULL != m_pQDpChar && -1.0 != m_dQnom && -1.0 != dRho )
			{
				double dDpNom = m_pQDpChar->GetValue( m_dQnom );
				dKvNom = CalcKv( m_dQnom, dDpNom, dRho );
			}

			break;
	}

	return dKvNom;
}

double CDB_QDpCharacteristic::GetKvMax( double dRho )
{
	double dKvMax = -1.0;

	switch( m_eQDpCharCurveType )
	{
		case QDpCharCurveTypeNA:
			break;

		case QDpCharCurveTypeKv:
			dKvMax = m_dKv;
			break;
			
		case QDpCharCurveTypeQDp:

			if( NULL != m_pQDpChar && -1.0 != m_dQmax && -1.0 != dRho )
			{
				double dDpMax = m_pQDpChar->GetValue( m_dQmax );
				dKvMax = CalcKv( m_dQmax, dDpMax, dRho );
			}

			break;
	}

	return dKvMax;
}

#define CDB_QDPCHARACTERISTIC_VERSION	1
void CDB_QDpCharacteristic::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_QDPCHARACTERISTIC_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_Characteristic::Write( outf );
	
	// Infos.
	outf.write( (char *)&m_dQmin, sizeof( m_dQmin ) );
	outf.write( (char *)&m_dQnom, sizeof( m_dQnom ) );
	outf.write( (char *)&m_dQmax, sizeof( m_dQmax ) );
	outf.write( (char *)&m_eQDpCharCurveType, sizeof( m_eQDpCharCurveType ) );
	
	if( QDpCharCurveTypeNA == m_eQDpCharCurveType )
	{
		return;
	}
	else if( QDpCharCurveTypeKv == m_eQDpCharCurveType )
	{
		outf.write( (char *)&m_dKv, sizeof( m_dKv ) );
	}
	else
	{
		// The curves.
		int i = m_pQDpChar->GetSize();
		outf.write( (char *)&i, sizeof( i ) );

		for( i--; i >= 0; i-- )
		{
			// Q.
			double dQ = m_pQDpChar->GetPointX( i );
			outf.write( (char *)&dQ, sizeof( double ) );
		
			// Dp.
			double dDp = m_pQDpChar->GetPointF( i );
			outf.write( (char *)&dDp, sizeof( double ) );
		}
	}
}

bool CDB_QDpCharacteristic::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_QDPCHARACTERISTIC_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_Characteristic::Read( inpf ) )
	{
		return false;
	}
	
	// Infos.
	m_dQmin = ReadDouble( inpf );
	m_dQnom = ReadDouble( inpf );
	m_dQmax = ReadDouble( inpf );
	inpf.read( (char *)&m_eQDpCharCurveType, sizeof( m_eQDpCharCurveType ) );

	if( QDpCharCurveTypeNA == m_eQDpCharCurveType )
	{
		return true;
	}
	else if( QDpCharCurveTypeKv == m_eQDpCharCurveType )
	{
		m_dKv = ReadDouble( inpf );
	}
	else
	{
		// QDpCharCurveTypeQDp
		if( NULL != m_pQDpChar )
		{
			delete m_pQDpChar;
		}

		m_pQDpChar = new CCurveFitter;
		int iNbrPoints;
		inpf.read( (char *)&iNbrPoints, sizeof( iNbrPoints ) );
		
		for( ; 0 != iNbrPoints ; iNbrPoints-- )
		{
			double dQ = ReadDouble( inpf );
			double dDp = ReadDouble( inpf );
			m_pQDpChar->AddPoint( dQ, &dDp );
		}
	}
	
	return true;
}

#ifndef TACBX 
void CDB_QDpCharacteristic::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_QDpCharacteristic format
		// line 0 : open curve bracket and call base class.
		// line 1 : qmin
		// line 2 : qnom
		// line 3 : qmax
		// line 4 : curve type ('QDpCharCurveTypeKv' or 'QDpCharCurveTypeQDp').
		// line 5 : Kv or q1 / Dp1
		// line 6 :       q2 / Dp2
		// ...
		// line x : close curve bracket.
	
		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Read base.
		CDB_Characteristic::ReadText( inpf, pusLineCount );

		TCHAR *ptcEndPtr;
	
		// Qmin.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		m_dQmin = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Cant read 'CDB_QDpCharacteristic::Qmin' (%s) (pos: %i)."), ptcLine, *pusLineCount );
		}

		if( m_dQmin < 0.0 )
		{
			HYSELECT_THROW( _T("'CDB_QDpCharacteristic::Qmin' (%f) can't be lower than 0.0 (pos: %i)."), m_dQmin, *pusLineCount );
		}

		// Qnom.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_dQnom = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Cant read 'CDB_QDpCharacteristic::Qnom' (%s) (pos: %i)."), ptcLine, *pusLineCount );
		}

		if( m_dQnom < 0.0 )
		{
			HYSELECT_THROW( _T("'CDB_QDpCharacteristic::Qnom' (%f) can't be lower than 0.0 (pos: %i)."), m_dQnom, *pusLineCount );
		}

		// Qmax.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_dQmax = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Cant read 'CDB_QDpCharacteristic::Qmax' (%s) (pos: %i)."), ptcLine, *pusLineCount );
		}

		if( m_dQmax < 0.0 )
		{
			HYSELECT_THROW( _T("'CDB_QDpCharacteristic::Qmax' (%f) can't be lower than 0.0 (pos: %i)."), m_dQmax, *pusLineCount );
		}

		// Curve type.
		int iValue = ReadEnumLine( inpf, pusLineCount );

		if( iValue < QDpCharCurveTypeNA || iValue > QDpCharCurveTypeQDp )
		{	
			HYSELECT_THROW( _T("'CDB_ValveCharacteristic::CurveType' value must be one of these values: '#eCurveType_Kv' or '#eCurveType_QDp'.") );
		}

		m_eQDpCharCurveType = (QDpCharCurveType)iValue;

		if( QDpCharCurveType::QDpCharCurveTypeNA == m_eQDpCharCurveType )
		{
			// Read the close curve bracket.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _T('}') != *ptcLine )
			{
				HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
			}
		}
		else if( QDpCharCurveType::QDpCharCurveTypeKv == m_eQDpCharCurveType )
		{
			// Kv.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_dKv = _tcstod( ptcLine, &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't read the Kv value (%s) at position 0 of the curve definition (pos: %i)."), ptcLine, *pusLineCount );
			}

			if( m_dKv < 0.0 )
			{
				HYSELECT_THROW( _T("Kv value (%f) can't be lower than 0 (pos: %i)."), ptcLine, *pusLineCount );
			}

			// Read the close curve bracket.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _T('}') != *ptcLine )
			{
				HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
			}
		}
		else
		{
			// QDpCharCurveTypeQDp.
			if( NULL != m_pQDpChar )
			{
				delete m_pQDpChar;
			}

			m_pQDpChar = new CCurveFitter;

			if( NULL == m_pQDpChar )
			{
				HYSELECT_THROW( _T("Internal error: 'm_pQDpChar' instantiation error (pos: %i)."), *pusLineCount );
			}

			TCHAR **pptcField;
		
			do 
			{
				// Start the loop on lines.
				ptcLine = ReadTextLine( inpf, pusLineCount );

				if( _T('}') == *ptcLine )
				{
					break;
				}

				int nCheck = 0;
				pptcField = ParseTextLine( ptcLine, &nCheck );

				if( 2 != nCheck )
				{
					HYSELECT_THROW( _T("The current line has not the correct number of tokens (%i != 2) (pos: %i)."), nCheck, *pusLineCount );
				}

				// Look for the flow and pressure drop.
				double dQ = _tcstod( pptcField[0], &ptcEndPtr );

				if( _T('\0') != *ptcEndPtr )
				{
					HYSELECT_THROW( _T("Can't read the flow value (%s) at position 0 of the curve definition (pos: %i)."), pptcField[0], *pusLineCount );
				}

				double dDp = _tcstod( pptcField[1], &ptcEndPtr );

				if( _T('\0') != *ptcEndPtr )
				{
					HYSELECT_THROW( _T("Can't read the Dp value (%s) at position 1 of the curve definition (pos: %i)."), pptcField[1], *pusLineCount );
				}

				// Add data to the "curve".
				m_pQDpChar->AddPoint( dQ, &dDp );

			}while( 1 );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_QDpCharacteristic::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif 

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_CloseOffChar
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_CloseOffChar)

CDB_CloseOffChar::CDB_CloseOffChar( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
	m_OpenType = Linear;
	m_LimitType = CloseOffDp;
	m_pCloseOffCharacteristic = NULL;
}

double CDB_CloseOffChar::GetCloseOffDpMax() 
{
	double dCloseOffDpMax = -1.0;

	if( CloseOffDp == m_LimitType )
	{
		dCloseOffDpMax = m_pCloseOffCharacteristic->GetMaxFX();
	}

	return dCloseOffDpMax;
}

double CDB_CloseOffChar::GetCloseOffDpMin()
{
	double dCloseOffDpMin = -1.0;

	if( CloseOffDp == m_LimitType )
	{
		dCloseOffDpMin = m_pCloseOffCharacteristic->GetMinFX();
	}

	return dCloseOffDpMin;
}

double CDB_CloseOffChar::GetCloseOffDp( double dF )
{
	double dCloseOffDp = -1.0;

	if( CloseOffDp == m_LimitType )
	{
		if( m_pCloseOffCharacteristic->GetMinX() == m_pCloseOffCharacteristic->GetMaxX() )
		{
			dCloseOffDp = m_pCloseOffCharacteristic->GetMaxFX();				
		}
		else
		{
			dCloseOffDp = m_pCloseOffCharacteristic->GetValue( dF );
		}
	}

	return dCloseOffDp;
}

double CDB_CloseOffChar::GetMaxInletPressureMax()
{
	double dMaxInletPressureMax = -1.0;

	if( InletPressure == m_LimitType )
	{
		dMaxInletPressureMax = m_pCloseOffCharacteristic->GetMaxFX();
	}

	return dMaxInletPressureMax;
}

double CDB_CloseOffChar::GetMaxInletPressureMin()
{
	double dMaxInletPressureMin = -1.0;

	if( InletPressure == m_LimitType )
	{
		dMaxInletPressureMin = m_pCloseOffCharacteristic->GetMinFX();
	}

	return dMaxInletPressureMin;
}

double CDB_CloseOffChar::GetMaxInletPressure( double dF )
{
	double dMaxInletPressure = -1.0;

	if( InletPressure == m_LimitType )
	{
		if( m_pCloseOffCharacteristic->GetMinX() == m_pCloseOffCharacteristic->GetMaxX() )
		{
			dMaxInletPressure = m_pCloseOffCharacteristic->GetMaxFX();
		}
		else
		{
			dMaxInletPressure = m_pCloseOffCharacteristic->GetValue( dF );
		}
	}

	return dMaxInletPressure;
}

double CDB_CloseOffChar::GetForceTorqueMax()
{
	return m_pCloseOffCharacteristic->GetMaxX();
}

double CDB_CloseOffChar::GetForceTorqueMin()
{
	return m_pCloseOffCharacteristic->GetMinX();
}

double CDB_CloseOffChar::GetForceTorqueFromDp( double dCloseOffDp )
{
	double dForceTorque = -1.0;

	if( CloseOffDp == m_LimitType )
	{
		dForceTorque = _GetForceTorque( dCloseOffDp );
	}

	return dForceTorque;
}

double CDB_CloseOffChar::GetForceTorqueFromInletPressure( double dInletPressure )
{
	double dForceTorque = -1.0;

	if( InletPressure == m_LimitType )
	{
		dForceTorque = _GetForceTorque( dInletPressure );
	}

	return dForceTorque;
}

void CDB_CloseOffChar::OnDatabaseDestroy()
{
	CData::OnDatabaseDestroy();
}

#define CDB_CLOSEOFFCHAR_VERSION	2
// Version 2: 'm_LimitType' added.
void CDB_CloseOffChar::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_CLOSEOFFCHAR_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CData::Write( outf );

	// Characteristic type.
	outf.write( (char *)&m_OpenType, sizeof( m_OpenType ) );

	// The curve.
	int i = m_pCloseOffCharacteristic->GetSize();
	outf.write( (char *)&i, sizeof( i ) );

	for( i--; i >= 0; i-- )
	{
		// Position.
		double dX = m_pCloseOffCharacteristic->GetPointX( i );
		outf.write( (char *)&dX, sizeof( double ) );
		double dF = m_pCloseOffCharacteristic->GetPointF( i );
		outf.write( (char *)&dF, sizeof( double ) );
	}

	// Version 2.
	outf.write( ( char * )&m_LimitType, sizeof( m_LimitType ) );
}

bool CDB_CloseOffChar::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );
	
	if( Version < 1 || Version > CDB_CLOSEOFFCHAR_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	m_pCloseOffCharacteristic = new CCurveFitter ();

	if( NULL == m_pCloseOffCharacteristic )
	{
		return false;
	}
	
	// Characteristic type.
	inpf.read( (char *)&m_OpenType, sizeof( m_OpenType ) );

	// The curve.
	int i;
	double x;
	double f;

	for( inpf.read( (char *)&i, sizeof( i ) ); i; i-- )
	{
		x = ReadDouble( inpf );
		f = ReadDouble( inpf );
		m_pCloseOffCharacteristic->AddPoint( x, &f );
	}

	if( Version < 2 )
	{
		return true;
	}

	inpf.read( ( char * )&m_LimitType, sizeof( m_LimitType ) );

	return true;
}

#ifndef TACBX 
void CDB_CloseOffChar::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		//	new:CDB_CloseOffChar(ID) -> CLSOFF_CHAR_TAB
		//	{
		//		Linear/Circular (0/1)
		//      LimitType								Can be #eLIMITTYPE_CloseOffDp or # eLIMITTYPE_InletPressure.
		//		Force/Torque 1 \ Close-off Dp 1
		//		Force/Torque 2 \ Close-off Dp 2
		//		...
		//	}

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Read base.
		CData::ReadText( inpf, pusLineCount );

		// Read the opening type.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		// If first character is '#' the string must be interpreted as a enum.
		int iValue = 0;
	
		if( _T('#') == *ptcLine )
		{
			CString str = ptcLine;
			iValue = ReadEnum( str );

			if( iValue != eOpenType::Linear && iValue != eOpenType::Circular )
			{
				HYSELECT_THROW( _T("'CDB_CloseOffChar::OpenType' value must be one of these values: '#eOPENTYPE_Linear' or '#eOPENTYPE_Circular' (pos: %i)."), *pusLineCount );
			}
		}
		else
		{
			iValue = _ttoi( ptcLine );

			if( iValue != eOpenType::Linear && iValue != eOpenType::Circular )
			{
				HYSELECT_THROW( _T("'CDB_CloseOffChar::OpenType' value must be 0 or 1 (pos: %i)."), *pusLineCount );
			}
		}

		m_OpenType = (enum eOpenType)iValue;
	
		// Read the limitation type.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		// If first character is '#' the string must be interpreted as a enum.
		iValue = 0;

		if( _T('#') == *ptcLine )
		{
			CString str = ptcLine;
			iValue = ReadEnum( str );

			if( iValue != eLimitType::CloseOffDp && iValue != eLimitType::InletPressure )
			{
				HYSELECT_THROW( _T("'CDB_CloseOffChar::OpenType' value must be one of these values: '#eLIMITTYPE_CloseOffDp' or '#eLIMITTYPE_InletPressure' (pos: %i)."), *pusLineCount );
			}
		}
		else
		{
			iValue = _ttoi( ptcLine );
		}

		m_LimitType = ( enum eLimitType )iValue;

		// Read the curve characteristics.
		m_pCloseOffCharacteristic = new CCurveFitter();

		if( NULL == m_pCloseOffCharacteristic )
		{
			HYSELECT_THROW( _T("Internal error: 'm_pCloseOffCharacteristic' instantiation error (pos: %i)."), *pusLineCount );
		}
	
		// Variables for temporary storage of data.
		int nCheck;
		double dForce, dCloseOffValue;
		TCHAR *ptcEndPtr;
		TCHAR **pptcField;
	
		// Start the loop on lines.
		bool bNoValues = false;

		do 
		{
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _T('}') == *ptcLine )
			{
				break;
			}

			nCheck = 0;
			pptcField = ParseTextLine( ptcLine, &nCheck );

			if( 2 != nCheck )
			{
				HYSELECT_THROW( _T("The current line has not the correct number of tokens (%i != 2) (pos: %i)."), nCheck, *pusLineCount );
			}

			// Look for force/torque.
			dForce = _tcstod( pptcField[0], &ptcEndPtr);

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't read the force/torque value (%s) at position 0 of the close-off characteristic definition (pos: %i)."), pptcField[0], *pusLineCount );
			}

			// Look for close off value.
			dCloseOffValue = _tcstod( pptcField[1], &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't read the close-off value (%s) at position 0 of the close-off characteristic definition (pos: %i)."), pptcField[1], *pusLineCount );
			}
		
			if( -1.0 == dForce || -1.0 == dCloseOffValue )
			{
				bNoValues = true;
			}

			// Add data to the "curve".
			m_pCloseOffCharacteristic->AddPoint( dForce, &dCloseOffValue );

		}while( 1 );

		// Make check on CofDp. Be sure that CofDp is a monotonic function of force.
		if( false == bNoValues )
		{
			if( m_pCloseOffCharacteristic->GetSize() <= 0 )
			{
				HYSELECT_THROW( _T("Close-off characteristic definition must have at least one y value (pos: %i)."), *pusLineCount );
			}

			for( int i = m_pCloseOffCharacteristic->GetSize() - 1; i>1; i-- )
			{
				if( ( ( m_pCloseOffCharacteristic->GetPointF( i ) - m_pCloseOffCharacteristic->GetPointF( i - 1 ) ) *
					( m_pCloseOffCharacteristic->GetPointF( i - 1 ) - m_pCloseOffCharacteristic->GetPointF( i - 2 ) ) ) < 0.0 )
				{
					HYSELECT_THROW( _T("Error in the Close-off characteristic definition (pos: %i)."), *pusLineCount );
				}
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_CloseOffChar::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif

double CDB_CloseOffChar::_GetForceTorque( double dValue )
{
	if( dValue > m_pCloseOffCharacteristic->GetMaxFX() )
	{
		return -1.0;
	}

	double d;

	if( false == m_pCloseOffCharacteristic->GetRoot( dValue, &d ) )
	{
		double dCloseOffDpMin = m_pCloseOffCharacteristic->GetMinFX();
		double dCloseOffDpMax = m_pCloseOffCharacteristic->GetMaxFX();
		double dMaxForce = m_pCloseOffCharacteristic->GetValue( m_pCloseOffCharacteristic->GetMaxX() );
		double dMinForce = m_pCloseOffCharacteristic->GetValue( m_pCloseOffCharacteristic->GetMinX() );

		if( ( dValue < dCloseOffDpMin && dMaxForce > dMinForce )
				 ||	( dValue > dCloseOffDpMax && dMaxForce < dMinForce ) )
		{
			return m_pCloseOffCharacteristic->GetMinX();
		}
		else
		{
			return m_pCloseOffCharacteristic->GetMaxX();
		}
	}

	return d;
}
 

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_PICVCharacteristic
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_PICVCharacteristic )

CDB_PICVCharacteristic::CDB_PICVCharacteristic( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_ValveCharacteristic( pDataBase, ID )
{
	m_nNumberOfPICVCharCurves = 0;
	m_dKvd = 0.0;
	m_dFc = 0.0;
	m_dQmax = 0.0;
	m_bQmaxCharGiven = false;
	m_bDpminCharGiven = false;
	m_bStrokeCharGiven = false;
	m_pQmaxDpminChar = NULL;
}

CDB_PICVCharacteristic::~CDB_PICVCharacteristic()
{
	if( NULL != m_pQmaxDpminChar )
	{
		delete m_pQmaxDpminChar;
	}
}

void CDB_PICVCharacteristic::SetQmaxDpminChar( CCurveFitter* pQmaxDpMinChar )
{
	if( NULL != m_pQmaxDpminChar )
	{
		delete m_pQmaxDpminChar;
		m_pQmaxDpminChar = NULL;
	}
	
	if( NULL == pQmaxDpMinChar )
	{
		return;
	}
	
	m_pQmaxDpminChar = new CCurveFitter();

	if( NULL == m_pQmaxDpminChar )
	{
		return;
	}

	pQmaxDpMinChar->Copy( m_pQmaxDpminChar );
}

double CDB_PICVCharacteristic::GetSettingMax()
{
	double dSettingMax = -1.0;

	if( NULL != m_pQmaxDpminChar )
	{
		dSettingMax = m_pQmaxDpminChar->GetMaxX();
	}

	return dSettingMax;
}

double CDB_PICVCharacteristic::GetSettingMin()
{
	double dSettingMin = -1.0;
	if( NULL != m_pQmaxDpminChar )
	{
		dSettingMin = m_pQmaxDpminChar->GetMinX();
	}

	return dSettingMin;
}

#ifndef TACBX
bool CDB_PICVCharacteristic::IsStrokeCurveDefined()
{
	return ( 3 == m_pQmaxDpminChar->GetFuncNumber() ) ? true : false;
}

double CDB_PICVCharacteristic::GetMinSettingWithActuator( CDB_Actuator *pclActuator )
{
	double dMinSettingWithTASlider = 0.0;
	
	if( false == m_pQmaxDpminChar->GetRoot( pclActuator->GetMinLimitedStroke(), &dMinSettingWithTASlider, 2 ) )
	{
		dMinSettingWithTASlider = 0.0;
	}

	return dMinSettingWithTASlider;
}
#endif

double CDB_PICVCharacteristic::GetQmaxMax()
{
	double dQmaxMax = -1.0;

	if( NULL != m_pQmaxDpminChar )
	{
		dQmaxMax = m_pQmaxDpminChar->GetMaxFX();
	}

	return dQmaxMax;
}
	
double CDB_PICVCharacteristic::GetQmaxMin()
{
	double dQmaxMin = -1.0;

	if( NULL != m_pQmaxDpminChar )
	{
		dQmaxMin = m_pQmaxDpminChar->GetMinFX();
	}

	return dQmaxMin;
}
	
double CDB_PICVCharacteristic::GetDpminMax()
{
	double dDpminMax = -1.0;

	if( NULL != m_pQmaxDpminChar )
	{
		dDpminMax = m_pQmaxDpminChar->GetMaxFX( 1 );
	}

	return dDpminMax;
}
	
double CDB_PICVCharacteristic::GetDpminMin()
{
	double dDpminMin = -1.0;

	if( NULL != m_pQmaxDpminChar )
	{
		dDpminMin = m_pQmaxDpminChar->GetMinFX( 1 );
	}

	return dDpminMin;
}
	
double CDB_PICVCharacteristic::GetQmax( double dSetting )
{
	double dQmax = -1.0;
	if( NULL != m_pQmaxDpminChar )
	{
		dQmax = m_pQmaxDpminChar->GetValue( dSetting );
	}

	return dQmax;
}
	
double CDB_PICVCharacteristic::GetDpmin( double dSetting )
{
	double dDpmin = -1.0;

	if( NULL != m_pQmaxDpminChar )
	{
		dDpmin = m_pQmaxDpminChar->GetValue( dSetting, 1 );
	}

	return dDpmin;
}

double CDB_PICVCharacteristic::GetSettingFromQmax( double dQmax )
{
	if( NULL == m_pQmaxDpminChar || dQmax > m_pQmaxDpminChar->GetMaxFX() )
	{
		return -1.0;
	}
	
	double dSetting;

	if( false == m_pQmaxDpminChar->GetRoot( dQmax, &dSetting ) )
	{
		// If can't get setting (it means 'dQmax' is out of the curve range).

		// Check if we must take the min setting or the max setting (it depends in fact of the direction of the curve).
		if( ( dQmax < m_pQmaxDpminChar->GetMinFX() &&
			  m_pQmaxDpminChar->GetValue( m_pQmaxDpminChar->GetMaxX() ) > m_pQmaxDpminChar->GetValue( m_pQmaxDpminChar->GetMinX() ) ) ||
			( dQmax > m_pQmaxDpminChar->GetMaxFX() &&
			  m_pQmaxDpminChar->GetValue( m_pQmaxDpminChar->GetMaxX() ) < m_pQmaxDpminChar->GetValue( m_pQmaxDpminChar->GetMinX() ) ) )
		{
			dSetting = m_pQmaxDpminChar->GetMinX();
		}
		else
		{
			dSetting = m_pQmaxDpminChar->GetMaxX();
		}
	}
	
	return dSetting;
}

double CDB_PICVCharacteristic::GetSettingFromDpmin( double dDpmin )
{
	if( NULL == m_pQmaxDpminChar || dDpmin > m_pQmaxDpminChar->GetMaxFX( 1 ) )
	{
		return -1.0;
	}
	
	double dSetting;

	if( false == m_pQmaxDpminChar->GetRoot( dDpmin, &dSetting, 1 ) )
	{
		if( ( dDpmin < m_pQmaxDpminChar->GetMinFX( 1 ) &&
			  m_pQmaxDpminChar->GetValue( m_pQmaxDpminChar->GetMaxX(), 1 ) > m_pQmaxDpminChar->GetValue( m_pQmaxDpminChar->GetMinX(), 1 ) ) ||
			( dDpmin > m_pQmaxDpminChar->GetMaxFX( 1 ) &&
			  m_pQmaxDpminChar->GetValue( m_pQmaxDpminChar->GetMaxX(), 1 ) < m_pQmaxDpminChar->GetValue( m_pQmaxDpminChar->GetMinX(), 1 ) ) )
		{
			dSetting = m_pQmaxDpminChar->GetMinX();
		}
		else
		{
			dSetting = m_pQmaxDpminChar->GetMaxX();
		}
	}
	
	return dSetting;
}

double CDB_PICVCharacteristic::GetStroke( double dSetting )
{
	double dStroke = -1.0;

	if( true == m_bStrokeCharGiven && NULL != m_pQmaxDpminChar )
	{
		dStroke = m_pQmaxDpminChar->GetValue( dSetting, 2 );
	}

	return dStroke;
}

double CDB_PICVCharacteristic::GetFc()
{
	if( false == DpminCharGiven() )
	{
		return m_dFc;
	}
	else 
	{
		return -1;
	}
}

void CDB_PICVCharacteristic::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_PICVCharacteristic *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_PICVCharacteristic' object!") );
		}
	
		// Base class.
		CDB_ValveCharacteristic::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_PICVCharacteristic" class.
		CDB_PICVCharacteristic *pclDestinationPICVCharacteristic = (CDB_PICVCharacteristic *)pclDestination;
		
		pclDestinationPICVCharacteristic->SetKvd( m_dKvd );
		pclDestinationPICVCharacteristic->SetFc( m_dFc );
		pclDestinationPICVCharacteristic->SetQmax( m_dQmax );
		pclDestinationPICVCharacteristic->SetNumberOfCurves( m_nNumberOfPICVCharCurves );
		pclDestinationPICVCharacteristic->SetQmaxCharGiven( m_bQmaxCharGiven );
		pclDestinationPICVCharacteristic->SetDpminCharGiven( m_bDpminCharGiven );
		pclDestinationPICVCharacteristic->SetQmaxDpminChar( m_pQmaxDpminChar );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_PICVCharacteristic::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_PICVCHARACTERISTIC_VERSION  4
// HYS-1355: add 'm_bStrokeCharGiven'.
void CDB_PICVCharacteristic::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_PICVCHARACTERISTIC_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_ValveCharacteristic::Write( outf );
	
	// Info.
	outf.write( (char *)&m_dKvd, sizeof( m_dKvd ) );
	outf.write( (char *)&m_dFc, sizeof( m_dFc ) );
	outf.write( (char *)&m_dQmax, sizeof( m_dQmax ) );
	outf.write( (char *)&m_bQmaxCharGiven, sizeof( m_bQmaxCharGiven ) );
	outf.write( (char *)&m_bDpminCharGiven, sizeof( m_bDpminCharGiven ) );

	// Version 4.
	outf.write( (char*)&m_bStrokeCharGiven, sizeof( m_bStrokeCharGiven ) );
	
	if( true == m_bQmaxCharGiven || true == m_bDpminCharGiven )	// DpminChar can be given only if QmaxChar is given
	{
		// The qmax/Dpmin characteristic.
		int i = m_pQmaxDpminChar->GetSize();
		outf.write( (char *)&i, sizeof( i ) );
		
		for( i--; i >= 0; i-- )
		{
			// Position.
			double dX = m_pQmaxDpminChar->GetPointX( i );
			outf.write( (char *)&dX, sizeof( double ) );
			
			// Qmax and Dpmin.
			for( int j = 0; j < m_nNumberOfPICVCharCurves; j++ )
			{
				double dF = m_pQmaxDpminChar->GetPointF( i, j );
				outf.write( (char *)&dF, sizeof( double ) );
			}
		}
	}
}

bool CDB_PICVCharacteristic::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_PICVCHARACTERISTIC_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDB_ValveCharacteristic::Read( inpf ) )
	{
		return false;
	}

	// Info.
	m_dKvd = ReadDouble( inpf );
	m_dFc = ReadDouble( inpf );
	m_dQmax = ReadDouble( inpf );

	inpf.read( (char *)&m_bQmaxCharGiven, sizeof( bool ) );
	
	if( 1 == Version )
	{
		m_bDpminCharGiven = true;
	}
	else
	{
		inpf.read( (char *)&m_bDpminCharGiven, sizeof( bool ) );
	}

	if( Version >= 4 )
	{
		inpf.read( (char*)&m_bStrokeCharGiven, sizeof( bool ) );
	}
	
	if( true == m_bQmaxCharGiven )
	{
		m_nNumberOfPICVCharCurves = m_bStrokeCharGiven ? 3 : ( m_bDpminCharGiven ? 2 : 1 );	// DpminChar can be given only if QmaxChar is given
		m_pQmaxDpminChar = new CCurveFitter( m_nNumberOfPICVCharCurves );

		if( NULL == m_pQmaxDpminChar )
		{
			return false;
		}

		// The curve.
		int i;
		double x;
		double *pDouble = new double [m_nNumberOfPICVCharCurves];

		if( NULL == pDouble )
		{
			return false;
		}

		for( inpf.read( (char *)&i, sizeof( i ) ); i; i-- )
		{
			x = ReadDouble( inpf );

			for( int j = 0; j < m_nNumberOfPICVCharCurves; j++ )
			{
				pDouble[j] = ReadDouble( inpf );
			}

			m_pQmaxDpminChar->AddPoint( x, pDouble );
		}
		
		delete[] pDouble;
	}
	
	return true;
}

#ifndef TACBX 
void CDB_PICVCharacteristic::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int ipos = pStr->Find( _T("CDB_PICVCharacteristic") );
		
		if( ipos < 0 )
		{
			CDB_ValveCharacteristic::InterpretInheritedData( pStr );
		}
		else
		{
			pStr->Delete( ipos, _tcsclen( _T("CDB_PICVCharacteristic") ) );
			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 )
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( _T("::Kvd=") ) > -1 )
			{
				double d;

				if( RD_OK != ReadDouble( strField, &d ) )
				{
					HYSELECT_THROW( _T("'CDB_PICVCharacteristic::Kvd' must be a double (%s)."), strField );
				}
			
				m_dKvd = d;
			}
			else if( pStr->Find( _T("::Fc=") ) > -1 )
			{
				double d;

				if( RD_OK != ReadDouble( strField, &d ) )
				{
					HYSELECT_THROW( _T("'CDB_PICVCharacteristic::Fc' must be a double (%s)."), strField );
				}
			
				m_dFc = d;
			}
			else if( pStr->Find( _T("::Qmax=") ) > -1 )
			{
				double d;

				if( RD_OK != ReadDouble( strField, &d ) )
				{
					HYSELECT_THROW( _T("'CDB_PICVCharacteristic::Qmax' must be a double (%s)."), strField );
				}
			
				m_dQmax = d;
			}
			else if( pStr->Find( _T("::QmaxDpminChar=") ) > -1 )
			{
				int iQmaxDpminChar = _ttoi( (LPCTSTR)strField );
			
				if( iQmaxDpminChar < 0 || iQmaxDpminChar > 3 )
				{
					HYSELECT_THROW( _T("'CDB_PICVCharacteristic::QmaxDpminChar' is incorrect (0 > %i > 3)."), iQmaxDpminChar );
				}
			
				m_nNumberOfPICVCharCurves = iQmaxDpminChar;
				m_bQmaxCharGiven = ( m_nNumberOfPICVCharCurves > 0 ) ? true : false;
				m_bDpminCharGiven = ( m_nNumberOfPICVCharCurves > 1 ) ? true : false;
				m_bStrokeCharGiven = (m_nNumberOfPICVCharCurves > 2) ? true : false;
			}
			else if( pStr->Find( _T("::QmaxDpminCurve=") ) > -1 )
			{
				if( NULL == m_pQmaxDpminChar )
				{
					m_pQmaxDpminChar = new CCurveFitter( m_nNumberOfPICVCharCurves );
				}

				if( NULL == m_pQmaxDpminChar )
				{
					HYSELECT_THROW( _T("Internal error: 'm_pQmaxDpminChar' instantiation error.") );
				}

				// Variables for temporary storage of data.
				double *parDouble = new double[m_nNumberOfPICVCharCurves];

				if( NULL == parDouble )
				{
					HYSELECT_THROW( _T("Internal error: 'parDouble' instantiation error.") );
				}
		
				int iCurPos = 0;
				CString strToken = strField.Tokenize( _T("\\"), iCurPos );

				// Look for setting.
				TCHAR *ptcEndPtr;
				double dSetting = _tcstod( (LPCTSTR)strToken, &ptcEndPtr );
			
				if( _T('\0') != *ptcEndPtr )
				{
					HYSELECT_THROW( _T("Can't read the setting value (%s) at position 0 of the curve definition."), strToken );
				}
			
				// Look for qmax,Dpmin.
				for( int i = 1; i <= m_nNumberOfPICVCharCurves; i++ )
				{
					strToken = strField.Tokenize( _T("\\"), iCurPos );
					
					if( true == strToken.IsEmpty() )
					{
						delete[] parDouble;
						HYSELECT_THROW( _T("Value at position %i is not defined for the curve definition."), i );
					}
				
					parDouble[i - 1] = _tcstod( (LPCTSTR)strToken, &ptcEndPtr );
				
					if( _T('\0') != *ptcEndPtr )
					{
						delete[] parDouble;
						HYSELECT_THROW( _T("Can't read the double value (%s) at position %i of the curve definition."), strToken, i );
					}
				}
			
				// Add data to the "curve".
				m_pQmaxDpminChar->AddPoint( dSetting, parDouble, true );
				delete[] parDouble;
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_PICVCharacteristic::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_PICVCharacteristic::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		//	new:CDB_PICVCharacteristic(ID) -> VALVE_CHAR_TAB
		//	{
		//		{
		//			{
		//				Discrete/Continuous enum(1/0)
		//				Single/Multi/Electronic-turn enum
		//			}
		//			Min measurable setting
		//			Min recommended setting (for selection)
		//			Opening 1 \ Kv catalogue [ \ Lambda \Re* \ Kv from test ]
		//			Opening 2 \ Kv catalogue [ \ Lambda \Re* \ Kv from test ]
		//			...
		//		}
		//		Kvd				Kvs of the Dp controller
		//		Fc				Stabilized Dp in the throttle
		//		Qmax			Max flow of the valve
		//		Number of curves: 0 = no curve; 1 = Qmax curve; 2 = Qmax and Dpmin curve
		//		Setting 1 \ Dpmin 1 \ qmax 1
		//		Setting 2 \ Dpmin 2 \ qmax 2
		//		...
		//	}

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;
	
		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_PICVCharacteristic *)idptr.MP )->Copy( this );
		
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar, 50 );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				InterpretInheritedData( &str );
			}

			// Read the close curve bracket.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _T('}') != *ptcLine )
			{
				HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
			}
		}
		else
		{
			// Read base.
			CDB_ValveCharacteristic::ReadText( inpf, pusLineCount );

			TCHAR *ptcEndPtr;
	
			// Kvd.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_dKvd = _tcstod( ptcLine, &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't read the 'CDB_PICVCharacteristic::Kvd' value (%s) (pos: %i)."), ptcLine, *pusLineCount );
			}
	
			// Fc.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_dFc = _tcstod( ptcLine, &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't read the 'CDB_PICVCharacteristic::Fc' value (%s) (pos: %i)."), ptcLine, *pusLineCount );
			}
	
			// Qmax.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_dQmax = _tcstod( ptcLine, &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't read the 'CDB_PICVCharacteristic::Qmax' value (%s) (pos: %i)."), ptcLine, *pusLineCount );
			}
	
			// Number of curves: 0 = no curve; 1 = Qmax curve; 2 = Qmax and Dpmin curve.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_nNumberOfPICVCharCurves = _ttoi( ptcLine );

			if( m_nNumberOfPICVCharCurves < 0 || m_nNumberOfPICVCharCurves > 3 )
			{
				HYSELECT_THROW( _T("'CDB_PICVCharacteristic::QmaxDpminChar' is incorrect (0 > %i > 3)."), m_nNumberOfPICVCharCurves );
			}

			m_bQmaxCharGiven = (m_nNumberOfPICVCharCurves > 0) ? true : false;
			m_bDpminCharGiven = (m_nNumberOfPICVCharCurves > 1) ? true : false;
			m_bStrokeCharGiven = (m_nNumberOfPICVCharCurves > 2) ? true : false;
		
			if( true == m_bQmaxCharGiven || true == m_bDpminCharGiven )
			{
				// Read the qmax/Dpmin characteristics.
				m_pQmaxDpminChar = new CCurveFitter( m_nNumberOfPICVCharCurves );

				if( NULL == m_pQmaxDpminChar )
				{
					HYSELECT_THROW( _T("Internal error: 'm_pQmaxDpminChar' instantiation error.") );
				}

				// Variables for temporary storage of data.
				int nCheck;
				double dSetting;
				double *parDouble = new double[m_nNumberOfPICVCharCurves];

				if( NULL == parDouble )
				{
					HYSELECT_THROW( _T("Internal error: 'parDouble' instantiation error.") );
				}
		
				// Start the loop on lines.
				TCHAR **pptcField;
				bool bNoValues = false;

				do 
				{
					ptcLine = ReadTextLine( inpf, pusLineCount );

					if( _T('}') == *ptcLine )
					{
						break;
					}

					nCheck = 0;
					pptcField = ParseTextLine( ptcLine, &nCheck );

					if( nCheck != m_nNumberOfPICVCharCurves + 1 )
					{
						HYSELECT_THROW( _T("The current line has not the correct number of tokens (%i != %i) (pos: %i)."), nCheck, ( m_nNumberOfPICVCharCurves + 1 ), *pusLineCount );
					}
	
					// Look for setting.
					dSetting = _tcstod( pptcField[0], &ptcEndPtr );

					if( _T('\0') != *ptcEndPtr )
					{
						HYSELECT_THROW( _T("Can't read yhe setting value (%s) at position 0 of the curve definition (pos: %i)."), pptcField[0], *pusLineCount );
					}
			
					// Look for qmax,Dpmin.
					for( int i = 1; i <= m_nNumberOfPICVCharCurves; i++ )
					{
						parDouble[i - 1] = _tcstod( pptcField[i], &ptcEndPtr );

						if( _T('\0') != *ptcEndPtr )
						{
							HYSELECT_THROW( _T("Can't read the double value (%s) at position %i of the curve definition (pos: %i)."), pptcField[i], i, *pusLineCount );
						}
					}
			
					// Add data to the "curve".
					m_pQmaxDpminChar->AddPoint( dSetting, parDouble );

				}while( 1 );

				delete[] parDouble;
			}
			else
			{
				// Read the close curve bracket.
				ptcLine = ReadTextLine( inpf, pusLineCount );

				if( _T('}') != *ptcLine )
				{
					HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
				}
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_PICVCharacteristic::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif 

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_FLCVCharacteristic
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_FLCVCharacteristic )

CDB_FLCVCharacteristic::CDB_FLCVCharacteristic( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_ValveCharacteristic( pDataBase, ID )
{
	m_dDpmax = 0.0;						// Max differential pressure (60KPa).
	m_dDpminLF = 0.0;					// Min differential pressure at low flow (10-100l/h).
	m_dQLFmin = 0.0;					// Flow min for 'DpminLF' (10l/h).
	m_dQLFmax = 0.0;					// Flow max for 'DpminLF' (100l/h).
	m_dDpminNF = 0.0;					// Min differential pressure at normal flow (100-150l/h)
	m_dQNFmin = 0.0;					// Flow min for 'DpminNF' (100l/h).
	m_dQNFmax = 0.0;					// Flow max for 'DpminNF' (150l/h).
	m_pSettingFlowChar = NULL;
}

CDB_FLCVCharacteristic::~CDB_FLCVCharacteristic()
{
	if( NULL != m_pSettingFlowChar )
	{
		delete m_pSettingFlowChar;
		m_pSettingFlowChar = NULL;
	}
}

double CDB_FLCVCharacteristic::GetDpmin( double dSetting )
{
	if( dSetting < m_pSettingFlowChar->GetMinX() || dSetting > m_pSettingFlowChar->GetMaxX() )
	{
		return -1.0;
	}

	double dQ = GetQ( dSetting );
	double dDpMin = -1.0;
	
	if( dQ >= m_dQLFmin && dQ < m_dQLFmax )
	{
		dDpMin = m_dDpminLF;
	}
	
	if( dQ >= m_dQNFmin && dQ <= m_dQNFmax )
	{
		dDpMin = m_dDpminNF;
	}

	return dDpMin;
}

double CDB_FLCVCharacteristic::GetSettingFromQ( double dQ )
{
	if( dQ > m_pSettingFlowChar->GetMaxFX() )
	{
		return -1.0;
	}
	
	double dSetting;
	
	if( false == m_pSettingFlowChar->GetRoot( dQ, &dSetting ) )
	{
		double dQMin = m_pSettingFlowChar->GetMinFX();
		double dQMax = m_pSettingFlowChar->GetMaxFX();
		double dHMax = m_pSettingFlowChar->GetValue( m_pSettingFlowChar->GetMaxX() );
		double dHMin = m_pSettingFlowChar->GetValue( m_pSettingFlowChar->GetMinX() );
		
		if( ( dQ < dQMin &&	dHMax > dHMin ) || ( dQ > dQMax && dHMax < dHMin ) )
		{
			dSetting = m_pSettingFlowChar->GetMinX();
		}
		else
		{
			dSetting = m_pSettingFlowChar->GetMaxX();
		}
	}
	
	return dSetting;
}

#define CDB_FLCVCHARACTERISTIC_VERSION		1
void CDB_FLCVCharacteristic::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_FLCVCHARACTERISTIC_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_ValveCharacteristic::Write( outf );
	
	// Info.
	outf.write( (char *)&m_dDpmax, sizeof( m_dDpmax ) );
	outf.write( (char *)&m_dDpminLF, sizeof( m_dDpminLF ) );
	outf.write( (char *)&m_dQLFmin, sizeof( m_dQLFmin ) );
	outf.write( (char *)&m_dQLFmax, sizeof( m_dQLFmax ) );
	outf.write( (char *)&m_dDpminNF, sizeof( m_dDpminNF ) );
	outf.write( (char *)&m_dQNFmin, sizeof( m_dQNFmin ) );
	outf.write( (char *)&m_dQNFmax, sizeof( m_dQNFmax ) );

	// The Setting/Flow characteristic.
	int i = m_pSettingFlowChar->GetSize();
	outf.write( (char *)&i, sizeof( i ) );

	for( i--; i >= 0; i-- )
	{
		// Setting.
		double dX = m_pSettingFlowChar->GetPointX( i );
		outf.write( (char *)&dX, sizeof( double ) );

		// Flow.
		double dF = m_pSettingFlowChar->GetPointF( i );
		outf.write( (char *)&dF, sizeof( double ) );
	}
}

bool CDB_FLCVCharacteristic::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );
	
	if( Version < 1 || Version > CDB_FLCVCHARACTERISTIC_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDB_ValveCharacteristic::Read( inpf ) )
	{
		return false;
	}

	// Info.
	m_dDpmax = ReadDouble( inpf );
	m_dDpminLF = ReadDouble( inpf );
	m_dQLFmin = ReadDouble( inpf );
	m_dQLFmax = ReadDouble( inpf );
	m_dDpminNF = ReadDouble( inpf );
	m_dQNFmin = ReadDouble( inpf );
	m_dQNFmax = ReadDouble( inpf );

	m_pSettingFlowChar = new CCurveFitter();
	
	if( NULL == m_pSettingFlowChar )
	{
		return false;
	}

	// The curve.
	int i;
	double dX;
	double dY;
	
	for( inpf.read( (char *)&i, sizeof( i ) ); i; i-- )
	{
		dX = ReadDouble( inpf );
		dY = ReadDouble( inpf );
		m_pSettingFlowChar->AddPoint( dX, &dY );
	}
	
	return true;
}

#ifndef TACBX 
void CDB_FLCVCharacteristic::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		//	new:CDB_FLCVCharacteristic(ID\1) -> FLCV_CHAR_TAB
		//	{
		//		{
		//			Discrete/Continuous enum(1/0)
		//			Single/Multi/Electronic-turn enum
		//		}
		//		Dpmax						Max differential pressure (60KPa).
		//		DpminLF						Min differential pressure at low flow (10-100l/h).
		//      QLFmin						Flow min for 'DpminLF' (10l/h).
		//      QLFmax						Flow max for 'DpminLF' (100l/h).
		//		DpminNF						Min differential pressure at normal flow (100-150l/h)
		//      QNFmin						Flow min for 'DpminNF' (100l/h).
		//      QNFmax						Flow max for 'DpminNF' (150l/h).
		//		Setting 1 \ Flow 1
		//		Setting 2 \ Flow 2
		//		...
		//	}

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Read base.
		CDB_ValveCharacteristic::ReadText( inpf, pusLineCount );

		TCHAR *ptcEndPtr;

		// Dpmax.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_dDpmax = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Cant read 'CDB_FLCVCharacteristic::Dpmax' (%s) (pos: %i)."), ptcLine, *pusLineCount );
		}
	
		// DpminLF.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_dDpminLF = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Cant read 'CDB_FLCVCharacteristic::DpminLF' (%s) (pos: %i)."), ptcLine, *pusLineCount );
		}

		// QLFmin.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_dQLFmin = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Cant read 'CDB_FLCVCharacteristic::QLFmin' (%s) (pos: %i)."), ptcLine, *pusLineCount );
		}

		// QLFmax.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_dQLFmax = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Cant read 'CDB_FLCVCharacteristic::QLFmax' (%s) (pos: %i)."), ptcLine, *pusLineCount );
		}

		// DpminNF.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_dDpminNF = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Cant read 'CDB_FLCVCharacteristic::DpminNF' (%s) (pos: %i)."), ptcLine, *pusLineCount );
		}

		// QNFmin.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_dQNFmin = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Cant read 'CDB_FLCVCharacteristic::QNFmin' (%s) (pos: %i)."), ptcLine, *pusLineCount );
		}

		// QNFmax.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_dQNFmax = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Cant read 'CDB_FLCVCharacteristic::QNFmax' (%s) (pos: %i)."), ptcLine, *pusLineCount );
		}
	
		// Read the Setting/Flow characteristics.
		m_pSettingFlowChar = new CCurveFitter();
	
		if( NULL == m_pSettingFlowChar )
		{
			HYSELECT_THROW( _T("Internal error: 'm_pSettingFlowChar' instantiation error (pos: %i)."), *pusLineCount );
		}

		// Variables for temporary storage of data.
		int nCheck;
		double dSetting;
		double dQ;
		TCHAR **pptcField;
		
		do 
		{
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _T('}') == *ptcLine )
			{
				break;
			}

			nCheck = 0;
			pptcField = ParseTextLine( ptcLine, &nCheck );

			if( nCheck != 2 )
			{
				HYSELECT_THROW( _T("The current line has not the correct number of tokens (%i != 2) (pos: %i)."), nCheck, *pusLineCount );
			}
	
			// Look for setting.
			dSetting = _tcstod( pptcField[0], &ptcEndPtr);

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't read the setting value (%s) at position 0 of the curve definition (pos: %i)."), pptcField[0], *pusLineCount );
			}
		
			// Look for flow.
			dQ = _tcstod( pptcField[1], &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't read the flow value (%s) at position 0 of the curve definition (pos: %i)."), pptcField[0], *pusLineCount );
			}

			// Add data to the "curve".
			m_pSettingFlowChar->AddPoint( dSetting, &dQ );

		}while( 1 );
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_FLCVCharacteristic::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif 

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_DpCBCVCharacteristic
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_DpCBCVCharacteristic )

CDB_DpCBCVCharacteristic::CDB_DpCBCVCharacteristic( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_ValveCharacteristic( pDataBase, ID )
{
	m_dKvm = 0.0;
	m_dQmin = 0.0;
	m_dQmax = 0.0;
	m_dDplmin = 0.0;
	m_FlowDeltaPkCurveIDPtr = _NULL_IDPTR;
	m_SettingKvcCurveIDPtr = _NULL_IDPTR;
}

double CDB_DpCBCVCharacteristic::GetDp( double dFlow, double dSetting, double dRho )
{
	double dDpp = GetDpp( dFlow, dRho );

	if( -1.0 == dDpp )
	{
		return -1.0;
	}

	// Differential pressure through the control part.
	double dDpc = GetDpc( dFlow, dSetting, dRho );

	if( -1.0 == dDpc )
	{
		return -1.0;
	}

	return ( dDpp + dDpc );
}

double CDB_DpCBCVCharacteristic::GetDpp( double dFlow, double dRho )
{
	double dKvm = GetKvm();

	if( 0.0 == dKvm )
	{
		return -1.0;
	}

	// Differential pressure through the Dp controller part.
	double dDpp = CalcDp( dFlow, dKvm, dRho );

	if( 0.0 == dDpp )
	{
		return -1.0;
	}

	return dDpp;
}

double CDB_DpCBCVCharacteristic::GetDpc( double dFlow, double dSetting, double dRho )
{
	if( NULL == GetSettingKvcCurve() || NULL == GetSettingKvcCurve()->GetpCurve() )
	{
		return -1.0;
	}

	double dKvc = GetSettingKvcCurve()->GetpCurve()->GetValue( dSetting );

	if( 0.0 == dKvc )
	{
		return -1.0;
	}

	double dDpc = CalcDp( dFlow, dKvc, dRho );

	if( 0.0 == dDpc )
	{
		return -1.0;
	}
	
	return dDpc;
}

CDB_Curve *CDB_DpCBCVCharacteristic::GetFlowDeltaPkCurve()
{
	CDB_Curve *pCurve = NULL;

	if( _T('\0') != *m_FlowDeltaPkCurveIDPtr.ID )
	{
		m_FlowDeltaPkCurveIDPtr.DB = GetIDPtr().DB;
		Extend( &m_FlowDeltaPkCurveIDPtr );
		pCurve  = dynamic_cast<CDB_Curve *>( m_FlowDeltaPkCurveIDPtr.MP );
	}

	return pCurve;
}

CDB_Curve *CDB_DpCBCVCharacteristic::GetSettingKvcCurve()
{
	CDB_Curve *pCurve = NULL;

	if( _T('\0') != *m_SettingKvcCurveIDPtr.ID )
	{
		m_SettingKvcCurveIDPtr.DB = GetIDPtr().DB;
		Extend( &m_SettingKvcCurveIDPtr );
		pCurve = dynamic_cast<CDB_Curve *>( m_SettingKvcCurveIDPtr.MP );
	}

	return pCurve;
}

void CDB_DpCBCVCharacteristic::SetFlowDeltaPkCurveID( LPCTSTR strFlowDeltaPkCurveID )
{
	m_FlowDeltaPkCurveIDPtr = _NULL_IDPTR;

	if( _tcslen( strFlowDeltaPkCurveID ) > _ID_LENGTH )
	{
		ASSERT( 0 );
		return;
	}

	_tcsncpy_s( m_FlowDeltaPkCurveIDPtr.ID, SIZEOFINTCHAR( m_FlowDeltaPkCurveIDPtr.ID ), (LPCTSTR)strFlowDeltaPkCurveID, SIZEOFINTCHAR( m_FlowDeltaPkCurveIDPtr.ID ) - 1 );
}

void CDB_DpCBCVCharacteristic::SetSettingKvcCurveID( LPCTSTR strSettingKvcCurveID )
{
	m_SettingKvcCurveIDPtr = _NULL_IDPTR;

	if( _tcslen( strSettingKvcCurveID ) > _ID_LENGTH )
	{
		ASSERT( 0 );
		return;
	}

	_tcsncpy_s( m_SettingKvcCurveIDPtr.ID, SIZEOFINTCHAR( m_SettingKvcCurveIDPtr.ID ), (LPCTSTR)strSettingKvcCurveID, SIZEOFINTCHAR( m_SettingKvcCurveIDPtr.ID ) - 1 );
}

double CDB_DpCBCVCharacteristic::GetDpk( double dFlow )
{
	if( dFlow <= 0.0 || NULL == GetFlowDeltaPkCurve() || NULL == GetFlowDeltaPkCurve()->GetpCurve() )
	{
		return -1.0;
	}

	if( dFlow > m_dQmax )
	{
		dFlow = m_dQmax;
	}

	return GetFlowDeltaPkCurve()->GetpCurve()->GetValue( dFlow );
}

double CDB_DpCBCVCharacteristic::GetSetting( double dDpc, double dFlow, double dRho )
{
	if( dDpc <= 0.0 || dFlow <= 0.0 || NULL == GetSettingKvcCurve() || NULL == GetSettingKvcCurve()->GetpCurve() )
	{
		return -1.0;
	}

	double dKvc = CalcKv( dFlow, dDpc, dRho );

	double dSetting = -1.0;
	
	if( false == GetSettingKvcCurve()->GetpCurve()->GetRoot( dKvc, &dSetting, 0 ) )
	{
		dSetting = -1.0;
	}

	return dSetting;
}

void CDB_DpCBCVCharacteristic::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_DpCBCVCharacteristic *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_DpCBCVCharacteristic' object!") );
		}

		// Base class.
		CDB_ValveCharacteristic::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_DpCBCVCharacteristic" class.
		CDB_DpCBCVCharacteristic *pclDestinationDpCBCVCharacteristic = (CDB_DpCBCVCharacteristic *)pclDestination;

		pclDestinationDpCBCVCharacteristic->SetKvm( m_dKvm );
		pclDestinationDpCBCVCharacteristic->SetQmin( m_dQmin );
		pclDestinationDpCBCVCharacteristic->SetQmax( m_dQmax );
		pclDestinationDpCBCVCharacteristic->SetQmax( m_dDplmin );
		pclDestinationDpCBCVCharacteristic->SetFlowDeltaPkCurveID( m_FlowDeltaPkCurveIDPtr.ID );
		pclDestinationDpCBCVCharacteristic->SetSettingKvcCurveID( m_SettingKvcCurveIDPtr.ID );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_DpCBCVCharacteristic::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_DPCBCVCHARACTERISTIC_VERSION  1
void CDB_DpCBCVCharacteristic::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_DPCBCVCHARACTERISTIC_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_ValveCharacteristic::Write( outf );
	
	// Info.
	outf.write( (char *)&m_dKvm, sizeof( m_dKvm ) );
	outf.write( (char *)&m_dQmin, sizeof( m_dQmin ) );
	outf.write( (char *)&m_dQmax, sizeof( m_dQmax ) );
	outf.write( (char *)&m_dDplmin, sizeof( m_dDplmin ) );

	WriteString( outf, m_FlowDeltaPkCurveIDPtr.ID );
	WriteString( outf, m_SettingKvcCurveIDPtr.ID );
}

bool CDB_DpCBCVCharacteristic::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_DPCBCVCHARACTERISTIC_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDB_ValveCharacteristic::Read( inpf ) )
	{
		return false;}

	// Info.
	m_dKvm = ReadDouble( inpf );
	m_dQmin = ReadDouble( inpf );
	m_dQmax = ReadDouble( inpf );
	m_dDplmin = ReadDouble( inpf );

	if( false == ReadString( inpf, m_FlowDeltaPkCurveIDPtr.ID, sizeof( m_FlowDeltaPkCurveIDPtr.ID ) ) )
	{
		return false;
	}

	m_FlowDeltaPkCurveIDPtr.DB = GetIDPtr().DB;

	if( false == ReadString( inpf, m_SettingKvcCurveIDPtr.ID, sizeof( m_SettingKvcCurveIDPtr.ID ) ) )
	{
		return false;
	}

	m_SettingKvcCurveIDPtr.DB = GetIDPtr().DB;

	return true;
}

#ifndef TACBX
#define DPCBCVCHAR_Kvm						_T("::Kvm=")
#define DPCBCVCHAR_Qmin						_T("::Qmin=")
#define DPCBCVCHAR_Qmax						_T("::Qmax=")
#define DPCBCVCHAR_Dplmin					_T("::Dplmin=")
#define DPCBCVCHAR_FlowDeltaPkCurveID		_T("::FlowDeltaPkCurveID=")
#define DPCBCVCHAR_SettingKvcCurveID		_T("::SettingKvcCurveID=")
void CDB_DpCBCVCharacteristic::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int ipos = pStr->Find( CLASS( CDB_DpCBCVCharacteristic ) );

		if( _T("::") != pStr->Left( 2 ) && ipos < 0 )
		{
			CDB_ValveCharacteristic::InterpretInheritedData( pStr );
		}
		else
		{
			if( ipos >= 0 )
			{
				pStr->Delete( ipos, _tcsclen( CLASS( CDB_DpCBCVCharacteristic ) ) );
			}

			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 )
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}
		
			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( DPCBCVCHAR_Kvm ) > -1 )
			{
				double d;
			
				if( RD_OK != ReadDouble( strField, &d ) )
				{
					HYSELECT_THROW( _T("'CDB_DpCBCVCharacteristic::Kvm' must be a double (%s)."), strField );
				}
			
				m_dKvm = d;
			}
			else if( pStr->Find( DPCBCVCHAR_Qmin ) > -1 )
			{
				double d;
			
				if( RD_OK != ReadDouble( strField, &d ) )
				{
					HYSELECT_THROW( _T("'CDB_DpCBCVCharacteristic::Qmin' must be a double (%s)."), strField );
				}
			
				m_dQmin = d;
			}
			else if( pStr->Find( DPCBCVCHAR_Qmax ) > -1 )
			{
				double d;
			
				if( RD_OK != ReadDouble( strField, &d ) )
				{
					HYSELECT_THROW( _T("'CDB_DpCBCVCharacteristic::Qmax' must be a double (%s)."), strField );
				}
			
				m_dQmax = d;
			}
			else if( pStr->Find( DPCBCVCHAR_Dplmin ) > -1 )
			{
				double d;
			
				if( RD_OK != ReadDouble( strField, &d ) )
				{
					HYSELECT_THROW( _T("'CDB_DpCBCVCharacteristic::Dplmin' must be a double (%s)."), strField );
				}
			
				m_dDplmin = d;
			}
			else if( pStr->Find( DPCBCVCHAR_FlowDeltaPkCurveID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_DpCBCVCharacteristic::FlowDeltaPkCurveID' stringn is too long (%s > %i)."), strField.GetLength(), _ID_LENGTH );
				}

				_tcsncpy_s( m_FlowDeltaPkCurveIDPtr.ID, _ID_LENGTH + 1, (LPCTSTR)strField, _ID_LENGTH );
				m_FlowDeltaPkCurveIDPtr.DB = GetIDPtr().DB;
			}
			else if( pStr->Find( DPCBCVCHAR_SettingKvcCurveID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_DpCBCVCharacteristic::SettingKvcCurveID' stringn is too long (%s > %i)."), strField.GetLength(), _ID_LENGTH );
				}

				_tcsncpy_s( m_SettingKvcCurveIDPtr.ID, _ID_LENGTH + 1, (LPCTSTR)strField, _ID_LENGTH );
				m_SettingKvcCurveIDPtr.DB = GetIDPtr().DB;
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_DpCBCVCharacteristic::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_DpCBCVCharacteristic::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		//	new:CDB_DpCBCVCharacteristic(ID) -> VALVE_CHAR_TAB
		//	{
		//		{
		//			{
		//				Discrete/Continuous enum					Discrete set of data or continuous characteristic (#eDISCRETE_True, #eDISCRETE_False or #eDISCRETE_Undefined).
		//				Single/Multi/Electronic-turn enum			Number of turns of the valve (#eTURN_Single, #eTURN_Multi, #eTURN_Electronic or #eTURN_Undefined).
		//			}
		//			Min measurable setting
		//			Min recommended setting (for selection)
		//			Number of curves
		//			Opening 1 \ Kv catalogue [ \ Lambda \Re* \ Kv from test ]
		//			Opening 2 \ Kv catalogue [ \ Lambda \Re* \ Kv from test ]
		//			...
		//		}
		//		Kvm						max Kv of the DP-controller in the valve (control part excluded).
		//		Qmin					Min flow of the valve.
		//		Qmax					Max flow of the valve.
		//		Dplmin					Minimum Dp that can be stabilized.
		//		FlowDeltaPkCurveID		Stabilized Dp characteristic (curve with relation between the flow and Dpk).
		//								'Dpk' is the Dp stabilized from the internal point of the valve between the Dp-controller and the control part to
		//                              the point after the load.
		//		SettingKvcCurveID		Kvc characteristic (curve with relation between setting and Kvc,D).
		//								'c' because it concerns the control part of the valve and 'D' for design.
		//	}

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_DpCBCVCharacteristic *)idptr.MP)->Copy( this );
		
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar, 50 );

			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );
			
				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_ValveCharacteristic::ReadText( inpf, pusLineCount );
		
			CStringArray TxtHdr;
			TxtHdr.Add( DPCBCVCHAR_Kvm );
			TxtHdr.Add( DPCBCVCHAR_Qmin );
			TxtHdr.Add( DPCBCVCHAR_Qmax );
			TxtHdr.Add( DPCBCVCHAR_Dplmin );
			TxtHdr.Add( DPCBCVCHAR_FlowDeltaPkCurveID );
			TxtHdr.Add( DPCBCVCHAR_SettingKvcCurveID );

			for( int i = 0; i < TxtHdr.GetSize(); i++ )
			{
				ptcLine = ReadTextLine( inpf, pusLineCount );

				CString str = TxtHdr[i] + CString( ptcLine );
				CDB_DpCBCVCharacteristic::InterpretInheritedData( &str );
			}
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_DpCBCVCharacteristic::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif 

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_ControlProperties
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_ControlProperties)

CDB_ControlProperties::CDB_ControlProperties( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
	m_CV2W3W = CV2W;
	m_CVFunc = ControlOnly;
	m_CtrlChar = Linear;
	m_MixDiv = None;
	m_PushClose = Undef;
	m_BCVType = ebcvtNone;
}

// Check if control properties of the CDB_ControlProperties fits parameters
bool CDB_ControlProperties::CtrlParamFits( CV2W3W cv2w3w, eCVFUNC cvFunc )
{
	bool bReturn = true;
	
	// Check if valve has the same way numbers.
	if( cv2w3w < LastCV2W3W )
	{	
		if( m_CV2W3W != cv2w3w )
		{
			bReturn = false;
		}
	}
	
	// Check if valve has the same function (no control, control only, presettable or presettable PT).
	if( true == bReturn && cvFunc < LastCVFUNC )
	{	
		// HYS-1579: A combination of CVFunc is possible
		if( m_CVFunc != (cvFunc & m_CVFunc) )
		{
			bReturn = false;
		}
	}
	
	return bReturn;
}

bool CDB_ControlProperties::CtrlParamFits( CV2W3W cv2w3w, eCVFUNC cvFunc, eCTRLCHAR ctrlchar )
{
	// HYS-1579: A combination of CVFunc is possible
	if( m_CV2W3W == cv2w3w && m_CVFunc == (cvFunc & m_CVFunc) && m_CtrlChar == ctrlchar )
	{
		return true;
	}
	else 
	{
		return false;
	}
}

bool CDB_ControlProperties::CvCtrlTypeFits( CvCtrlType CvCtrlType )
{
	bool bReturn = false;

	// 2017-02-17: Following a skype call with Jean-Christophe, it has been clarified links between control type and 
	//             valve characteristic as following:
	//
	//             --------------+ Valve characteristic -----
	//             Ctrl mode     | No   | Linear | Equal %
	//             --------------+------+--------+-----------
	//				On/Off       |  1   |    1   |    1
	//              3 points     |  0   |    1   |    1
	//              Proportional |  0   |    1   |    1
	//
	// There is no more strict or not strict mode.

	switch( CvCtrlType )
	{
		case eCvOnOff:
			// User wants an On/Off control on the valve. We accept valve of any characteristic type.
			bReturn = true;
			break;
		
		case eCv3point:
		case eCvProportional:
			// User wants a 3 points or proportional control on the valve.
			// We accept either linear or equal % but not valve without characteristic.
			
			if( Linear == m_CtrlChar || EqualPc == m_CtrlChar )
			{
				bReturn = true;
			}

			break;

		case eCvNU:
			bReturn = true;
			break;
		
		default:
			ASSERT( 0 );
			break;
	}
	
	return bReturn;
}

CDB_ControlProperties::CvCtrlType CDB_ControlProperties::GetCtrlType()
{
	CvCtrlType eReturn = eCvNU;

	switch( m_CtrlChar )
	{
		case EqualPc:
			eReturn = eCvProportional;
			break;
	
		case NotCharacterized:
		case Linear:
			eReturn = eCvOnOff;
			break;
	
		default:
			break;
	}

	return eReturn;
}

_string CDB_ControlProperties::GetCvCtrlTypeStr( CDB_ControlProperties::CvCtrlType CtrlType, bool bStrShort )
{
	static _string str;
	static _string *pstr = NULL;

	switch( CtrlType )
	{
		default:
		case eCvProportional:

			if( true == bStrShort )
			{
				str = L"IDS_CVCTRLTYPE_PROPORTIONAL";
				pstr = GetpXmlStrTab()->GetIDSStr( str.c_str() );
			}			
			else
			{
				str = L"IDS_CVCTRLTYPE_PROPORTIONALCTRL";
				pstr = GetpXmlStrTab()->GetIDSStr( str.c_str() );
			}			
			
			break;
		
		case eCvOnOff:

			if( true == bStrShort)
			{
				str = L"IDS_CVCTRLTYPE_ONOFF";
				pstr = GetpXmlStrTab()->GetIDSStr( str.c_str() );
			}			
			else
			{
				str = L"IDS_CVCTRLTYPE_ONOFFCTRL";
				pstr = GetpXmlStrTab()->GetIDSStr( str.c_str() );
			}			
			
			break;
		
		case eCv3point:

			if( true == bStrShort )
			{
				str = L"IDS_CVCTRLTYPE_3POINT";
				pstr = GetpXmlStrTab()->GetIDSStr( str.c_str() );
			}			
			else
			{
				str = L"IDS_CVCTRLTYPE_3POINTCTRL";
				pstr = GetpXmlStrTab()->GetIDSStr( str.c_str() );
			}			
			
			break;
	}
	
	if( NULL != pstr )
	{
		str = *pstr;
	}

	return str;
}

_string CDB_ControlProperties::GetCv2W3WStr(CDB_ControlProperties::CV2W3W Cv2w3w)
{
	static _string str;
	static _string *pstr = NULL;

	switch( Cv2w3w )
	{
		default:
		case CV2W:
			str = L"IDS_CTRLPROP_2WAY";
			pstr = GetpXmlStrTab()->GetIDSStr( str.c_str() );
			break;
	
		case CV3W:
			str = L"IDS_CTRLPROP_3WAY";
			pstr = GetpXmlStrTab()->GetIDSStr( str.c_str() );
			break;
		
		case CV4W:
			str = L"IDS_CTRLPROP_4WAY";
			pstr = GetpXmlStrTab()->GetIDSStr( str.c_str() );
			break;

		case CV6W:
			str = L"IDS_CTRLPROP_6WAY";
			pstr = GetpXmlStrTab()->GetIDSStr( str.c_str() );
			break;
	}
	
	if( NULL != pstr )
	{
		str = *pstr;
	}

	return str;
}

_string CDB_ControlProperties::GetCvFuncStr( CDB_ControlProperties::eCVFUNC CVFUNC )
{
	static _string str;
	static _string *pstr = NULL;

	switch( CVFUNC )
	{
		default:
		case CDB_ControlProperties::NoControl:
			str = L"IDS_CTRLPROP_NOCONTROL";
			pstr = GetpXmlStrTab()->GetIDSStr( str.c_str() );
			break;
	
		case CDB_ControlProperties::ControlOnly:
			str = L"IDS_CTRLPROP_CONTROLONLY";
			pstr = GetpXmlStrTab()->GetIDSStr( str.c_str() );
			break;
		
		case CDB_ControlProperties::Presettable:
			str = L"IDS_CTRLPROP_PRESETTABLE";
			pstr = GetpXmlStrTab()->GetIDSStr( str.c_str() );
			break;

		case CDB_ControlProperties::PresetPT:
			str = L"IDS_CTRLPROP_PRESETPT";
			pstr = GetpXmlStrTab()->GetIDSStr( str.c_str() );
			break;

		case CDB_ControlProperties::Electronic:
			str = L"IDS_CTRLPROP_ELECTRONIC";
			pstr = GetpXmlStrTab()->GetIDSStr( str.c_str() );
			break;
	}
	
	if( NULL != pstr )
	{
		str = *pstr;
	}

	return str;
}

void CDB_ControlProperties::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = 4;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CData::Write( outf );
	
	// Number of CV ports.
	outf.write( (char *)&m_CV2W3W, sizeof( m_CV2W3W ) );

	// CV Func.
	outf.write( (char *)&m_CVFunc, sizeof( m_CVFunc ) );

	// Control characteristic type.
	outf.write( (char *)&m_CtrlChar, sizeof( m_CtrlChar ) );
	
	// Mixing/Dividing.
	outf.write( (char *)&m_MixDiv, sizeof( m_MixDiv ) );
	
	// PushClose.
	outf.write( (char *)&m_PushClose, sizeof( m_PushClose ) );
	
	// BCVType.
	outf.write( (char *)&m_BCVType, sizeof( m_BCVType ) );
}

bool CDB_ControlProperties::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > 4 )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Number of CV ports.
	inpf.read( (char *)&m_CV2W3W, sizeof( m_CV2W3W ) );

	// CV type.
	inpf.read( (char *)&m_CVFunc, sizeof( m_CVFunc ) );

	// Control characteristic type.
	inpf.read( (char *)&m_CtrlChar, sizeof( m_CtrlChar ) );
	
	if( 1 == Version )
	{
		return true;
	}
	
	// Mixing/Dividing.
	inpf.read( (char *)&m_MixDiv, sizeof( m_MixDiv ) );

	if( 2 == Version )
	{
		return true;
	}
	
	// PushClose.
	inpf.read( (char *)&m_PushClose, sizeof( m_PushClose ) );

	if( 3 == Version )
	{
		return true;
	}
	
	// BCVType.
	inpf.read( (char *)&m_BCVType, sizeof( m_BCVType ) );

	return true;
}

#ifndef TACBX 
void CDB_ControlProperties::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_ControlProperties format
		// line 0 : open curve bracket and call base class
		// line 1 : enum: Nr of ports of the control valve
		// line 2 : enum: CV type: ControlOnly, Presettable, PresetPT
		// line 3 : enum: Control characteristic: Linear, EqualPc
		// line 4 : enum: Mixing/Dividing
		// line 5 : enum: ePushClose
		// line 6 : enum: eBCVType
		// line 7 : close curve bracket

		// Skip the open curve bracket
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Read base.
		CData::ReadText( inpf, pusLineCount );
	
		// Read the nr of ports of the control valve.
		int iValue = ReadEnumLine( inpf, pusLineCount );

		if( iValue < CVUnknown || iValue >= LastCV2W3W )
		{
			HYSELECT_THROW( _T("'CDB_ControlProperties::CV2W3W' value must be one of these values: '#eCV2W3W_CVNU', '#eCV2W3W_CV2W', '#eCV2W3W_CV3W', '#eCV2W3W_CV4W' or '#eCV2W3W_CV6W'.") );
		}

		m_CV2W3W = (CV2W3W)iValue;
	
		// Read CV type.
		iValue = ReadEnumLine( inpf, pusLineCount );

		if( iValue < NoControl || iValue >= LastCVFUNC )
		{
			HYSELECT_THROW( _T("'CDB_ControlProperties::CVFUNC' value must be one of these values: '#eCVFUNC_NoControl', '#eCVFUNC_ControlOnly', '#eCVFUNC_Presettable', '#eCVFUNC_PresetPT' or '#eCVFUNC_Electronic'.") );
		}

		m_CVFunc = (eCVFUNC)iValue;
	
		// Read Control characteristic type.
		iValue = ReadEnumLine( inpf, pusLineCount );

		if( iValue < eCvNU || iValue >= eLastCvCtrlType )
		{
			HYSELECT_THROW( _T("'CDB_ControlProperties::CvCtrlType' value must be one of these values: '#eCTRLTYPE_Prop', '#eCTRLTYPE_OnOff' or '#eCTRLTYPE_3Point'.") );
		}
	
		m_CtrlChar = (eCTRLCHAR)iValue;
	
		// Read Mixing Dividing.
		iValue = ReadEnumLine( inpf, pusLineCount );

		if( iValue < None || iValue >= LastMixDiv )
		{
			HYSELECT_THROW( _T("'CDB_ControlProperties::MixDiv' value must be one of these values: '#eMIXDIV_None', '#eMIXDIV_Mixing' or '#eMIXDIV_Dividing'.") );
		}

		m_MixDiv = (eMixDiv)iValue;
	
		// Read PushClose.
		iValue = ReadEnumLine( inpf, pusLineCount );

		if( iValue < Undef || iValue >= LastPushClose )
		{
			HYSELECT_THROW( _T("'CDB_ControlProperties::PushOrPullToClose' value must be one of these values: '#ePUSHCLOSE_Undef', '#ePUSHCLOSE_False' or '#ePUSHCLOSE_True'.") );
		}

		m_PushClose = (ePushOrPullToClose)iValue;
	
		// Read BCVType.
		iValue = ReadEnumLine( inpf, pusLineCount );

		if( iValue < ebcvtNone || iValue >= ebcvtLast )
		{
			HYSELECT_THROW( _T("'CDB_ControlProperties::BCVType' value must be one of these values: '#eBcvType_None', '#eBcvType_KvSeries', 'eBcvType_LiftLimit', '#eBcvType_CharIndep', '#eBcvType_Electronic' or '#eBcvType_ElectronicDpC'.") );
		}

		m_BCVType = (eBCVType)iValue;

		// Read the close curve bracket
		ptcLine = ReadTextLine( inpf, pusLineCount ); 

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_ControlProperties::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif 

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_AdditCharacteristic
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_AdditCharacteristic)

CDB_AdditCharacteristic::CDB_AdditCharacteristic( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID ), m_iPc( 0 ), m_iT( 0 ), m_nData( 4 ), m_bTmin( false ), m_bTmax( false ) 
{
	m_padditFitter = NULL;
	m_lastRes.Reset();
	m_lastRes.f = new double[m_nData];
	m_lastSurfValReturn = SV_OK;
}

CDB_AdditCharacteristic::~CDB_AdditCharacteristic()
{
	if( NULL != m_padditFitter )
	{
		delete m_padditFitter;
		m_padditFitter = NULL;
	}

	if( NULL != m_lastRes.f )
	{
		delete [] m_lastRes.f;
	}
}

SurfValReturn_enum CDB_AdditCharacteristic::GetAdditProp( double dPc, double dT, double *pdDensity, double *pdKinVisc, double *pdSpecifHeat, double *pdVaporPressure )
{
	m_lastSurfValReturn = m_padditFitter->GetPoint( dPc, dT, *pdDensity, *pdKinVisc, *pdSpecifHeat, *pdVaporPressure );
	return m_lastSurfValReturn;
}

bool CDB_AdditCharacteristic::IsaDilutedAddit()
{
	// Only two % in weight values.
	// First % in weight value is equal to 0.0.
	// Second % in weight value is equal to 100.
	// Sampled function value is the same for both % in weight

	if( 2 == m_padditFitter->GetNbrOfConcentrationCurves() )
	{
		double dConcentration0, dConcentration1;

		if( true == m_padditFitter->GetPointX( 0, dConcentration0 ) && true == m_padditFitter->GetPointX( 1, dConcentration1 ) )
		{
			if( 0.0 == dConcentration0 && 100.0 == dConcentration1 )
			{
				// Then, functions do not depend on % in weight: the additive is not to be diluted (Ready-to-use).
				// Works as well for the 'Any other fluid' option because pure water characteristic is fakely associated to this option.
				return false;
			}
		}
	}
	
	// Functions depend on % in weight.
	return true;
}

double CDB_AdditCharacteristic::GetTfreez( double dPc )
{
	double dTmin;

	if( false == IsaDilutedAddit() )
	{
		dPc = 0;
	}

	m_padditFitter->GetTminTmax(dPc, &dTmin);
	
	return dTmin;
}

double CDB_AdditCharacteristic::GetMaxT( double dPc )
{
	double dTmax = DBL_MAX;

	if( false == IsaDilutedAddit() )
	{
		dPc = 0;
	}

	m_padditFitter->GetTminTmax(dPc, NULL, &dTmax);
	
	return dTmax;
}

double CDB_AdditCharacteristic::GetMinPc(void)
{
	double d;
	m_padditFitter->GetPointX( 0, d );
	
	return d;
}

double CDB_AdditCharacteristic::GetMaxPc( void )
{
	UINT uiCurveNbr = m_padditFitter->GetNbrOfConcentrationCurves();
	double d;
	m_padditFitter->GetPointX( uiCurveNbr - 1, d );

	return d;
}

bool CDB_AdditCharacteristic::IsDensityDefined()
{
	bool bIsDefined = false;

	if( NULL != m_padditFitter && m_padditFitter->GetFunctionNumber() >= 1 )
	{
		bIsDefined = true;
	}

	return bIsDefined;
}

bool CDB_AdditCharacteristic::IsKinematicViscosityDefined()
{
	bool bIsDefined = false;

	if( NULL != m_padditFitter && m_padditFitter->GetFunctionNumber() >= 2 )
	{
		bIsDefined = true;
	}

	return bIsDefined;
}

bool CDB_AdditCharacteristic::IsSpecificHeatDefined()
{
	bool bIsDefined = false;

	if( NULL != m_padditFitter && m_padditFitter->GetFunctionNumber() >= 3 )
	{
		bIsDefined = true;
	}

	return bIsDefined;
}

bool CDB_AdditCharacteristic::IsVaporPressureDefined()
{
	bool bIsDefined = false;

	if( NULL != m_padditFitter && m_padditFitter->GetFunctionNumber() >= 4 )
	{
		bIsDefined = true;
	}

	return bIsDefined;
}

#define CDB_ADDITCHARACTERISTIC_VERSION		1
void CDB_AdditCharacteristic::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_ADDITCHARACTERISTIC_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CData::Write( outf );

	m_padditFitter->Write( outf );
}

bool CDB_AdditCharacteristic::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_ADDITCHARACTERISTIC_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	if( NULL != m_padditFitter )
	{
		delete m_padditFitter;
	}
	
	m_padditFitter = new CAdditFitter();

	if( NULL == m_padditFitter )
	{
		return false;
	}

	bool bRet = m_padditFitter->Read( inpf );

	if( true == bRet )
	{
		m_padditFitter->CreateCurveTminTmax();
	}
	
	return bRet;
}

#ifndef TACBX 
void CDB_AdditCharacteristic::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_AdditCharacteristic format
		// line 0 : open curve bracket and call base class
		// line 1 : max nbr. of x points \ max nbr. of y points \ T_min flag
		// line 2 :	y0 \ y1 \ y2 \ ... \ yn-1
		// line 3 : x (\ Tmin) \ y \ rho \ nu \ cp
		// line 4 to ny+3-1 : y \ rho \ nu \ cp
			// block [line 3 - line 4 to ny+3-1] repeated x times
		// line n : close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Read base.
		CData::ReadText( inpf, pusLineCount );

		// Variables for temporary storage of data.
		TCHAR *ptcEndPtr;
		TCHAR **pptcField;

		// Info: max nbr. of x points, max nbr. of y points, T_min flag.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		int n = 3;
		pptcField = ParseTextLine( ptcLine, &n );
	
		// Max number of x points (Weigth).
		m_iPc = _ttoi( pptcField[0] );

		if( 0 == m_iPc )
		{
			HYSELECT_THROW( _T("Max. number of x points can't null (pos: %i)."), *pusLineCount );
		}

		// Max number of y points (Temperature).
		m_iT = _ttoi( pptcField[1] );

		if( 0 == m_iT )
		{
			HYSELECT_THROW( _T("Max. number of y points can't null (pos: %i)."), *pusLineCount );
		}

		m_bTmin = ( 0 != _ttoi( pptcField[2] ) ) ? true : false;

		CSurfaceFitter *m_pCharSurf = new CSurfaceFitter( m_iPc, m_iT, m_nData, m_bTmin, m_bTmax );

		if( NULL == m_pCharSurf )
		{
			HYSELECT_THROW( _T("Internal error: 'm_pCharSurf' instantiation error (pos: %i)."), *pusLineCount );
		}

		m_padditFitter = new CAdditFitter();

		if( NULL == m_padditFitter )
		{
			HYSELECT_THROW( _T("Internal error: 'm_padditFitter' instantiation error (pos: %i)."), *pusLineCount );
		}

		// The y vector.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		n = m_iT;
		pptcField = ParseTextLine( ptcLine, &n );

		int i;
	
		for( i = 0; i < m_iT; i++ )
		{
			m_pCharSurf->SetY( i, _tcstod( pptcField[i], &ptcEndPtr ) );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't read the double value (%s) at position %i of the additive characteristic definition (pos: %i)."), pptcField[i], i, *pusLineCount );
			}
		}

		// The surface(s).
		i = 0;
		int j, c;
		double dTmin, dTCheck;
		double *parDouble = new double [m_nData];

		if( NULL == parDouble )
		{
			HYSELECT_THROW( _T("Internal error: 'parDouble' instantiation error (pos: %i)."), *pusLineCount );
		}
	
		// Start the loop on lines.
		double dPc = 0.0;

		do 
		{
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _T('}') == *ptcLine )
			{
				break;
			}

			c = 0;
			n = 0;
			pptcField = ParseTextLine( ptcLine, &n );

			if( n > m_nData + 3 + m_bTmin )
			{
				HYSELECT_THROW( _T("The current line has not the correct number of tokens (%i != %i) (pos: %i)."), n, ( m_nData + 3 + m_bTmin ), *pusLineCount );
			}

			// Read Pc & Tmin values if present on the line.
			if( n > m_nData + 1 )
			{
				dPc = _tcstod( pptcField[c], &ptcEndPtr );

				if( _T('\0') != *ptcEndPtr )
				{
					HYSELECT_THROW( _T("Can't read the weight value (%s) at position 0 of the additive characteristic definition (pos: %i)."), pptcField[c], *pusLineCount );
				}
			
				m_pCharSurf->SetX( i++, dPc);				
				j = 0;
				c++;
			
				// Read Tmin value if present on the line.
				if( true == m_bTmin )
				{
					dTmin = _tcstod( pptcField[c], &ptcEndPtr );

					if( _T('\0') != *ptcEndPtr )
					{
						HYSELECT_THROW( _T("Can't read the Tmin value (%s) at position 1 of the additive characteristic definition (pos: %i)."), pptcField[c], *pusLineCount );
					}

					if( dTmin < m_pCharSurf->GetPointY( 0 ) )
					{
						HYSELECT_THROW( _T("Tmin value is too low (%f < %f) (pos: %i)."), dTmin, m_pCharSurf->GetPointY( 0 ), *pusLineCount );
					}
					else if( dTmin > m_pCharSurf->GetPointY( m_iT - 1 ) )
					{
						HYSELECT_THROW( _T("Tmin value is too high (%f > %f) (pos: %i)."), dTmin, m_pCharSurf->GetPointY( m_iT - 1 ), *pusLineCount );
					}

					j = m_pCharSurf->GetYSegment( dTmin );

					if( j < 0 )
					{
						HYSELECT_THROW( _T("Don't find a valid segment for Tmin value (%i < 0) (pos: %i)."), j, *pusLineCount );
					}
					else if( j >= m_iT - 1 )
					{
						HYSELECT_THROW( _T("Don't find a valid segment for Tmin value (%i > %i) (pos: %i)."), j, ( m_iT - 1 ), *pusLineCount );
					}

					m_pCharSurf->AddYminYmax( m_pCharSurf->GetPointX( i - 1 ), &dTmin );
					c++;
				}
			}
		
			// Check T value.
			dTCheck = _tcstod( pptcField[c], &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't read the temperature value (%s) at position %i of the additive characteristic definition (pos: %i)."), pptcField[c], c, *pusLineCount );
			}

			if( dTCheck < m_pCharSurf->GetPointY( j ) )
			{
				HYSELECT_THROW( _T("Temperature value is too low (%f < %f) (pos: %i)."), dTCheck, m_pCharSurf->GetPointY( j ), *pusLineCount );
			}
			else if( dTCheck > m_pCharSurf->GetPointY( m_iT - 1 ) )
			{
				HYSELECT_THROW( _T("Temperature value is too high (%f > %f) (pos: %i)."), dTCheck, m_pCharSurf->GetPointY( m_iT - 1 ), *pusLineCount );
			}

			// Read density and kinematic viscosity.
			parDouble[0] = _tcstod( pptcField[++c], &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't read the density value (%s) at position %i of the additive characteristic definition (pos: %i)."), pptcField[c], c, *pusLineCount );
			}

			parDouble[1] = _tcstod( pptcField[++c], &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't read the kinematic viscosity value (%s) at position %i of the additive characteristic definition (pos: %i)."), pptcField[c], c, *pusLineCount );
			}

			parDouble[2] = _tcstod( pptcField[++c], &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't read the specific heat value (%s) at position %i of the additive characteristic definition (pos: %i)."), pptcField[c], c, *pusLineCount );
			}

			parDouble[3] = _tcstod( pptcField[++c], &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't read the vapor pressure value (%s) at position %i of the additive characteristic definition (pos: %i)."), pptcField[c], c, *pusLineCount );
			}

			m_pCharSurf->AddPoint( i - 1, j++, parDouble );

			m_padditFitter->AddPoint(dPc, dTCheck, parDouble[0], parDouble[1], parDouble[2], parDouble[3]);
		}while( 1 );
	
		m_padditFitter->CreateCurveTminTmax();
		delete [] parDouble;
		delete m_pCharSurf;
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_AdditCharacteristic::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif 


///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_Thing
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_Thing)	

CDB_Thing::CDB_Thing( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
	m_Fixed = 0;		// 1 if the object is fixed in DB
	m_FreeInt1 = 0;
	m_FreeInt2 = 0;
	m_SortInt = 0;
}

bool CDB_Thing::IsAvailable( bool bForHub )
{
	if( true == bForHub )
	{
		if( ( false != CData::IsAvailable() || true == GetIDPtr().DB->IsSuperUserPsw() ) && ( true == IsForHub() || true == IsForHubStation() ) )
		{
			return true;
		}
	}
	else
	{
		if( ( false != CData::IsAvailable() || true == GetIDPtr().DB->IsSuperUserPsw() ) && false == IsForHub() && false == IsForHubStation() )
		{
			return true;
		}
	}
	
	return false;
}

void CDB_Thing::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_Thing *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_Thing' object!") );
		}

		// Base class.
		CData::Copy( pclDestination );

		// Copy now what it is common to the "CDB_Thing" class.
		CDB_Thing *pclDestinationThing = (CDB_Thing *)pclDestination;

		pclDestinationThing->SetFix( m_Fixed );
		pclDestinationThing->SetInt1( m_FreeInt1 );
		pclDestinationThing->SetInt2( m_FreeInt2 );
		pclDestinationThing->SetSortInt( m_SortInt );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_Thing::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_THING_VERSION	3
// Version 3: 2018-06-11: Add 'm_SortInt' variable.
void CDB_Thing::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_THING_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CData::Write( outf );
	
	// Info.
	outf.write( (char *)&m_Fixed, sizeof( m_Fixed ) );
	outf.write( (char *)&m_FreeInt1, sizeof( m_FreeInt1 ) );
	outf.write( (char *)&m_FreeInt2, sizeof( m_FreeInt2 ) );
	outf.write( (char *)&m_SortInt, sizeof( m_SortInt ) );
}

bool CDB_Thing::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_THING_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}
	
	// Info.
	if( Version < 2 )
	{
		int i = 0;	
		inpf.read( (char *)&i, sizeof( i ) );
		SetDeleted( i != 0 );
		inpf.read( (char *)&i, sizeof( i ) );
		SetAvailable( i != 0 );
		inpf.read( (char *)&i, sizeof( i ) );
		SetHidden( i != 0 );
	}

	inpf.read( (char *)&m_Fixed, sizeof( m_Fixed ) );
	inpf.read( (char *)&m_FreeInt1, sizeof( m_FreeInt1 ) );
	inpf.read( (char *)&m_FreeInt2, sizeof( m_FreeInt2 ) );
	
	if( Version < 3 )
	{
		return true;
	}

	inpf.read( (char *)&m_SortInt, sizeof( m_SortInt ) );

	return true;
}

#ifndef TACBX

#define THING_DELETED		_T("::Deleted=")
#define THING_AVAILABLE		_T("::Available=")
#define THING_HIDDEN		_T("::Hidden=")
#define THING_FIXED			_T("::Fixed=")
#define THING_FREEINT1		_T("::FreeInt1=")
#define THING_FREEINT2		_T("::FreeInt2=")
#define THING_SORTINT		_T("::SortInt=")

void CDB_Thing::InterpretInheritedData( CString *pStr )
{
	try
	{
		int iPos = pStr->Find( CLASS( CDB_Thing ) );

		if( pStr->Left(2) != _T("::") && iPos < 0 )
		{
			CData::InterpretInheritedData( pStr );
		}
		else
		{
			if( iPos >= 0 )
			{
				pStr->Delete( iPos, _tcsclen( CLASS( CDB_Thing ) ) );
			}

			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 )
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}
	
			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );
	
			if( pStr->Find( THING_DELETED ) > -1 )
			{
				double d;

				if( RD_OK != ReadDouble( strField, &d ) )
				{
					HYSELECT_THROW( _T("'CDB_Thing::Deleted' must be a double (%s)."), strField );
				}
			
				SetDeleted( ( d > 0.0 ) ? true : false );
			}
			else if( pStr->Find( THING_AVAILABLE ) > -1 )
			{
				double d;
			
				if( RD_OK != ReadDouble( strField, &d ) )
				{
					HYSELECT_THROW( _T("'CDB_Thing::Available' must be a double (%s)."), strField );
				}
			
				SetAvailable( ( d > 0.0 ) ? true : false );
			}
			else if( pStr->Find( THING_HIDDEN ) > -1 )
			{
				double d;
			
				if( RD_OK != ReadDouble( strField, &d ) )
				{
					HYSELECT_THROW( _T("'CDB_Thing::Hidden' must be a double (%s)."), strField );
				}
			
				SetHidden( ( d > 0.0 ) ? true : false );
			}
			else if( pStr->Find( THING_FIXED ) > -1 )
			{
				double d;

				if( RD_OK != ReadDouble( strField, &d ) )
				{
					HYSELECT_THROW( _T("'CDB_Thing::Fixed' must be a double (%s)."), strField );
				}
			
				m_Fixed = ( d > 0.0 ) ? true : false;  
			}
			else if( pStr->Find( THING_FREEINT1 ) > -1 )
			{
				m_FreeInt1 = InterpretBinaryLine( strField );
			}
			else if( pStr->Find( THING_FREEINT2 ) > -1 )
			{
				m_FreeInt2 = InterpretBinaryLine( strField );
			}
			else if( pStr->Find( THING_SORTINT ) > -1 )
			{
				m_SortInt = _ttoi( strField );

				if( m_SortInt < 0 || m_SortInt >= 10000 )
				{
					HYSELECT_THROW( _T("'CDB_Thing::SortInt' is incorrect (0 > %i > 1000)."), m_SortInt );
				}
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Thing::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_Thing::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_Thing format
		// line 0 : open curve bracket and call base class.
		// line 1 : isDeleted value (0 or 1)
		// line 2 : isAvailable value (0 or 1)
		// line 3 : isHidden value (0 or 1)
		// line 4 : isFix value (0 or 1)
		// line 5 : FreeInt1 -> Integer for flagging b31...b0 (bit 0: InCbi, bit1: available for Hub, bit2: available for HubStation )
		// line 6 : FreeInt2 -> Free integer (bit 0: NotForIndSel, bit 1: NotForDirSel, bit 2: NotForHMCalc)
		// line 7 : Sort integer -> Allow to show a group of articles in the order defined with this variable.
		// line 2 : close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;
	
		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_Thing *)idptr.MP )->Copy( this );
		
			CStringArray ar;

			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CData::ReadText( inpf, pusLineCount );
	
			CStringArray TxtHdr;
			TxtHdr.Add( THING_DELETED );
			TxtHdr.Add( THING_AVAILABLE );
			TxtHdr.Add( THING_HIDDEN );
			TxtHdr.Add( THING_FIXED );
			TxtHdr.Add( THING_FREEINT1 );
			TxtHdr.Add( THING_FREEINT2 );
			TxtHdr.Add( THING_SORTINT );

			for( int i = 0; i < TxtHdr.GetSize(); i++ )
			{
				ptcLine = ReadTextLine( inpf, pusLineCount );

				CString str = TxtHdr[i] + CString( ptcLine );
				CDB_Thing::InterpretInheritedData( &str );
			}
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Thing::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_Thing::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str,str1;
		
	// Write object header.
	if( true == IsClass( CLASS( CDB_Thing ) ) )
	{
		CData::WriteText( outf, strTab );
	}
	
	// Opening bracket.
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");
	
	// Data.
	str1 = ( true == IsDeleted() ) ? _T("1") : _T("0");
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	
	str1 = ( IsAvailable( IsForHub() || IsForHubStation() ) ) ? _T("1") : _T("0");
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	
	str1 = ( true == IsHidden() ) ? _T("1") : _T("0");
	str.Format( _T("\r\n%s"), strTab + str1);
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	
	str1 = ( true == IsFixed() ) ? _T("1") : _T("0");
	str.Format( _T("\r\n%s"), strTab + str1);
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	
	str1.Format( _T("%x"), m_FreeInt1 );
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	
	str1.Format( _T("%x"), m_FreeInt2 );
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	str1.Format( _T("%x"), m_SortInt );
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	
	// Closing bracket.
	strTab.Delete( 0 ); // Delete one \t
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}
#endif 

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_HydroThing
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_HydroThing)	

CDB_HydroThing::CDB_HydroThing( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_Thing( pDataBase, ID )
{
	m_Pmaxmin = 0.0;	// Lowest max. working static pressure
	m_Pmaxmax = 0.0;	// Highest max. working static pressure
	m_Tmax = 0.0;	// Max. working static temperature
	m_Tmin = 0.0;	// Min. working static temperature
	m_pPNTab = (CTable*)GetDB()->Get(_T("PN_TAB")).MP;
	m_bDispPmaxmin = false;
	m_pIDPtrPNRuledTab = NULL;
	m_PNIDptr = _NULL_IDPTR;
}

CDB_HydroThing::~CDB_HydroThing()
{
	if( NULL != m_pIDPtrPNRuledTab )
	{
		delete m_pIDPtrPNRuledTab;
	}

	m_pIDPtrPNRuledTab = NULL;
}

CDB_RuledTable *CDB_HydroThing::GetpPNRuledTab()
{
	CDB_RuledTable *pclRuledTable = NULL;

	if( NULL != m_pIDPtrPNRuledTab && _T('\0') != *m_pIDPtrPNRuledTab->ID )
	{
		m_pIDPtrPNRuledTab->DB = GetpTADB();
		Extend(m_pIDPtrPNRuledTab);
		pclRuledTable = static_cast<CDB_RuledTable *>( m_pIDPtrPNRuledTab->MP );
	}

	return pclRuledTable;
}

void CDB_HydroThing::SetpPNRuledTab( CDB_RuledTable *pclRuledTable )
{
	if( NULL == pclRuledTable )
	{
		return;
	}
	
	if( NULL == m_pIDPtrPNRuledTab )
	{
		m_pIDPtrPNRuledTab = new IDPTR( pclRuledTable->GetIDPtr().ID );

		if( NULL == m_pIDPtrPNRuledTab )
		{
			return;
		}
		
		m_pIDPtrPNRuledTab->DB = GetpTADB();
		Extend( m_pIDPtrPNRuledTab );
	}
}

void CDB_HydroThing::SetpPNRuledTabID( _string ID, bool bExtend )
{
	if( true == ID.empty() )
	{
		if( NULL != m_pIDPtrPNRuledTab )
		{
			delete m_pIDPtrPNRuledTab;
		}
		
		m_pIDPtrPNRuledTab = NULL;
		return;
	}
	
	if( NULL == m_pIDPtrPNRuledTab )
	{
		m_pIDPtrPNRuledTab = new IDPTR( ID );

		if( NULL == m_pIDPtrPNRuledTab )
		{
			return;
		}

		m_pIDPtrPNRuledTab->DB = GetpTADB();

		if( true == bExtend )
		{
			Extend( m_pIDPtrPNRuledTab );
		}
	}
}

void CDB_HydroThing::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_HydroThing *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_HydroThing' object!") );
		}

		// Base class.
		CDB_Thing::Copy( (CDB_Thing *)pclDestination );

		// Copy now what it is common to the "CDB_HydroThing" class.
		CDB_HydroThing *pclDestinationHydroThing = (CDB_HydroThing *)pclDestination;

		pclDestinationHydroThing->SetPmaxmin( GetPmaxmin() );
		pclDestinationHydroThing->SetPmaxmax( GetPmaxmax() );
		pclDestinationHydroThing->SetTmax( GetTmax() );
		pclDestinationHydroThing->SetTmin( GetTmin() );
		pclDestinationHydroThing->SetDispPmaxmin( GetDispPmaxmin() );
		pclDestinationHydroThing->SetpPNRuledTab( GetpPNRuledTab() );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_HydroThing::Copy' method with the object '%s'."), GetIDPtr().ID )
}

bool CDB_HydroThing::IsPNIncludedInPNRange( _string strPNID )
{
	if( true == strPNID.empty() )
	{
		return false;
	}

	// CDB_RuledTable exist use it.
	if( NULL != GetpPNRuledTab() )
	{
		IDPTR idptr = GetpPNRuledTab()->Get( strPNID.c_str() );
		return ( NULL != idptr.MP );
	}

	IDPTR idptr( strPNID );
	idptr.DB = GetpTADB();
	Extend( &idptr );
	
	return IsPNIncludedInPNRange( idptr );
}

bool CDB_HydroThing::IsPNIncludedInPNRange( const IDPTR &PNIDPtr )
{
	CDB_StringID *pStrID = dynamic_cast<CDB_StringID *>( PNIDPtr.MP );

	if( NULL == pStrID )
	{
		ASSERTA_RETURN( false );
	}

	// CDB_RuledTable exist use it
	if( NULL != GetpPNRuledTab() )
	{
		IDPTR idptr = GetpPNRuledTab()->Get(PNIDPtr.ID );
		return ( NULL != idptr.MP );
	}

	double dPress = 0;

	if( RD_OK == ReadDoubleFromStr( (TCHAR *)pStrID->GetIDstr(), &dPress ) )
	{
		return IsPNIncludedInPNRange(dPress);
	}

	ASSERTA_RETURN( false );
}

bool CDB_HydroThing::IsPNIncludedInPNRange( double dPress )
{
	if( dPress >= m_Pmaxmin && dPress <= m_Pmaxmax )
	{
		return true;
	}

	return false;
}

const IDPTR &CDB_HydroThing::GetPNIDPtr( bool bPmaxmax )
{
	// If 'PNRangeID' is defined this method will return:
	//   - if 'bPmaxmax' is 'true' (By default): the last value in the table (that must be the highest PN) pointed by 'PNRangeID'.
	//   - if 'bPmaxmax' is false: the first value in the table (that must be the lowest PN) pointed by 'PNRangeID'.
	//
	// If 'PNRangeID' is not defined this method will return:
	//   - if 'bPmaxmax' is 'true' (By default): the closer value below the 'Pmaxmax' value defined in the object.
	//   - if 'bPmaxmax' is 'false': the close value below the 'Pmaxmin' value defined in the object.

	double PN = 0.0;

	if( NULL == m_pPNTab )
	{
		m_pPNTab = (CTable*)( GetDB()->Get( _T("PN_TAB") ).MP );
	}

	if( NULL == m_pPNTab )
	{
		ASSERTA_RETURN( _NULL_IDPTR );
	}

	m_PNIDptr = _NULL_IDPTR;

	// CDB_RuledTable exist use it.
	if( NULL != GetpPNRuledTab() )
	{
		if( false == bPmaxmax )
		{
			return GetpPNRuledTab()->GetFirst();
		}
		
		for( IDPTR idptr = GetpPNRuledTab()->GetFirst(); _T('\0') != *idptr.ID; idptr = GetpPNRuledTab()->GetNext( idptr.MP ) )
		{
			m_PNIDptr = idptr;		// Keep the latest, CTable are ordered
		}

		return m_PNIDptr;	
	}

	double dDP = DBL_MAX; 
	double dPmax = m_Pmaxmax;

	if( false == bPmaxmax )
	{
		dPmax = m_Pmaxmin;
	}
	
	// Take the closest one just below (never above!!).
	for( IDPTR PNIDPtr = m_pPNTab->GetFirst( CLASS( CDB_StringID ) ); _T('\0') != *PNIDPtr.ID; PNIDPtr = m_pPNTab->GetNext( ) )
	{
		if( RD_OK != ReadDoubleFromStr( (TCHAR *)( (CDB_StringID *)PNIDPtr.MP )->GetIDstr(), &PN ) )
		{
			ASSERTA_RETURN( _NULL_IDPTR );
		}

		if( ( dPmax - PN ) >= 0.0 && fabs( dPmax - PN ) < dDP )
		{
			dDP = fabs( dPmax - PN );
			m_PNIDptr = PNIDPtr;
		}
	}

	return m_PNIDptr;
}

_string CDB_HydroThing::GetPN()
{
	_string str = _T("");
	
	// CDB_RuledTable exist use it.
	if( NULL != GetpPNRuledTab() )
	{
		CDB_RuledTable *pRT = static_cast<CDB_RuledTable *>(m_pIDPtrPNRuledTab->MP);
		bool bFirst =  true;

		for( IDPTR idptr = pRT->GetFirst(); _T('\0') != *idptr.ID; idptr = pRT->GetNext( idptr.MP ) )
		{
			if( false == bFirst )
			{
				str += _string( _T("/") );
			}
			else
			{
				bFirst = false;
			}
			
			CDB_StringID *pStrID = dynamic_cast<CDB_StringID*>( idptr.MP );
			ASSERT( NULL != pStrID );

			if( NULL != pStrID )
			{
				str += pStrID->GetString();
			}
		}
	}
	else
	{
		CDB_StringID *pStrPmaxmin = NULL;
		CDB_StringID *pStrPmaxmax = (CDB_StringID *)( GetPNIDPtr( true ).MP );

		// As it is indicated in the 'GetPNIDPtr' method: "Take the closest one just below (never above!!)."
		// Now we have for example membrane vessel (MN-6: 11110-15006) that has pmaxmin and pmaxmax set to 3.5 bar.
		// The first PN (PN_1) is already at 6 bar. We can't thus take this ID because this value is already above 3.5 bar.
		// And in this case, 'GetPNIDPtr' returns NULL.
		if( NULL != pStrPmaxmax )
		{
			if( true == m_bDispPmaxmin )
			{
				pStrPmaxmin = (CDB_StringID *)( GetPNIDPtr(false).MP );
				ASSERT( NULL != pStrPmaxmin );

				if( NULL != pStrPmaxmin )
				{
					str = pStrPmaxmin->GetString() + _string(_T("-"));
				}
			}
	
			if( NULL != pStrPmaxmax )
			{
				str += pStrPmaxmax->GetString();
			}
		}
	}
	
	return str;
}

bool CDB_HydroThing::GetPNList( CRankEx *pList )
{
	if( NULL == pList )
	{
		ASSERTA_RETURN( false );
	}

	// CDB_RuledTable exist use it.
	if( NULL != GetpPNRuledTab() )
	{
		CDB_RuledTable *pRT = static_cast<CDB_RuledTable *>(m_pIDPtrPNRuledTab->MP);

		for( IDPTR idptr = pRT->GetFirst(); _T('\0') != *idptr.ID; idptr = pRT->GetNext( idptr.MP ) )
		{
			CDB_StringID *pStrID = dynamic_cast<CDB_StringID*>( idptr.MP );
			ASSERT( NULL != pStrID );

			if( NULL != pStrID )
			{
				double dPN = 0.0;
				
				if( RD_OK != ReadDoubleFromStr( (TCHAR*)pStrID->GetIDstr(), &dPN ) )
				{
					ASSERTA_RETURN( false );
				}

				pList->Add( pStrID->GetString(), dPN, (LPARAM)pStrID, false );
			}
		}
		
		return true;
	}
	
	if( NULL == m_pPNTab )
	{
		m_pPNTab = (CTable*)( GetDB()->Get( _T("PN_TAB") ).MP );
	}
	
	if( true == GetDispPmaxmin() )
	{
		// Add all PN between Pmaxmin and Pmaxmax.
		for( IDPTR PNIDPtr = m_pPNTab->GetFirst(); _T('\0') != *PNIDPtr.ID; PNIDPtr = m_pPNTab->GetNext( PNIDPtr.MP ) )
		{
			CDB_StringID * pStrID = dynamic_cast<CDB_StringID *> (PNIDPtr.MP);

			if( NULL != pStrID )
			{
				double dPN = 0.0;

				if( RD_OK != ReadDoubleFromStr( (TCHAR*)pStrID->GetIDstr(), &dPN ) )
				{
					ASSERTA_RETURN( false );
				}

				// Excluded out of range.
				if( dPN < m_Pmaxmin )
				{
					continue;
				}

				if( dPN > m_Pmaxmax )
				{
					continue;
				}

				pList->Add( pStrID->GetString(), dPN, (LPARAM)pStrID, false );

				if( m_Pmaxmin == m_Pmaxmax )
				{
					break;
				}
			}
		}
	}
	else
	{
		// Add only Pmaxmax.
		double dDelta = DBL_MAX;
		double dPN = 0;
		CDB_StringID *pStrIDmax = NULL;
		CDB_StringID *pStrID = NULL;

		for( IDPTR PNIDPtr = m_pPNTab->GetFirst(); _T('\0') != *PNIDPtr.ID; PNIDPtr = m_pPNTab->GetNext( PNIDPtr.MP ) )
		{
			pStrID = dynamic_cast<CDB_StringID *>( PNIDPtr.MP );
			
			if( NULL != pStrID )
			{
				double d = 0.0;
				
				if( RD_OK != ReadDoubleFromStr( (TCHAR*)pStrID->GetIDstr(), &d ) )
				{
					ASSERTA_RETURN( false );
				}
				
				if( d > m_Pmaxmax )
				{
					continue;
				}
				
				double d2 = m_Pmaxmax - d;
				
				if( d2 < dDelta )
				{
					dPN = d;
					dDelta = d2;
					pStrIDmax = pStrID;
				}
			}
		}

		pList->Add( pStrIDmax->GetString(), dPN, (LPARAM)pStrIDmax, false );
	}
	
	return true;
}

double CDB_HydroThing::GetPNPress( bool bPmaxmax )
{
	CDB_StringID *pStr = (CDB_StringID *)( GetPNIDPtr( bPmaxmax ).MP );
	ASSERT( NULL != pStr );

	return _tcstod( pStr->GetIDstr(), '\0' );
}

void CDB_HydroThing::OnDatabaseDestroy()
{
	CDB_Thing::OnDatabaseDestroy();
}

void CDB_HydroThing::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = 2;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CDB_Thing::Write( outf );
	
	// Info.
	outf.write( (char *)&m_Pmaxmax, sizeof( m_Pmaxmax ) );
	outf.write( (char *)&m_Tmax, sizeof( m_Tmax ) );
	outf.write( (char *)&m_Tmin, sizeof( m_Tmin ) );
	outf.write( (char *)&m_Pmaxmin, sizeof( m_Pmaxmin ) );
	outf.write( (char *)&m_bDispPmaxmin, sizeof( m_bDispPmaxmin ) );
	
	if( NULL != GetpPNRuledTab() )
	{
		WriteString( outf, GetpPNRuledTab()->GetIDPtr().ID );
	}
	else
	{
		WriteString( outf, _T("") );
	}
}

bool CDB_HydroThing::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > 2 )
	{
		return false;
	}

	// Base class.
	if( false == CDB_Thing::Read( inpf ) )
	{
		return false;
	}

	// Info.
	m_Pmaxmax = ReadDouble( inpf );
	m_Tmax = ReadDouble( inpf );
	m_Tmin = ReadDouble( inpf );
	m_Pmaxmin = m_Pmaxmax;

	if( Version > 1 )
	{
		m_Pmaxmin = ReadDouble( inpf );
		inpf.read( (char *)&m_bDispPmaxmin, sizeof( m_bDispPmaxmin ) );
		_string strID;
		
		if( false == ReadString( inpf, strID ) )
		{
			return false;
		}

		if( true == strID.empty() )
		{
			SetpPNRuledTabID( strID, false );	// Don't extend now, all table are not yet loaded
		}
	}
	
	return true;
}

void CDB_HydroThing::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_Thing::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( NULL != m_pIDPtrPNRuledTab && _tcscmp( _NO_ID, (*m_pIDPtrPNRuledTab).ID ) )
		{
			IDPtr = GetDB()->Get( (*m_pIDPtrPNRuledTab).ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("PN ruled table ID (%s) is defined but not found in the database."), (*m_pIDPtrPNRuledTab).ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_RuledTable ) ) )
			{
				HYSELECT_THROW( _T("PN ruled table ID (%s) is found in the database but it's not a 'CDB_RuledTable' object."), (*m_pIDPtrPNRuledTab).ID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_HydroThing::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

#ifndef TACBX 
void CDB_HydroThing::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( _T("CDB_HydroThing") );

		if( iPos < 0 )
		{
			CDB_Thing::InterpretInheritedData( pStr );
		}
		else
		{
			pStr->Delete( iPos, _tcsclen( _T("CDB_HydroThing") ) );
			int iEq = pStr->Find( _T("=") ); 
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( _T("::Tmin=") ) > -1 )
			{
				if( RD_OK != ReadDouble( strField, &m_Tmin ) || m_Tmin <= -273.15 )
				{
					HYSELECT_THROW( _T("'CDB_HydroThing::Tmin' must be a double (%s)."), strField );
				}
			}
			else if( pStr->Find( _T("::Tmax=") ) > -1 )
			{
				if( RD_OK != ReadDouble( strField, &m_Tmax ) || m_Tmax <= -273.15 )
				{
					HYSELECT_THROW( _T("'CDB_HydroThing::Tmax' must be a double (%s)."), strField );
				}
			}
			else if( pStr->Find( _T("::PNRange=") ) > -1 )
			{
				SetpPNRuledTabID( _T(""), false );

				if( -1 == strField.Find( _NO_ID ) )
				{	
					if( strField.GetLength() > _ID_LENGTH )
					{
						HYSELECT_THROW( _T("'CDB_HydroThing::PNRange' (%s) variable length is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
					}

					// ID exist, take it.
					if( _T('\0') == *GetpTADB()->Get( strField ).ID )
					{
						HYSELECT_THROW( _T("'CDB_HydroThing::PNRange' (%s) variable can't be empty."), strField );
					}

					SetpPNRuledTabID( (LPCTSTR)strField, true );
				}
			}
			else if( pStr->Find( _T("::Pmax=") ) > -1 )
			{
				int nCheck = 0;
				TCHAR *ptcEndPtr;
				TCHAR **pptcField;
				pptcField = ParseTextLine( (LPTSTR)(LPCTSTR)strField, &nCheck );
			
				if( 2 != nCheck )
				{
					HYSELECT_THROW( _T("The current line (%s) has not the correct number of tokens (%i != 2)."), strField, nCheck );
				}

				// Look for Pmaxmin/Pmaxmax.
				m_Pmaxmax = _tcstod( pptcField[1], &ptcEndPtr );

				if( _T('\0') != *ptcEndPtr )
				{
					HYSELECT_THROW( _T("Can't read the Pmaxmax value (%s) at position 1."), pptcField[1] );
				}

				m_bDispPmaxmin = false;

				if( _T('d') == pptcField[0][0] || _T('D') == pptcField[0][0] )
				{
					m_bDispPmaxmin = true;
					m_Pmaxmin = _tcstod( &pptcField[0][1], &ptcEndPtr );
				
					if( _T('\0') != *ptcEndPtr )
					{
						HYSELECT_THROW( _T("Can't read the Pmaxmin value (%s) at position 0."), pptcField[0] );
					}
				}
				else
				{
					m_Pmaxmin = _tcstod( pptcField[0], &ptcEndPtr );
				
					if( _T('\0') != *ptcEndPtr )
					{
						HYSELECT_THROW( _T("Can't read the Pmaxmin value (%s) at position 0."), pptcField[0] );
					}

					// Get Fist available PN.
					CDB_StringID *pStrID = dynamic_cast<CDB_StringID *>( GetDB()->Get( _T("PN_1") ).MP );
				
					if( NULL == pStrID )
					{
						HYSELECT_THROW( _T("Internal error: Can't access the 'PN_1' object in the database.") );
					}

					double dPmin = 0.0;
				
					if( RD_OK != ReadDoubleFromStr( pStrID->GetIDstr(), &dPmin ) )
					{
						HYSELECT_THROW( _T("Can't convert '%s' in double."), pStrID->GetIDstr() );
					}
				
					if( m_Pmaxmin != m_Pmaxmax && m_Pmaxmin != dPmin )
					{
						m_bDispPmaxmin = true;
					}
				}

				if( m_Pmaxmin < 0.0 )
				{
					HYSELECT_THROW( _T("Pmaxmin (%f) can't be lower than 0."), m_Pmaxmin );
				}
				else if( m_Pmaxmax < 0.0 )
				{
					HYSELECT_THROW( _T("Pmaxmax (%f) can't be lower than 0."), m_Pmaxmax );
				}
				else if( m_Pmaxmax < m_Pmaxmin )
				{
					HYSELECT_THROW( _T("Pmaxmax (%f) can't be lower than Pmaxmin (%f)."), m_Pmaxmax, m_Pmaxmin );
				}
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_HydroThing::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_HydroThing::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_HydroThing format
		// line 0 : open curve bracket and call base class.
		// line 1 : Pmaxmin and Pmaxmax in Pa (if Pmaxmin = PN6, Pmaxmin is not used in PN string; a 'd' in front of Pmaxmin enforces it in PN string)
		// line 2 : PNRangeID	Identifier of CDB_RuledTable that contains available PN, could be NO_ID in this case Pmaxmin/max are used
		// line 2 : Tmax
		// line 3 : Tmin
		// line 4 : close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Read base.
		CDB_Thing::ReadText( inpf, pusLineCount );

		// Read the value of Fixed.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		int nCheck = 0;
		TCHAR *ptcEndPtr;
		TCHAR **pptcField;

		pptcField = ParseTextLine( ptcLine, &nCheck );

		if( 2 != nCheck )
		{
			HYSELECT_THROW( _T("The current line (%s) has not the correct number of tokens (%i != 2) (pos: %i)."), ptcLine, nCheck, *pusLineCount );
		}
	
		// Look for Pmaxmin/Pmaxmax.
		m_Pmaxmax = DBL_MAX;

		if( 0 != _tcscmp( _T("DBL_MAX"), pptcField[1] ) )
		{
			m_Pmaxmax = _tcstod( pptcField[1], &ptcEndPtr );
			
			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't read the Pmaxmax value (%s) at position 1 (pos: %i)."), pptcField[1], *pusLineCount );
			}
		}

		m_bDispPmaxmin = false;

		if( _T('d') == pptcField[0][0] || _T('D') == pptcField[0][0] )
		{
			m_bDispPmaxmin = true;
			m_Pmaxmin = _tcstod( &pptcField[0][1], &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't read the Pmaxmin value (%s) at position 0 (pos: %i)."), pptcField[0], *pusLineCount );
			}
		}
		else
		{
			m_Pmaxmin = _tcstod( pptcField[0], &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't read the Pmaxmin value (%s) at position 0 (pos: %i)."), pptcField[0], *pusLineCount );
			}

			// Get Fist available PN.
			CDB_StringID *pStrID = dynamic_cast<CDB_StringID *>( GetDB()->Get( _T("PN_1") ).MP );

			if( NULL == pStrID )
			{
				HYSELECT_THROW( _T("Internal error: Can't access the 'PN_1' object in the database (pos: %i)."), *pusLineCount );
			}

			double dPmin = 0.0;

			if( NULL != pStrID )
			{
				if( RD_OK != ReadDoubleFromStr( pStrID->GetIDstr(), &dPmin ) )
				{
					HYSELECT_THROW( _T("Can't convert '%s' in double (pos: %i)."), pStrID->GetIDstr(), *pusLineCount );
				}
			}
		
			if( m_Pmaxmin != m_Pmaxmax && m_Pmaxmin > dPmin )
			{
				m_bDispPmaxmin = true;
			}
		}

		if( m_Pmaxmin < 0.0 )
		{
			HYSELECT_THROW( _T("Pmaxmin (%f) can't be lower than 0 (pos: %i)."), m_Pmaxmin, *pusLineCount );
		}
	
		if( m_Pmaxmax < 0.0 )
		{
			HYSELECT_THROW( _T("Pmaxmax (%f) can't be lower than 0 (pos: %i)."), m_Pmaxmax, *pusLineCount );
		}
	
		if( m_Pmaxmax < m_Pmaxmin )
		{
			HYSELECT_THROW( _T("Pmaxmax (%f) can't be lower than Pmaxmin (%f) (pos: %i)."), m_Pmaxmax, m_Pmaxmin, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		CString strField = ptcLine;

		if( -1 == strField.Find( _NO_ID ) )
		{	
			if( strField.GetLength() > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("'PNRangeID' (%s) length is too long (%i > %i) (pos: %i)."), strField, strField.GetLength(), _ID_LENGTH, *pusLineCount );
			}

			// ID exist, take it.
			SetpPNRuledTabID( (LPCTSTR)strField, false );
		}
	
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_Tmax = DBL_MAX;

		if( 0 != _tcscmp( _T("DBL_MAX"), ptcLine ) )
		{
			m_Tmax = _tcstod( ptcLine, &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("'Tmax' (%s) must be a double (pos: %i)."), ptcLine, *pusLineCount );
			}

			if( m_Tmax <= -273.15 )
			{
				HYSELECT_THROW( _T("'Tmax' (%f) can't be lower than -273.15 (pos: %i)."), m_Tmax, *pusLineCount );
			}
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_Tmin = -273.15;

		if( 0 != _tcscmp( _T("DBL_MIN" ), ptcLine ) )
		{
			m_Tmin = _tcstod( ptcLine, &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("'Tmin' (%s) must be a double (pos: %i)."), ptcLine, *pusLineCount );
			}

			if( m_Tmin <= -273.15 )
			{
				HYSELECT_THROW( _T("'Tmin' (%f) can't be lower than -273.15 (pos: %i)."), m_Tmin, *pusLineCount );
			}
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_HydroThing::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_HydroThing::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str, str1;

	// Write object header.
	if( true == IsClass( CLASS( CDB_HydroThing ) ) )
	{
		CData::WriteText( outf, strTab );
	}

	// Opening bracket.
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");

	CDB_Thing::WriteText( outf, strTab );
	
	// Data.
	if( true == m_bDispPmaxmin )
	{
		str1 = _T("d");
	}
	
	str1 += CString( WriteDouble( m_Pmaxmin, 2, 1 ) ) + CString( _T(" \\ ") ) + CString( WriteDouble( m_Pmaxmax, 2, 1 ) );
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	
	if( NULL == GetpPNRuledTab() )
	{
		str1 = _NO_ID;
	}
	else
	{
		str1 = GetpPNRuledTab()->GetIDPtr().ID;
	}
	
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	str1 = WriteDouble( m_Tmax, 2, 1 );
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	str1 = WriteDouble( m_Tmin, 2, 1 );
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	// Closing bracket.
	strTab.Delete( 0 ); // Delete one \t
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}

const CString CDB_HydroThing::GetTempRange( bool bWithUnits )
{
	CString str = _T("-/-");

	if( -273.15 < GetTmin() )
	{
		str = WriteCUDouble( _U_TEMPERATURE, GetTmin(), false );
	}
	else
	{
		str = _T("-");
	}
	
	str += _T("/");
	
	if( -273.15 < GetTmax() )
	{
		str += WriteCUDouble( _U_TEMPERATURE, GetTmax(), false );
	}
	else
	{
		str = _T("-");
	}

	if( true == bWithUnits )
	{
		str = str + L" " + GetNameOf( TASApp.GetpUnitDB()->GetDefaultUnit( _U_TEMPERATURE ) ).c_str();
	}
	
	return str;
}
#endif 


///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_Pipe
//
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_Pipe)
		
CDB_Pipe::CDB_Pipe( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_HydroThing( pDataBase, ID )
{
	*m_tcSizeID = _T('\0');
	m_dInternalDiameter = -1.0;
	m_dRoughness = -1.0;
}

double CDB_Pipe::GetLinearDp( double dFlow, double dRho, double dNu )
{
	return CalcPipeDp( dFlow, dRho, dNu, m_dRoughness, m_dInternalDiameter );
}

double CDB_Pipe::GetVelocity( double dFlow )
{
	double dVelocity = 0.0;

	if( m_dInternalDiameter > 0.0 )
	{
		dVelocity = dFlow / ( 0.785398163398 * m_dInternalDiameter * m_dInternalDiameter );
	}

	return dVelocity;
}

LPCTSTR CDB_Pipe::GetName()
{
	_string *pStr = GetpXmlStrTab()->GetIDSStr( m_Name );

	if( NULL != pStr )
	{
		return pStr->c_str();
	}
	else
	{
		return m_Name.c_str();
	}
}

const IDPTR &CDB_Pipe::GetSizeIDPtr( CDataBase *pSizeDataBase ) 
{
	if( NULL != pSizeDataBase )
	{
		return pSizeDataBase->Get( m_tcSizeID );
	}
	else
	{
		return GetDB()->Get( m_tcSizeID );
	}
}

LPCTSTR CDB_Pipe::GetSize( CDataBase *pSizeDataBase )
{
	if( NULL == pSizeDataBase )
	{
		pSizeDataBase = GetDB();
	}

	if( NULL == pSizeDataBase )
	{
		ASSERTA_RETURN( _T("") );
	}

	CDB_StringID *pStr = (CDB_StringID *)( GetSizeIDPtr( pSizeDataBase ).MP );
	
	if( NULL == pStr )
	{
		ASSERTA_RETURN( _T("") );
	}

	return pStr->GetString();
}

int CDB_Pipe::GetSizeKey( CDataBase *pSizeDataBase )
{
	CDB_StringID *pclStringID = (CDB_StringID *)( GetSizeIDPtr( pSizeDataBase ).MP );

	if( NULL == pclStringID )
	{
		ASSERTA_RETURN( -1 );
	}

	int iDN;
	pclStringID->GetIDstrAs<int>( 0, iDN );

	return iDN;
}

void CDB_Pipe::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_HydroThing::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( _T('\0') !=  *m_tcSizeID && 0 != _tcscmp( _NO_ID, m_tcSizeID ) )
		{
			IDPtr = GetDB()->Get( m_tcSizeID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Size ID (%s) is defined but not found in the database."), m_tcSizeID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("Size ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_tcSizeID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_Pipe::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

#ifndef TACBX
void CDB_Pipe::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str,str1;

	// Write object header.
	if( true == IsClass( CLASS( CDB_Pipe ) ) )
	{
		CData::WriteText( outf, strTab );
	}

	// Opening bracket..
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");
	CDB_HydroThing::WriteText( outf, strTab );

	// Data.
	WriteFormatedStringW( outf, m_Name.c_str(), strTab, true) ;

	WriteFormatedStringW( outf, m_tcSizeID, strTab );

	WriteFormatedStringW( outf, WriteDouble( m_dInternalDiameter, 4, 1 ), strTab );

	WriteFormatedStringW( outf, WriteDouble( m_dRoughness, 4, 1 ), strTab );

	// Closing bracket.
	strTab.Delete( 0 ); // Delete one \t
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}
#endif

void CDB_Pipe::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_Pipe *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_Pipe' object!") );
		}

		// Base class.
		CDB_HydroThing::Copy( pclDestination );

		// Copy now what it is common to the "CDB_Pipe" class.
		CDB_Pipe *pclDestinationPipe = (CDB_Pipe *)pclDestination;

		pclDestinationPipe->SetName( m_Name.c_str() );
		pclDestinationPipe->SetSizeID( GetSizeID() );
		pclDestinationPipe->SetIntDiameter( GetIntDiameter() );
		pclDestinationPipe->SetRoughness( GetRoughness() );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_Pipe::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_PIPE_VERSION	1
void CDB_Pipe::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_PIPE_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CDB_HydroThing::Write( outf );
	
	// Info.
	WriteString( outf, m_Name.c_str() );
	WriteString( outf, m_tcSizeID );
	outf.write( (char *)&m_dInternalDiameter, sizeof( m_dInternalDiameter ) );
	outf.write( (char *)&m_dRoughness, sizeof( m_dRoughness ) );
}

bool CDB_Pipe::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version>CDB_PIPE_VERSION)
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_HydroThing::Read( inpf ) )
	{
		return false;
	}

	// Info.
	if( false == ReadString( inpf,m_Name ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_tcSizeID, sizeof( m_tcSizeID ) ) )
	{
		return false;
	}

	m_dInternalDiameter = ReadDouble( inpf );
	m_dRoughness = ReadDouble( inpf );
	return true;
}

#ifndef TACBX
void CDB_Pipe::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_Pipe format
		// line 0 : open curve bracket and call base class.
		// line 1 : Name of the pipe
		// line 2 : Corresp. valve size identifier
		// line 3 : Internal diameter
		// line 4 : Roughness
		// line 5 : close curve bracket

		// Skip the open curve bracket
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Inherited ?
		CString ihID;
	
		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_Pipe *)idptr.MP )->Copy( this );

			CStringArray ar;

			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_HydroThing::ReadText( inpf, pusLineCount );

			// Read the name.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			int iLength = _tcslen( ptcLine );

			if( iLength > ( _PIPE_NAME_LENGTH + 2 ) )
			{
				HYSELECT_THROW( _T("Pipe name (%s) is too long (%i > %i) (pos: %i)."), ptcLine, iLength, ( _PIPE_NAME_LENGTH + 2 ), *pusLineCount );
			}

			if( _T('"') != *ptcLine )
			{
				HYSELECT_THROW( _T("Pipe name must start with \" (pos: %i)."), *pusLineCount );
			}
			else if( _T('"') != ptcLine[iLength - 1] )
			{
				HYSELECT_THROW( _T("Pipe name must end with \" (pos: %i)."), *pusLineCount );
			}

			ptcLine[iLength - 1] = _T('\0');
			m_Name = ptcLine + 1;
		
			// Corresponding valve size identifier.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Pipe size ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			_tcsncpy_s( m_tcSizeID, SIZEOFINTCHAR( m_tcSizeID ), ptcLine, SIZEOFINTCHAR( m_tcSizeID ) - 1 );

			// Diameter and roughness
			ptcLine = ReadTextLine( inpf, pusLineCount );

			TCHAR *ptcEndPtr;
			m_dInternalDiameter = _tcstod( ptcLine, &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't convert internal diameter value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
			}
			else if( m_dInternalDiameter <= 0.0 )
			{
				HYSELECT_THROW( _T("Internal diameter value (%f) can't be lower or equal to 0 (pos: %i)."), m_dInternalDiameter, *pusLineCount );
			}

			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_dRoughness = _tcstod( ptcLine, &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't convert roughness value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
			}
			else if( m_dRoughness <= 0.0 )
			{
				HYSELECT_THROW( _T("Roughness value (%f) can't be lower or equal to 0 (pos: %i)."), m_dRoughness, *pusLineCount );
			}
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Pipe::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_Pipe::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( _T("CDB_Pipe") );

		if( iPos < 0 )
		{
			CDB_HydroThing::InterpretInheritedData( pStr );
		}
		else
		{
			pStr->Delete( iPos, _tcsclen( _T("CDB_Pipe") ) );
			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( _T("::Name=") ) > -1 )
			{
				if( strField.GetLength() > ( _PIPE_NAME_LENGTH + 2 ) )
				{
					HYSELECT_THROW( _T("'CDB_Pipe::Name' (%s) is too long (%i > %i)."), strField, strField.GetLength(), ( _PIPE_NAME_LENGTH + 2 ) );
				}

				if( _T('"') != strField.GetAt( 0 ) )
				{
					HYSELECT_THROW( _T("'CDB_Pipe::Name' (%s) must start with \"."), strField );
				}
				else if( _T('"') != strField.GetAt( strField.GetLength() - 1 ) )
				{
					HYSELECT_THROW( _T("'CDB_Pipe::Name' (%s) must end with \"."), strField );
				}

				// Add a function to remove the " on the first and the last place and not remove
				// all " as previous because the string can contain one " like --> 2"(inch).
				strField = strField.Mid( 1, strField.GetLength() - 2 );
				m_Name = strField;
			}
			else if( pStr->Find( _T("::SizeID=") ) > -1 )
			{
				// Corresponding valve size identifier.
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_Pipe::SizeID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				_tcsncpy_s( m_tcSizeID, SIZEOFINTCHAR( m_tcSizeID ), (LPCTSTR)strField, SIZEOFINTCHAR( m_tcSizeID ) - 1 );
			}
			else if( pStr->Find( _T("::Di=") ) > -1 )
			{
				TCHAR *ptcEndPtr;
			
				m_dInternalDiameter = _tcstod( (LPCTSTR)strField, &ptcEndPtr);

				if( _T('\0') != *ptcEndPtr )
				{
					HYSELECT_THROW( _T("Can't convert 'CDB_Pipe::Di' (%s) in double."), strField );
				}
				else if( m_dInternalDiameter <= 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_Pipe::Di' (%f) can't be lower or equal to 0."), m_dInternalDiameter );
				}
			}
			else if( pStr->Find( _T("::Roughness=") ) > -1 )
			{
				TCHAR *ptcEndPtr;
				m_dRoughness = _tcstod( (LPCTSTR)strField, &ptcEndPtr );

				if( _T('\0') != *ptcEndPtr )
				{
					HYSELECT_THROW( _T("Can't convert 'CDB_Pipe::Roughness' (%s) in double."), strField );
				}
				else if( m_dRoughness <= 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_Pipe::Roughness' (%f) can't be lower or equal to 0."), m_dRoughness );
				}
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Pipe::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif 

///////////////////////////////////////////////////////////////////////////////////
//
//								CProductSortKey
// used to create/compare product sorting key
///////////////////////////////////////////////////////////////////////////////////

CProductSortKey::CProductSortKey()
{
	m_usKey.LL.L = 0;
	m_usKey.LL.H = 0;
	m_pKeyOrderList = NULL;
	m_iKeyOrderSize = 0;
	m_psidType = NULL;
	m_dPriority = 0.0;
	m_psidPN = NULL;
	m_psidFam = NULL;

	_InitProductSortKey();
}

CProductSortKey::CProductSortKey( CDB_Product *pclProduct )
{
	if( NULL == pclProduct )
	{
		return;
	}

	m_usKey.LL.L = 0;  
	m_usKey.LL.H = 0;  
	m_pKeyOrderList = NULL;
	m_iKeyOrderSize = 0;
	m_psidType = dynamic_cast<CDB_StringID *>( pclProduct->GetTypeIDPtr().MP );
	m_dPriority = ( true == pclProduct->IsDeleted() ) ? 11: (UINT)pclProduct->GetPriorityLevel();	// Priority level; set to lower level when product is deleted
	m_psidPN = dynamic_cast<CDB_StringID *>( pclProduct->GetPNIDPtr().MP );
	m_psidFam = dynamic_cast<CDB_StringID *>( pclProduct->GetFamilyIDPtr().MP );

	_InitProductSortKey();
}

CProductSortKey::CProductSortKey( sLL sLLKey )
{
	m_usKey.LL = sLLKey;
	m_pKeyOrderList = NULL;
	m_iKeyOrderSize = 0;
	m_psidType = NULL;
	m_dPriority = 0.0;
	m_psidPN = NULL;
	m_psidFam = NULL;

	_InitProductSortKey();
}

CProductSortKey::CProductSortKey( CDB_StringID *psidType, CDB_StringID *psidFam, CDB_StringID *psidPN, UINT uiPriority )
{
	Init( psidType, psidFam, psidPN, uiPriority );
	_InitProductSortKey();
}

void CProductSortKey::Init( CDB_StringID *psidType, CDB_StringID *psidFam, CDB_StringID *psidPN, UINT uiPriority )
{
	m_usKey.LL.L = 0;  
	m_usKey.LL.H = 0;  
	m_psidType = psidType;  
	m_psidFam = psidFam;
	m_psidPN = psidPN; 
	m_dPriority = uiPriority;
	m_pKeyOrderList = NULL;
	m_iKeyOrderSize = 0;
}

void CProductSortKey::InitWithDouble( double dKey )
{
	if( NULL == m_pKeyOrderList )
	{
		PrepareKeyOrderMap();
	}

	uSortingKey Key;
	
	// Convert double value to uSortingKey
	double dDiv = 0x10000;
	dDiv *= 0x10000;

#ifndef TACBX
#pragma warning (disable : 4244)
#endif	

	unsigned long uH = (unsigned long)( dKey / dDiv );
	double d = uH;
	d *= dDiv;
	unsigned long uL =(unsigned long)( dKey - d );

#ifndef TACBX
#pragma warning (default : 4244)
#endif	

	for( int i = 0; i < m_iKeyOrderSize; ++i )
	{
		unsigned long ulValue = ( true == m_pKeyOrderList[i].m_fHiOrLow ) ? uH : uL;
		Key.ar[i] = (unsigned char)( ( ulValue >> m_pKeyOrderList[i].m_nBitToShift) & m_pKeyOrderList[i].m_nMask );
	}

	m_usKey = Key;
}

void CProductSortKey::PrepareKeyOrderMap( void )
{
	// Double's mantise is only 52 bits
	//					Values		nbr bits	Mask			Bit pos in double	Mult. factor
	// Type 			16			4			0x003C0000		L 18				262144
	// Priority			16			4			0x0003C000		L 14				16384
	// PN				64			6			0x00003F00		L 8					256
	// Family			256			8			0x000000FF		L 0					1
	//						Total  20

	m_pKeyOrderList = m_arProductSortKey;
	m_iKeyOrderSize = sizeof( m_arProductSortKey ) / sizeof( m_arProductSortKey[0] );
}

void CProductSortKey::ComputeSortingKey()
{
	HYSELECT_TRY
	{
		CDB_StringID *strTab[PKO_Last];
		strTab[PKO_Type] = m_psidType;   
		strTab[PKO_Priority] = NULL;   
		strTab[PKO_Pn] = m_psidPN;   
		strTab[PKO_Fam] = m_psidFam;   

		m_usKey.LL.H = m_usKey.LL.L = 0;
		UINT uiVal = 0;

		for( UINT i = 0; i < PKO_Last; i++ )
		{
			CDB_StringID *pStrID = dynamic_cast<CDB_StringID *>( strTab[i] );
			int iVal;

			switch( i )
			{
				// PN
				case PKO_Pn:
				{
					double dPN = 0;

					if( NULL != pStrID && pStrID->GetIDstrAs<double>( 0, dPN ) )
					{
						dPN /= 100000.0;			// PN is expressed in Pa return to bar

						if( dPN >= 64.0 )
						{
							HYSELECT_THROW( _T("The 'PN' key (%f) can't be higher than 64."), dPN );
						}

						uiVal = (UINT)dPN;
					}
					else
					{
						uiVal = 0;
					}

					break;
				}

				// Priority level.
				case PKO_Priority:
					uiVal = (UINT)m_dPriority;

					if( uiVal >= 16 )
					{
						HYSELECT_THROW( _T("The 'Priority level' key (%i) can't be higher than 16."), uiVal );
					}

					// Priority level is limited to 4bits (double compliant see below)
					uiVal &= 0x0F;
					break;
			
				case PKO_Type:
				case PKO_Fam:

					if( NULL != pStrID && pStrID->GetIDstrAs<int>( 0, iVal ) )
					{
						uiVal = (unsigned int)iVal;
					}
					else
					{
						uiVal = 0;
					}

					if( PKO_Type == i )
					{
						if( uiVal >= 16 )
						{
							HYSELECT_THROW( _T("The 'Type' key (%i) can't be higher than 16."), uiVal );
						}
					}
					else if( PKO_Fam == i )
					{
						if( uiVal >= 256 )
						{
							HYSELECT_THROW( _T("The 'Family' key (%i) can't be higher than 256."), uiVal );
						}
					}

					break;
			}
		
			uiVal &= 0xFF;
			m_usKey.ar[i] = (unsigned char)uiVal;
		}
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CProductSortKey::ComputeSortingKey' method.") )
}

double CProductSortKey::GetSortingKeyAsDouble( CPSKMask *pclMask )
{
	HYSELECT_TRY
	{
		if( 0 == m_usKey.LL.H && 0 == m_usKey.LL.L )
		{
			ComputeSortingKey();
		}

		if( NULL == m_pKeyOrderList )
		{
			PrepareKeyOrderMap();
		}

		uSortingKey uKey;
		uKey.LL = GetSortingKeyAsLL( pclMask );

		unsigned long ulH = 0;
		unsigned long ulL = 0;

		for( int i = 0; i < m_iKeyOrderSize; ++i )
		{
			unsigned long lValue = ( (unsigned long)uKey.ar[i] & m_pKeyOrderList[i].m_nMask) << m_pKeyOrderList[i].m_nBitToShift;

			if( true == m_pKeyOrderList[i].m_fHiOrLow )
			{
				ulH += lValue;
			}
			else
			{
				ulL += lValue;
			}
		}

		double dRet = ( (double)ulH );
		dRet *= 0x10000;			// Splitted in two for CBX compatibility
		dRet *= 0x10000;			// Splitted in two for CBX compatibility
		dRet += ulL;

		return dRet;
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CProductSortKey::GetSortingKeyAsDouble' method.") )
}

double CProductSortKey::GetSortingKeyCustomAsDouble( CPSKMask *pclMask, ... )
{
	if( NULL == pclMask )
	{
		return 0.0;
	}

	if( 0 == m_usKey.LL.H && 0 == m_usKey.LL.L )
	{
		ComputeSortingKey();
	}
	
	if( NULL == m_pKeyOrderList )
	{
		PrepareKeyOrderMap();
	}

	uSortingKey uKey;
	uKey.LL = GetSortingKeyAsLL( pclMask );

	std::map<int, int> mapArgumentKeyList;

	// Fill the map ordered in load's information.
	va_list vl;
	va_start( vl, pclMask );
	int i = 0;
	int iKeyMask = va_arg( vl, int );
	
	while( -1 != iKeyMask )
	{		
		mapArgumentKeyList.insert( std::pair<int,int>( i, iKeyMask ) );
		iKeyMask = va_arg( vl, int );
		i++;
	}
	
	va_end( vl );

	// Add all missing fields (Key) after key listed into the argument list.
	std::map <int, int>::iterator iterArgList;
	
	for( int i = m_iKeyOrderSize - 1; i <= 0; --i )
	{
		int iKeyMask = i;
		bool bAlreadyUsed = false;

		for( iterArgList = mapArgumentKeyList.begin() ; iterArgList != mapArgumentKeyList.end() && false == bAlreadyUsed; ++iterArgList )
		{
			if( (int)( iterArgList->second & pclMask->GetMaskAll() ) == iKeyMask )
			{
				bAlreadyUsed = true;
			}
		}

		if( true == bAlreadyUsed )
		{
			continue;
		}
		
		mapArgumentKeyList.insert( std::pair<int,int>( i, iKeyMask ) );
		i++;
	}

	// Verify first if we don't exceed available space.
	// Remark: we work with a 'double' that is encoded on 64 bits. 1 bits for sign, 11 bits for exponent and 52 bits for fraction (in French 'mantise').
	//         we work ONLY with the fraction part of 52 bits. The total number of bits must thus MUST NOT exceed 52 bits.
	int iNbrBits = 0;
	
	for( int iLoopArgList = 0; iLoopArgList < (int)mapArgumentKeyList.size(); iLoopArgList++ )
	{
		iNbrBits += GetNbrBitsKeyUsed( mapArgumentKeyList[iLoopArgList] & pclMask->GetMaskAll() );
	}

	if( iNbrBits > 52 )
	{
		ASSERT( 0 );
		return 0.0;
	}

	double dRet = 0.0;
	int iShift = 0;

	for( std::map<int, int>::reverse_iterator riter = mapArgumentKeyList.rbegin(); riter != mapArgumentKeyList.rend(); riter++ )
	{
		int iSortingKey = riter->second & pclMask->GetMaskAll();
		bool fInverse = ( pclMask->GetMaskInverse() == ( riter->second & pclMask->GetMaskInverse() ) ) ? true : false;

		unsigned char ucMask = ( 1 << GetNbrBitsKeyUsed( iSortingKey ) ) - 1;
		unsigned char ucValue = uKey.ar[iSortingKey];

		if( true == fInverse )
		{
			ucValue = ~ucValue;
		}

		// Don't use 'dValue = (double)( ( ucValue & ucMask ) << iShift )'.
		// Above 32 bits, the right part becomes negative.
		double dMultiply = 1.0;
		int iShiftLeft = iShift;

		while( iShiftLeft-- > 0 )
		{
			dMultiply *= 2.0;
		}

 		double dValue = (double)( ucValue & ucMask ) * dMultiply;
 		dRet += dValue;
		iShift += GetNbrBitsKeyUsed( riter->second & pclMask->GetMaskAll() );
	}

	return dRet;
}

LONGLONG CProductSortKey::GetPartialSortingKey( int &iNbreTotBits, CPSKMask *pclMask, ... )
{
	if( NULL == pclMask )
	{
		return 0;
	}

	if( 0 == m_usKey.LL.H && 0 == m_usKey.LL.L )
	{
		ComputeSortingKey();
	}

	uSortingKey uKey;
	uKey.LL = GetSortingKeyAsLL( pclMask );
	std::vector<int> vecKeyOrder;
	
	// Fill the map ordered in load's information.
	va_list vl;
	va_start( vl, pclMask );
	int iKeyMask = va_arg( vl, int );
	
	while( -1 != iKeyMask )
	{		
		vecKeyOrder.push_back( iKeyMask );
		iKeyMask = va_arg( vl, int );
	}

	va_end( vl );
	
	iNbreTotBits = 0;
	LONGLONG LL = 0;
	int iBits = 0;
	
	for( unsigned int i = 0; i < vecKeyOrder.size(); i++ )
	{
		int iKey = ( vecKeyOrder.at( i ) & pclMask->GetMaskAll() );
		unsigned char ucMask = ( 1 << GetNbrBitsKeyUsed( iKey ) ) - 1;
		iBits = GetNbrBitsKeyUsed( iKey );
		LL <<= iBits;

		unsigned char ucValue = uKey.ar[iKey];

		if( pclMask->GetMaskInverse() == ( vecKeyOrder.at( i ) & pclMask->GetMaskInverse() ) )
		{
			ucValue = ~ucValue;
		}

		LL += (unsigned long)( ucValue & ucMask );
		iNbreTotBits += iBits;
	}

	return LL;	
}

int CProductSortKey::GetNbrBitsKeyUsed( int iKey )
{
	if( NULL == m_pKeyOrderList )
	{
		PrepareKeyOrderMap();
	}

	int iResult = 0;

	if( m_iKeyOrderSize - 1 >= iKey )
	{
		iResult = m_pKeyOrderList[iKey].m_nBits;
	}

	return iResult;
}

CProductSortKey::sLL CProductSortKey::GetSortingKeyAsLL( CPSKMask *pclMask )
{
	uSortingKey uKey;
	
	if( NULL == pclMask )
	{
		uKey.LL.H = 0;
		uKey.LL.L = 0;
		return uKey.LL;
	}

	if( 0 == m_usKey.LL.H && 0 == m_usKey.LL.L )
	{
		ComputeSortingKey();
	}
	
	uKey = m_usKey;

	if( pclMask->GetMask() != pclMask->GetMaskAll() )
	{
		uSortingKey uKeyMask;
		uKeyMask.LL.H = 0;
		uKeyMask.LL.L = 0;
		UINT uiBitScan = pclMask->GetMask() & pclMask->GetMaskAll();	
		
		for( int j = 7; j >= 0; j-- )
		{
			if( 0x80 == ( uiBitScan & 0x80 ) )
			{
				uKeyMask.ar[j] = 0xFF;
			}

			uiBitScan <<= 1;
			uiBitScan &= 0xFF; // Keep only needed bits
		}

		uKey.LL.L &= uKeyMask.LL.L;
		uKey.LL.H &= uKeyMask.LL.H;
	}

	return uKey.LL;
}

int CProductSortKey::Compare( CProductSortKey *pSK, CPSKMask *pclMask )
{
	if( NULL == pSK || NULL == pclMask )
	{
		return -1;
	}

	double dVal = pSK->GetSortingKeyAsDouble( pclMask );
	double dThisVal = GetSortingKeyAsDouble( pclMask );
	
	if( dThisVal < dVal )
	{
		return 1;
	}
	
	if( dThisVal > dVal )
	{
		return -1;
	}
	
	return 0;
}

bool CProductSortKey::operator==( CProductSortKey *pSK ) 
{
	CPSKMask clCPSKMask( PSKM_All );
	int iRet = Compare( pSK, &clCPSKMask );
	return ( 0 == iRet );
}

void CProductSortKey::_InitProductSortKey()
{
	m_arProductSortKey[0].m_fHiOrLow = false;
	m_arProductSortKey[0].m_nBits = 8;
	m_arProductSortKey[0].m_nBitToShift = 0;
	m_arProductSortKey[0].m_nMask = 0xFF;

	m_arProductSortKey[1].m_fHiOrLow = false;
	m_arProductSortKey[1].m_nBits = 4;
	m_arProductSortKey[1].m_nBitToShift = 8;
	m_arProductSortKey[1].m_nMask = 0x0F;

	m_arProductSortKey[2].m_fHiOrLow = false;
	m_arProductSortKey[2].m_nBits = 4;
	m_arProductSortKey[2].m_nBitToShift = 12;
	m_arProductSortKey[2].m_nMask = 0x0F;

	m_arProductSortKey[3].m_fHiOrLow = false;
	m_arProductSortKey[3].m_nBits = 4;
	m_arProductSortKey[3].m_nBitToShift = 16;
	m_arProductSortKey[3].m_nMask = 0x0F;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CTAPSortKey
// used to create/compare TA Product sorting key
///////////////////////////////////////////////////////////////////////////////////

CTAPSortKey::CTAPSortKey()
	: CProductSortKey()
{
	m_psidSize = NULL;
	m_psidBdy = NULL;
	m_psidConn = NULL;
	m_psidVers = NULL;

	_InitTAProductSortKey();
}

CTAPSortKey::CTAPSortKey( CDB_TAProduct *pTAP )
	: CProductSortKey( pTAP )
{
	if( NULL == pTAP )
	{
		return;
	}

	// 'm_psidType', 'm_uiPriority', 'm_psidPN', and 'm_psidFam' are initialized in the base class.
	
	m_psidSize = dynamic_cast<CDB_StringID *>( pTAP->GetSizeIDPtr().MP );
	m_psidBdy = dynamic_cast<CDB_StringID *>( pTAP->GetBodyMaterialIDPtr().MP );
	m_psidConn = dynamic_cast<CDB_StringID *>( pTAP->GetConnectIDPtr().MP );
	m_psidVers = dynamic_cast<CDB_StringID *>( pTAP->GetVersionIDPtr().MP );

	_InitTAProductSortKey();
}

CTAPSortKey::CTAPSortKey( sLL sLLKey ) 
	: CProductSortKey( sLLKey )
{
	m_psidSize = NULL;
	m_psidBdy = NULL;
	m_psidConn = NULL;
	m_psidVers = NULL;

	_InitTAProductSortKey();
}

CTAPSortKey::CTAPSortKey( CDB_StringID *psidType, CDB_StringID *psidSize, CDB_StringID *psidFam, CDB_StringID *psidBdy, CDB_StringID *psidConn, 
		CDB_StringID *psidVers, CDB_StringID *psidPN, UINT uiPriority )
	: CProductSortKey( psidType, psidFam, psidPN, uiPriority )
{
	Init( psidType, psidSize, psidFam, psidBdy, psidConn, psidVers, psidPN, uiPriority );
	_InitTAProductSortKey();
}

void CTAPSortKey::Init( CDB_StringID *psidType, CDB_StringID *psidSize, CDB_StringID *psidFam, CDB_StringID *psidBdy, CDB_StringID *psidConn,
		CDB_StringID *psidVers, CDB_StringID *psidPN, UINT uiPriority )
{
	CProductSortKey::Init( psidType, psidFam, psidPN, uiPriority );

	m_psidSize = psidSize;
	m_psidBdy = psidBdy;
	m_psidConn = psidConn;
	m_psidVers = psidVers;

	_InitTAProductSortKey();
}

void CTAPSortKey::PrepareKeyOrderMap()
{
	// Double's mantise is only 52 bits
	//					Values		nbr bits	Mask			Bit pos in double	Mult. factor
	// Type 			16			4			0x01E000		H 13				8192
	// Size				32			5			0x001F00		H 8					256
	// Priority			16			4			0x0000F0		H 4					16
	// BdyMat			16			4			0x00000F		H 0					1
	// Connect			64			6			0x07E00000      L 21                2097152
	// Version			128			7			0x001FC000		L 14				16384
	// PN				64			6			0x00003F00		L 8					256
	// Family			256			8			0x000000FF		L 0					1
	//						Total  44

	// For PN, we have extracted all the products from the database. For the moment, the maximum value for 
	// a product inherited from a 'CDB_Product' or a 'CDB_TAProduct' is the CV 225/240... = 40 bar.
	// We can then encoded this value on 6 bits.

	m_pKeyOrderList = m_arTAPProductSortKey;
	m_iKeyOrderSize = sizeof( m_arTAPProductSortKey) / sizeof( m_arTAPProductSortKey[0]);
}

void CTAPSortKey::ComputeSortingKey()
{
	// Family, BdyMat, Connect, Version.
	CDB_StringID *strTab[TAPKO_Last];
	
	strTab[TAPKO_Type] = m_psidType;   
	strTab[TAPKO_Size] = m_psidSize;
	strTab[TAPKO_Priority] = NULL;   
	strTab[TAPKO_BdyMat] = m_psidBdy;   
	strTab[TAPKO_Conn] = m_psidConn;   
	strTab[TAPKO_Vers] = m_psidVers;   
	strTab[TAPKO_Pn] = m_psidPN;   
	strTab[TAPKO_Fam] = m_psidFam;   

	m_usKey.LL.H = m_usKey.LL.L = 0;
	UINT uiVal = 0;
	
	for( UINT i = 0; i < TAPKO_Last; i++ )
	{
		CDB_StringID *pStrID = dynamic_cast<CDB_StringID *>( strTab[i] );
		int iVal;
		
		switch( i )
		{
			// PN
			case TAPKO_Pn:
			{
				double dPN = 0.0;

				if( NULL != pStrID && pStrID->GetIDstrAs<double>( 0, dPN ) )
				{
					dPN /= 100000.0;			// PN is expressed in Pa return to bar
					ASSERT( dPN < 64.0 );

					uiVal = (UINT)dPN;
				}
				else
				{
					uiVal = 0;
				}

				break;
			}

			// Priority level.
			case TAPKO_Priority:
				uiVal = (UINT)m_dPriority;
				ASSERT( uiVal < 16.0 );

				// Priority level is limited to 4bits (double compliant see below)
				uiVal &= 0x0F;
				break;
			
			case TAPKO_Type:
			case TAPKO_Size:
			case TAPKO_BdyMat:
			case TAPKO_Conn:
			case TAPKO_Vers:
			case TAPKO_Fam:
				
				if( NULL != pStrID && pStrID->GetIDstrAs<int>( 0, iVal ) )
				{
					uiVal = (unsigned int)iVal;
				}
				else
				{
					uiVal = 0;
				}

				if( TAPKO_Type == i )
				{
					ASSERT( uiVal < 16 );
				}
				else if( TAPKO_Size == i )
				{
					ASSERT( uiVal < 32 );
				}
				else if( TAPKO_BdyMat == i )
				{
					ASSERT( uiVal < 16 );
				}
				else if( TAPKO_Conn == i )
				{
					ASSERT( uiVal < 64 );
				}
				else if( TAPKO_Vers == i )
				{
					ASSERT( uiVal < 128 );
				}
				else if( TAPKO_Fam == i )
				{
					ASSERT( uiVal < 256 );
				}

				break;
		}
		
		// Limited to one byte.
		ASSERT( uiVal < 256 );
		uiVal &= 0xFF;
		m_usKey.ar[i] = (unsigned char)uiVal;
	}
}

void CTAPSortKey::_InitTAProductSortKey()
{
	// Family.
	m_arTAPProductSortKey[0].m_fHiOrLow = false;
	m_arTAPProductSortKey[0].m_nBits = 8;
	m_arTAPProductSortKey[0].m_nBitToShift = 0;
	m_arTAPProductSortKey[0].m_nMask = 0xFF;

	// PN.
	m_arTAPProductSortKey[1].m_fHiOrLow = false;
	m_arTAPProductSortKey[1].m_nBits = 6;
	m_arTAPProductSortKey[1].m_nBitToShift = 8;
	m_arTAPProductSortKey[1].m_nMask = 0x3F;

	// Version.
	m_arTAPProductSortKey[2].m_fHiOrLow = false;
	m_arTAPProductSortKey[2].m_nBits = 7;
	m_arTAPProductSortKey[2].m_nBitToShift = 14;
	m_arTAPProductSortKey[2].m_nMask = 0x3F;

	// Connect.
	m_arTAPProductSortKey[3].m_fHiOrLow = false;
	m_arTAPProductSortKey[3].m_nBits = 6;
	m_arTAPProductSortKey[3].m_nBitToShift = 21;
	m_arTAPProductSortKey[3].m_nMask = 0x3F;

	// Body material.
	m_arTAPProductSortKey[4].m_fHiOrLow = true;
	m_arTAPProductSortKey[4].m_nBits = 4;
	m_arTAPProductSortKey[4].m_nBitToShift = 0;
	m_arTAPProductSortKey[4].m_nMask = 0x0F;

	// Priority.
	m_arTAPProductSortKey[5].m_fHiOrLow = true;
	m_arTAPProductSortKey[5].m_nBits = 4;
	m_arTAPProductSortKey[5].m_nBitToShift = 4;
	m_arTAPProductSortKey[5].m_nMask = 0x0F;

	// Size.
	m_arTAPProductSortKey[6].m_fHiOrLow = true;
	m_arTAPProductSortKey[6].m_nBits = 5;
	m_arTAPProductSortKey[6].m_nBitToShift = 8;
	m_arTAPProductSortKey[6].m_nMask = 0x1F;

	// Type.
	m_arTAPProductSortKey[7].m_fHiOrLow = true;
	m_arTAPProductSortKey[7].m_nBits = 4;
	m_arTAPProductSortKey[7].m_nBitToShift = 13;
	m_arTAPProductSortKey[7].m_nMask = 0x0F;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_Product
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_Product )

CDB_Product::CDB_Product( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_HydroThing( pDataBase, ID )
{
	m_tcArtNum[0] = _T('\0');					// Product article number.
	m_tcName[0] = _T('\0');						// Product name.
	m_TypeIDPtr = _NULL_IDPTR;				// Product type IDPTR.
	m_FamilyIDPtr = _NULL_IDPTR;			// Product family IDPTR.
	m_VersionIDPtr = _NULL_IDPTR;
	m_iPriorityLevel = 0;					// Prior. level for select. [1,10].
	m_strComment = L"";						// Product comment.
	m_strProdPicID = L"";					// Product image ID.
	m_AccessGroupIDPtr = _NULL_IDPTR;
	m_ePartOfaSet = ePartOfaSetNo;
	m_strTableSetID = L"";					// ID of the corresponding table set if exist.
	m_dPrice = 0.0;							// Product price.
	m_SortingKey.H = 0;
	m_SortingKey.L = 0;
	m_pStr = NULL;
	
	// HYS-1018
	m_iProductUseFlag = -1;								// Product use: 0 if only Product, 1 if Accessory, 2 if both
	m_AccessTypeIDPtr = _NULL_IDPTR;								// Product type IDPTR.
	m_AccessFamilyIDPtr = _NULL_IDPTR;								// Product family IDPTR.
	m_SeriesIDPtr = _NULL_IDPTR;
	m_bAttached = true;
}

LPCTSTR CDB_Product::GetBodyArtNum()
{
	m_pStr = GetpXmlStrTab()->GetIDSStr( m_tcArtNum );

	if( NULL != m_pStr )
	{
		return m_pStr->c_str();
	}
	else
	{
		return m_tcArtNum;
	}
}

LPCTSTR CDB_Product::GetName()
{
	m_pStr = GetpXmlStrTab()->GetIDSStr( m_tcName );

	if( NULL != m_pStr )
	{
		return m_pStr->c_str();
	}
	else
	{
		return m_tcName;
	}
}

const IDPTR &CDB_Product::GetFamilyIDPtr()
{
	m_FamilyIDPtr.DB = GetDB();
	Extend(&m_FamilyIDPtr);
	return m_FamilyIDPtr;
}

LPCTSTR CDB_Product::GetFamily()
{
	// Call 'GetFamilyIDPtr' to force 'Extend' if it is not already done.
	IDPTR FamilyIDPtr = GetFamilyIDPtr();

	if( NULL != FamilyIDPtr.MP )
	{
		CDB_StringID *pStr = (CDB_StringID *)( FamilyIDPtr.MP );
		return pStr->GetString();
	}
	else
	{
		return _T("");
	}
}

const IDPTR &CDB_Product::GetVersionIDPtr()
{
	m_VersionIDPtr.DB = GetDB();
	Extend( &m_VersionIDPtr );
	return m_VersionIDPtr;
}

LPCTSTR CDB_Product::GetVersion()
{
	// Call 'GetVersionIDPtr' to force 'Extend' if it is not already done.
	IDPTR VersionIDPtr = GetVersionIDPtr();

	if( NULL != VersionIDPtr.MP )
	{
		CDB_StringID *pStr = (CDB_StringID *)( VersionIDPtr.MP );
		return pStr->GetString();
	}
	else
	{
		return _T("");
	}
}

const IDPTR &CDB_Product::GetTypeIDPtr()
{
	m_TypeIDPtr.DB = GetDB();
	Extend( &m_TypeIDPtr );
	return m_TypeIDPtr;
}

LPCTSTR CDB_Product::GetType()
{
	// Call 'GetTypeIDPtr' to force 'Extend' if it is not already done.
	IDPTR TypeIDPtr = GetTypeIDPtr();

	if( NULL != TypeIDPtr.MP )
	{
		CDB_StringID *pStr = (CDB_StringID *)( TypeIDPtr.MP );
		return pStr->GetString();
	}
	else
	{
		return _T("");
	}
}

LPCTSTR CDB_Product::GetComment()
{
	m_pStr = GetpXmlStrTab()->GetIDSStr( m_strComment );

	if( NULL != m_pStr )
	{
		return m_pStr->c_str();
	}
	else
	{
		return m_strComment.c_str();
	}
}

IDPTR CDB_Product::GetAccessoriesGroupIDPtr()
{
	m_AccessGroupIDPtr.DB = GetDB();

	if( _T('\0') != *m_AccessGroupIDPtr.ID && 0 != _tcscmp( _NO_ID, m_AccessGroupIDPtr.ID ) && NULL != m_AccessGroupIDPtr.DB )
	{
		Extend( &m_AccessGroupIDPtr );
		return m_AccessGroupIDPtr;
	}
	else
	{
		return _NULL_IDPTR;
	}
}

CTableSet *CDB_Product::GetTableSet()
{ 
	return (CTableSet *)( GetDB()->Get( m_strTableSetID.c_str() ).MP );
}

IDPTR CDB_Product::GetSeriesIDPtr()
{
	m_SeriesIDPtr.DB = GetDB();
	Extend( &m_SeriesIDPtr );
	return m_SeriesIDPtr;
}

const IDPTR &CDB_Product::GetAccessTypeIDPtr()
{
	m_AccessTypeIDPtr.DB = GetDB();
	Extend( &m_AccessTypeIDPtr );
	return m_AccessTypeIDPtr;
}

const IDPTR &CDB_Product::GetAccessFamilyIDPtr()
{
	m_AccessFamilyIDPtr.DB = GetDB();
	Extend( &m_AccessFamilyIDPtr );
	return m_AccessFamilyIDPtr;
}

LPCTSTR CDB_Product::SetArtNum( LPCTSTR tcArtNum )
{
	Modified();
	return PurgeString( m_tcArtNum, tcArtNum, SIZEOFINTCHAR( m_tcArtNum ) );
}

LPCTSTR CDB_Product::SetName( LPCTSTR tcName )
{
	Modified();
	_string tmp = tcName;

	size_t found = tmp.find_first_not_of( _T(" ") );

	if( 0 != found && _string::npos != found )
	{
		tmp.erase( tmp.begin(), tmp.begin() + found );
	}

	found = tmp.find_last_not_of( _T(" ") );

	if( ( found + 1 ) < tmp.size() && _string::npos != found )
	{
		tmp.erase( tmp.begin() + found + 1 );
	}

	_tcsncpy_s( m_tcName, SIZEOFINTCHAR( m_tcName ), tmp.c_str(), SIZEOFINTCHAR( m_tcName ) - 1);
	return m_tcName;
}

LPCTSTR CDB_Product::SetFamilyID( LPCTSTR tcFamilyID )
{
	m_FamilyIDPtr = _NULL_IDPTR;
	Modified();
	return PurgeString( m_FamilyIDPtr.ID, tcFamilyID, SIZEOFINTCHAR( m_FamilyIDPtr.ID ) );
}

void CDB_Product::ApplyComment( _string *pstrComment )
{
	_string str = GetComment();

	if( false == str.empty() )
	{
		size_t found;
		found = pstrComment->find( str );

		// Verify if the comment already exist.
		if( _string::npos == found )
		{
			*pstrComment += str;
			*pstrComment += _T("\r\n");
		}
	}
}

#ifndef TACBX 
bool CDB_Product::VerifyOneCatExist()
{
	_string artNumber = GetBodyArtNum();

	// If the catalog exists in the folder return true.
	if( TASApp.GetDocDb().GetHTreeItemFromArticleNumber( artNumber ) )
	{
		return true;
	}

	// HYS-1057: if the document doesn't exists in the current language, search in default language "en"
	if( -1 != TASApp.GetDocDbEn().GetHTreeItemIndexFromArticleNumber( artNumber ) )
	{
		return true;
	}

	// In all other cases.
	return false;
}

#endif

double CDB_Product::GetSortingKey( CProductSortKey::CPSKMask *pclMask )
{
	CProductSortKey::CPSKMask clCPSKMask( CProductSortKey::PSKM_All );
	
	if( NULL == pclMask )
	{
		pclMask = &clCPSKMask;
	}
	
	double dKey;
	
	if( 0 != m_SortingKey.H || 0 != m_SortingKey.L )
	{
		CProductSortKey sKey( m_SortingKey );
		dKey = sKey.GetSortingKeyAsDouble( pclMask );
	}
	else
	{
		CProductSortKey sKey( this );
		dKey = sKey.GetSortingKeyAsDouble( pclMask );
	}
	
	return dKey;
}

void CDB_Product::SetSeriesID( LPCTSTR strSeriesID )
{
	wcscpy( m_SeriesIDPtr.ID, _T("") );

	if( _tcslen( strSeriesID ) > _ID_LENGTH )
	{
		ASSERT( 0 );
		return;
	}

	wcsncpy( m_SeriesIDPtr.ID, (LPCTSTR)strSeriesID, SIZEOFINTCHAR( m_SeriesIDPtr.ID ) - 1 );
}

void CDB_Product::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_Product *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_Product' object!") );
		}

		// Base class.
		CDB_HydroThing::Copy( (CDB_Product *)pclDestination );

		// Copy now what it is common to the "CDB_Product" class.
		CDB_Product *pclDestinationProduct = (CDB_Product *)pclDestination;

		pclDestinationProduct->SetArtNum( GetBodyArtNum() );
		pclDestinationProduct->SetName( GetName() );
		pclDestinationProduct->SetFamilyID( GetFamilyID() );
		pclDestinationProduct->SetVersionID( GetVersionID() );
		pclDestinationProduct->SetTypeID( GetTypeID() );
		pclDestinationProduct->SetPriorityLevel( GetPriorityLevel() );
		pclDestinationProduct->SetComment( GetComment() );
		pclDestinationProduct->SetProdPicID( GetProdPicID() );
		pclDestinationProduct->SetAccessGroupID( m_AccessGroupIDPtr.ID );
		pclDestinationProduct->SetPartOfaSet( m_ePartOfaSet );
		pclDestinationProduct->SetTableSetID( m_strTableSetID );
		pclDestinationProduct->SetPrice( pclDestinationProduct->GetPrice() );
		pclDestinationProduct->SetSortingKeyAsLL( GetSortingKeyAsLL( ) );
		pclDestinationProduct->SetProductUseFlag( GetProductUseFlag() );
		pclDestinationProduct->SetAccessTypeID( GetAccessTypeID() );
		pclDestinationProduct->SetAccessFamilyID( GetAccessFamilyID() );
		pclDestinationProduct->SetSeriesID( GetSeriesIDPtr().ID );
		pclDestinationProduct->SetBoolAttached( IsAttached() );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_Product::Copy' method with the object '%s'."), GetIDPtr().ID )
}

void CDB_Product::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_HydroThing::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( _T('\0') != *m_FamilyIDPtr.ID && 0 != _tcscmp( _NO_ID, m_FamilyIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_FamilyIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Family ID (%s) is defined but not found in the database."), m_FamilyIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("Family ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_FamilyIDPtr.ID );
			}
		}

		if( _T('\0') != *m_VersionIDPtr.ID && 0 != _tcscmp( _NO_ID, m_VersionIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_VersionIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Version ID (%s) is defined but not found in the database."), m_VersionIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("Version ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_VersionIDPtr.ID );
			}
		}

		if( _T('\0') != *m_TypeIDPtr.ID && 0 != _tcscmp( _NO_ID, m_TypeIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_TypeIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Type ID (%s) is defined but not found in the database."), m_TypeIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("Type ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_TypeIDPtr.ID );
			}
		}

		if( _T('\0') != *m_AccessGroupIDPtr.ID && 0 != _tcscmp( _NO_ID, m_AccessGroupIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_AccessGroupIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Accessory group ID (%s) is defined but not found in the database."), m_AccessGroupIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_RuledTable ) ) )
			{
				HYSELECT_THROW( _T("Accessory group ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_AccessGroupIDPtr.ID );
			}
		}

		if( _T('\0') != *m_strTableSetID.c_str() && 0 != _tcscmp( _NO_ID, m_strTableSetID.c_str() ) )
		{
			IDPtr = GetDB()->Get( m_strTableSetID.c_str() );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Table set ID (%s) is defined but not found in the database."), m_strTableSetID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CTableSet ) ) )
			{
				HYSELECT_THROW( _T("Table set  ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_strTableSetID );
			}
		}

		if( _T('\0') !=  *m_SeriesIDPtr.ID && 0 != _tcscmp( _NO_ID, m_SeriesIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_SeriesIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Series ID (%s) is defined but not found in the database."), m_SeriesIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CData ) ) )
			{
				HYSELECT_THROW( _T("Series ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_SeriesIDPtr.ID );
			}
		}

		if( _T('\0') != *m_AccessTypeIDPtr.ID && 0 != _tcscmp( _NO_ID, m_AccessTypeIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_AccessTypeIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Accessory type ID (%s) is defined but not found in the database."), m_AccessTypeIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("Accessory type ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_AccessTypeIDPtr.ID );
			}
		}

		if( _T('\0') != *m_AccessFamilyIDPtr.ID && 0 != _tcscmp( _NO_ID, m_AccessFamilyIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_AccessFamilyIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Accessory family ID (%s) is defined but not found in the database."), m_AccessFamilyIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("Accessory family ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_AccessFamilyIDPtr.ID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_Product::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

void CDB_Product::OnDatabaseDestroy()
{
	CDB_HydroThing::OnDatabaseDestroy();
}

#define CDB_PRODUCT_VERSION	 5
// Version 5: 2019-03-28: Merge CDB_Accessory and CDB_Product.
// Version 4: 2018-06-14: 'm_strTableSetID' variable added.
// Version 3: 2018-01-15: 'm_tcCatFileID' and 'm_tcQrsFileID' variables removed.
// Version 2: Price is now in CDB_Product (instead of 'CDB_TAProduct').
void CDB_Product::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_PRODUCT_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CDB_HydroThing::Write( outf );

	// Info.
	WriteString( outf, m_tcArtNum );
	WriteString( outf, m_tcName );
	WriteString( outf, m_FamilyIDPtr.ID );
	WriteString( outf, m_VersionIDPtr.ID );
	WriteString( outf, m_TypeIDPtr.ID );
	outf.write( (char *)&m_iPriorityLevel, sizeof( m_iPriorityLevel ) );
	WriteString( outf, m_strComment.c_str() );
	WriteString( outf, m_strProdPicID.c_str() );
	WriteString( outf, m_AccessGroupIDPtr.ID );
	outf.write( (char *)&m_ePartOfaSet, sizeof( m_ePartOfaSet ) );
	outf.write( (char *)&m_dPrice, sizeof( m_dPrice ) );

	// Version 4.
	WriteString( outf, m_strTableSetID.c_str() );

	// Version 5.
	outf.write( (char *)&m_iProductUseFlag, sizeof( m_iProductUseFlag ) );
	WriteString( outf, (LPCTSTR)m_SeriesIDPtr.ID );
	outf.write( (char *)&m_bAttached, sizeof( m_bAttached ) );
	WriteString( outf, m_AccessTypeIDPtr.ID );
	WriteString( outf, m_AccessFamilyIDPtr.ID );
}

bool CDB_Product::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_PRODUCT_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDB_HydroThing::Read( inpf ) )
	{
		return false;
	}

	// Info.
	if( false == ReadString( inpf, m_tcArtNum, sizeof( m_tcArtNum ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_tcName, sizeof( m_tcName ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_FamilyIDPtr.ID, sizeof( m_FamilyIDPtr.ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_VersionIDPtr.ID, sizeof( m_VersionIDPtr.ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_TypeIDPtr.ID, sizeof( m_TypeIDPtr.ID ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_iPriorityLevel, sizeof( m_iPriorityLevel ) );

	if( false == ReadString( inpf, m_strComment) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strProdPicID ) )
	{
		return false;
	}

	m_AccessGroupIDPtr = _NULL_IDPTR;

	if( false == ReadString( inpf, m_AccessGroupIDPtr.ID, sizeof( m_AccessGroupIDPtr.ID ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_ePartOfaSet, sizeof( m_ePartOfaSet ) );

	// Version 2.
	m_dPrice = ReadDouble( inpf );

	if( Version < 4 )
	{
		return true;
	}

	// Version 4.
	if( false == ReadString( inpf, m_strTableSetID ) )
	{
		return false;
	}

	if( Version < 5 )
	{
		return true;
	}

	// Version 5.
	inpf.read( (char *)&m_iProductUseFlag, sizeof( m_iProductUseFlag ) );

	if( false == ReadString( inpf, m_SeriesIDPtr.ID, sizeof( m_SeriesIDPtr.ID ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_bAttached, sizeof( m_bAttached ) );

	if( false == ReadString( inpf, m_AccessTypeIDPtr.ID, sizeof( m_AccessTypeIDPtr.ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_AccessFamilyIDPtr.ID, sizeof( m_AccessFamilyIDPtr.ID ) ) )
	{
		return false;
	}

	return true;
}

#ifndef TACBX 
#define PRODUCT_REFERENCE		_T("::Reference=")
#define PRODUCT_NAME			_T("::Name=")
#define PRODUCT_TYPEID			_T("::TypeID=")
#define PRODUCT_FAMILYID		_T("::FamilyID=")
#define PRODUCT_VERSIONID		_T("::VersionID=")            
#define PRODUCT_PRIORITYLEVEL	_T("::PriorityLevel=")
#define PRODUCT_COMMENT			_T("::Comment=")
#define PRODUCT_PRODIMGID		_T("::ProdImgID=")
#define PRODUCT_ACCESSGROUPID	_T("::AccessGroupID=")
#define PRODUCT_PARTOFASET		_T("::PartOfaSet=")
#define PRODUCT_TABLESETID		_T("::TableSetID=")
#define PRODUCT_PRICE			_T("::Price=")
#define PRODUCT_USE				_T("::ProductUseFlag=")
#define PRODUCT_ACC_SERIESID	_T("::AccessorySeriesID=")
#define PRODUCT_ACC_ISATTACHED	_T("::isAttached=")
#define PRODUCT_ACC_TYPEID	    _T("::AccTypeID=")
#define PRODUCT_ACC_FAMILYID	_T("::AccFamilyID=")

void CDB_Product::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int ipos = pStr->Find( CLASS( CDB_Product));
	
		if( pStr->Left(2) != _T("::") && ipos < 0 )
		{
			CDB_HydroThing::InterpretInheritedData( pStr );
		}
		else
		{
			if( ipos >= 0 )
			{
				pStr->Delete( ipos, _tcsclen( CLASS( CDB_Product ) ) );
			}

			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}
		
			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );
		
			if( pStr->Find( PRODUCT_REFERENCE ) > -1 )
			{
				if( _T('"') != strField.GetAt( 0 ) )
				{
					HYSELECT_THROW( _T("'CDB_Product::Reference' (%s) must start with \"."), strField );
				}
				else if( _T('"') != strField.GetAt( strField.GetLength() - 1 ) )
				{
					HYSELECT_THROW( _T("'CDB_Product::Reference' (%s) must end with \"."), strField );
				}

				strField = strField.Mid( 1, strField.GetLength() - 2 );
				SetArtNum( (LPCTSTR)strField );
			}
			else if( pStr->Find( PRODUCT_NAME ) > -1 )
			{
				if( _T('\"') == strField.GetAt( 0 ) )
				{
					strField.Delete( 0 );
				}

				if( _T('\"') == strField.GetAt( strField.GetLength() - 1 ) )
				{
					strField.Delete(strField.GetLength() - 1);
				}

				SetName( (LPCTSTR)strField );
			}
			else if( pStr->Find( PRODUCT_TYPEID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_Product::TypeID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetTypeID( (LPCTSTR)strField );
			}
			else if( pStr->Find(PRODUCT_FAMILYID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_Product::FamilyID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetFamilyID( (LPCTSTR)strField );
			}
			else if( pStr->Find(PRODUCT_VERSIONID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_Product::VersionID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetVersionID( (LPCTSTR)strField );
			}
			else if( pStr->Find(PRODUCT_PRIORITYLEVEL ) > -1 )
			{
				m_iPriorityLevel = _ttoi( (LPCTSTR)strField );

				if( m_iPriorityLevel <= 0 )
				{
					HYSELECT_THROW( _T("'CDB_Product::PriorityLevel' (%f) can't be lower or equal than 0."), m_iPriorityLevel );
				}
				else if( m_iPriorityLevel > 10 )
				{
					HYSELECT_THROW( _T("'CDB_Product::PriorityLevel' (%f) can't be higher than 10."), m_iPriorityLevel );
				}
			}
			else if( pStr->Find(PRODUCT_COMMENT ) > -1 )
			{
				if( _T('"') != strField.GetAt( 0 ) )
				{
					HYSELECT_THROW( _T("'CDB_Product::Comment' (%s) must start with \"."), strField );
				}
				else if( _T('"') != strField.GetAt( strField.GetLength() - 1 ) )
				{
					HYSELECT_THROW( _T("'CDB_Product::Comment' (%s) must end with \"."), strField );
				}

				strField = strField.Mid( 1, strField.GetLength() - 2 );
				SetComment( (LPCTSTR)strField );
			}
			else if( pStr->Find(PRODUCT_PRODIMGID ) > -1 )
			{
				if( _T('"') != strField.GetAt( 0 ) )
				{
					HYSELECT_THROW( _T("'CDB_Product::ProdImgID' (%s) must start with \"."), strField );
				}
				else if( _T('"') != strField.GetAt( strField.GetLength() - 1 ) )
				{
					HYSELECT_THROW( _T("'CDB_Product::ProdImgID' (%s) must end with \"."), strField );
				}

				strField = strField.Mid( 1, strField.GetLength() - 2 );
			
				// TODO
				// exclude testing of picture existence for pressurization product
				// No time to implement picture in DLL 
				bool btest = ( NULL != dynamic_cast<CDB_Vessel *>( this ) ) || ( NULL != dynamic_cast<CDB_TecBox *>( this ) );

				// Verify the implemented DescriptorID exist in the DLL.
				if( _NO_ID != strField && false == btest )
				{
					if( false == TASApp.VerifyPicExist( strField ) )
					{
						HYSELECT_THROW( _T("'CDB_Product::ProdImgID' (%s) doesn't exist in the DLL."), strField );
					}
				}
				else
				{
					SetProdPicID( _T("") );
				}

				SetProdPicID( (_string)strField );
			}
			else if( pStr->Find(PRODUCT_ACCESSGROUPID ) > -1 )
			{
				SetAccessGroupID( (LPCTSTR)strField );
			}
			else if( pStr->Find(PRODUCT_PARTOFASET ) > -1 )
			{
				int iPartOfASet = ReadEnum( (LPCTSTR)strField );

				if( iPartOfASet != ePartOfaSetNo && iPartOfASet != ePartOfaSetYes && iPartOfASet != ePartOfaSetYesBreakOk && iPartOfASet != ePartOfaSetYesBreakOnMsg )
				{
					HYSELECT_THROW( _T("'CDB_Product::PartOfaSet' must be one of these values: '#ePartOfaSetNo', '#ePartOfaSetYes', 'ePartOfaSetYesBreakOk' or '#ePartOfaSetYesBreakOnMsg'.") );
				}

				m_ePartOfaSet = (ePartOfaSet)iPartOfASet;
			}
			else if( pStr->Find(PRODUCT_TABLESETID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_Product::TableSetID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetTableSetID( (LPCTSTR)strField );
			}
			else if( pStr->Find( PRODUCT_PRICE  ) > -1 )
			{
				m_dPrice = _wtof( (LPCTSTR)strField );

				if( m_dPrice < 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_Product::Price' (%f) can't be lower than 0."), m_dPrice );
				}
			}
			else if( pStr->Find( PRODUCT_USE ) > -1 )
			{
				m_iProductUseFlag = ReadEnum( (LPCTSTR)strField );

				if( m_iProductUseFlag != eProdUse::eProduct && m_iProductUseFlag != eProdUse::eAccessory && m_iProductUseFlag != eProdUse::eBoth )
				{
					HYSELECT_THROW( _T("'CDB_Product::ProductUseFlag' must be one of these values: '#eProduct', '#eAccessory' or '#eBoth'.") );
				}
			}
			else if( pStr->Find( PRODUCT_ACC_SERIESID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_Product::AccessorySeriesID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetSeriesID( (LPCTSTR)strField );
			}
			else if( pStr->Find( PRODUCT_ACC_ISATTACHED ) > -1 )
			{
				strField = strField.Mid( 1, strField.GetLength() - 2 );
				m_bAttached = _ttoi( strField ) ? true : false;
			}
			else if( pStr->Find( PRODUCT_ACC_TYPEID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_Product::AccTypeID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetAccessTypeID( (LPCTSTR)strField );
			}
			else if( pStr->Find( PRODUCT_ACC_FAMILYID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_Product::AccFamilyID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetAccessFamilyID( (LPCTSTR)strField );
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Product::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_Product::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_Product format
		// line 0 : open curve bracket and call base class.
		// line 1 : Reference between double quotes
		// line 2 : Name between double quotes
		// line 3 : Type ID
		// line 4 : Family ID
		// line 5 : Version ID
		// line 6 : PriorityLevel
		// line 7 : comments
		// line 8 : Product image ID
		// line 9 : Accessories group IDPTR
		// line 10: Flag part of a set
		// line 11: Table set ID
		// line 12: Price
		// line 13: ProductUseFlag
		// line 14: AccessorySeriesID
		// line 15: isAttached
		// line 16: AccTypeID
		// line 17: AccFamilyID
		// line 18: close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}
		
			( (CDB_Product *)idptr.MP )->Copy( this );
		
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				CDB_Product::InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_HydroThing::ReadText( inpf, pusLineCount );
		
			CStringArray TxtHdr;
			TxtHdr.Add( PRODUCT_REFERENCE );
			TxtHdr.Add( PRODUCT_NAME );
			TxtHdr.Add( PRODUCT_TYPEID );
			TxtHdr.Add( PRODUCT_FAMILYID );
			TxtHdr.Add( PRODUCT_VERSIONID );
			TxtHdr.Add( PRODUCT_PRIORITYLEVEL );
			TxtHdr.Add( PRODUCT_COMMENT );
			TxtHdr.Add( PRODUCT_PRODIMGID );
			TxtHdr.Add( PRODUCT_ACCESSGROUPID );
			TxtHdr.Add( PRODUCT_PARTOFASET );
			TxtHdr.Add( PRODUCT_TABLESETID );
			TxtHdr.Add( PRODUCT_PRICE );
			TxtHdr.Add( PRODUCT_USE );
			TxtHdr.Add( PRODUCT_ACC_SERIESID );
			TxtHdr.Add( PRODUCT_ACC_ISATTACHED );
			TxtHdr.Add( PRODUCT_ACC_TYPEID );
			TxtHdr.Add( PRODUCT_ACC_FAMILYID );

			for( int i = 0; i < TxtHdr.GetSize(); i++ )
			{
				ptcLine = ReadTextLine( inpf, pusLineCount );

				CString str = TxtHdr[i] + CString( ptcLine );
				CDB_Product::InterpretInheritedData( &str );
			}
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Product::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_Product::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str, str1, str2;

	// Write object header.
	if( true == IsClass( CLASS( CDB_Product ) ) )
	{
		CData::WriteText( outf, strTab );
	}

	// Opening bracket.
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");
	CDB_HydroThing::WriteText( outf, strTab );

	// Data
	// ArtNum.
	WriteFormatedStringW( outf, m_tcArtNum, strTab, true );

	// Name.
	WriteFormatedStringW( outf, m_tcName, strTab, true );

	// Type.
	WriteFormatedStringW( outf, m_TypeIDPtr.ID, strTab );

	// Family.
	WriteFormatedStringW( outf, m_FamilyIDPtr.ID, strTab );

	// Version.
	WriteFormatedStringW( outf, m_VersionIDPtr.ID, strTab );

	// PriorityLevel.
	WriteFormatedStringW( outf, WriteDouble(m_iPriorityLevel, 2, 1), strTab );

	// Comment.
	WriteFormatedStringW( outf, m_strComment.c_str(), strTab, true );

	// m_ProdImgID.
	WriteFormatedStringW( outf, m_strProdPicID.c_str(), strTab, true );

	WriteFormatedStringW( outf, m_AccessGroupIDPtr.ID, strTab );

	WriteFormatedStringW( outf, WriteDouble( m_ePartOfaSet, 2, 1 ), strTab );

	// m_strTableSetID.
	WriteFormatedStringW( outf, m_strTableSetID.c_str(), strTab, true );

	// Price.
	WriteFormatedStringW( outf, WriteDouble( m_dPrice, 2, 1 ), strTab );

	// HYS-1018
	WriteFormatedStringW( outf, WriteDouble( m_iProductUseFlag, 2, 1 ), strTab );
	WriteFormatedStringW( outf, m_SeriesIDPtr.ID, strTab );
	str1 = ( true == m_bAttached ) ? _T("1" ) : _T( "0");
	WriteFormatedStringW( outf, str1, strTab );

	// Type.
	WriteFormatedStringW( outf, m_AccessTypeIDPtr.ID, strTab );

	// Family.
	WriteFormatedStringW( outf, m_AccessFamilyIDPtr.ID, strTab );
	// Closing bracket..
	strTab.Delete(0); // Delete one \t
	str.Format(_T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}

CData::CheckFilterReturnValue CDB_Product::CheckFilter( CFilterTab *pclFilter, CString strFilter )
{
	try
	{
		//	Filter string
		//  CDB_ClassName;TABLE;ID;EDIT;FAMILY;VERSION;Availability;Mask & Value;Priority
		//	Field 0			1	2	3	4		5		6	        7		     8

		if( true == strFilter.IsEmpty() )
		{
			HYSELECT_THROW( _T("Filter line can't be empty.") );
		}

		int iFieldNumber = pclFilter->GetNumberOfFields( strFilter );
		
		if( 9 != iFieldNumber )
		{
			HYSELECT_THROW( _T("Number of fields (%i) must be 9."), iFieldNumber );
		}

		// Family.
		CString str = pclFilter->GetField( 4, strFilter );
		
		if( false == str.IsEmpty() )
		{
			if( 0 != _tcscmp( (LPCTSTR)str, GetFamilyIDPtr().ID ) )
			{
				return CData::CFRV_FilterNotApplied;
			}
		}

		// Version.
		str = pclFilter->GetNextField( strFilter );
		
		if( false == str.IsEmpty() )
		{
			if( 0 != _tcscmp( (LPCTSTR)str, GetVersionIDPtr().ID ) )
			{
				return CData::CFRV_FilterNotApplied;
			}
		}

		// All Field checked do modifications.
		// Availability.
		str = pclFilter->GetNextField( strFilter );
		
		if( false == str.IsEmpty() )
		{
			if( _T('0') == str[0] )
			{
				SetAvailable( 0 );
			}

			if( _T('1') == str[0] )
			{
				SetAvailable( 1 );
			}

			if( _T('0') == str[2] )
			{
				SetHidden( 0 );
			}

			if( _T('1') == str[2] )
			{
				SetHidden( 1 );
			}
		}

		// Some flags with a mask					// Mask and value integers
		// The first integer contains mask bits, the second contains the values, 
		// mask integer and value integer are separated by a comma.
		// Both are coded in Hexadecimal like 0x....
		// Only value bit with a mask bit set to 1 will be taken into account 
		str = pclFilter->GetNextField( strFilter );

		if( false == str.IsEmpty() )
		{
			// Split Mask and Value into two integers.
			CString strMask = str.Left( str.Find( _T(',') ) );
			CString strVal = str.Right( str.GetLength() - ( str.Find( _T(',') ) + 1 ) );

			unsigned int uiMask, uiNVal;
			_stscanf_s( (LPCTSTR)strMask, _T("%x"), &uiMask );
			_stscanf_s( (LPCTSTR)strVal, _T("%x"), &uiNVal );

			// Set or reset non masked bit.
			unsigned int uiInt1 = GetInt1();

			//          set bits				reset bits
			uiInt1 = ( uiInt1 | ( uiMask & uiNVal ) ) & ~( uiMask & ~uiNVal );
			SetInt1( uiInt1 );
		}

		// Priority.
		str = pclFilter->GetNextField( strFilter );
		
		if( false == str.IsEmpty() )
		{
			int priority = _tcstol( (LPCTSTR)str, 0, 10 );
			SetPriorityLevel( priority );
		}

		return CData::CFRV_FilterApplied;
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Product::CheckFilter' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		clHySelectException.AddMessage( _T("  -> Filter: '%s'."), __LINE__, __FILE__, strFilter );
		throw;
	}
}

void CDB_Product::DeleteArticle()
{
	CData::DeleteArticle();

 	CString strCleaned = DeleteArticleNumber( CString( m_tcArtNum ) );
 	wcscpy( m_tcArtNum, (LPCTSTR)strCleaned );
}

#endif 

#ifndef TACBX
///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_DpSensor
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_DpSensor )

CDB_DpSensor::CDB_DpSensor( CDataBase *pDataBase, LPCTSTR ptcStrID )
	: CDB_Product( pDataBase, ptcStrID )
{
	m_dMinMeasurableDp = 0.0;
	m_dMaxMeasurableDp = 0.0;
	m_dBurstPressure = 0.0;
	m_OutputSignals.RemoveAll();
}

CString CDB_DpSensor::GetFullName()
{
	CString strFullName( _T("") );

	CString strMinMeasurableDp = WriteCUDouble( _U_DIFFPRESS, m_dMinMeasurableDp );
	CString strMaxMeasurableDp = WriteCUDouble( _U_DIFFPRESS, m_dMaxMeasurableDp );
	
	TCHAR tcUnitName[_MAXCHARS];
	CUnitDatabase *pclUnitDB = CDimValue::AccessUDB();
	GetNameOf( pclUnitDB->GetDefaultUnit( _U_DIFFPRESS ), tcUnitName );

	strFullName.Format( _T("%s [%s-%s%s]"), GetName(), (LPCTSTR)strMinMeasurableDp, (LPCTSTR)strMaxMeasurableDp, tcUnitName );
	return strFullName;
}

_string CDB_DpSensor::GetFormatedDplRange( bool bWithUnit )
{
	_string strDplmin = (-1.0 == GetMinMeasurableDp()) ? L"x" : WriteCUDouble( _U_DIFFPRESS, GetMinMeasurableDp() );
	_string strDplmax = (-1.0 == GetMaxMeasurableDp()) ? L"x" : WriteCUDouble( _U_DIFFPRESS, GetMaxMeasurableDp() );

	_string str = _T( "[" ) + strDplmin + _T( "-" ) + strDplmax + _T( "]" );

	if( true == bWithUnit )
	{
		CUnitDatabase* pUnitDB = CDimValue::AccessUDB();
		str += _T( " " ) + pUnitDB->GetNameOfDefaultUnit( _U_DIFFPRESS );
	}

	return str;
}

bool CDB_DpSensor::IsOutputSignalAvailable( IDPTR IDPtrOutput )
{
	for (int i = 0; i < (int)GetNumOfOutputSignalsIDptr(); i++)
	{
		if( GetOutputSignalsIDPtr(i).MP == IDPtrOutput.MP ) 
		{
			return true;
		}
	}
	
	return false;
}

IDPTR CDB_DpSensor::GetOutputSignalsIDPtr( unsigned int uiIndex )
{
	if( uiIndex >= GetNumOfOutputSignalsIDptr() )
	{
		ASSERTA_RETURN( _NULL_IDPTR );
	}

	IDPTR idptr = m_OutputSignals.GetAt( uiIndex );
	idptr.DB = GetDB();
	Extend( &idptr );
	m_OutputSignals.SetAt( uiIndex, idptr );
	return idptr;
}

CString CDB_DpSensor::GetOutputSignalsStr( CString strSeparator )
{
	CArray<IDPTR>* pArray;
	int iCount;

	pArray = &m_OutputSignals;
	iCount = GetNumOfOutputSignalsIDptr();

	// SIG_ON-OFF \ SIG_3POINT \ SIG_0-10V \ SIG_2-10V \ SIG_0-20mA \ SIG_4-20mA \ SIG_KNX \ SIG_MODBUS_RTU \ SIG_BACNET_MSTP
	// SIG_MODBUS_TCP \ SIG_BACNET_IP
	CString str, str1, str2, strOut;
	std::map< CString, short > mapSignalTypeCount;

	for( int i = 0; i < iCount; i++ )
	{
		CString IDstr;

		IDstr = GetOutputSignalsIDPtr( i ).ID;

		if( IDstr != _T( "NO_ID" ) )
		{
			mapSignalTypeCount[IDstr] = i;
		}
	}

	// If the signal is not define, return "-".
	if( 0 == (int)mapSignalTypeCount.size() )
	{
		return _T( "-" );
	}

	strOut.Empty();

	// SIG_ON-OFF.
	if( mapSignalTypeCount.count( CString( _T( "SIG_ON-OFF" ) ) ) > 0 )
	{
		strOut = ((CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T( "SIG_ON-OFF" ) )] ).MP)->GetString();
	}

	// SIG_3POINT.
	str.Empty();

	if( mapSignalTypeCount.count( CString( _T( "SIG_3POINT" ) ) ) > 0 )
	{
		str = ((CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T( "SIG_3POINT" ) )] ).MP)->GetString();
	}

	if( false == strOut.IsEmpty() && false == str.IsEmpty() )
	{
		strOut += strSeparator;
	}

	strOut += str;

	// SIG_0-10V and SIG_2-10V.
	// HYS-905: Add 0-5V 10-2V 5-0V 10-2V 10-0V 10-5V and 5-10V signals
	str.Empty();

	if( mapSignalTypeCount.count( CString( _T( "SIG_0-10V" ) ) ) > 0 )
	{
		str = ((CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T( "SIG_0-10V" ) )] ).MP)->GetString();

		if( mapSignalTypeCount.count( CString( _T( "SIG_2-10V" ) ) ) > 0 )
		{
			str1 = ((CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T( "SIG_2-10V" ) )] ).MP)->GetString();
			str2.Format( _T( "(%C)" ), str1.GetAt( 0 ) );
			str.Replace( _T( "%1" ), str2 );
		}
		else
		{
			str.Replace( _T( "%1" ), _T( "" ) );
		}
	}
	else
	{
		if( mapSignalTypeCount.count( CString( _T( "SIG_2-10V" ) ) ) > 0 )
		{
			str = ((CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T( "SIG_2-10V" ) )] ).MP)->GetString();
		}
		if( mapSignalTypeCount.count( CString( _T( "SIG_10-2V" ) ) ) > 0 )
		{
			str = ((CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T( "SIG_10-2V" ) )] ).MP)->GetString();
		}
		if( mapSignalTypeCount.count( CString( _T( "SIG_10-0V" ) ) ) > 0 )
		{
			str = ((CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T( "SIG_10-0V" ) )] ).MP)->GetString();
		}
		if( mapSignalTypeCount.count( CString( _T( "SIG_5-10V" ) ) ) > 0 )
		{
			str = ((CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T( "SIG_5-10V" ) )] ).MP)->GetString();
		}
		if( mapSignalTypeCount.count( CString( _T( "SIG_10-5V" ) ) ) > 0 )
		{
			str = ((CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T( "SIG_10-5V" ) )] ).MP)->GetString();
		}
		if( mapSignalTypeCount.count( CString( _T( "SIG_5-0V" ) ) ) > 0 )
		{
			str = ((CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T( "SIG_5-0V" ) )] ).MP)->GetString();
		}
		if( mapSignalTypeCount.count( CString( _T( "SIG_0-5V" ) ) ) > 0 )
		{
			str = ((CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T( "SIG_0-5V" ) )] ).MP)->GetString();
		}
	}

	if( false == strOut.IsEmpty() && false == str.IsEmpty() )
	{
		strOut += strSeparator;
	}

	strOut += str;

	// SIG_0-20mA and SIG_4-20mA.
	// HYS-905: Add  20-4mA 
	str.Empty();

	if( mapSignalTypeCount.count( CString( _T( "SIG_0-20mA" ) ) ) > 0 )
	{
		str = ((CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T( "SIG_0-20mA" ) )] ).MP)->GetString();

		if( mapSignalTypeCount.count( CString( _T( "SIG_4-20mA" ) ) ) > 0 )
		{
			str1 = ((CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T( "SIG_4-20mA" ) )] ).MP)->GetString();
			str2.Format( _T( "(%C)" ), str1.GetAt( 0 ) );
			str.Replace( _T( "%1" ), str2 );
		}
		else
		{
			str.Replace( _T( "%1" ), _T( "" ) );
		}
	}
	else
	{
		if( mapSignalTypeCount.count( CString( _T( "SIG_4-20mA" ) ) ) > 0 )
		{
			str = ((CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T( "SIG_4-20mA" ) )] ).MP)->GetString();
		}
		if( mapSignalTypeCount.count( CString( _T( "SIG_20-4mA" ) ) ) > 0 )
		{
			str = ((CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T( "SIG_20-4mA" ) )] ).MP)->GetString();
		}
	}

	if( false == strOut.IsEmpty() && false == str.IsEmpty() )
	{
		strOut += strSeparator;
	}

	strOut += str;

	// SIG_KNX
	str.Empty();

	if( mapSignalTypeCount.count( CString( _T( "SIG_KNX" ) ) ) > 0 )
	{
		str = ((CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T( "SIG_KNX" ) )] ).MP)->GetString();
	}

	if( false == strOut.IsEmpty() && false == str.IsEmpty() )
	{
		strOut += strSeparator;
	}

	strOut += str;

	// SIG_MODBUS_RTU
	str.Empty();

	if( mapSignalTypeCount.count( CString( _T( "SIG_MODBUS_RTU" ) ) ) > 0 )
	{
		str = ((CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T( "SIG_MODBUS_RTU" ) )] ).MP)->GetString();
	}

	if( false == strOut.IsEmpty() && false == str.IsEmpty() )
	{
		strOut += strSeparator;
	}

	strOut += str;

	// SIG_BACNET_MSTP
	str.Empty();

	if( mapSignalTypeCount.count( CString( _T( "SIG_BACNET_MSTP" ) ) ) > 0 )
	{
		str = ((CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T( "SIG_BACNET_MSTP" ) )] ).MP)->GetString();
	}

	if( false == strOut.IsEmpty() && false == str.IsEmpty() )
	{
		strOut += strSeparator;
	}

	strOut += str;

	// SIG_MODBUS_TCP
	str.Empty();

	if( mapSignalTypeCount.count( CString( _T( "SIG_MODBUS_TCP" ) ) ) > 0 )
	{
		str = ((CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T( "SIG_MODBUS_TCP" ) )] ).MP)->GetString();
	}

	if( false == strOut.IsEmpty() && false == str.IsEmpty() )
	{
		strOut += strSeparator;
	}

	strOut += str;

	// SIG_BACNET_IP
	str.Empty();

	if( mapSignalTypeCount.count( CString( _T( "SIG_BACNET_IP" ) ) ) > 0 )
	{
		str = ((CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T( "SIG_BACNET_IP" ) )] ).MP)->GetString();
	}

	if( false == strOut.IsEmpty() && false == str.IsEmpty() )
	{
		strOut += strSeparator;
	}

	strOut += str;

	return strOut;
}

void CDB_DpSensor::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_DpSensor *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_DpSensor' object!") );
		}

		// Base class.
		CDB_Product::Copy( pclDestination );

		// Copy now what it is common to the "CDB_DpSensor" class.
		CDB_DpSensor *pDestinationDpSensor = (CDB_DpSensor *)pclDestination;

		pDestinationDpSensor->SetMinMeasurableDp( m_dMinMeasurableDp );
		pDestinationDpSensor->SetMaxMeasurableDp( m_dMaxMeasurableDp );
		pDestinationDpSensor->SetBurstPressure( m_dBurstPressure );
		pDestinationDpSensor->SetOutputSignals( m_OutputSignals );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_DpSensor::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_DPSENSOR_VERSION	 1
// Version 1: HYS-1941
void CDB_DpSensor::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_DPSENSOR_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CDB_Product::Write( outf );

	// Info.
	outf.write( (char *)&m_dMinMeasurableDp, sizeof( m_dMinMeasurableDp ) );
	outf.write( (char *)&m_dMaxMeasurableDp, sizeof( m_dMaxMeasurableDp ) );
	outf.write( (char *)&m_dBurstPressure, sizeof( m_dBurstPressure ) );

	// Output signals.
	int iCount = m_OutputSignals.GetCount();
	outf.write( (char *)&iCount, sizeof( iCount ) );

	for( int i = 0; i < iCount; i++ )
	{
		IDPTR idptr = m_OutputSignals.GetAt( i );
		WriteString( outf, idptr.ID );
	}
}

bool CDB_DpSensor::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_DPSENSOR_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDB_Product::Read( inpf ) )
	{
		return false;
	}

	// Info.
	m_dMinMeasurableDp = ReadDouble( inpf );
	m_dMaxMeasurableDp = ReadDouble( inpf );
	m_dBurstPressure = ReadDouble( inpf );

	// Output signals.
	int iCount = 0;
	inpf.read( (char *)&iCount, sizeof( iCount ) );
	m_OutputSignals.SetSize( iCount );

	for( int i = 0; i < iCount; i++ )
	{
		IDPTR idptr = _NULL_IDPTR;

		if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
		{
			return false;
		}

		idptr.DB = GetDB();
		m_OutputSignals.SetAt( i, idptr );
	}

	return true;
}

void CDB_DpSensor::SetOutputSignals( CArray<IDPTR> &arOutputSignals )
{
	m_OutputSignals.RemoveAll();

	for( int i = 0; i < arOutputSignals.GetCount(); i++ )
	{
		IDPTR IDPtr;
		IDPtr.SetID( arOutputSignals.GetAt( i ).ID );
		m_OutputSignals.Add( IDPtr );
	}
}

void CDB_DpSensor::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_Product::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( m_OutputSignals.GetCount() > 0 )
		{
			for( int i = 0; i < m_OutputSignals.GetCount(); i++ )
			{
				if( _T('\0') != *m_OutputSignals[i].ID && 0 != _tcscmp( _NO_ID, m_OutputSignals[i].ID ) )
				{
					IDPtr = GetDB()->Get( m_OutputSignals[i].ID );

					if( NULL == IDPtr.MP )
					{
						HYSELECT_THROW( _T("Output signal ID (%s) is defined but not found in the database."), m_OutputSignals[i].ID );
					}

					if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
					{
						HYSELECT_THROW( _T("Output signal ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_OutputSignals[i].ID );
					}
				}
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_DpSensor::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

#define DPSENSOR_MINMEASURABLEDP	_T("::MinMeasurableDp=")
#define DPSENSOR_MAXMEASURABLEDP	_T("::MaxMeasurableDp=")
#define DPSENSOR_BURSTPRESSURE		_T("::BurstPressure=")
#define DPSENSOR_OUTPUTSIGNALS		_T("::OutputSignals=")

void CDB_DpSensor::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( CLASS( CDB_DpSensor ) );

		if( pStr->Left(2) != _T("::") && iPos < 0 )
		{
			CDB_Product::InterpretInheritedData( pStr );
		}
		else
		{
			if( iPos >= 0 )
			{
				pStr->Delete( iPos, _tcsclen( CLASS( CDB_DpSensor ) ) );
			}

			int iEq = pStr->Find( _T("=") );

			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( DPSENSOR_MINMEASURABLEDP ) > -1 )
			{
				m_dMinMeasurableDp = _wtof( (LPCTSTR)strField );

				if( m_dMinMeasurableDp < 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_DpSensor::MinMeasurableDp' (%f) can't be lower than 0."), m_dMinMeasurableDp );
				}
			}
			else if( pStr->Find( DPSENSOR_MAXMEASURABLEDP ) > -1 )
			{
				m_dMaxMeasurableDp = _wtof( (LPCTSTR)strField );

				if( m_dMaxMeasurableDp < 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_DpSensor::MaxMeasurableDp' (%f) can't be lower than 0."), m_dMaxMeasurableDp );
				}
			}
			else if( pStr->Find( DPSENSOR_BURSTPRESSURE ) > -1 )
			{
				m_dBurstPressure = _wtof( (LPCTSTR)strField );

				if( m_dBurstPressure < 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_DpSensor::BurstPressure' (%f) can't be lower than 0."), m_dBurstPressure );
				}
			}
			else if( pStr->Find( DPSENSOR_OUTPUTSIGNALS ) > -1 )
			{
				ParseIDList( &m_OutputSignals, strField );
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_DpSensor::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_DpSensor::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_DpSensor format
		// line 0 : open curve bracket and call base class.
		// line 1 : Minimum differential pressure that the instrument can read.
		// line 2 : Maximum differential pressure that the instrument can read.
		// line 3 : List of accepted output control signals separated by '\'.
		// line 4: close curve bracket.

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_DpSensor *)idptr.MP )->Copy( this );

			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );

			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				CDB_DpSensor::InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_Product::ReadText( inpf, pusLineCount );

			CStringArray TxtHdr;
			TxtHdr.Add( DPSENSOR_MINMEASURABLEDP );
			TxtHdr.Add( DPSENSOR_MAXMEASURABLEDP );
			TxtHdr.Add( DPSENSOR_BURSTPRESSURE );
			TxtHdr.Add( DPSENSOR_OUTPUTSIGNALS );

			for( int i = 0; i < TxtHdr.GetSize(); i++ )
			{
				ptcLine = ReadTextLine( inpf, pusLineCount );

				CString str = TxtHdr[i] + CString( ptcLine );
				CDB_DpSensor::InterpretInheritedData( &str );
			}
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_DpSensor::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_DpSensor::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str;

	// Write object header.
	if( true == IsClass( CLASS( CDB_DpSensor ) ) )
	{
		CData::WriteText( outf, strTab );
	}

	// Opening bracket.
	str.Format( _T("\r\n%s{"), (LPCTSTR)strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");
	CDB_Product::WriteText( outf, strTab );

	// Data
	// Minimum differential pressure that the instrument can read.
	WriteFormatedStringW( outf, WriteDouble( m_dMinMeasurableDp, 2, 1 ), strTab );

	// Maximum differential pressure that the instrument can read.
	WriteFormatedStringW( outf, WriteDouble( m_dMaxMeasurableDp, 2, 1 ), strTab );

	// Maximum burst pressure.
	WriteFormatedStringW( outf, WriteDouble( m_dBurstPressure, 2, 1 ), strTab );

	// Output signals.
	CString str1 = _T("");
	int iNumber = m_OutputSignals.GetCount();

	for( int i = 0; i < iNumber;i++ )
	{
		if( i != 0 )
		{
			str1 += _T(" \\ ");
		}

		str1 += m_OutputSignals.GetAt(i).ID;
	}

	if( (INT_PTR)0 == iNumber )
	{
		str1 = _T("NO_ID");
	}

	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	// Closing bracket..
	strTab.Delete(0); // Delete one \t
	str.Format(_T("\r\n%s}"), (LPCTSTR)strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}
#endif 

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_TAProduct
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_TAProduct)	

CDB_TAProduct::CDB_TAProduct( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_Product( pDataBase, ID )
{
	m_SizeIDPtr = _NULL_IDPTR;				// corresponding valve size IDPTR.
	m_ConnectIDPtr = _NULL_IDPTR;			// Connection (inlet/pipe side) IDPTR.
	m_tcConnTabID[0] = _T('\0');				// Connection table ID, can be NO_ID.
	m_tcConn2ID[0] = _T('\0');					// Connection outlet/body side ID, can be NO_ID.
	m_tcCBIType[0] = _T('\0');
	m_tcCBISize[0] = _T('\0');
	m_tcCBISizeInch[0] = _T('\0');
	m_iCBICompatibilityIndex = 0;			// Compatibility index.
	m_tcCBIVersion[0] = _T('\0');				// CBI version.
	m_dDpmax = 0.0;							// maximum Dp.
	m_uMeasPt = 0 ;							// Measuring points.
	m_uMeasurableData = 0;					// Measurable data.
	m_InletSizeIDPtr.Clear();				// Identifier of the inlet size ID.
	m_OutletSizeIDPtr.Clear();				// Identifier of the outlet size ID.
}

const IDPTR &CDB_TAProduct::GetBodyMaterialIDPtr()
{
	m_BodyMaterialIDPtr.DB = GetDB();
	Extend( &m_BodyMaterialIDPtr );
	return m_BodyMaterialIDPtr;
}

LPCTSTR CDB_TAProduct::GetBodyMaterial()
{
	// Call 'GetBodyMaterialIDPtr' to force 'Extend' if it is not already done.
	IDPTR BodyMaterialIDPtr = GetBodyMaterialIDPtr();

	if( NULL != BodyMaterialIDPtr.MP )
	{
		CDB_StringID *pStr = (CDB_StringID *)( BodyMaterialIDPtr.MP );
		return pStr->GetString();
	}
	else
	{
		return _T("");
	}
}

const IDPTR &CDB_TAProduct::GetSizeIDPtr() 
{
	m_SizeIDPtr.DB = GetDB();
	Extend( &m_SizeIDPtr );
	return m_SizeIDPtr;
}

LPCTSTR CDB_TAProduct::GetSize()
{
	// Call 'GetSizeIDPtr' to force 'Extend' if it is not already done.
	IDPTR SizeIDPtr = GetSizeIDPtr();

	if( NULL != SizeIDPtr.MP )
	{
		CDB_StringID *pStr = (CDB_StringID *)( SizeIDPtr.MP );
		return pStr->GetString();
	}
	else
	{
		return _T("");
	}
}

int CDB_TAProduct::GetSizeKey()
{
	// Call 'GetSizeIDPtr' to force 'Extend' if it is not already done.
	IDPTR SizeIDPtr = GetSizeIDPtr();

	if( NULL != SizeIDPtr.MP )
	{
		CDB_StringID *pStr = (CDB_StringID *)( SizeIDPtr.MP );
		return _ttoi( pStr->GetIDstr() );
	}
	else
	{
		return -1;
	}
}

const IDPTR &CDB_TAProduct::GetConnectIDPtr()
{
	m_ConnectIDPtr.DB = GetDB();
	Extend( &m_ConnectIDPtr );

	if( true == IsConnTabUsed() )		// Reference to a component
	{
		return ( (CDB_Component *)m_ConnectIDPtr.MP )->GetConnectIDPtr();
	}
	else
	{
		return m_ConnectIDPtr;
	}
}

LPCTSTR CDB_TAProduct::GetConnect()
{
	// Call 'GetConnectIDPtr' to force 'Extend' if it is not already done.
	IDPTR ConnectIDPtr = GetConnectIDPtr();

	if( NULL != ConnectIDPtr.MP )
	{
		CDB_StringID *pStr = (CDB_StringID *)( ConnectIDPtr.MP );
		return pStr->GetString();
	}
	else
	{
		return _T("");
	}
}

const IDPTR &CDB_TAProduct::GetConnTabIDPtr() 
{
	if( _T('\0') == *m_tcConnTabID || 0 == _tcscmp( _NO_ID, m_tcConnTabID ) )
	{
		return GetDB()->Get( _T("") );
	}
	else
	{
		return GetDB()->Get( m_tcConnTabID );
	}
}	

const IDPTR &CDB_TAProduct::GetConn2IDPtr()
{
	if( 0 == _tcscmp( _NO_ID, m_tcConn2ID ) )
	{
		return GetDB()->Get( _T("") );
	}
	else
	{
		return GetDB()->Get( m_tcConn2ID );
	}
}

LPCTSTR CDB_TAProduct::GetConnect2()
{
	// Call 'GetConn2IDPtr' to force 'Extend' if it is not already done.
	IDPTR Connect2IDPtr = GetConn2IDPtr();

	if( NULL != Connect2IDPtr.MP )
	{
		CDB_StringID *pStr = (CDB_StringID *)( Connect2IDPtr.MP );
		return pStr->GetString();
	}
	else
	{
		return _T("");
	}
}

LPCTSTR CDB_TAProduct::GetArtNum( bool fWithoutConnection )
{
	// If there is no component (no reference to connection)...
	if( false == IsConnTabUsed() || true == fWithoutConnection )
	{
		return GetBodyArtNum();
	}

	// Otherwise article number is composed of a body + Inlet + Outlet

	// Check if product is already composed.
	CDB_Component *pclComponent = dynamic_cast<CDB_Component *>(GetDB()->Get( m_ConnectIDPtr.ID).MP);

	if( NULL == pclComponent )
	{
		return GetBodyArtNum();
	}

	_string TestStr;
	static _string str;
	str.erase();
	str = _string(GetBodyArtNum()) + _T("&");
	TestStr = str;

	if( 0 == _tcscmp( m_tcConn2ID, _NO_ID ) )
	{
		str += _string( pclComponent->GetArtNum() );
	}
	else
	{
		if( 0 == _tcscmp( m_tcConn2ID, m_ConnectIDPtr.ID ) )
		{
			str += _string( _T("2*") ) + _string( pclComponent->GetArtNum() );
		}
		else
		{
			str += _string( pclComponent->GetArtNum() ) + _T("&") + _string( ( (CDB_Component *)GetDB()->Get( m_tcConn2ID ).MP )->GetArtNum() );
		}
	}

	TestStr = str;
	return (LPCTSTR)str.c_str();
}

double CDB_TAProduct::GetDpmax()
{
	return m_dDpmax;
}

LPCTSTR CDB_TAProduct::GetInletSizeStr()
{
	CDB_StringID *pStr = (CDB_StringID *)( GetInletSizeIDPtr().MP );
	
	if( NULL != pStr )
	{
		return pStr->GetString();
	}
	else
	{
		return _T("-");
	}
}

const IDPTR &CDB_TAProduct::GetInletSizeIDPtr()
{
	m_InletSizeIDPtr.DB = GetDB();
	Extend( &m_InletSizeIDPtr );
	return m_InletSizeIDPtr;
}

LPCTSTR CDB_TAProduct::GetOutletSizeStr()
{
	CDB_StringID *pStr = (CDB_StringID *)( GetOutletSizeIDPtr().MP );
	
	if( NULL != pStr )
	{
		return pStr->GetString();
	}
	else
	{
		return _T("-");
	}
}

const IDPTR &CDB_TAProduct::GetOutletSizeIDPtr()
{
	m_OutletSizeIDPtr.DB = GetDB();
	Extend( &m_OutletSizeIDPtr );
	return m_OutletSizeIDPtr;
}

LPCTSTR CDB_TAProduct::SetSizeID( LPCTSTR sizeid )
{
	m_SizeIDPtr = _NULL_IDPTR;
	Modified();
	return PurgeString( m_SizeIDPtr.ID, sizeid, SIZEOFINTCHAR( m_SizeIDPtr.ID ) );
}

LPCTSTR CDB_TAProduct::SetCBIType( LPCTSTR cbitype )
{
	Modified();
	_string tmp = cbitype;
	StrTrimRight( tmp ); // Do not use PurgeString because it cleans 
	StrTrimLeft( tmp );
	_tcsncpy_s( m_tcCBIType, SIZEOFINTCHAR( m_tcCBIType ), tmp.c_str(), SIZEOFINTCHAR( m_tcCBIType ) - 1 );	// spaces inside the CBIType.
	return m_tcCBIType;
}

bool CDB_TAProduct::IsConnTabUsed()
{
	if( _T('\0') == *m_tcConnTabID || 0 == _tcscmp( _NO_ID, m_tcConnTabID ) )
	{
		return false;
	}

	return true;
}

double CDB_TAProduct::GetSortingKey( CProductSortKey::CPSKMask *pclMask )
{
	HYSELECT_TRY
	{
		CTAPSortKey::CTAPSKMask clCTAPSKMask( CTAPSortKey::TAPSKM_All );
	
		if( NULL == pclMask )
		{
			pclMask = &clCTAPSKMask;
		}
	
		double dKey;
	
		if( 0 != m_SortingKey.H || 0 != m_SortingKey.L )
		{
			CTAPSortKey sKey( m_SortingKey );
			dKey = sKey.GetSortingKeyAsDouble( pclMask );
		}
		else
		{
			CTAPSortKey sKey( this );
			CTAPSortKey::CTAPSKMask clCTAPSKMask( CTAPSortKey::TAPSKM_All );
			m_SortingKey = sKey.GetSortingKeyAsLL( &clCTAPSKMask );
			dKey = sKey.GetSortingKeyAsDouble( pclMask );
		}
	
		return dKey;
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_TAProduct::GetSortingKey' method (Object ID: %s)."), GetIDPtr().ID )
}

void CDB_TAProduct::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_TAProduct *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_TAProduct' object!") );
		}

		// Base class.
		CDB_Product::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_TAProduct" class.
		CDB_TAProduct *pclDestinationTAProduct = (CDB_TAProduct *)pclDestination;

		pclDestinationTAProduct->SetBodyMaterialID( GetBodyMaterialID() );

		pclDestinationTAProduct->SetSizeID( GetSizeID() );
		pclDestinationTAProduct->SetConnectID( GetConnectID() );
		pclDestinationTAProduct->SetVersionID( GetVersionID() );
		
		pclDestinationTAProduct->SetConnTabID( GetConnTabID() );
		pclDestinationTAProduct->SetConn2ID( GetConn2ID() );
		
		pclDestinationTAProduct->SetCBIType( GetCBIType() );
		pclDestinationTAProduct->SetCBISize( GetCBISize() );
		pclDestinationTAProduct->SetCBISizeInch( GetCBISizeInch() );
		pclDestinationTAProduct->SetCBICompatibilityIndex( GetCBICompatibilityIndex() );
		pclDestinationTAProduct->SetCBIVersion( GetCBIVersion() );

		pclDestinationTAProduct->SetDpmax( GetDpmax() );
		pclDestinationTAProduct->SetComment( GetComment() );
		pclDestinationTAProduct->SetMeasPt( m_uMeasPt );
		pclDestinationTAProduct->SetMeasurableData( m_uMeasurableData );
		pclDestinationTAProduct->SetInletSizeID( GetInletSizeIDPtr().ID );
		pclDestinationTAProduct->SetOutletSizeID( GetOutletSizeIDPtr().ID );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_TAProduct::Copy' method with the object '%s'."), GetIDPtr().ID )
}

void CDB_TAProduct::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_Product::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( _T('\0') != *m_BodyMaterialIDPtr.ID && 0 != _tcscmp( _NO_ID, m_BodyMaterialIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_BodyMaterialIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Body material ID (%s) is defined but not found in the database."), m_BodyMaterialIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("Body material ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_BodyMaterialIDPtr.ID );
			}
		}
	
		if( _T('\0') !=  *m_SizeIDPtr.ID && 0 != _tcscmp( _NO_ID, m_SizeIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_SizeIDPtr.ID );
		
			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Size ID (%s) is defined but not found in the database."), m_SizeIDPtr.ID );
			}
		
			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("Size ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_SizeIDPtr.ID );
			}
		}

		if( _T('\0') !=  *m_ConnectIDPtr.ID && 0 != _tcscmp( _NO_ID, m_ConnectIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_ConnectIDPtr.ID );
		
			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Connection ID (%s) is defined but not found in the database."), m_ConnectIDPtr.ID );
			}

			if( false == IsConnTabUsed() )
			{
				if( false == IDPtr.MP->IsClass( CLASS( CDB_Connect ) ) )
				{
					HYSELECT_THROW( _T("Connection ID (%s) is found in the database but it's not a 'CDB_Connect' object."), m_ConnectIDPtr.ID );
				}
			}
			else
			{
				if( false == IDPtr.MP->IsClass( CLASS( CDB_Component ) ) )
				{
					HYSELECT_THROW( _T("Connection ID (%s) is found in the database but it's not a 'CDB_Component' object."), m_ConnectIDPtr.ID );
				}
			}
		}

		if( _T('\0') !=  *m_tcConnTabID && 0 != _tcscmp( _NO_ID, m_tcConnTabID ) )
		{
			IDPtr = GetDB()->Get( m_tcConnTabID );
		
			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Connection table ID (%s) is defined but not found in the database."), m_tcConnTabID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CTable ) ) )
			{
				HYSELECT_THROW( _T("Connection table ID (%s) is found in the database but it's not a 'CTable' object."), m_tcConnTabID );
			}
		}

		if( _T('\0') != *m_tcConn2ID && 0 != _tcscmp( _NO_ID, m_tcConn2ID ) )
		{
			IDPtr = GetDB()->Get( m_tcConn2ID );
		
			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Connection 2 ID (%s) is defined but not found in the database."), m_tcConn2ID );
			}

			// Remark: ConnTabID can be a string ID for CDB_Component itself.
			//         And can be a 'CDB_Connect' (See Safety valve for example).
			if( false == IDPtr.MP->IsClass( CLASS( CDB_Component ) ) &&	false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) 
					&& false == IDPtr.MP->IsClass( CLASS( CDB_Connect ) )  )
			{
				HYSELECT_THROW( _T("Connection 2 ID (%s) is found in the database but it's not a 'CDB_Component', 'CDB_StringID' or 'CDB_Connect' object."), m_tcConn2ID );
			}
		}

		if( _T('\0') != *m_InletSizeIDPtr.ID && 0 != _tcscmp( _NO_ID, m_InletSizeIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_InletSizeIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Inlet size ID (%s) is defined but not found in the database."), m_InletSizeIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("Inlet size ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_InletSizeIDPtr.ID );
			}
		}

		if( _T('\0') != *m_OutletSizeIDPtr.ID && 0 != _tcscmp( _NO_ID, m_OutletSizeIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_OutletSizeIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Outlet size ID (%s) is defined but not found in the database."), m_OutletSizeIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("Outlet size ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_OutletSizeIDPtr.ID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_TAProduct::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

#define CDB_TAPRODUCT_VERSION	17
// 17: 2018-11-14: 'm_InletSizeIDPtr' and 'm_OutletSizeIDPtr' variables added.
// 16: Price is now in CDB_Product.
// 15: Inherit CDB_TAProduct from CDB_Product
// 14: Changing type of PartOfaSet
// 13: deleting of local article number.
void CDB_TAProduct::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_TAPRODUCT_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CDB_Product::Write( outf );

	// Info.
	WriteString( outf, m_SizeIDPtr.ID );
	WriteString( outf, m_ConnectIDPtr.ID );
	WriteString( outf, m_tcCBIType );
	WriteString( outf, m_tcCBISize );
	WriteString( outf, m_tcCBISizeInch );
	outf.write( (char *)&m_iCBICompatibilityIndex, sizeof( m_iCBICompatibilityIndex ) );
	WriteString( outf, m_tcCBIVersion );
	outf.write( (char *)&m_dDpmax, sizeof( m_dDpmax ) );
	WriteString( outf, m_tcConnTabID );
	WriteString( outf, m_tcConn2ID );
	WriteString( outf, m_BodyMaterialIDPtr.ID );
	outf.write( (char *)&m_SortingKey.H, sizeof( m_SortingKey.H ) );
	outf.write( (char *)&m_SortingKey.L, sizeof( m_SortingKey.L ) );
	outf.write( (char *)&m_uMeasPt, sizeof( m_uMeasPt ) );
	outf.write( (char *)&m_uMeasurableData, sizeof( m_uMeasurableData ) );

	// Version 17.
	WriteString( outf, GetInletSizeIDPtr().ID );
	WriteString( outf, GetOutletSizeIDPtr().ID );
}

bool CDB_TAProduct::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_TAPRODUCT_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_Product::Read( inpf ) )
	{
		return false;
	}
	
	if( false == ReadString( inpf, m_SizeIDPtr.ID, sizeof( m_SizeIDPtr.ID ) ) )
	{
		return false;     
	}

	if( false == ReadString( inpf, m_ConnectIDPtr.ID, sizeof( m_ConnectIDPtr.ID ) ) )
	{
		return false;  
	}

	// V2 CBIType, CBISize, CBISizeInch added.
	if( false == ReadString( inpf, m_tcCBIType, sizeof( m_tcCBIType ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_tcCBISize, sizeof( m_tcCBISize ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_tcCBISizeInch, sizeof( m_tcCBISizeInch ) ) )
	{
		return false;
	}
	
	// V3 CBICompatibilityIndex, CBIVersion added.
	inpf.read( (char *)&m_iCBICompatibilityIndex, sizeof( m_iCBICompatibilityIndex ) );

	if( false == ReadString( inpf, m_tcCBIVersion, sizeof( m_tcCBIVersion ) ) )
	{
		return false;
	}
	
	m_dDpmax = ReadDouble( inpf );
	
	if( false == ReadString( inpf, m_tcConnTabID, sizeof( m_tcConnTabID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_tcConn2ID, sizeof( m_tcConn2ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_BodyMaterialIDPtr.ID, sizeof( m_BodyMaterialIDPtr.ID ) ) )
	{
		return false;  
	}
	
	inpf.read( (char *)&m_SortingKey.H, sizeof( m_SortingKey.H ) );
	inpf.read( (char *)&m_SortingKey.L, sizeof( m_SortingKey.L ) );

	inpf.read( (char *)&m_uMeasPt, sizeof( m_uMeasPt ) );
	inpf.read( (char *)&m_uMeasurableData, sizeof( m_uMeasurableData ) );

	// Version 17.
	if( false == ReadString( inpf, m_InletSizeIDPtr.ID, sizeof( m_InletSizeIDPtr.ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_OutletSizeIDPtr.ID, sizeof( m_OutletSizeIDPtr.ID ) ) )
	{
		return false;
	}
	
	return true;
}

#ifndef TACBX 
#define TAP_BODYMATERIALID			_T("::BodyMaterialID=")
#define TAP_SIZEID					_T("::SizeID=")
#define TAP_CONNECTID				_T("::ConnectID=")
#define TAP_CONNTABID				_T("::ConnTabID=")
#define TAP_CONN2ID					_T("::Conn2ID=")
#define TAP_CBITYPE					_T("::CBIType=")
#define TAP_CBISIZE					_T("::CBISize=")
#define TAP_CBISIZEINCH				_T("::CBISizeInch=")
#define TAP_CBICOMPATIBILITYINDEX	_T("::CBICompatibilityIndex=")
#define TAP_CBIVERSION				_T("::CBIVersion=")
#define TAP_DPMAX					_T("::Dpmax=")
#define TAP_MEASPT					_T("::MeasPt=")
#define TAP_MEASURABLEDATA			_T("::MeasurableData=")
#define TAP_INLETSIZEID    			_T("::InletSizeID=")
#define TAP_OUTLETSIZEID    		_T("::OutletSizeID=")

void CDB_TAProduct::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int ipos = pStr->Find( CLASS( CDB_TAProduct ) );

		if( pStr->Left(2) != _T("::") && ipos < 0 )
		{
			CDB_Product::InterpretInheritedData( pStr );
		}
		else
		{
			if( ipos >= 0 )
			{
				pStr->Delete( ipos, _tcsclen( CLASS( CDB_TAProduct ) ) );
			}

			int iEq = pStr->Find( _T("=") );

			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );
		
			if( pStr->Find( TAP_BODYMATERIALID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_TAProduct::BodyMaterialID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetBodyMaterialID( (LPCTSTR)strField );
			}
			else if( pStr->Find( TAP_SIZEID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_TAProduct::SizeID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetSizeID( (LPCTSTR)strField );
			}
			else if( pStr->Find( TAP_CONNECTID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_TAProduct::ConnectID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetConnectID( (LPCTSTR)strField );
			}
			else if( pStr->Find( TAP_CONNTABID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_TAProduct::ConnTabID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetConnTabID( (LPCTSTR)strField );
			}
			else if( pStr->Find( TAP_CONN2ID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_TAProduct::Conn2ID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetConn2ID( (LPCTSTR)strField );
			}
			else if( pStr->Find( TAP_CBITYPE ) > -1 )
			{
				if( strField.GetLength() > ( _CBI_TYPE_LENGTH + 2 ) )
				{
					HYSELECT_THROW( _T("'CDB_TAProduct::CBIType' (%s) is too long (%i > %i)."), strField, strField.GetLength(), ( _CBI_TYPE_LENGTH + 2 ) );
				}

				if( _T('"') != strField.GetAt( 0 ) )
				{
					HYSELECT_THROW( _T("'CDB_TAProduct::CBIType' (%s) must start with \"."), strField );
				}
				else if( _T('"') != strField.GetAt( strField.GetLength() - 1 ) )
				{
					HYSELECT_THROW( _T("'CDB_TAProduct::CBIType' (%s) must end with \"."), strField );
				}
			
				strField = strField.Mid( 1, strField.GetLength() - 2 );
				_tcsncpy_s( m_tcCBIType, SIZEOFINTCHAR( m_tcCBIType ), (LPCTSTR)strField, SIZEOFINTCHAR( m_tcCBIType ) - 1 );
			}
			else if( pStr->Find( TAP_CBISIZE ) > -1 )
			{
				if( strField.GetLength() > ( _CBI_SIZE_LENGTH + 2 ) )
				{
					HYSELECT_THROW( _T("'CDB_TAProduct::CBISize' (%s) is too long (%i > %i)."), strField, strField.GetLength(), ( _CBI_TYPE_LENGTH + 2 ) );
				}

				if( _T('"') != strField.GetAt( 0 ) )
				{
					HYSELECT_THROW( _T("'CDB_TAProduct::CBISize' (%s) must start with \"."), strField );
				}
				else if( _T('"') != strField.GetAt( strField.GetLength() - 1 ) )
				{
					HYSELECT_THROW( _T("'CDB_TAProduct::CBISize' (%s) must end with \"."), strField );
				}

				strField = strField.Mid( 1, strField.GetLength() - 2 );
				_tcsncpy_s( m_tcCBISize, SIZEOFINTCHAR( m_tcCBISize ), (LPCTSTR)strField, SIZEOFINTCHAR( m_tcCBISize ) - 1 );
			}
			else if( pStr->Find( TAP_CBISIZEINCH ) > -1 )
			{
				if( strField.GetLength() > ( _CBI_SIZE_LENGTH + 2 ) )
				{
					HYSELECT_THROW( _T("'CDB_TAProduct::CBISizeInch' (%s) is too long (%i > %i)."), strField, strField.GetLength(), ( _CBI_TYPE_LENGTH + 2 ) );
				}

				if( _T('"') != strField.GetAt( 0 ) )
				{
					HYSELECT_THROW( _T("'CDB_TAProduct::CBISizeInch' (%s) must start with \"."), strField );
				}
				else if( _T('"') != strField.GetAt( strField.GetLength() - 1 ) )
				{
					HYSELECT_THROW( _T("'CDB_TAProduct::CBISizeInch' (%s) must end with \"."), strField );
				}

				strField = strField.Mid( 1, strField.GetLength() - 2 );
				_tcsncpy_s( m_tcCBISizeInch, SIZEOFINTCHAR( m_tcCBISizeInch ), (LPCTSTR)strField, SIZEOFINTCHAR( m_tcCBISizeInch ) - 1 );
			}
			else if( pStr->Find( TAP_CBICOMPATIBILITYINDEX ) > -1 )
			{
				m_iCBICompatibilityIndex = _ttoi( (LPCTSTR)strField ); 
			}
			else if( pStr->Find( TAP_CBIVERSION ) > -1 )
			{
				if( strField.GetLength() > ( _CBI_SIZE_LENGTH + 2 ) )
				{
					HYSELECT_THROW( _T("'CDB_TAProduct::CBIVersion' (%s) is too long (%i > %i)."), strField, strField.GetLength(), ( _CBI_TYPE_LENGTH + 2 ) );
				}

				if( _T('"') != strField.GetAt( 0 ) )
				{
					HYSELECT_THROW( _T("'CDB_TAProduct::CBIVersion' (%s) must start with \"."), strField );
				}
				else if( _T('"') != strField.GetAt( strField.GetLength() - 1 ) )
				{
					HYSELECT_THROW( _T("'CDB_TAProduct::CBIVersion' (%s) must end with \"."), strField );
				}

				strField = strField.Mid( 1, strField.GetLength() - 2 );
				_tcsncpy_s( m_tcCBIVersion, SIZEOFINTCHAR( m_tcCBIVersion ), (LPCTSTR)strField, SIZEOFINTCHAR( m_tcCBIVersion ) - 1 );
			}
			else if( pStr->Find( TAP_DPMAX ) > -1 )
			{
				TCHAR *ptcEndPtr;
				m_dDpmax = _tcstod( (LPCTSTR)strField, &ptcEndPtr );
			
				if( _T('\0') != *ptcEndPtr )
				{
					HYSELECT_THROW( _T("Can't convert 'CDB_TAProduct::Dpmax' (%s) in double."), strField );
				}
			}
			else if( pStr->Find( TAP_MEASPT ) > -1 )
			{
				m_uMeasPt = ReadEnum( strField );

				if( m_uMeasPt < eMeasPt::empNone || m_uMeasPt >= eMeasPt::empLast )
				{
					HYSELECT_THROW( _T("'CDB_TAProduct::MeasPt' value must be a combination of these values: '#eMeasPointNone', '#eMeasPointInlet', '#eMeasPointOutlet', '#eMeasPointMeasStatOut' or '#eMeasPointP+'.") );
				}
			}
			else if( pStr->Find(TAP_MEASURABLEDATA ) > -1 )
			{
				m_uMeasurableData = ReadEnum( strField );

				if( m_uMeasPt < eMeasurableData::emdNone || m_uMeasPt >= eMeasurableData::emdLast )
				{
					HYSELECT_THROW( _T("'CDB_TAProduct::MeasurableData' value must be a combination of these values: '#eMeasDataNone', '#eMeasDataDp', '#eMeasDataFlow', '#eMeasDataDpSignal', '#eMeasDataDpAvail', '#eMeasDataDpStab' or '#eMeasDataDpCAlwaysOn+'.") );

				}
			}
			else if( pStr->Find( TAP_INLETSIZEID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_TAProduct::InletSizeID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetInletSizeID( (LPCTSTR)strField );
			}
			else if( pStr->Find( TAP_OUTLETSIZEID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_TAProduct::OutletSizeID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetOutletSizeID( (LPCTSTR)strField );
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_TAProduct::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_TAProduct::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_TAProduct format
		// line 0 : open curve bracket and call base class.
		// line 1 : Body Material ID
		// line 2 : Size ID
		// line 3 : Connect ID
		// line 4 :	Connection table ID 
		// line 5 : Outlet/body side connection ID
		// line 6 : CBI Type
		// line 7 : CBI Size
		// line 8 : CBI Size us
		// line 9 : CBI Compatibility Index
		// line 10: CBI Version
		// line 11: Dpmax
		// line 12: Measuring points
		// line 13: Measurable data
		// line 14: Inlet size ID
		// line 15: Outlet size ID
		// line 16: close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_TAProduct *)idptr.MP )->Copy( this );
			
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );

			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				CDB_TAProduct::InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_Product::ReadText( inpf, pusLineCount );

			CStringArray TxtHdr;
			TxtHdr.Add( TAP_BODYMATERIALID );
			TxtHdr.Add( TAP_SIZEID );
			TxtHdr.Add( TAP_CONNECTID );
			TxtHdr.Add( TAP_CONNTABID );
			TxtHdr.Add( TAP_CONN2ID );
			TxtHdr.Add( TAP_CBITYPE );
			TxtHdr.Add( TAP_CBISIZE );
			TxtHdr.Add( TAP_CBISIZEINCH );
			TxtHdr.Add( TAP_CBICOMPATIBILITYINDEX );
			TxtHdr.Add( TAP_CBIVERSION );
			TxtHdr.Add( TAP_DPMAX );
			TxtHdr.Add( TAP_MEASPT );
			TxtHdr.Add( TAP_MEASURABLEDATA );
			TxtHdr.Add( TAP_INLETSIZEID );
			TxtHdr.Add( TAP_OUTLETSIZEID );
		
			for( int i = 0; i < TxtHdr.GetSize(); i++ )
			{
				ptcLine = ReadTextLine( inpf, pusLineCount );

				CString str = TxtHdr[i] + CString( ptcLine );
				CDB_TAProduct::InterpretInheritedData( &str );
			}
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_TAProduct::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_TAProduct::WriteText( OUTSTREAM outf, CString& strTab )
{
	CString str, str1, str2;
		
	// Write object header.
	if( true == IsClass( CLASS( CDB_TAProduct ) ) )
	{
		CData::WriteText( outf, strTab );
	}
	
	// Opening bracket..
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");
	CDB_Product::WriteText( outf, strTab );
	
	// Data
	// BodyMaterial.
	WriteFormatedStringW( outf, m_BodyMaterialIDPtr.ID, strTab );
	
	// Size.
	WriteFormatedStringW( outf, m_SizeIDPtr.ID, strTab );
	
	// Connection.
	WriteFormatedStringW( outf, m_ConnectIDPtr.ID, strTab );

	// ConnTabID.
	WriteFormatedStringW( outf, m_tcConnTabID, strTab );

	// Conn2ID.
	WriteFormatedStringW( outf, m_tcConn2ID, strTab );
	
	// CBIType.
	WriteFormatedStringW( outf, m_tcCBIType, strTab, true );
	
	// CBISize.
	WriteFormatedStringW( outf, m_tcCBISize, strTab, true );
	
	// CBISizeInch.
	WriteFormatedStringW( outf, m_tcCBISizeInch, strTab, true );
	
	// CBI CompatibilityIndex.
	WriteFormatedStringW( outf, WriteDouble( m_iCBICompatibilityIndex, 2, 1 ), strTab, true );

	// CBI Version.
	WriteFormatedStringW( outf, m_tcCBIVersion, strTab, true );

	// Dpmax.
	WriteFormatedStringW( outf, WriteDouble( m_dDpmax, 2, 1 ), strTab, true );
	
	// m_MeasPt.
	str.Format( _T("%x"), m_uMeasPt );
	WriteFormatedStringW( outf, str, strTab, true );
	
	// m_MeasurableData.
	str.Format( _T("%x"), m_uMeasurableData );
	WriteFormatedStringW( outf, str, strTab, true );

	// Inlet size ID.
	WriteFormatedStringW( outf, m_InletSizeIDPtr.ID, strTab );

	// Outlet size ID.
	WriteFormatedStringW( outf, m_OutletSizeIDPtr.ID, strTab );
	
	// Closing bracket..
	strTab.Delete( 0 ); // Delete one \t
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}

CData::CheckFilterReturnValue CDB_TAProduct::CheckFilter( CFilterTab *pclFilter, CString strFilter )
{
	HYSELECT_TRY
	{
		//	Filter string
		//  CDB_ClassName;TABLE;ID;EDIT;FAMILY;CONNECTION;VERSION;PN;Availability;Mask & Value;Priority; -d IDBROL
		//	Field 0			1	2	3	4			5		6	 7		8			9			10       11

		if( true == strFilter.IsEmpty() )
		{
			HYSELECT_THROW( _T("Filter line can't be empty.") );
		}

		int iFieldNumber = pclFilter->GetNumberOfFields( strFilter );
		
		if( 12 != iFieldNumber )
		{
			HYSELECT_THROW( _T("Number of fields (%i) must be 12."), iFieldNumber );
		}

		// Retrieve field 11 (It's for debug purpose if defined).
		CString str = pclFilter->GetField( 11, strFilter );
		
		if( false == str.IsEmpty() )
		{
			int iPos = str.Find( _T('-') );

			if( iPos >= 0 )
			{
				// Remove '-d' in front of the field.
				str.Delete( iPos, 2 );
				str = str.Trim();
				
				// Check if an ID is defined.
				if( false == str.IsEmpty() )
				{
					// If ID is defined, we break only when it's the same ID as the current one.
					IDPTR idptr = GetIDPtr();

					if( true == idptr.IDMatch( (LPCTSTR)str ) )
					{
						DebugBreak();
					}
				}
				else
				{
					// If ID is not defined, we beak always.
					DebugBreak();
				}
			}
		}

		// Family.
		str = pclFilter->GetField( 4, strFilter );

		if( false == str.IsEmpty() )
		{
			if( 0 != _tcscmp( (LPCTSTR)str, GetFamilyIDPtr().ID ) )
			{
				return CData::CFRV_FilterNotApplied;
			}
		}
		
		// Connection.
		str = pclFilter->GetNextField( strFilter );

		if( false == str.IsEmpty() )
		{
			if( 0 != _tcscmp( (LPCTSTR)str, GetConnectIDPtr().ID ) )
			{
				return CData::CFRV_FilterNotApplied;
			}
		}
		
		// Version.
		str = pclFilter->GetNextField( strFilter );

		if( false == str.IsEmpty() )
		{
			if( 0 != _tcscmp( (LPCTSTR)str, GetVersionIDPtr().ID ) )
			{
				return CData::CFRV_FilterNotApplied;
			}
		}
		
		// PN.
		str = pclFilter->GetNextField( strFilter );

		if( false == str.IsEmpty() )
		{
			CString LimPNID = str.Right( str.GetLength() - 2 );
			str.Delete( 2, str.GetLength() - 2 );
			
			// Find the pressure of limit PN in the filter.
			CDB_StringID *pPN = (CDB_StringID *)( GetDB()->Get( LimPNID ).MP );
			ASSERT( NULL != pPN );

			double LimitP = _tcstod( pPN->GetIDstr(), _T('\0') );
			
			// Find the pressure of current TAProduct PN (and not the Pmax of TAProduct).
			double CurrPmax = GetPNPress();

			if( ( ( ( _T("==") == str ) && ( CurrPmax != LimitP ) )
					|| ( ( _T("<=") == str ) && ( CurrPmax > LimitP ) )
					|| ( ( _T(">=") == str ) && ( CurrPmax < LimitP ) ) ) )
			{
				return CData::CFRV_FilterNotApplied;
			}
		}
		
		// All Field checked do modifications.
		// Availability.
		str = pclFilter->GetNextField( strFilter );

		if( false == str.IsEmpty() )
		{
			if( _T('0') == str[0] )
			{
				SetAvailable( 0 );
			}

			if( _T('1') == str[0] )
			{
				SetAvailable( 1 );
			}

			if( _T('0') == str[2] )
			{
				SetHidden( 0 );
			}

			if( _T('1') == str[2] )
			{
				SetHidden( 1 );
			}
		}

		// Some flags with a mask					// Mask and value integers
		// The first integer contains mask bits, the second contains the values, 
		// mask integer and value integer are separated by a comma.
		// Both are coded in Hexadecimal like 0x....
		// Only value bit with a mask bit set to 1 will be taken into account 
		str = pclFilter->GetNextField( strFilter );

		if( false == str.IsEmpty() )
		{
			// Split Mask and Value into two integers.
			CString strMask = str.Left( str.Find( _T(',') ) );
			CString strVal = str.Right( str.GetLength() - ( str.Find( _T(',') ) + 1 ) );
			
			unsigned int uiMask, uiNVal;
			_stscanf_s( (LPCTSTR)strMask, _T("%x"), &uiMask );
			_stscanf_s( (LPCTSTR)strVal, _T("%x"), &uiNVal );
			
			// Set or reset non masked bit.
			unsigned int uiInt1 = GetInt1();
			
			//          set bits				reset bits
			uiInt1 = ( uiInt1 | ( uiMask & uiNVal ) ) & ~( uiMask & ~uiNVal );
			SetInt1( uiInt1 );
		}
		
		// Priority.
		str = pclFilter->GetNextField( strFilter );

		if( false == str.IsEmpty() )
		{
			int priority = _tcstol( (LPCTSTR)str, 0, 10 );
			SetPriorityLevel( priority );
		}

		return CData::CFRV_FilterApplied;
	}
	catch( CHySelectException &clHySelectException )
	{ 
		clHySelectException.AddMessage( _T("Error in 'CDB_TAProduct::CheckFilter' (Data ID: %s)."), __LINE__, __FILE__, GetIDPtr().ID );
		clHySelectException.AddMessage( _T("\tFilter: %s."), __LINE__, __FILE__, strFilter );
		throw;
	}
}

//	Redefinition string
//	Object_ID;Name;FamilyID;QrsID;CBIType
//	Field 0		1	2		3		4
void CDB_TAProduct::CheckRedefinition( CRedefineTab *pclRedef, CString strRedefinition )
{
	if( true == strRedefinition.IsEmpty() )
	{
		return;
	}
	
	CString str, tmp;

	// Do modifications.

	// Name
	str = pclRedef->GetField( 1, strRedefinition );

	if( false == str.IsEmpty() )
	{
		SetName( str );
	}

	// Family ID.
	str = pclRedef->GetNextField( strRedefinition );
	
	if( false == str.IsEmpty() )
	{
		SetFamilyID( str );
		ASSERT( NULL != GetFamilyIDPtr().MP && true == GetFamilyIDPtr().MP->IsClass( CLASS( CDB_StringID ) ) );
	}

	// CatFile ID.
	str = pclRedef->GetNextField( strRedefinition );
/*	if( false == str.IsEmpty() )
		SetCatFileID( str );
*/
	
// QrsFile ID.
	str = pclRedef->GetNextField( strRedefinition );
/*	if( false == str.IsEmpty() )
		SetQrsFileID( str );
*/

	// CBIType.
	str = pclRedef->GetNextField( strRedefinition );

	if( false == str.IsEmpty() )
	{
		SetCBIType( str );
	}
}
#endif

#ifndef TACBX
///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_AirVent
//
///////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DATA( CDB_AirVent )

CDB_AirVent::CDB_AirVent( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_TAProduct( pDataBase, ID )
{
	m_dDpp = 0.0;
}

void CDB_AirVent::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_AirVent *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_AirVent' object!") );
		}

		// Base class.
		CDB_TAProduct::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_AirVent" class.
		CDB_AirVent *pclDestinationAirVent = (CDB_AirVent *)pclDestination;

		pclDestinationAirVent->SetDpp( m_dDpp );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_AirVent::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_AIRVENT_VERSION		1
void CDB_AirVent::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_AIRVENT_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_TAProduct::Write( outf );
	
	// Infos.
	outf.write( (char *)&m_dDpp, sizeof( m_dDpp ) );
}

bool CDB_AirVent::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_AIRVENT_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_TAProduct::Read( inpf ) )
	{
		return false;
	}
	
	// Infos.
	m_dDpp = ReadDouble( inpf );

	return true;
}

void CDB_AirVent::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( _T("CDB_AirVent") );

		if( iPos < 0 )
		{
			CDB_TAProduct::InterpretInheritedData( pStr );
		}
		else
		{
			pStr->Delete( iPos, _tcsclen( _T("CDB_AirVent") ) );
			int iEq = pStr->Find( _T("=") );

			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}
		
			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( _T("::Dpp=") ) > -1 )
			{
				if( RD_OK != ReadDouble( strField, &m_dDpp ) )
				{
					HYSELECT_THROW( _T("'CDB_AirVent::Dpp' must be a double (%s)."), strField );
				}
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_AirVent::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_AirVent::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_AirVent format
		// line 0 : open curve bracket and call base class.
		// line 1 : Max static pressure difference with the atmosphere
		// line 2 : close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_AirVent *)idptr.MP )->Copy( this );
			CStringArray ar;

			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );
			
				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_TAProduct::ReadText( inpf, pusLineCount );

			// Dpp.
			TCHAR *ptcEndPtr;
			ptcLine = ReadTextLine( inpf, pusLineCount );

			m_dDpp = _tcstod( ptcLine, &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't convert Dpp value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
			}
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_AirVent::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_AirVent::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str, str1;
	
	// Write object header.
	if( true == IsClass( CLASS( CDB_AirVent ) ) )
	{
		CData::WriteText( outf, strTab );
	}
	
	// Opening bracket.
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");
	CDB_TAProduct::WriteText( outf, strTab );
	
	// Data.
	WriteFormatedStringW( outf, WriteDouble( m_dDpp, 2, 1 ), strTab );
	
	// Closing bracket.
	strTab.Delete( 0 );
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_Separator
//
///////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DATA( CDB_Separator )

CDB_Separator::CDB_Separator( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_TAProduct( pDataBase, ID )
{
	m_QDpCharacteristicID[0] = _T('\0');	// Q-Dp Characteristic ID.
	m_pQDpCharacteristic = NULL;		// Pointer on Q-Dp characteristic.
	m_iNbOfMagnet = 0;
}

CDB_QDpCharacteristic *CDB_Separator::GetQDpCharacteristic()
{
	try
	{
		if( NULL == m_pQDpCharacteristic )
		{
			if( _T('\0') != *m_QDpCharacteristicID && 0 != IDcmp( m_QDpCharacteristicID, _NO_ID ) )
			{
				IDPTR CharactPtr = GetDB()->Get( m_QDpCharacteristicID );

				if( _T('\0') == *CharactPtr.ID )
				{
					HYSELECT_THROW( _T("Internal error: Can't find characteristic '%s' in the database."), m_QDpCharacteristicID );
				}

				m_pQDpCharacteristic = (CDB_QDpCharacteristic*)( CharactPtr.MP );

				if( NULL != m_pQDpCharacteristic )
				{
					m_pQDpCharacteristic->Lock( GetIDPtr() );
				}
			}
		}
	
		return m_pQDpCharacteristic;
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Separator::GetQDpCharacteristic'."), __LINE__, __FILE__ );
		throw;
	}
}

void CDB_Separator::SetQDpCharacteristicID( _string ID )
{
	ASSERT( ID.length() <= _ID_LENGTH );
	_tcsncpy_s( m_QDpCharacteristicID, SIZEOFINTCHAR( m_QDpCharacteristicID ), ID.c_str(), _ID_LENGTH );
	
	// Unlock if previous one exist.
	if( NULL != m_pQDpCharacteristic )
	{
		m_pQDpCharacteristic->Unlock( GetIDPtr() );
	}

	// Force a call to 'GetQDpCharacteristic' to update 'm_pQDpCharacteristic'.
	m_pQDpCharacteristic = NULL;
	GetQDpCharacteristic();
}

void CDB_Separator::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_Separator *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_Separator' object!") );
		}
	
		// Base class.
		CDB_TAProduct::Copy( pclDestination );

		// Copy now what it is common to the "CDB_Separator" class.
		CDB_Separator *pclDestinationSeparator = (CDB_Separator *)pclDestination;

		pclDestinationSeparator->SetQDpCharacteristicID( m_QDpCharacteristicID );
		pclDestinationSeparator->SetNumberOfMagnet( m_iNbOfMagnet );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_Separator::Copy' method with the object '%s'."), GetIDPtr().ID )
}

void CDB_Separator::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_TAProduct::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( _T('\0') !=  *m_QDpCharacteristicID && 0 != _tcscmp( _NO_ID, m_QDpCharacteristicID ) )
		{
			IDPtr = GetDB()->Get( m_QDpCharacteristicID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Q-Dp characteristic ID (%s) is defined but not found in the database."), m_QDpCharacteristicID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_QDpCharacteristic ) ) )
			{
				HYSELECT_THROW( _T("Q-Dp characteristic ID (%s) is found in the database but it's not a 'CDB_QDpCharacteristic' object."), m_QDpCharacteristicID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_Separator::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

void CDB_Separator::OnDatabaseDestroy()
{
	CDB_TAProduct::OnDatabaseDestroy();

	// Unlock the Q-Dp characteristic.
	if( NULL != GetQDpCharacteristic() )
	{
		GetQDpCharacteristic()->Unlock( GetIDPtr() );
	}
}

// Version 2 : 01/26/2021 - HYS-1572 : Add a m_iNbOfMagnet
#define CDB_SEPARATOR_VERSION	2
void CDB_Separator::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_SEPARATOR_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_TAProduct::Write( outf );
	
	// Infos.
	// The Q-Dp characteristic ID.
	WriteString( outf, m_QDpCharacteristicID );
	
	// Version 2.
	outf.write( (char*)&m_iNbOfMagnet, sizeof( m_iNbOfMagnet ) );
}

bool CDB_Separator::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_SEPARATOR_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_TAProduct::Read( inpf ) )
	{
		return false;
	}
	
	// Infos.
	
	// The Q-Dp characteristic ID.
	if( false == ReadString( inpf, m_QDpCharacteristicID, sizeof( m_QDpCharacteristicID ) ) )
	{
		return false;
	}

	// HYS-1572 
	if( Version < 2 )
	{
		return true;
	}

	if( Version >= 2 )
	{
		inpf.read( (char*)&m_iNbOfMagnet, sizeof( m_iNbOfMagnet ) );
	}
	
	return true;
}

void CDB_Separator::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( _T("CDB_Separator") );

		if( iPos < 0 )
		{
			CDB_TAProduct::InterpretInheritedData( pStr );
		}
		else
		{
			pStr->Delete( iPos, _tcsclen( _T("CDB_Separator") ) );
			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( _T("::CharactID=") ) > -1 )
			{
				SetQDpCharacteristicID( (LPCTSTR)strField );
			}
			else if( pStr->Find( _T("::NumberOfMagnet=") ) > -1 )
			{
				int iValue = _ttoi( (LPCTSTR)strField );
				SetNumberOfMagnet( iValue );
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Separator::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_Separator::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_Separator format
		// line 0 : open curve bracket and call base class.
		// line 1 : Q-Dp characteristic ID.
		// line 2 : number of magnet
		// line 3 : close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;
	
		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_Separator *)idptr.MP )->Copy( this );
			
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_TAProduct::ReadText( inpf, pusLineCount );
		
			// The Q-Dp characteristic ID.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Q-Dp characteristic ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			_tcsncpy_s( m_QDpCharacteristicID, SIZEOFINTCHAR( m_QDpCharacteristicID ), ptcLine, SIZEOFINTCHAR( m_QDpCharacteristicID ) - 1 );

			// HYS-1572
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_iNbOfMagnet = _tstoi( ptcLine );

			if( m_iNbOfMagnet < 0.0 )
			{
				HYSELECT_THROW( _T("Number og magnet (%i) cann't be lower than 0 (pos: %i)."), m_iNbOfMagnet, *pusLineCount );
			}
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Separator::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_Separator::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str, str1;
	
	// Write object header.
	if( true == IsClass( CLASS( CDB_Separator ) ) )
	{
		CData::WriteText( outf, strTab );
	}
	
	// Opening bracket.
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");
	CDB_TAProduct::WriteText( outf, strTab );
	
	// Data.
	WriteFormatedStringW( outf, m_QDpCharacteristicID, strTab );

	// m_iNbOfMagnet.
	str.Format( _T("\r\n%s%i"), strTab, m_iNbOfMagnet );
	outf.write( (char*)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	// Closing bracket.
	strTab.Delete( 0 );
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_PlenoRefill
//
///////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DATA( CDB_PlenoRefill )
CDB_PlenoRefill::CDB_PlenoRefill( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_Product( pDataBase, ID )
{
	m_iFunctions = ePRFunc_None;			// PlenoRefill functions 	#ePRFunc_None/#ePRFunc_Soft/#ePRFunc_Desalin
	m_dCapacity = 0.0;						// Capacity					double ( l*dH -> SI: m3*mol/m3 = mol)
	m_dMaxFlow = 0.0;						// MaxFlow					double (m3/s)
	m_dMaxSupplyWaterPressure = 0.0;		// MaxSupplyWaterP			double (pa)
	m_dMinSupplyWaterPressure = 0.0;		// MinSupplyWaterP			double (pa)
	m_InConnectIDPtr.Clear();				// InConnectID				string ID
	m_InSizeIDPtr.Clear();					// InSizeID					string ID
	m_OutConnectIDPtr.Clear();				// OutConnectID				string ID
	m_OutSizeIDPtr.Clear();					// OutSizeID				string ID
	m_dHeight = 0.0;						// Height					double (m)
	m_dWidthWoConnection = 0.0;				// WidthWoConnect			double (m)
	m_dWidthWConnection = 0.0;				// WidthWConnect			double (m)
	m_dWeight = 0.0;						// Weight					double (kg)
	m_bDegasserCompatible = false;			// DegasserCompatible		0/1
}

CString CDB_PlenoRefill::GetFunctionsStr( void )
{
	CString str;

	if( ePRFunc_None == m_iFunctions )
	{
		str = TASApp.LoadLocalizedString( IDS_PLENOREFILLFCT_NONE );
	}
	else if( ePRFunc_Soft == m_iFunctions )
	{
		str = TASApp.LoadLocalizedString( IDS_PLENOREFILLFCT_SOFT );
	}
	else if( ePRFunc_Desalin == m_iFunctions )
	{
		str = TASApp.LoadLocalizedString( IDS_PLENOREFILLFCT_DESAL );
	}
	else if( ( ePRFunc_Soft | ePRFunc_Desalin ) == m_iFunctions )
	{
		str = TASApp.LoadLocalizedString( IDS_PLENOREFILLFCT_SOFTDESAL );
	}
	else
	{
		str = TASApp.LoadLocalizedString( IDS_PLENOREFILLFCT_NONE );
	}

	return str;
}

CString CDB_PlenoRefill::GetCapacityStr( bool bWithUnit )
{
	if( -1.0 == m_dCapacity )
	{
		return _T("-");
	}

	double dVolume = CDimValue::SItoCU( _U_VOLUME, m_dCapacity );
	double dWaterHardness = CDimValue::SItoCU( _U_WATERHARDNESS, 1.0 );
	
	if( 0.0 == dWaterHardness )
	{
		return _T("-");
	}

	double dCapacity = dVolume * dWaterHardness;
	CString str = WriteDouble( dCapacity, 3, 2 );

	if( true == bWithUnit )
	{
		TCHAR tcName[_MAXCHARS];
		CUnitDatabase *pclUnitDB = CDimValue::AccessUDB();
		GetNameOf( pclUnitDB->GetDefaultUnit( _U_VOLUME ), tcName );
		str += _T(" ") + CString( tcName );
		GetNameOf( pclUnitDB->GetDefaultUnit( _U_WATERHARDNESS ), tcName );
		str += _T("/") + CString( tcName );
	}

	return str;
}

double CDB_PlenoRefill::GetMaxVolume( double dWaterHardness, double dTotalHardnessOfSystem )
{
	if( m_dCapacity <= 0.0 || dWaterHardness <= 0.0 || dTotalHardnessOfSystem <= 0.0 )
	{
		return -1.0;
	}

	if( dWaterHardness - dTotalHardnessOfSystem <= 0 )
	{
		return -1.0;
	}

	if( ePRFunc_Soft == ( ePRFunc_Soft & m_iFunctions ) )
	{
		return ( m_dCapacity / ( dWaterHardness - dTotalHardnessOfSystem ) );
	}
	else
	{
		return ( m_dCapacity / dWaterHardness );
	}
}

CString CDB_PlenoRefill::GetSupplyWaterPressureRangeStr()
{
	CString str = WriteCUDouble( _U_PRESSURE, m_dMinSupplyWaterPressure );
	str += _T("/");
	str += WriteCUDouble( _U_PRESSURE, m_dMaxSupplyWaterPressure );
	return str;
}

LPCTSTR CDB_PlenoRefill::GetInConnectStr()
{
	CDB_StringID *pStr = (CDB_StringID *)( GetInConnectIDPtr().MP );

	if( NULL != pStr )
	{
		return pStr->GetString();
	}
	else
	{
		return _T("-");
	}
}

const IDPTR &CDB_PlenoRefill::GetInConnectIDPtr()
{
	m_InConnectIDPtr.DB = GetDB();
	Extend( &m_InConnectIDPtr );
	return m_InConnectIDPtr;
}

LPCTSTR CDB_PlenoRefill::GetInSizeStr()
{
	CDB_StringID *pStr = (CDB_StringID *)( GetInSizeIDPtr().MP );
	
	if( NULL != pStr )
	{
		return pStr->GetString();
	}
	else
	{
		return _T("-");
	}
}

const IDPTR &CDB_PlenoRefill::GetInSizeIDPtr()
{
	m_InSizeIDPtr.DB = GetDB();
	Extend( &m_InSizeIDPtr );
	return m_InSizeIDPtr;
}

CString CDB_PlenoRefill::GetInConnectSizeStr()
{
	CString str = _T("-");

	if( 0 != CString( _T("-") ).Compare( GetInConnectStr() ) )
	{
		str = CString( GetInConnectStr() );

		if( 0 != CString( _T("-") ).Compare( GetInSizeStr() ) )
		{
			str += _T(" ") + CString( GetInSizeStr() );
		}
	}

	return str;
}

LPCTSTR CDB_PlenoRefill::GetOutConnectStr()
{
	CDB_StringID *pStr = (CDB_StringID *)( GetOutConnectIDPtr().MP );
	
	if( NULL != pStr )
	{
		return pStr->GetString();
	}
	else
	{
		return _T("-");
	}
}

const IDPTR &CDB_PlenoRefill::GetOutConnectIDPtr()
{
	m_OutConnectIDPtr.DB = GetDB();
	Extend( &m_OutConnectIDPtr );
	return m_OutConnectIDPtr;
}

LPCTSTR CDB_PlenoRefill::GetOutSizeStr()
{
	CDB_StringID *pStr = (CDB_StringID *)( GetOutSizeIDPtr().MP );
	
	if( NULL != pStr )
	{
		return pStr->GetString();
	}
	else
	{
		return _T("-");
	}
}

const IDPTR &CDB_PlenoRefill::GetOutSizeIDPtr()
{
	m_OutSizeIDPtr.DB = GetDB();
	Extend( &m_OutSizeIDPtr );
	return m_OutSizeIDPtr;
}

CString CDB_PlenoRefill::GetOutConnectSizeStr()
{
	CString str = _T("-");

	if( 0 != CString( _T("-") ).Compare( GetOutConnectStr() ) )
	{
		str = CString( GetOutConnectStr() );

		if( 0 != CString( _T("-") ).Compare( GetOutSizeStr() ) )
		{
			str += _T(" ") + CString( GetOutSizeStr() );
		}
	}

	return str;
}

double CDB_PlenoRefill::GetWidth( bool fWithConnection ) const
{
	if( true == fWithConnection )
	{
		return m_dWidthWConnection;
	}
	else
	{
		return m_dWidthWoConnection;
	}
}

void CDB_PlenoRefill::SetWidth( double dWidth, bool fWithConnection )
{
	if( true == fWithConnection )
	{
		m_dWidthWConnection = dWidth;
	}
	else
	{
		m_dWidthWoConnection = dWidth;
	}
}

void CDB_PlenoRefill::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_PlenoRefill *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_PlenoRefill' object!") );
		}

		// Base class.
		CDB_Product::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_PlenoRefill" class.
		CDB_PlenoRefill *pclDestinationPlenoRefill = (CDB_PlenoRefill *)pclDestination;

		pclDestinationPlenoRefill->SetFunctions( GetFunctions() );
		pclDestinationPlenoRefill->SetCapacity( GetCapacity() );
		pclDestinationPlenoRefill->SetMaxFlow( GetMaxFlow() );
		pclDestinationPlenoRefill->SetMaxSupplyWaterPressure( GetMaxSupplyWaterPressure() );
		pclDestinationPlenoRefill->SetMinSupplyWaterPressure( GetMinSupplyWaterPressure() );
		pclDestinationPlenoRefill->SetInConnectID( GetInConnectIDPtr().ID );
		pclDestinationPlenoRefill->SetInSizeID( GetInSizeIDPtr().ID );
		pclDestinationPlenoRefill->SetOutConnectID( GetOutConnectIDPtr().ID );
		pclDestinationPlenoRefill->SetOutSizeID( GetOutSizeIDPtr().ID );
		pclDestinationPlenoRefill->SetHeight( GetHeight() );
		pclDestinationPlenoRefill->SetWidth( GetWidth( true ), true );
		pclDestinationPlenoRefill->SetWidth( GetWidth( false ), false );
		pclDestinationPlenoRefill->SetWeight( GetWeight() );
		pclDestinationPlenoRefill->SetDegasserCompatible( IsDegasserCompatible() );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_PlenoRefill::Copy' method with the object '%s'."), GetIDPtr().ID )
}

void CDB_PlenoRefill::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_Product::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;
	
		if( _T('\0') != *m_InConnectIDPtr.ID && 0 != _tcscmp( _NO_ID, m_InConnectIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_InConnectIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Inlet connection ID (%s) is defined but not found in the database."), m_InConnectIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_Connect ) ) )
			{
				HYSELECT_THROW( _T("Inlet connection ID (%s) is found in the database but it's not a 'CDB_Connect' object."), m_InConnectIDPtr.ID );
			}
		}

		if( _T('\0') != *m_InSizeIDPtr.ID && 0 != _tcscmp( _NO_ID, m_InSizeIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_InSizeIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Inlet connection size ID (%s) is defined but not found in the database."), m_InSizeIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("Inlet connection size ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_InSizeIDPtr.ID );
			}
		}

		if( _T('\0') != *m_OutConnectIDPtr.ID && 0 != _tcscmp( _NO_ID, m_OutConnectIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_OutConnectIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Outlet connection ID (%s) is defined but not found in the database."), m_OutConnectIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_Connect ) ) )
			{
				HYSELECT_THROW( _T("Outlet connection ID (%s) is found in the database but it's not a 'CDB_Connect' object."), m_OutConnectIDPtr.ID );
			}
		}

		if( _T('\0') != *m_OutSizeIDPtr.ID && 0 != _tcscmp( _NO_ID, m_OutSizeIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_OutSizeIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Outlet connection size ID (%s) is defined but not found in the database."), m_OutSizeIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("Outlet connection size ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_OutSizeIDPtr.ID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_PlenoRefill::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

#define CDB_PLENOREFILL_VERSION		2
// Version 2: HYS-1232: Add the 'm_bDegasserCompatible' variable.
void CDB_PlenoRefill::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_PLENOREFILL_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CDB_Product::Write( outf );

	// Info.
	outf.write( (char *)&m_iFunctions, sizeof( m_iFunctions ) );
	WriteDouble( outf, GetCapacity() );
	WriteDouble( outf, GetMaxFlow() );
	WriteDouble( outf, GetMaxSupplyWaterPressure() );
	WriteDouble( outf, GetMinSupplyWaterPressure() );
	WriteString( outf, GetInConnectIDPtr().ID );
	WriteString( outf, GetInSizeIDPtr().ID );
	WriteString( outf, GetOutConnectIDPtr().ID );
	WriteString( outf, GetOutSizeIDPtr().ID );
	WriteDouble( outf, GetHeight() );
	WriteDouble( outf, GetWidth() );
	WriteDouble( outf, GetWidth( false ) );
	WriteDouble( outf, GetWeight() );

	// Version 2: HYS-1232: add the 'm_bDegasserCompatible' variable.
	outf.write( (char *)&m_bDegasserCompatible, sizeof( m_bDegasserCompatible ) );
}

bool CDB_PlenoRefill::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );
	
	if( Version < 1 || Version > CDB_PLENOREFILL_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDB_Product::Read( inpf ) )
	{
		return false;
	}

	inpf.read( (char *)&m_iFunctions, sizeof( m_iFunctions ) );

	SetCapacity( ReadDouble( inpf ) );
	SetMaxFlow( ReadDouble( inpf ) );
	SetMaxSupplyWaterPressure( ReadDouble( inpf ) );
	SetMinSupplyWaterPressure( ReadDouble( inpf ) );

	if( false == ReadString( inpf, m_InConnectIDPtr.ID, sizeof( m_InConnectIDPtr.ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_InSizeIDPtr.ID, sizeof( m_InSizeIDPtr.ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_OutConnectIDPtr.ID, sizeof( m_OutConnectIDPtr.ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_OutSizeIDPtr.ID, sizeof( m_OutSizeIDPtr.ID ) ) )
	{
		return false;
	}

	SetHeight( ReadDouble( inpf ) );
	SetWidth( ReadDouble( inpf ), true );
	SetWidth( ReadDouble( inpf ), false );
	SetWeight( ReadDouble( inpf ) );

	if( Version < 2 )
	{
		return true;
	}

	// Version 2: HYS-1232: add the 'm_bDegasserCompatible' variable.
	inpf.read( (char *)&m_bDegasserCompatible, sizeof( m_bDegasserCompatible ) );

	return true;
}

#define PLENOREFILL_Functions			_T("::Functions=")
#define PLENOREFILL_Capacity			_T("::Capacity=")
#define PLENOREFILL_MaxFlow				_T("::MaxFlow=")
#define PLENOREFILL_MaxSupplyWaterP		_T("::MaxSupplyWaterP=")
#define PLENOREFILL_MinSupplyWaterP		_T("::MinSupplyWaterP=")
#define PLENOREFILL_InConnectID    		_T("::InConnectID=")
#define PLENOREFILL_InSizeID    		_T("::InSizeID=")
#define PLENOREFILL_OutConnectID    	_T("::OutConnectID=")
#define PLENOREFILL_OutSizeID    		_T("::OutSizeID=")
#define PLENOREFILL_Height       		_T("::Height=")
#define PLENOREFILL_WidthWoConnect     	_T("::WidthWoConnect=")
#define PLENOREFILL_WidthWConnect     	_T("::WidthWConnect=")
#define PLENOREFILL_Weight       		_T("::Weight=")
#define PLENOREFILL_DegasserCompatible	_T("::DegasserCompatible=")

void CDB_PlenoRefill::InterpretInheritedData( CString* pStr )
{
	try
	{
		// Base class.
		int ipos = pStr->Find( CLASS( CDB_PlenoRefill ) );
	
		if( pStr->Left( 2 ) != _T("::") && ipos < 0 )
		{
			CDB_Product::InterpretInheritedData( pStr );
		}
		else
		{
			if( ipos >= 0 )
			{
				pStr->Delete( ipos, _tcsclen( CLASS( CDB_PlenoRefill ) ) );
			}

			int iEq = pStr->Find( _T("=") );

			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( PLENOREFILL_Functions ) > -1 )
			{
				m_iFunctions = ReadEnum( strField );

				if( m_iFunctions != ePRFunctions::ePRFunc_None && m_iFunctions != ePRFunctions::ePRFunc_Soft && m_iFunctions != ePRFunctions::ePRFunc_Desalin )
				{
					HYSELECT_THROW( _T("'CDB_PlenoRefill::Functions' value must be one of these values: '#ePRFunc_None', '#ePRFunc_Soft' or '#ePRFunc_Desalin'.") );
				}
			}
			else if( pStr->Find( PLENOREFILL_Capacity ) > -1 )
			{
				m_dCapacity = _ttof( (LPCTSTR)strField );

				// In case of 'Refill Filter' this value is not needed.
				if( m_dCapacity <= 0.0 && -1.0 != m_dCapacity )
				{
					HYSELECT_THROW( _T("'CDB_PlenoRefill::Capacity' (%f) must be equal to -1.0 or greather than 0.0."), m_dCapacity );
				}
			}
			else if( pStr->Find( PLENOREFILL_MaxFlow ) > -1 )
			{
				m_dMaxFlow = _ttof( (LPCTSTR)strField );
			
				if( m_dMaxFlow <= 0.0 && -1.0 != m_dMaxFlow )
				{
					HYSELECT_THROW( _T("'CDB_PlenoRefill::MaxFlow' (%f) must be equal to -1.0 or greather than 0.0."), m_dMaxFlow );
				}
			}
			else if( pStr->Find( PLENOREFILL_MaxSupplyWaterP ) > -1 )
			{
				m_dMaxSupplyWaterPressure = _ttof( (LPCTSTR)strField );

				if( m_dMaxSupplyWaterPressure <= 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_PlenoRefill::MaxSupplyWaterP' (%f) can't be lower or equal to 0.0."), m_dMaxSupplyWaterPressure );
				}
			}
			else if( pStr->Find( PLENOREFILL_MinSupplyWaterP ) > -1 )
			{
				m_dMinSupplyWaterPressure = _ttof( (LPCTSTR)strField );
			
				if( m_dMinSupplyWaterPressure <= 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_PlenoRefill::MinSupplyWaterP' (%f) can't be lower or equal to 0.0."), m_dMinSupplyWaterPressure );
				}
			}
			else if( pStr->Find( PLENOREFILL_InConnectID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_PlenoRefill::InConnectID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetInConnectID( (LPCTSTR)strField );
			}
			else if( pStr->Find( PLENOREFILL_InSizeID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_PlenoRefill::InSizeID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetInSizeID( (LPCTSTR)strField );
			}
			else if( pStr->Find( PLENOREFILL_OutConnectID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_PlenoRefill::OutConnectID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetOutConnectID( (LPCTSTR)strField );
			}
			else if( pStr->Find( PLENOREFILL_OutSizeID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_PlenoRefill::OutSizeID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetOutSizeID( (LPCTSTR)strField );
			}
			else if( pStr->Find( PLENOREFILL_Height ) > -1 )
			{
				m_dHeight = _ttof( (LPCTSTR)strField );

				if( m_dHeight <= 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_PlenoRefill::Height' (%f) can't be lower or equal to 0.0."), m_dHeight );
				}
			}
			else if( pStr->Find( PLENOREFILL_WidthWoConnect ) > -1 )
			{
				m_dWidthWoConnection = _ttof( (LPCTSTR)strField );

				if( m_dWidthWoConnection <= 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_PlenoRefill::WidthWoConnect' (%f) can't be lower or equal to 0.0."), m_dWidthWoConnection );
				}
			}
			else if( pStr->Find( PLENOREFILL_WidthWConnect ) > -1 )
			{
				m_dWidthWConnection = _ttof( (LPCTSTR)strField );
			
				// If "Refill 6000 Module" there is no connection than this value is set to -1.
				if( m_dWidthWConnection <= 0.0 && -1.0 != m_dWidthWConnection )
				{
					HYSELECT_THROW( _T("'CDB_PlenoRefill::WidthWConnect' (%f) must be equal to -1.0 or greather than 0.0."), m_dWidthWConnection );
				}
			}
			else if( pStr->Find( PLENOREFILL_Weight ) > -1 )
			{
				m_dWeight = _ttof( (LPCTSTR)strField );

				if( m_dWeight <= 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_PlenoRefill::Weight' (%f) can't be lower or equal to 0.0."), m_dWeight );
				}
			}
			else if( pStr->Find( PLENOREFILL_DegasserCompatible ) > -1 )
			{
				m_bDegasserCompatible = ( 0 == _ttoi( (LPCTSTR)strField ) ) ? false : true;
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_PlenoRefill::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_PlenoRefill::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		//		Function			#ePRFunc_None/#ePRFunc_Soft/#ePRFunc_Desalin
		//		Capacity			double ( l*dH -> SI: m3*mol/m3 = mol)
		//		MaxFlow				double (m3/s)
		//		MaxSupplyWaterP		double (pa)
		//		MinSupplyWaterP		double (pa)
		//		InConnectID			string ID
		//		InSizeID			string ID
		//		OutConnectID		string ID
		//		OutSizeID			string ID
		//		Height				double (m)
		//		WidthWoConnect		double (m )
		//		WidthWConnect		double (m)	
		//		Weight				double (kg)
		//		DegasserCompatible	0/1

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}
		
			( (CDB_PlenoRefill *)idptr.MP )->Copy( this );
		
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );
			
				CDB_PlenoRefill::InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_Product::ReadText( inpf, pusLineCount );
	
			CStringArray TxtHdr;
			TxtHdr.Add( PLENOREFILL_Functions );
			TxtHdr.Add( PLENOREFILL_Capacity );
			TxtHdr.Add( PLENOREFILL_MaxFlow );
			TxtHdr.Add( PLENOREFILL_MaxSupplyWaterP );
			TxtHdr.Add( PLENOREFILL_MinSupplyWaterP );
			TxtHdr.Add( PLENOREFILL_InConnectID );
			TxtHdr.Add( PLENOREFILL_InSizeID );
			TxtHdr.Add( PLENOREFILL_OutConnectID );
			TxtHdr.Add( PLENOREFILL_OutSizeID );
			TxtHdr.Add( PLENOREFILL_Height );
			TxtHdr.Add( PLENOREFILL_WidthWoConnect );
			TxtHdr.Add( PLENOREFILL_WidthWConnect );
			TxtHdr.Add( PLENOREFILL_Weight );
			TxtHdr.Add( PLENOREFILL_DegasserCompatible );
		
			for( int i = 0; i < TxtHdr.GetSize(); i++ )
			{
				ptcLine = ReadTextLine(inpf, pusLineCount);

				CString str = TxtHdr[i] + CString( ptcLine );
				CDB_PlenoRefill::InterpretInheritedData( &str );
			}
		}
	
		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_PlenoRefill::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_TotalHardnessCharacteristic
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_TotalHardnessCharacteristic)

CDB_TotalHardnessCharacteristic::CDB_TotalHardnessCharacteristic( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
}

CDB_TotalHardnessCharacteristic::~CDB_TotalHardnessCharacteristic()
{
	_Reset();
}

double CDB_TotalHardnessCharacteristic::GetTotalHardnessOfSystem( double dTotalHeatLoad, double dSpecificVolume )
{
	if( 0 == m_rArray.m_iRows || 0 == m_rArray.m_iCols || NULL == m_rArray.m_prTotalHeatLoadIndex || NULL == m_rArray.m_prSpecificVolumeIndex
			|| NULL == m_rArray.m_pardMaxAdmissibleHardness )
	{
		return -1.0;
	}
	
	// Remark: 'THL' is for 'Total Heat Load'.
	int iRowIndex = -1;

	for( int iLoopTHL = 0; iLoopTHL < m_rArray.m_iRows; iLoopTHL++ )
	{
		// HYS-36: don't verify upper limit it this one is -1.
		if( dTotalHeatLoad >= m_rArray.m_prTotalHeatLoadIndex[iLoopTHL].m_dMin
				&& ( -1 == m_rArray.m_prTotalHeatLoadIndex[iLoopTHL].m_dMax || dTotalHeatLoad < m_rArray.m_prTotalHeatLoadIndex[iLoopTHL].m_dMax ) )
		{
			iRowIndex = iLoopTHL;
			break;
		}
	}

	if( -1 == iRowIndex )
	{
		return -1.0;
	}

	// Remark: 'SV' is for 'Specific Volume'.
	int iColIndex = -1;

	for( int iLoopSV = 0; iLoopSV < m_rArray.m_iCols; iLoopSV++ )
	{
		// HYS-36: don't verify upper limit it this one is -1.
		if( dSpecificVolume >= m_rArray.m_prSpecificVolumeIndex[iLoopSV].m_dMin
				&& ( -1 == m_rArray.m_prSpecificVolumeIndex[iLoopSV].m_dMax || dSpecificVolume < m_rArray.m_prSpecificVolumeIndex[iLoopSV].m_dMax ) )
		{
			iColIndex = iLoopSV;
			break;
		}
	}

	if( -1 == iColIndex )
	{
		return -1.0;
	}

	return m_rArray.m_pardMaxAdmissibleHardness[iRowIndex * m_rArray.m_iCols + iColIndex];
}

void CDB_TotalHardnessCharacteristic::CopyAllArray( AllArray *parDestinationAllArray )
{
	HYSELECT_TRY
	{
		_Reset();

		if( NULL == parDestinationAllArray )
		{
			HYSELECT_THROW( _T("Internal error: 'parDestinationAllArray' can't be NULL.") );
		}

		if( 0 == m_rArray.m_iRows || 0 == m_rArray.m_iCols )
		{
			return;
		}

		parDestinationAllArray->m_iRows = m_rArray.m_iRows;
		parDestinationAllArray->m_iCols = m_rArray.m_iCols;

		parDestinationAllArray->m_prTotalHeatLoadIndex = new MinMax[m_rArray.m_iRows];

		if( NULL == parDestinationAllArray->m_prTotalHeatLoadIndex )
		{
			HYSELECT_THROW( _T("Internal error: 'parDestinationAllArray->m_prTotalHeatLoadIndex' instantiation error.") );
		}

		parDestinationAllArray->m_prSpecificVolumeIndex = new MinMax[m_rArray.m_iCols];

		if( NULL == parDestinationAllArray->m_prSpecificVolumeIndex )
		{
			HYSELECT_THROW( _T("Internal error: 'parDestinationAllArray->m_prSpecificVolumeIndex' instantiation error.") );
		}

		parDestinationAllArray->m_pardMaxAdmissibleHardness = new double[m_rArray.m_iRows * m_rArray.m_iCols];

		if( NULL == parDestinationAllArray->m_pardMaxAdmissibleHardness )
		{
			HYSELECT_THROW( _T("Internal error: 'parDestinationAllArray->m_pardMaxAdmissibleHardness' instantiation error.") );
		}

		CopyMemory( parDestinationAllArray->m_prTotalHeatLoadIndex, m_rArray.m_prTotalHeatLoadIndex, m_rArray.m_iRows * sizeof( MinMax ) );
		CopyMemory( parDestinationAllArray->m_prSpecificVolumeIndex, m_rArray.m_prSpecificVolumeIndex, m_rArray.m_iCols * sizeof( MinMax ) );
		CopyMemory( parDestinationAllArray->m_pardMaxAdmissibleHardness, m_rArray.m_pardMaxAdmissibleHardness, m_rArray.m_iRows * m_rArray.m_iCols * sizeof( double ) );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_TotalHardnessCharacteristic::CopyAllArray' method with the object '%s'."), GetIDPtr().ID )
}

void CDB_TotalHardnessCharacteristic::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_TotalHardnessCharacteristic *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_TotalHardnessCharacteristic' object!") );
		}

		// Base class.
		CData::Copy( pclDestination );

		// Copy now what it is common to the "CDB_TotalHardnessCharacteristic" class.
		CDB_TotalHardnessCharacteristic *pclDestinationTotalHardnessCharacteristic = (CDB_TotalHardnessCharacteristic *)( pclDestination );

		if( NULL == pclDestinationTotalHardnessCharacteristic->GetArray() )
		{
			return;
		}

		CopyAllArray( pclDestinationTotalHardnessCharacteristic->GetArray() );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_TotalHardnessCharacteristic::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_TOTALHARDNESSCHARACTERISTIC_VERSION		1
void CDB_TotalHardnessCharacteristic::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_TOTALHARDNESSCHARACTERISTIC_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CData::Write( outf );

	// Number of rows.
	outf.write( (char *)&m_rArray.m_iRows, sizeof( m_rArray.m_iRows ) );
	outf.write( (char *)&m_rArray.m_iCols, sizeof( m_rArray.m_iCols ) );

	if( 0 == m_rArray.m_iRows || 0 == m_rArray.m_iCols )
	{
		return;
	}

	for( int iLoopRow = 0; iLoopRow < m_rArray.m_iRows; iLoopRow++ )
	{
		outf.write( (char *)&m_rArray.m_prTotalHeatLoadIndex[iLoopRow].m_dMin, sizeof( double ) );
		outf.write( (char *)&m_rArray.m_prTotalHeatLoadIndex[iLoopRow].m_dMax, sizeof( double ) );
	}

	for( int iLoopCol = 0; iLoopCol < m_rArray.m_iCols; iLoopCol++ )
	{
		outf.write( (char *)&m_rArray.m_prSpecificVolumeIndex[iLoopCol].m_dMin, sizeof( double ) );
		outf.write( (char *)&m_rArray.m_prSpecificVolumeIndex[iLoopCol].m_dMax, sizeof( double ) );
	}

	for( int iLoopValue = 0; iLoopValue < m_rArray.m_iRows * m_rArray.m_iCols; iLoopValue++ )
	{
		outf.write( (char *)&m_rArray.m_pardMaxAdmissibleHardness[iLoopValue], sizeof( double ) );
	}
}

bool CDB_TotalHardnessCharacteristic::Read( INPSTREAM  inpf )
{
	_Reset();

	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_TOTALHARDNESSCHARACTERISTIC_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Number of data.
	inpf.read( (char *)&m_rArray.m_iRows, sizeof( m_rArray.m_iRows ) );
	inpf.read( (char *)&m_rArray.m_iCols, sizeof( m_rArray.m_iCols ) );
		
	if( 0 == m_rArray.m_iRows || 0 == m_rArray.m_iCols )
	{
		_Reset();
		return false;
	}

	m_rArray.m_prTotalHeatLoadIndex = new MinMax[m_rArray.m_iRows];
	m_rArray.m_prSpecificVolumeIndex = new MinMax[m_rArray.m_iCols];
	m_rArray.m_pardMaxAdmissibleHardness = new double[m_rArray.m_iRows * m_rArray.m_iCols];

	if( NULL == m_rArray.m_prTotalHeatLoadIndex || NULL == m_rArray.m_prSpecificVolumeIndex || NULL == m_rArray.m_pardMaxAdmissibleHardness )
	{
		_Reset();
		return false;
	}

	for( int iLoopRow = 0; iLoopRow < m_rArray.m_iRows; iLoopRow++ )
	{
		inpf.read( (char *)&m_rArray.m_prTotalHeatLoadIndex[iLoopRow].m_dMin, sizeof( double ) );
		inpf.read( (char *)&m_rArray.m_prTotalHeatLoadIndex[iLoopRow].m_dMax, sizeof( double ) );
	}

	for( int iLoopCol = 0; iLoopCol < m_rArray.m_iCols; iLoopCol++ )
	{
		inpf.read( (char *)&m_rArray.m_prSpecificVolumeIndex[iLoopCol].m_dMin, sizeof( double ) );
		inpf.read( (char *)&m_rArray.m_prSpecificVolumeIndex[iLoopCol].m_dMax, sizeof( double ) );
	}

	for( int iLoopValue = 0; iLoopValue < m_rArray.m_iRows * m_rArray.m_iCols; iLoopValue++ )
	{
		inpf.read( (char *)&m_rArray.m_pardMaxAdmissibleHardness[iLoopValue], sizeof( double ) );
	}

	return true;
}

void CDB_TotalHardnessCharacteristic::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_TotalHardnessCharacteristic format
		// line 0 : open curve bracket and call base class
		// line 1 : number of horizontal entries (excluding the definition of all VA ranges).
		// line 2 : number of vertical entries (It's in fact the number of VA range defined!!)
		// line 2 : definitions of all VA ranges ( -1.0 / -1.0 / VA min 1 / VA max 1 / VA min 2 / VA max 2 / ... )
		// line 3 to n-1 : definitions of THL min / THL max / dH1 / dH2 / ...
		// line n : close curve bracket

		_Reset();

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			// Reach the close curve bracket.
			while( _T('}') != *ptcLine )
			{
				ptcLine = ReadTextLine( inpf, pusLineCount );
			}

			HYSELECT_THROW( _T("No inheritance available for this object (pos: %i)."), *pusLineCount );
		}

		// Read base.
		CData::ReadText( inpf, pusLineCount );

		TCHAR *ptcEndPtr;

		// Read the number of horizontal entries.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		int iRows = _ttoi( ptcLine );

		if( iRows <= 0 )
		{
			HYSELECT_THROW( _T("At least one row must be defined (pos: %i)."), *pusLineCount );
		}

		// Read the number of vertical entries.
		ptcLine = ReadTextLine( inpf, pusLineCount );
	
		int iCols = _ttoi( ptcLine );

		if( iCols <= 0 )
		{
			HYSELECT_THROW( _T("At least one column by row must be defined (pos: %i)."), *pusLineCount );
		}

		if( iRows > 0 && iCols > 0 )
		{
			m_rArray.m_iRows = iRows;
			m_rArray.m_iCols = iCols;
			m_rArray.m_prTotalHeatLoadIndex = new MinMax[m_rArray.m_iRows];
			m_rArray.m_prSpecificVolumeIndex = new MinMax[m_rArray.m_iCols];
			m_rArray.m_pardMaxAdmissibleHardness = new double[m_rArray.m_iRows * m_rArray.m_iCols];

			if( NULL == m_rArray.m_prTotalHeatLoadIndex )
			{
				_Reset();
				HYSELECT_THROW( _T("Internal error: 'm_rArray.m_prTotalHeatLoadIndex' instantiation error (pos: %i)."), *pusLineCount );
			}
			else if( NULL == m_rArray.m_prSpecificVolumeIndex )
			{
				_Reset();
				HYSELECT_THROW( _T("Internal error: ' m_rArray.m_prSpecificVolumeIndex' instantiation error (pos: %i)."), *pusLineCount );
			}
			else if( NULL == m_rArray.m_pardMaxAdmissibleHardness )
			{
				_Reset();
				HYSELECT_THROW( _T("Internal error: 'm_rArray.m_pardMaxAdmissibleHardness' instantiation error (pos: %i)."), *pusLineCount );
			}

			// Read the first line (VA range definitions).
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _T('}') == *ptcLine )
			{
				HYSELECT_THROW( _T("Unexpected '}' (pos: %i)."), *pusLineCount );
			}

			int iCheck = 0;
			TCHAR **pptcField = ParseTextLine( ptcLine, &iCheck );

			// First two columns are for Total Heat Load range definition (min, max) and 2 * iCols for VA range definition.
			if( iCheck != ( 2 + 2 * iCols ) )
			{
				HYSELECT_THROW( _T("The current line has not the correct number of tokens (%i != %i) (pos: %i)."), iCheck, ( 2 + 2 * iCols ), *pusLineCount );
			}

			int iCount = 2;
		
			for( int iLoopVADefs = 0; iLoopVADefs < iCols; iLoopVADefs++ )
			{
				m_rArray.m_prSpecificVolumeIndex[iLoopVADefs].m_dMin = _tcstod( pptcField[iCount++], &ptcEndPtr );

				if( _T('\0') != *ptcEndPtr )
				{
					HYSELECT_THROW( _T("Can't convert VA range min %i (%s) in double (pos: %i)."), iLoopVADefs, ptcLine, *pusLineCount );
				}

				m_rArray.m_prSpecificVolumeIndex[iLoopVADefs].m_dMax = _tcstod( pptcField[iCount++], &ptcEndPtr );

				if( _T('\0') != *ptcEndPtr )
				{
					HYSELECT_THROW( _T("Can't convert VA range max %i (%s) in double (pos: %i)."), iLoopVADefs, ptcLine, *pusLineCount );
				}
			}

			// Start the loop on lines.
			iCount = 0;

			for( int iLoopRow = 0; iLoopRow < iRows; iLoopRow++ )
			{
				ptcLine = ReadTextLine( inpf, pusLineCount );

				if( _T('}') == *ptcLine )
				{
					HYSELECT_THROW( _T("Unexpected '}' (pos: %i)."), *pusLineCount );
				}

				iCheck = 0;
				pptcField = ParseTextLine( ptcLine, &iCheck );

				if( iCheck != 2 + iCols )
				{
					HYSELECT_THROW( _T("The current line has not the correct number of tokens (%i != %i) (pos: %i)."), iCheck, ( 2 + iCols ), *pusLineCount );
				}

				m_rArray.m_prTotalHeatLoadIndex[iLoopRow].m_dMin = _tcstod( pptcField[0], &ptcEndPtr );

				if( _T('\0') != *ptcEndPtr )
				{
					HYSELECT_THROW( _T("Can't convert total heat load range min (%s) in double (pos: %i)."), pptcField[0], *pusLineCount );
				}

				m_rArray.m_prTotalHeatLoadIndex[iLoopRow].m_dMax = _tcstod( pptcField[1], &ptcEndPtr );

				if( _T('\0') != *ptcEndPtr )
				{
					HYSELECT_THROW( _T("Can't convert total heat load range max (%s) in double (pos: %i)."), pptcField[1], *pusLineCount );
				}

				for( int iLoopHardness = 0; iLoopHardness < iCols; iLoopHardness++ )
				{
					m_rArray.m_pardMaxAdmissibleHardness[iCount++] = _tcstod( pptcField[2 + iLoopHardness], &ptcEndPtr );

					if( _T('\0') != *ptcEndPtr )
					{
						HYSELECT_THROW( _T("Can't convert total hardness for VA range %i (%s) in double (pos: %i)."), iLoopHardness, pptcField[2 + iLoopHardness], *pusLineCount );
					}
				}
			}
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_TotalHardnessCharacteristic::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_TotalHardnessCharacteristic::_Reset()
{
	if( NULL != m_rArray.m_prTotalHeatLoadIndex )
	{
		delete[] m_rArray.m_prTotalHeatLoadIndex;
	}

	if( NULL != m_rArray.m_prSpecificVolumeIndex )
	{
		delete[] m_rArray.m_prSpecificVolumeIndex;
	}

	if( NULL != m_rArray.m_pardMaxAdmissibleHardness )
	{
		delete[] m_rArray.m_pardMaxAdmissibleHardness;
	}
}
#endif


#ifndef TACBX
///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_SafetyValveBase
//
///////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DATA( CDB_SafetyValveBase )
CDB_SafetyValveBase::CDB_SafetyValveBase( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_TAProduct( pDataBase, ID )
{
	m_eApplicationCompatibility = InvalidProjectType;
	m_dSetPressure = 0.0;
	m_strMediumNameID[0] = _T('\0');
	m_strLiftingTypeID[0] = _T('\0');
	m_dTopOutHeight = 0.0;
	m_dOutBotHeight = 0.0;
	m_dWidth = 0.0;
	m_dWeight = 0.0;
	m_BlowTankAllocationTableIDPtr = _NULL_IDPTR;
}

CString CDB_SafetyValveBase::GetInOutletConnectionString()
{
	CString strResult = GetConnect();
	CString strOutlet = GetConnect2();

	if( strResult != strOutlet )
	{
		strResult += CString( _T("/") ) + strOutlet;
	}

	return strResult;
}

CString CDB_SafetyValveBase::GetInOutletSizeString()
{
	CString strResult = GetInletSizeStr() + CString( _T(" / ") ) + GetOutletSizeStr();
	return strResult;
}

CString CDB_SafetyValveBase::GetInOutletConnectionSizeString()
{
	CString strConnect = GetInOutletConnectionString();
	CString strSize = GetInOutletSizeString();
	CString strResult = strConnect + _T(" (" ) + strSize + _T(")");
	return strResult;
}

const IDPTR &CDB_SafetyValveBase::GetMediumNameIDPtr()
{
	if( 0 == _tcscmp( _NO_ID, m_strMediumNameID ) )
	{
		return GetDB()->Get( _T("") );
	}
	else
	{
		return GetDB()->Get( m_strMediumNameID );
	}
}

CString CDB_SafetyValveBase::GetMediumName()
{
	IDPTR MediumNameIDPtr = GetMediumNameIDPtr();

	if( NULL != MediumNameIDPtr.MP )
	{
		CDB_StringID *pStr = (CDB_StringID *)( MediumNameIDPtr.MP );
		return pStr->GetString();
	}
	else
	{
		return _T("");
	}
}

const IDPTR &CDB_SafetyValveBase::GetLiftingTypeIDPtr()
{
	if( 0 == _tcscmp( _NO_ID, m_strLiftingTypeID ) )
	{
		return GetDB()->Get( _T("") );
	}
	else
	{
		return GetDB()->Get( m_strLiftingTypeID );
	}
}
	
CString CDB_SafetyValveBase::GetLiftingType()
{
	IDPTR LiftingTypeIDPtr = GetLiftingTypeIDPtr();

	if( NULL != LiftingTypeIDPtr.MP )
	{
		CDB_StringID *pStr = (CDB_StringID *)( LiftingTypeIDPtr.MP );
		return pStr->GetString();
	}
	else
	{
		return _T("");
	}
}

IDPTR CDB_SafetyValveBase::GetBlowTankAllocationTableIDPtr()
{
	if( NULL == m_BlowTankAllocationTableIDPtr.MP )
	{
		if( _T('\0') !=  *m_BlowTankAllocationTableIDPtr.ID && 0 != IDcmp( m_BlowTankAllocationTableIDPtr.ID, _NO_ID ) )
		{
			m_BlowTankAllocationTableIDPtr.DB = GetDB();
			Extend( &m_BlowTankAllocationTableIDPtr );
		}
	}
	
	return m_BlowTankAllocationTableIDPtr;
}

CDB_BlowTankAllocation *CDB_SafetyValveBase::GetBlowTankAllocationTable()
{ 
	return dynamic_cast<CDB_BlowTankAllocation *>( GetBlowTankAllocationTableIDPtr().MP );
}

void CDB_SafetyValveBase::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_SafetyValveBase *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_SafetyValveBase' object!") );
		}

		// Base class.
		CDB_TAProduct::Copy( pclDestination );

		// Copy now what it is common to the "CDB_SafetyValveBase" class.
		CDB_SafetyValveBase *pclDestinationSafetyValveBase = (CDB_SafetyValveBase *)pclDestination;

		pclDestinationSafetyValveBase->SetApplicationCompatibility( m_eApplicationCompatibility );
		pclDestinationSafetyValveBase->SetSetPressure( m_dSetPressure );
		pclDestinationSafetyValveBase->SetMediumNameID( m_strMediumNameID );
		pclDestinationSafetyValveBase->SetLiftingTypeID( m_strLiftingTypeID );
		pclDestinationSafetyValveBase->SetTopOutHeight( m_dTopOutHeight );
		pclDestinationSafetyValveBase->SetOutBotHeight( m_dOutBotHeight );
		pclDestinationSafetyValveBase->SetWidth( m_dWidth );
		pclDestinationSafetyValveBase->SetWeight( m_dWeight );
		pclDestinationSafetyValveBase->SetBlowTankAllocationTableID( m_BlowTankAllocationTableIDPtr.ID );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_SafetyValveBase::Copy' method with the object '%s'."), GetIDPtr().ID )
}

void CDB_SafetyValveBase::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_TAProduct::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( _T('\0') != *m_strMediumNameID && 0 != _tcscmp( _NO_ID, m_strMediumNameID ) )
		{
			IDPtr = GetDB()->Get( m_strMediumNameID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Medium type ID (%s) is defined but not found in the database."), m_strMediumNameID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("Medium type ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_strMediumNameID );
			}
		}

		if( _T('\0') != *m_strLiftingTypeID && 0 != _tcscmp( _NO_ID, m_strLiftingTypeID ) )
		{
			IDPtr = GetDB()->Get( m_strLiftingTypeID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Lifting type ID (%s) is defined but not found in the database."), m_strLiftingTypeID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("Lifting type ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_strLiftingTypeID );
			}
		}

		if( _T('\0') !=  *m_BlowTankAllocationTableIDPtr.ID && 0 != _tcscmp( _NO_ID, m_BlowTankAllocationTableIDPtr.ID ) )
		{
			IDPTR IDPtr = GetDB()->Get( m_BlowTankAllocationTableIDPtr.ID );
		
			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Blow tank allocation table ID (%s) is defined but not found in the database."), m_BlowTankAllocationTableIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_BlowTankAllocation ) ) )
			{
				HYSELECT_THROW( _T("Blow tank allocation table ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_BlowTankAllocationTableIDPtr.ID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_SafetyValveBase::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

#define CDB_SAFETYVALVEBASE_VERSION		1
void CDB_SafetyValveBase::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_SAFETYVALVEBASE_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CDB_TAProduct::Write( outf );

	// Info.
	outf.write( (char *)&m_eApplicationCompatibility, sizeof( m_eApplicationCompatibility ) );
	WriteDouble( outf, m_dSetPressure );
	WriteString( outf, m_strMediumNameID );
	WriteString( outf, m_strLiftingTypeID );
	WriteDouble( outf, m_dTopOutHeight );
	WriteDouble( outf, m_dOutBotHeight );
	WriteDouble( outf, m_dWidth );
	WriteDouble( outf, m_dWeight );
	WriteString( outf, (LPCTSTR)m_BlowTankAllocationTableIDPtr.ID );
}

bool CDB_SafetyValveBase::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_SAFETYVALVEBASE_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDB_TAProduct::Read( inpf ) )
	{
		return false;
	}

	// Info.
	inpf.read( (char *)&m_eApplicationCompatibility, sizeof( m_eApplicationCompatibility ) );
	inpf.read( (char *)&m_dSetPressure, sizeof( m_dSetPressure ) );

	if( false == ReadString( inpf, m_strMediumNameID, sizeof( m_strMediumNameID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strLiftingTypeID, sizeof( m_strLiftingTypeID ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_dTopOutHeight, sizeof( m_dTopOutHeight ) );
	inpf.read( (char *)&m_dOutBotHeight, sizeof( m_dOutBotHeight ) );
	inpf.read( (char *)&m_dWidth, sizeof( m_dWidth ) );
	inpf.read( (char *)&m_dWeight, sizeof( m_dWeight ) );

	if( false == ReadString( inpf, m_BlowTankAllocationTableIDPtr.ID, sizeof( m_BlowTankAllocationTableIDPtr.ID ) ) )
	{
		return false;
	}

	return true;
}

// Remark: 'ProjectType' is read in the inherited class.
#define SafetyValveBase_SetPressure			_T("::SetPressure=")
#define SafetyValveBase_MediumNameID		_T("::MediumNameID=")
#define SafetyValveBase_LiftingTypeID		_T("::LiftingTypeID=")
#define SafetyValveBase_TopOutHeight		_T("::TopOutHeight=")
#define SafetyValveBase_OutBotHeight		_T("::OutBotHeight=")
#define SafetyValveBase_Width				_T("::Width=")
#define SafetyValveBase_Weight				_T("::Weight=")
#define SafetyValveBase_BlowTankTableID		_T("::BlowTankTableID=")

void CDB_SafetyValveBase::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int ipos = pStr->Find( CLASS( CDB_SafetyValveBase ) );
	
		if( _T("::") != pStr->Left( 2 ) && ipos < 0 )
		{
			CDB_TAProduct::InterpretInheritedData( pStr );
		}
		else
		{
			if( ipos >= 0 )
			{
				pStr->Delete( ipos, _tcsclen( CLASS( CDB_SafetyValveBase ) ) );
			}

			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );
		
			if( pStr->Find( SafetyValveBase_SetPressure ) > -1 )
			{
				m_dSetPressure = _ttof( (LPCTSTR)strField );
			}
			else if( pStr->Find( SafetyValveBase_MediumNameID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_SafetyValveBase::MediumNameID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				_tcsncpy_s( m_strMediumNameID, SIZEOFINTCHAR( m_strMediumNameID ), (LPCTSTR)strField, SIZEOFINTCHAR( m_strMediumNameID ) - 1 );
			}
			else if( pStr->Find( SafetyValveBase_LiftingTypeID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_SafetyValveBase::LiftingTypeID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				_tcsncpy_s( m_strLiftingTypeID, SIZEOFINTCHAR( m_strLiftingTypeID ), (LPCTSTR)strField, SIZEOFINTCHAR( m_strLiftingTypeID ) - 1 );
			}
			else if( pStr->Find( SafetyValveBase_TopOutHeight ) > -1 )
			{
				m_dTopOutHeight = _ttof( (LPCTSTR)strField );
			}
			else if( pStr->Find( SafetyValveBase_OutBotHeight ) > -1 )
			{
				m_dOutBotHeight = _ttof( (LPCTSTR)strField );
			}
			else if( pStr->Find( SafetyValveBase_Width ) > -1 )
			{
				m_dWidth = _ttof( (LPCTSTR)strField );
			}
			else if( pStr->Find( SafetyValveBase_Weight ) > -1 )
			{
				m_dWeight = _ttof( (LPCTSTR)strField );
			}
			else if( pStr->Find( SafetyValveBase_BlowTankTableID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_SafetyValveBase::BlowTankTableID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				PurgeString( m_BlowTankAllocationTableIDPtr.ID, strField, SIZEOFINTCHAR( m_BlowTankAllocationTableIDPtr.ID ) );
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_SafetyValveBase::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_SafetyValveBase::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_SafetyValveBase *)idptr.MP)->Copy( this );
			
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				CDB_SafetyValveBase::InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_TAProduct::ReadText( inpf, pusLineCount );

			CStringArray TxtHdr;
			TxtHdr.Add( SafetyValveBase_SetPressure );
			TxtHdr.Add( SafetyValveBase_MediumNameID );
			TxtHdr.Add( SafetyValveBase_LiftingTypeID );
			TxtHdr.Add( SafetyValveBase_TopOutHeight );
			TxtHdr.Add( SafetyValveBase_OutBotHeight );
			TxtHdr.Add( SafetyValveBase_Width );
			TxtHdr.Add( SafetyValveBase_Weight );
			TxtHdr.Add( SafetyValveBase_BlowTankTableID );
	
			for( int i = 0; i < TxtHdr.GetSize(); i++ )
			{
				ptcLine = ReadTextLine( inpf, pusLineCount );

				CString str = TxtHdr[i] + CString( ptcLine );
				CDB_SafetyValveBase::InterpretInheritedData( &str );
			}
		}
	
		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}

		if( 0 == CString( GetTypeID() ).Compare( _T("SFTYVTYPE_H") ) )
		{
			m_eApplicationCompatibility = ProjectType::Heating;
		}
		else if( 0 == CString( GetTypeID() ).Compare( _T("SFTYVTYPE_C") ) )
		{
			m_eApplicationCompatibility = ProjectType::Cooling;
		}
		else if( 0 == CString( GetTypeID() ).Compare( _T("SFTYVTYPE_S") ) )
		{
			m_eApplicationCompatibility = ProjectType::Solar;
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_SafetyValveBase::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_SafetyValveHeating
//
///////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DATA( CDB_SafetyValveHeating )
CDB_SafetyValveHeating::CDB_SafetyValveHeating( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_SafetyValveBase( pDataBase, ID )
{
}

double CDB_SafetyValveHeating::GetPowerLimit( CString strHeatGeneratorTypeID, CString strNormID )
{
	double dPowerLimit = 0.0;

	if( 0 == strHeatGeneratorTypeID.Compare( _T("HEATGENTYPEDIR") ) )
	{
		dPowerLimit = m_dPowerLimitDirect;
	}
	else if( 0 == strHeatGeneratorTypeID.Compare( _T("HEATGENTYPEINDIR") ) )
	{
		dPowerLimit = m_dPowerLimitIndirect;
	}

	return dPowerLimit;
}

void CDB_SafetyValveHeating::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_SafetyValveHeating *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_SafetyValveHeating' object!") );
		}

		// Base class.
		CDB_SafetyValveBase::Copy( pclDestination );
	
		// Copy now what it is common to the "CDB_SafetyValveHeating" class.
		CDB_SafetyValveHeating *pclDestinationSafetyValveHeating = (CDB_SafetyValveHeating *)pclDestination;

		pclDestinationSafetyValveHeating->SetPowerLimitDirect( m_dPowerLimitDirect );
		pclDestinationSafetyValveHeating->SetPowerLimitIndirect( m_dPowerLimitIndirect );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_SafetyValveHeating::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_SAFETYVALVEHEATING_VERSION		1
void CDB_SafetyValveHeating::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_SAFETYVALVEHEATING_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CDB_SafetyValveBase::Write( outf );

	// Info.
	WriteDouble( outf, m_dPowerLimitDirect );
	WriteDouble( outf, m_dPowerLimitIndirect );
}

bool CDB_SafetyValveHeating::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_SAFETYVALVEHEATING_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDB_SafetyValveBase::Read( inpf ) )
	{
		return false;
	}

	// Info.
	inpf.read( (char *)&m_dPowerLimitDirect, sizeof( m_dPowerLimitDirect ) );
	inpf.read( (char *)&m_dPowerLimitIndirect, sizeof( m_dPowerLimitIndirect ) );

	return true;
}

// Remark: 'ProjectType' is read in the inherited class.
#define SafetyValveHeating_PowerLimitDirect		_T("::PowerLimitDirect=")
#define SafetyValveHeating_PowerLimitIndirect	_T("::PowerLimitIndirect=")

void CDB_SafetyValveHeating::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( CLASS( CDB_SafetyValveHeating ) );
	
		if( _T("::") != pStr->Left( 2 ) && iPos < 0 )
		{
			CDB_SafetyValveBase::InterpretInheritedData( pStr );
		}
		else
		{
			if( iPos >= 0 )
			{
				pStr->Delete( iPos, _tcsclen( CLASS( CDB_SafetyValveHeating ) ) );
			}

			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );
		
			if( pStr->Find( SafetyValveHeating_PowerLimitDirect ) > -1 )
			{
				m_dPowerLimitDirect = _ttof( (LPCTSTR)strField );
			}
			else if( pStr->Find( SafetyValveHeating_PowerLimitIndirect ) > -1 )
			{
				m_dPowerLimitIndirect = _ttof( (LPCTSTR)strField );
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_SafetyValveHeating::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_SafetyValveHeating::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_SafetyValveHeating *)idptr.MP)->Copy( this );
			
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				CDB_SafetyValveHeating::InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_SafetyValveBase::ReadText( inpf, pusLineCount );

			CStringArray TxtHdr;
			TxtHdr.Add( SafetyValveHeating_PowerLimitDirect );
			TxtHdr.Add( SafetyValveHeating_PowerLimitIndirect );
	
			for( int i = 0; i < TxtHdr.GetSize(); i++ )
			{
				ptcLine = ReadTextLine( inpf, pusLineCount );

				CString str = TxtHdr[i] + CString( ptcLine );
				CDB_SafetyValveHeating::InterpretInheritedData( &str );
			}
		}
	
		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_SafetyValveHeating::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_SafetyValveCooling
//
///////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DATA( CDB_SafetyValveCooling )
CDB_SafetyValveCooling::CDB_SafetyValveCooling( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_SafetyValveBase( pDataBase, ID )
{
}

double CDB_SafetyValveCooling::GetPowerLimit( CString strHeatGeneratorTypeID, CString strNormID )
{
	double dPowerLimit = 0.0;

	if( 0 == strNormID.Compare( _T("PM_NORM_EN12828") ) )
	{
		dPowerLimit = m_dPowerLimitEN12828;
	}
	else if( 0 == strNormID.Compare( _T("PM_NORM_NONE") ) )
	{
		dPowerLimit = m_dPowerLimitNone;
	}

	return dPowerLimit;
}

void CDB_SafetyValveCooling::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_SafetyValveCooling *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_SafetyValveCooling' object!") );
		}

		// Base class.
		CDB_SafetyValveBase::Copy( pclDestination );

		// Copy now what it is common to the "CDB_SafetyValveCooling" class.
		CDB_SafetyValveCooling *pclDestinationSafetyValveCooling = (CDB_SafetyValveCooling *)pclDestination;

		pclDestinationSafetyValveCooling->SetPowerLimitEN12828( m_dPowerLimitEN12828 );
		pclDestinationSafetyValveCooling->SetPowerLimitNone( m_dPowerLimitNone );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_SafetyValveCooling::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_SAFETYVALVECOOLING_VERSION		1
void CDB_SafetyValveCooling::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_SAFETYVALVECOOLING_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CDB_SafetyValveBase::Write( outf );

	// Info.
	WriteDouble( outf, m_dPowerLimitEN12828 );
	WriteDouble( outf, m_dPowerLimitNone );
}

bool CDB_SafetyValveCooling::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_SAFETYVALVECOOLING_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDB_SafetyValveBase::Read( inpf ) )
	{
		return false;
	}

	// Info.
	inpf.read( (char *)&m_dPowerLimitEN12828, sizeof( m_dPowerLimitEN12828 ) );
	inpf.read( (char *)&m_dPowerLimitNone, sizeof( m_dPowerLimitNone ) );

	return true;
}

// Remark: 'ProjectType' is read in the inherited class.
#define SafetyValveCooling_PowerLimitEN12828	_T("::PowerLimitEN12828=")
#define SafetyValveCooling_PowerLimitNone		_T("::PowerLimitNone=")

void CDB_SafetyValveCooling::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( CLASS( CDB_SafetyValveCooling ) );
	
		if( _T("::") != pStr->Left( 2 ) && iPos < 0 )
		{
			CDB_SafetyValveBase::InterpretInheritedData( pStr );
		}
		else
		{
			if( iPos >= 0 )
			{
				pStr->Delete( iPos, _tcsclen( CLASS( CDB_SafetyValveCooling ) ) );
			}

			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );
		
			if( pStr->Find( SafetyValveCooling_PowerLimitEN12828 ) > -1 )
			{
				m_dPowerLimitEN12828 = _ttof( (LPCTSTR)strField );
			}
			else if( pStr->Find( SafetyValveCooling_PowerLimitNone ) > -1 )
			{
				m_dPowerLimitNone = _ttof( (LPCTSTR)strField );
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_SafetyValveCooling::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_SafetyValveCooling::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_SafetyValveCooling *)idptr.MP)->Copy( this );
			
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );
			
				CDB_SafetyValveCooling::InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_SafetyValveBase::ReadText( inpf, pusLineCount );

			CStringArray TxtHdr;
			TxtHdr.Add( SafetyValveCooling_PowerLimitEN12828 );
			TxtHdr.Add( SafetyValveCooling_PowerLimitNone );
	
			for( int i = 0; i < TxtHdr.GetSize(); i++ )
			{
				ptcLine = ReadTextLine( inpf, pusLineCount );

				CString str = TxtHdr[i] + CString( ptcLine );
				CDB_SafetyValveCooling::InterpretInheritedData( &str );
			}
		}
	
		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_SafetyValveCooling::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_SafetyValveSolar
//
///////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DATA( CDB_SafetyValveSolar )
CDB_SafetyValveSolar::CDB_SafetyValveSolar( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_SafetyValveBase( pDataBase, ID )
{
}

void CDB_SafetyValveSolar::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_SafetyValveSolar *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_SafetyValveSolar' object!") );
		}

		// Base class.
		CDB_SafetyValveBase::Copy( pclDestination );

		// Copy now what it is common to the "CDB_SafetyValveSolar" class.
		CDB_SafetyValveSolar *pclDestinationSafetyValveSolar = (CDB_SafetyValveSolar *)pclDestination;

		pclDestinationSafetyValveSolar->SetPowerLimit( m_dPowerLimit );
		pclDestinationSafetyValveSolar->SetCollectorLimit( m_dCollectorLimit );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_SafetyValveSolar::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_SAFETYVALVESOLAR_VERSION		1
void CDB_SafetyValveSolar::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_SAFETYVALVESOLAR_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CDB_SafetyValveBase::Write( outf );

	// Info.
	WriteDouble( outf, m_dPowerLimit );
	WriteDouble( outf, m_dCollectorLimit );
}

bool CDB_SafetyValveSolar::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_SAFETYVALVESOLAR_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDB_SafetyValveBase::Read( inpf ) )
	{
		return false;
	}

	// Info.
	inpf.read( (char *)&m_dPowerLimit, sizeof( m_dPowerLimit ) );
	inpf.read( (char *)&m_dCollectorLimit, sizeof( m_dCollectorLimit ) );

	return true;
}

// Remark: 'ProjectType' is read in the inherited class.
#define SafetyValveSolar_PowerLimit			_T("::PowerLimit=")
#define SafetyValveSolar_CollectorLimit		_T("::CollectorLimit=")

void CDB_SafetyValveSolar::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( CLASS( CDB_SafetyValveSolar ) );
	
		if( _T("::") != pStr->Left( 2 ) && iPos < 0 )
		{
			CDB_SafetyValveBase::InterpretInheritedData( pStr );
		}
		else
		{
			if( iPos >= 0 )
			{
				pStr->Delete( iPos, _tcsclen( CLASS( CDB_SafetyValveSolar ) ) );
			}

			int iEq = pStr->Find( _T("=") );

			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );
		
			if( pStr->Find( SafetyValveSolar_PowerLimit ) > -1 )
			{
				m_dPowerLimit = _ttof( (LPCTSTR)strField );
			}
			else if( pStr->Find( SafetyValveSolar_CollectorLimit ) > -1 )
			{
				m_dCollectorLimit = _ttof( (LPCTSTR)strField );
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_SafetyValveSolar::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_SafetyValveSolar::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_SafetyValveSolar *)idptr.MP)->Copy( this );
			
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );
			
				CDB_SafetyValveSolar::InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_SafetyValveBase::ReadText( inpf, pusLineCount );

			CStringArray TxtHdr;
			TxtHdr.Add( SafetyValveSolar_PowerLimit );
			TxtHdr.Add( SafetyValveSolar_CollectorLimit );
	
			for( int i = 0; i < TxtHdr.GetSize(); i++ )
			{
				ptcLine = ReadTextLine( inpf, pusLineCount );

				CString str = TxtHdr[i] + CString( ptcLine );
				CDB_SafetyValveSolar::InterpretInheritedData( &str );
			}
		}
	
		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_SafetyValveSolar::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_BlowTank
//
///////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DATA( CDB_BlowTank )
CDB_BlowTank::CDB_BlowTank( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_TAProduct( pDataBase, ID )
{
	m_eApplicationCompatibility = ProjectType::Heating;
	m_tcMediumNameID[0] = _T('\0');
	m_SteamLineSizeIDPtr.Clear();
	m_DrainLineSizeIDPtr.Clear();
	m_dWeight = 0.0;
	m_dDiameter = 0.0;
	m_dHeight = 0.0;
}

const IDPTR &CDB_BlowTank::GetMediumNameIDPtr()
{
	if( 0 == _tcscmp( _NO_ID, m_tcMediumNameID ) )
	{
		return GetDB()->Get( _T("") );
	}
	else
	{
		return GetDB()->Get( m_tcMediumNameID );
	}
}

CString CDB_BlowTank::GetMediumName()
{
	IDPTR MediumNameIDPtr = GetMediumNameIDPtr();

	if( NULL != MediumNameIDPtr.MP )
	{
		CDB_StringID *pStr = (CDB_StringID *)( MediumNameIDPtr.MP );
		return pStr->GetString();
	}
	else
	{
		return _T("");
	}
}

const IDPTR &CDB_BlowTank::GetSteamLineSizeIDPtr()
{
	m_SteamLineSizeIDPtr.DB = GetDB();
	Extend( &m_SteamLineSizeIDPtr );
	return m_SteamLineSizeIDPtr;
}

CString CDB_BlowTank::GetSteamLineSizeID()
{
	return GetSteamLineSizeIDPtr().ID;
}

CString CDB_BlowTank::GetSteamLineSizeString()
{
	CDB_StringID *pStr = (CDB_StringID *)( GetSteamLineSizeIDPtr().MP );
	
	if( NULL != pStr )
	{
		return pStr->GetString();
	}
	else
	{
		return _T("-");
	}
}

const IDPTR &CDB_BlowTank::GetDrainLineSizeIDPtr()
{
	m_DrainLineSizeIDPtr.DB = GetDB();
	Extend( &m_DrainLineSizeIDPtr );
	return m_DrainLineSizeIDPtr;
}

CString CDB_BlowTank::GetDrainLineSizeID()
{
	return GetDrainLineSizeIDPtr().ID;
}

CString CDB_BlowTank::GetDrainLineSizeString()
{
	CDB_StringID *pStr = (CDB_StringID *)( GetDrainLineSizeIDPtr().MP );
	
	if( NULL != pStr )
	{
		return pStr->GetString();
	}
	else
	{
		return _T("-");
	}
}

CString CDB_BlowTank::GetAllSizesString()
{
	CString strSizes[] = { GetSize(), GetSteamLineSizeString(), GetDrainLineSizeString() };

	for( auto &iter : strSizes )
	{
		int iFind = iter.Find( _T('(') );
	
		if( -1 != iFind )
		{
			iter.SetAt( iFind, _T('\0') );
			iter.Trim();
		}
	}

	CString strAllSizes = _T("DN") + strSizes[0];

	if( false == strSizes[1].IsEmpty() )
	{
		strAllSizes += _T("/") + strSizes[1];
	}

	if( false == strSizes[2].IsEmpty() )
	{
		strAllSizes += _T("/") + strSizes[2];
	}

	return strAllSizes;
}

void CDB_BlowTank::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_BlowTank *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_BlowTank' object!") );
		}

		// Base class.
		CDB_TAProduct::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_BlowTank" class.
		CDB_BlowTank *pclDestinationBlowTank = (CDB_BlowTank *)pclDestination;

		pclDestinationBlowTank->SetApplicationCompatibility( GetApplicationCompatibility() );
		pclDestinationBlowTank->SetMediumNameID( (LPCTSTR)GetMediumNameID() );
		pclDestinationBlowTank->SetSteamLineSizeID( (LPCTSTR)GetSteamLineSizeID() );
		pclDestinationBlowTank->SetDrainLineSizeID( (LPCTSTR)GetDrainLineSizeID() );
		pclDestinationBlowTank->SetWeight( GetWeight() );
		pclDestinationBlowTank->SetDiameter( GetDiameter() );
		pclDestinationBlowTank->SetHeight( GetHeight() );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_BlowTank::Copy' method with the object '%s'."), GetIDPtr().ID )
}

void CDB_BlowTank::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_TAProduct::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;
	
		if( _T('\0') != *m_tcMediumNameID && 0 != _tcscmp( _NO_ID, m_tcMediumNameID ) )
		{
			IDPtr = GetDB()->Get( m_tcMediumNameID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Medium type ID (%s) is defined but not found in the database."), m_tcMediumNameID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("Medium type ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_tcMediumNameID );
			}
		}

		if( _T('\0') != *m_SteamLineSizeIDPtr.ID && 0 != _tcscmp( _NO_ID, m_SteamLineSizeIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_SteamLineSizeIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Steam line size ID (%s) is defined but not found in the database."), m_SteamLineSizeIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("Steam line size ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_SteamLineSizeIDPtr.ID );
			}
		}

		if( _T('\0') != *m_DrainLineSizeIDPtr.ID && 0 != _tcscmp( _NO_ID, m_DrainLineSizeIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_DrainLineSizeIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Drain line size ID (%s) is defined but not found in the database."), m_DrainLineSizeIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("Drain line size  ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_DrainLineSizeIDPtr.ID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_BlowTank::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

#define CDB_BLOWTANK_VERSION		1
void CDB_BlowTank::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_BLOWTANK_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CDB_TAProduct::Write( outf );

	// Info.
	outf.write( (char *)&m_eApplicationCompatibility, sizeof( m_eApplicationCompatibility ) );
	WriteString( outf, m_tcMediumNameID );
	WriteString( outf, m_SteamLineSizeIDPtr.ID );
	WriteString( outf, m_DrainLineSizeIDPtr.ID );
	WriteDouble( outf, GetWeight() );
	WriteDouble( outf, GetDiameter() );
	WriteDouble( outf, GetHeight() );
}

bool CDB_BlowTank::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );
	
	if( Version < 1 || Version > CDB_BLOWTANK_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDB_TAProduct::Read( inpf ) )
	{
		return false;
	}

	inpf.read( (char *)&m_eApplicationCompatibility, sizeof( m_eApplicationCompatibility ) );

	if( false == ReadString( inpf, m_tcMediumNameID, sizeof( m_tcMediumNameID ) ) )
	{
		return false;
	}
	
	if( false == ReadString( inpf, m_SteamLineSizeIDPtr.ID, sizeof( m_SteamLineSizeIDPtr.ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_DrainLineSizeIDPtr.ID, sizeof( m_DrainLineSizeIDPtr.ID ) ) )
	{
		return false;
	}

	SetWeight( ReadDouble( inpf ) );
	SetDiameter( ReadDouble( inpf ) );
	SetHeight( ReadDouble( inpf ) );

	return true;
}

#define BLOWTANK_AppplicationCompatibility		_T("::ApplicationCompatibility=")
#define BLOWTANK_MediumNameID    				_T("::MediumNameID=")
#define BLOWTANK_SteamLineSizeID    			_T("::SteamLineSizeID=")
#define BLOWTANK_DrainLineSizeID    			_T("::DrainLineSizeID=")
#define BLOWTANK_Weight       					_T("::Weight=")
#define BLOWTANK_Diameter       				_T("::Diameter=")
#define BLOWTANK_Height       					_T("::Height=")
void CDB_BlowTank::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( CLASS( CDB_BlowTank ) );
	
		if( pStr->Left( 2 ) != _T("::") && iPos < 0 )
		{
			CDB_TAProduct::InterpretInheritedData( pStr );
		}
		else
		{
			if( iPos >= 0 )
			{
				pStr->Delete( iPos, _tcsclen( CLASS( CDB_BlowTank ) ) );
			}

			int iEq = pStr->Find( _T("=") );

			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( BLOWTANK_AppplicationCompatibility ) > -1 )
			{
				int iValue = ReadEnum( strField );

				if( iValue != Heating && iValue != Cooling && iValue != Solar )
				{
					HYSELECT_THROW( _T("'CDB_BlowTank::ApplicationCompatibility' value must be one of these values: '#ePMHeating', '#ePMCooling' or '#ePMSolar'.") );
				}

				m_eApplicationCompatibility = (ProjectType)iValue;
			}
			else if( pStr->Find( BLOWTANK_MediumNameID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_BlowTank::MediumNameID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				_tcsncpy_s( m_tcMediumNameID, SIZEOFINTCHAR( m_tcMediumNameID ), (LPCTSTR)strField, SIZEOFINTCHAR( m_tcMediumNameID ) - 1 );
			}
			else if( pStr->Find( BLOWTANK_SteamLineSizeID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_BlowTank::SteamLineSizeID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetSteamLineSizeID( (LPCTSTR)strField );
			}
			else if( pStr->Find( BLOWTANK_DrainLineSizeID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_BlowTank::DrainLineSizeID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetDrainLineSizeID( (LPCTSTR)strField );
			}
			else if( pStr->Find( BLOWTANK_Weight ) > -1 )
			{
				m_dWeight = _ttof( (LPCTSTR)strField );

				if( m_dWeight <= 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_BlowTank::Weight' (%f) can't be lower or equal to 0."), m_dWeight );
				}
			}
			else if( pStr->Find( BLOWTANK_Diameter ) > -1 )
			{
				m_dDiameter = _ttof( (LPCTSTR)strField );

				if( m_dDiameter <= 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_BlowTank::Diameter' (%f) can't be lower or equal to 0."), m_dDiameter );
				}
			}
			else if( pStr->Find( BLOWTANK_Height ) > -1 )
			{
				m_dHeight = _ttof( (LPCTSTR)strField );
			
				if( m_dHeight <= 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_BlowTank::Height' (%f) can't be lower or equal to 0."), m_dHeight );
				}
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_BlowTank::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_BlowTank::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		//	ApplicationCompatibility	Type of the application (Heating, cooling or solar).
		//	SteamLineSizeID				Identifier of the steam line (Sout) output size.
		//	DrainLineSizeID				Identifier of the drain line (Sw) output size.
		//	Weight						Weight (m) of the product.
		//	Diameter					Diameter (D) of the device.
		//	Height						Height (H) of the device.

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}
		
			( (CDB_BlowTank *)idptr.MP )->Copy( this );
		
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );
			
				CDB_BlowTank::InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_TAProduct::ReadText( inpf, pusLineCount );

			CStringArray TxtHdr;
			TxtHdr.Add( BLOWTANK_AppplicationCompatibility );
			TxtHdr.Add( BLOWTANK_MediumNameID );
			TxtHdr.Add( BLOWTANK_SteamLineSizeID );
			TxtHdr.Add( BLOWTANK_DrainLineSizeID );
			TxtHdr.Add( BLOWTANK_Weight );
			TxtHdr.Add( BLOWTANK_Diameter );
			TxtHdr.Add( BLOWTANK_Height );
		
			for( int i = 0; i < TxtHdr.GetSize(); i++ )
			{
				ptcLine = ReadTextLine(inpf, pusLineCount);

				CString str = TxtHdr[i] + CString( ptcLine );
				CDB_BlowTank::InterpretInheritedData( &str );
			}
		}
	
		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_BlowTank::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

///////////////////////////////////////////////////////////////////////////////////
//
//								HYS-1741: IPI: CDB_PWQPressureReducer
//
///////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DATA( CDB_PWQPressureReducer )
CDB_PWQPressureReducer::CDB_PWQPressureReducer( CDataBase* pDataBase, LPCTSTR ID )
	: CDB_TAProduct( pDataBase, ID )
{
	m_dMaxInletPressure = 0.0;
	m_dMinOutletPressure = 0.0;
	m_dMaxOutletPressure = 0.0;
}

CString CDB_PWQPressureReducer::GetOutletPressureRange()
{
	CString strMaxPressure = WriteCUDouble( _U_PRESSURE, GetMaxOutletPressure(), true );
	CString strMinPressure = WriteCUDouble( _U_PRESSURE, GetMinOutletPressure(), true );
	return _T( "[" ) + strMinPressure + _T( " - " ) + strMaxPressure + _T( "]" );
}

void CDB_PWQPressureReducer::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T( "'pclDestination' argument can't be null!" ) );
		}

		if( NULL == dynamic_cast<CDB_PWQPressureReducer*>( pclDestination ) )
		{
			HYSELECT_THROW( _T( "'pclDestination' argument is not a 'CDB_PWQPressureReducer' object!" ) );
		}

		// Base class.
		CDB_TAProduct::Copy( pclDestination );

		// Copy now what it is common to the "CDB_PWQPressureReducer" class.
		CDB_PWQPressureReducer *pclDestinationPressureReducer = (CDB_PWQPressureReducer *)pclDestination;

		pclDestinationPressureReducer->SetMaxInletPressure( GetMaxInletPressure() );
		pclDestinationPressureReducer->SetMinOutletPressure( GetMinOutletPressure() );
		pclDestinationPressureReducer->SetMaxOutletPressure( GetMaxOutletPressure() );
	}
		HYSELECT_CATCH_ARG( clHySelectException, _T( "Error in 'CDB_PWQPressureReducer::Copy' method with the object '%s'." ), GetIDPtr().ID )
}

#define CDB_PWQPRESSUREREDUCER_VERSION		1
void CDB_PWQPressureReducer::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_PWQPRESSUREREDUCER_VERSION;
	outf.write( (char*)&Version, sizeof( Version ) );

	// Base class.
	CDB_TAProduct::Write( outf );

	// Info.
	WriteDouble( outf, m_dMaxInletPressure );
	WriteDouble( outf, m_dMinOutletPressure );
	WriteDouble( outf, m_dMaxOutletPressure );
}

bool CDB_PWQPressureReducer::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char*)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_PWQPRESSUREREDUCER_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDB_TAProduct::Read( inpf ) )
	{
		return false;
	}

	inpf.read( (char*)&m_dMaxInletPressure, sizeof( m_dMaxInletPressure ) );
	inpf.read( (char*)&m_dMinOutletPressure, sizeof( m_dMinOutletPressure ) );
	inpf.read( (char*)&m_dMaxOutletPressure, sizeof( m_dMaxOutletPressure ) );

	return true;
}

#define PWQPRESSUREREDUCER_MaxInletPressure		_T("::MaxInletPressure=")
#define PWQPRESSUREREDUCER_MinOutletPressure    _T("::MinOutletPressure=")
#define PWQPRESSUREREDUCER_MaxOutletPressure    _T("::MaxOutletPressure=")
void CDB_PWQPressureReducer::InterpretInheritedData( CString* pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( CLASS( CDB_PWQPressureReducer ) );

		if( pStr->Left( 2 ) != _T( "::" ) && iPos < 0 )
		{
			CDB_TAProduct::InterpretInheritedData( pStr );
		}
		else
		{
			if( iPos >= 0 )
			{
				pStr->Delete( iPos, _tcsclen( CLASS( CDB_PWQPressureReducer ) ) );
			}

			int iEq = pStr->Find( _T( "=" ) );

			if( iEq <= 0 )
			{
				HYSELECT_THROW( _T( "Inherited variable value must be preceeded by '='" ) );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( PWQPRESSUREREDUCER_MaxInletPressure ) > -1 )
			{
				m_dMaxInletPressure = _ttof( (LPCTSTR)strField );
			}
			else if( pStr->Find( PWQPRESSUREREDUCER_MinOutletPressure ) > -1 )
			{
				m_dMinOutletPressure = _ttof( (LPCTSTR)strField );
			}
			else if( pStr->Find( PWQPRESSUREREDUCER_MaxOutletPressure ) > -1 )
			{
				m_dMaxOutletPressure = _ttof( (LPCTSTR)strField );
			}
			else
			{
				HYSELECT_THROW( _T( "Can't find inherited variable in '%s'." ), strField );
			}
		}
	}
	catch( CHySelectException& clHySelectException )
	{
		clHySelectException.AddMessage( _T( "Error in 'CDB_PWQPressureReducer::InterpretInheritedData' with the object '%s'." ), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_PWQPressureReducer::ReadText( INPSTREAM inpf, unsigned short* pusLineCount )
{
	try
	{
		//  	MaxInletPressure        Max. inlet pressure 
		//  	MinOutletPressure       Min. outlet pressure 
		//  	MaxOutletPressure       Max. outlet pressure 

		// Skip the open curve bracket.
		TCHAR* ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T( '{' ) != *ptcLine )
		{
			HYSELECT_THROW( _T( "First line must be '{' (pos: %i)." ), *pusLineCount );
		}

		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T( '\0' ) == *idptr.ID )
			{
				HYSELECT_THROW( _T( "ID for the base object must be defined (pos: %i)." ), *pusLineCount );
			}

			((CDB_PWQPressureReducer*)idptr.MP)->Copy( this );

			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );

			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				CDB_PWQPressureReducer::InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_TAProduct::ReadText( inpf, pusLineCount );

			CStringArray TxtHdr;
			TxtHdr.Add( PWQPRESSUREREDUCER_MaxInletPressure );
			TxtHdr.Add( PWQPRESSUREREDUCER_MinOutletPressure );
			TxtHdr.Add( PWQPRESSUREREDUCER_MaxOutletPressure );

			for( int i = 0; i < TxtHdr.GetSize(); i++ )
			{
				ptcLine = ReadTextLine( inpf, pusLineCount );

				CString str = TxtHdr[i] + CString( ptcLine );
				CDB_PWQPressureReducer::InterpretInheritedData( &str );
			}
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T( '}' ) != *ptcLine )
		{
			HYSELECT_THROW( _T( "Last line must be '}' (pos: %i)." ), *pusLineCount );
		}
	}
	catch( CHySelectException& clHySelectException )
	{
		clHySelectException.AddMessage( _T( "Error in 'CDB_PWQPressureReducer::ReadText' with the object '%s'." ), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

#endif

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_Component
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_Component )

CDB_Component::CDB_Component( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_TAProduct( pDataBase, ID )
{
	memset(m_IDext, 0, sizeof( m_IDext));
}

void CDB_Component::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_Component *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_Component' object!") );
		}

		// Base class.
		CDB_TAProduct::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_Component" class.
		CDB_Component *pclDestinationComponent = (CDB_Component *)pclDestination;
		
		pclDestinationComponent->SetIDext( m_IDext );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_Component::Copy' method with the object '%s'."), GetIDPtr().ID )
}

void CDB_Component::SetIDext( LPCTSTR pID )
{
	_tcsncpy_s( m_IDext, SIZEOFINTCHAR( m_IDext ), (LPCTSTR)pID, SIZEOFINTCHAR( m_IDext ) - 1 );
}

void CDB_Component::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = 1;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CDB_TAProduct::Write( outf );

	// Info.
	WriteString( outf, m_IDext );
}

bool CDB_Component::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > 1 )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_TAProduct::Read( inpf ) )
	{
		return false;
	}

	// Info.
	if( false == ReadString( inpf,m_IDext, sizeof( m_IDext)))
	{
		return false;
	}

	return true;
}

#ifndef TACBX 
void CDB_Component::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( _T("CDB_Component") );

		if( iPos < 0 )
		{
			CDB_TAProduct::InterpretInheritedData( pStr );
		}
		else
		{
			pStr->Delete( iPos, _tcsclen( _T("CDB_Component") ) );
			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( _T("::IDext=") ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_Component::IDext' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				_tcsncpy_s( m_IDext, SIZEOFINTCHAR( m_IDext ), (LPCTSTR)strField, SIZEOFINTCHAR( m_IDext ) - 1 );
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Component::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_Component::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_Component format
		// line 0 : open curve bracket and call base class.
		// line 1 : ID extension
		// line 2 : close curve bracket

		// Skip the open curve bracket
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_Component *)idptr.MP)->Copy( this );
			
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );
			
				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_TAProduct::ReadText( inpf, pusLineCount );

			// Read IDext.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _T('"') != *ptcLine )
			{
				HYSELECT_THROW( _T("ID must start with \" (pos: %i)."), *pusLineCount );
			}

			int iLength = _tcslen( ptcLine );

			if( _T('"') != ptcLine[iLength - 1] )
			{
				HYSELECT_THROW( _T("ID must end with \" (pos: %i)."), *pusLineCount );
			}

			if( iLength > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, iLength, _ID_LENGTH, *pusLineCount );
			}
		
			ptcLine[iLength - 1] = _T('\0');
			_tcsncpy_s( m_IDext, SIZEOFINTCHAR( m_IDext ), ptcLine + 1, SIZEOFINTCHAR( m_IDext ) - 1 );
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Component::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_Component::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str, str1, str2;
		
	// Write object header.
	if( true == IsClass( CLASS( CDB_Component ) ) )
	{
		CData::WriteText( outf, strTab );
	}

	// Opening bracket.
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");
	CDB_TAProduct::WriteText( outf, strTab );

	// Data.
	// m_IDext
	str1 = m_IDext;
	str2 = _T("\"") + str1 + _T("\"");
	str.Format( _T("\r\n%s"), strTab + str2 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	
	// Closing bracket.
	strTab.Delete( 0 ); // Delete one \t
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}
#endif 

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_RegulatingValve
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_RegulatingValve)

CDB_RegulatingValve::CDB_RegulatingValve( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_TAProduct( pDataBase, ID )
{
	*m_ValveCharacteristicID = _T('\0');
	m_pValveCharacteristic = NULL;
}

double CDB_RegulatingValve::GetKvs()
{
	double dKvs = -1.0;

	if( NULL != GetValveCharacteristic() )
	{
		dKvs = GetValveCharacteristic()->GetKvMax();
	}

	return dKvs;
}

bool CDB_RegulatingValve::IsValidCV( CDB_ControlProperties::CV2W3W cv2w3w, CDB_ControlProperties::eCVFUNC CVFunc )
{
	if( NULL != GetCtrlProp() )
	{
		if( true == GetCtrlProp()->CtrlParamFits( cv2w3w, CVFunc ) )
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	else
	{
		return false;
	}
}

bool CDB_RegulatingValve::IsValidCV( CDB_ControlProperties::CV2W3W cv2w3w, CDB_ControlProperties::eCVFUNC CVFunc, CDB_ControlProperties::eCTRLCHAR ctrlchar )
{
	if( NULL != GetCtrlProp() && true == GetCtrlProp()->CtrlParamFits( cv2w3w, CVFunc, ctrlchar ) )
	{
		return true;
	}
	else
	{
		return false;
	}
}

CDB_ValveCharacteristic *CDB_RegulatingValve::GetValveCharacteristic()
{
	HYSELECT_TRY
	{
		if( NULL == m_pValveCharacteristic )
		{
			if( _T('\0') != *m_ValveCharacteristicID && 0 != IDcmp( m_ValveCharacteristicID, _NO_ID ) )
			{
				IDPTR CharactPtr = GetDB()->Get( m_ValveCharacteristicID );
				
				if( _T('\0') == *CharactPtr.ID )
				{
					HYSELECT_THROW_RETURNARG( _T("Internal error: Can't find valve characteristic '%s' in the database."), NULL, m_ValveCharacteristicID );
				}

				m_pValveCharacteristic = (CDB_ValveCharacteristic*)( CharactPtr.MP );

				if( NULL != m_pValveCharacteristic )
				{
					m_pValveCharacteristic->Lock( GetIDPtr() );
				}
			}
		}
	
		return m_pValveCharacteristic;
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CDB_RegulatingValve::GetValveCharacteristic'.") )
}

void CDB_RegulatingValve::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_TAProduct::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( _T('\0') !=  *m_ValveCharacteristicID && 0 != _tcscmp( _NO_ID, m_ValveCharacteristicID ) )
		{
			IDPtr = GetDB()->Get( m_ValveCharacteristicID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Valve characteristic ID (%s) is defined but not found in the database."), m_ValveCharacteristicID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_ValveCharacteristic ) ) )
			{
				HYSELECT_THROW( _T("Valve characteristic ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_ValveCharacteristicID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_RegulatingValve::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

void CDB_RegulatingValve::SetValveCharacteristicID( LPCTSTR pID )
{
	ASSERT( _tcslen( pID ) <= _ID_LENGTH );
	_tcsncpy_s( m_ValveCharacteristicID, SIZEOFINTCHAR( m_ValveCharacteristicID ), (LPCTSTR)pID, SIZEOFINTCHAR( m_ValveCharacteristicID ) - 1 );

	// Unlock if previous one exist.
	if( NULL != m_pValveCharacteristic )
	{
		m_pValveCharacteristic->Unlock( GetIDPtr() );
	}

	// Force a call to 'GetValveCharacteristic' to update 'm_pValveCharacteristic'.
	m_pValveCharacteristic = NULL;
	GetValveCharacteristic();
}

void CDB_RegulatingValve::OnDatabaseDestroy()
{
	CDB_TAProduct::OnDatabaseDestroy();
	
	// Unlock the curve.
	if( NULL != GetValveCharacteristic() )
	{
		GetValveCharacteristic()->Unlock( GetIDPtr() );
	}
}

void CDB_RegulatingValve::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_RegulatingValve *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_RegulatingValve' object!") );
		}
		
		// Base class.
		CDB_TAProduct::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_RegulatingValve" class.
		CDB_RegulatingValve *pclDestinationRegulatingValve = (CDB_RegulatingValve *)pclDestination;

		pclDestinationRegulatingValve->SetValveCharacteristicID( m_ValveCharacteristicID );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_RegulatingValve::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_REGULATINGVALVE_VERSION		1
void CDB_RegulatingValve::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_REGULATINGVALVE_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_TAProduct::Write( outf );
	
	// Infos.
	// The curve ID.
	WriteString( outf, m_ValveCharacteristicID );
}

bool CDB_RegulatingValve::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );
	
	if( Version < 1 || Version > CDB_REGULATINGVALVE_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_TAProduct::Read( inpf ) )
	{
		return false;
	}
	
	// Infos.
	// The curve ID.
	if( false == ReadString( inpf, m_ValveCharacteristicID, sizeof( m_ValveCharacteristicID ) ) )
	{
		return false;
	}

	return true;
}

#ifndef TACBX 
void CDB_RegulatingValve::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( _T("CDB_RegulatingValve") );

		if( iPos < 0 )
		{
			CDB_TAProduct::InterpretInheritedData( pStr );
		}
		else
		{
			pStr->Delete( iPos, _tcsclen( _T("CDB_RegulatingValve") ) );
			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}
		
			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( _T("::CharactID=") ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_RegulatingValve::CharactID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetValveCharacteristicID( (LPCTSTR)strField );
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_RegulatingValve::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_RegulatingValve::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_RegulatingValve format
		// line 0 : open curve bracket and call base class.
		// line 1 : regulating valve characteristic ID
		// line 2 : close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_RegulatingValve *)idptr.MP )->Copy( this );
			
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.		
			CDB_TAProduct::ReadText( inpf, pusLineCount );
		
			// The regulating valve characteristic ID.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Valve characteristic ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			_tcsncpy_s( m_ValveCharacteristicID, SIZEOFINTCHAR( m_ValveCharacteristicID ), ptcLine, SIZEOFINTCHAR( m_ValveCharacteristicID ) - 1 );
		}
	
		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_RegulatingValve::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_RegulatingValve::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str, str1;
	
	// Write object header.
	if( true == IsClass( CLASS( CDB_RegulatingValve ) ) )
	{
		CData::WriteText( outf, strTab );
	}
	
	// Opening bracket.
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");
	CDB_TAProduct::WriteText( outf, strTab );
	
	// Infos.
	WriteFormatedStringW( outf, m_ValveCharacteristicID, strTab );
	
	// Closing bracket.
	strTab.Delete( 0 );
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}
#endif 

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_ThermostaticValve
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_ThermostaticValve)

CDB_ThermostaticValve::CDB_ThermostaticValve( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_ControlValve( pDataBase, ID )
{
	*m_ThermoCharacteristicID = _T('\0');
	m_pThermoCharacteristic = NULL;
	m_strDescription.clear();
	m_pStr = NULL;
}

CDB_ThermoCharacteristic *CDB_ThermostaticValve::GetThermoCharacteristic()
{
	HYSELECT_TRY
	{
		if( NULL == m_pThermoCharacteristic )
		{
			if( _T('\0') !=  *m_ThermoCharacteristicID && 0 != IDcmp( m_ThermoCharacteristicID, _NO_ID ) )
			{
				IDPTR CharactPtr = GetDB()->Get( m_ThermoCharacteristicID );
				
				if( _T('\0') == *CharactPtr.ID )
				{
					HYSELECT_THROW_RETURNARG( _T("Internal error: Can't find valve thermostatic characteristic '%s' in the database."), NULL, m_ThermoCharacteristicID );
				}

				m_pThermoCharacteristic = (CDB_ThermoCharacteristic*)( CharactPtr.MP );

				if( NULL != m_pThermoCharacteristic )
				{
					m_pThermoCharacteristic->Lock( GetIDPtr() );
				}
			}
		}
	
		return m_pThermoCharacteristic;
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CDB_ThermostaticValve::GetThermoCharacteristic'.") )
}

LPCTSTR CDB_ThermostaticValve::GetDescription()
{
	m_pStr = GetpXmlStrTab()->GetIDSStr( (LPCTSTR)m_strDescription.c_str() );

	if( NULL != m_pStr )
	{
		return m_pStr->c_str();
	}
	else
	{
		return (LPCTSTR)m_strDescription.c_str();
	}
}

void CDB_ThermostaticValve::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_ControlValve::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( _T('\0') !=  *m_ThermoCharacteristicID && 0 != _tcscmp( _NO_ID, m_ThermoCharacteristicID ) )
		{
			IDPtr = GetDB()->Get( m_ThermoCharacteristicID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Thermostatic characteristic ID (%s) is defined but not found in the database."), m_ThermoCharacteristicID );
			}
		
			if( false == IDPtr.MP->IsClass( CLASS( CDB_ThermoCharacteristic ) ) )
			{
				HYSELECT_THROW( _T("Thermostatic characteristic ID (%s) is found in the database but it's not a 'CDB_ThermoCharacteristic' object."), m_ThermoCharacteristicID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_ThermostaticValve::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

void CDB_ThermostaticValve::SetThermoCharacteristicID( LPCTSTR strCharacteristicID )
{
	ASSERT( _tcslen( strCharacteristicID ) <= _ID_LENGTH );
	_tcsncpy_s( m_ThermoCharacteristicID, SIZEOFINTCHAR( m_ThermoCharacteristicID ), (LPCTSTR)strCharacteristicID, SIZEOFINTCHAR( m_ThermoCharacteristicID ) - 1 );

	// Unlock if previous one exist.
	if( NULL != m_pThermoCharacteristic )
	{
		m_pThermoCharacteristic->Unlock( GetIDPtr() );
	}

	// Force a call to 'GetThermoCharacteristic' to update 'm_pFixOChar'.
	m_pThermoCharacteristic = NULL;
	GetThermoCharacteristic();
}

LPCTSTR CDB_ThermostaticValve::SetDescription( LPCTSTR strDescription )
{
	Modified();

	int iLength = _tcslen( strDescription );
	ASSERT( iLength <= ( _PRODUCT_DESCRIPTION_LENGTH + 2 ) );

	m_strDescription = strDescription;
	return m_strDescription.c_str();
}

void CDB_ThermostaticValve::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_ThermostaticValve *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_ThermostaticValve' object!") );
		}
	
		// Base class.
		CDB_ControlValve::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_ThermostaticValve" class.
		CDB_ThermostaticValve *pclDestinationThermostaticValve = (CDB_ThermostaticValve *)pclDestination;

		pclDestinationThermostaticValve->SetThermoCharacteristicID( m_ThermoCharacteristicID );
		pclDestinationThermostaticValve->SetDescription( m_strDescription.c_str() );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_ThermostaticValve::Copy' method with the object '%s'."), GetIDPtr().ID )
}

void CDB_ThermostaticValve::OnDatabaseDestroy()
{
	CDB_RegulatingValve::OnDatabaseDestroy();
	
	// Unlock the thermo curve.
	if( NULL != GetThermoCharacteristic() )
	{
		GetThermoCharacteristic()->Unlock( GetIDPtr() );
	}
}

#define CDB_THERMOSTATICVALVE_VERSION	1
void CDB_ThermostaticValve::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_THERMOSTATICVALVE_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_ControlValve::Write( outf );
	
	// Infos.
	// The thermostatic characteristic ID.
	WriteString( outf, m_ThermoCharacteristicID );
	
	// Description.
	WriteString( outf, m_strDescription.c_str() );
}

bool CDB_ThermostaticValve::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_THERMOSTATICVALVE_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDB_ControlValve::Read( inpf ) )
	{
		return false;
	}

	// Infos.
	// Read the thermo curve ID.
	if( false == ReadString( inpf, m_ThermoCharacteristicID, sizeof( m_ThermoCharacteristicID ) ) )
	{
		return false;
	}

	// Read description.
	if( false == ReadString( inpf, m_strDescription ) )
	{
		return false;
	}

	ASSERT( m_strDescription.size() <= ( _PRODUCT_DESCRIPTION_LENGTH + 2 ) );

	return true;
}

#ifndef TACBX 
void CDB_ThermostaticValve::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( _T("CDB_ThermostaticValve") );

		if( iPos < 0 )
		{
			CDB_ControlValve::InterpretInheritedData( pStr );
		}
		else
		{
			pStr->Delete( iPos, _tcsclen( _T("CDB_ThermostaticValve") ) );
			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}
		
			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( _T("::ThermoCharID=") ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_ThermostaticValve::ThermoCharID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetThermoCharacteristicID( (LPCTSTR)strField );
			}
			else if( pStr->Find( _T("::Description=") ) > -1 )
			{
				if( _T('\"') == strField.GetAt( 0 ) )
				{
					strField.Delete( 0 );
				}

				if( _T('\"') == strField.GetAt( strField.GetLength() - 1 ) )
				{
					strField.Delete( strField.GetLength() - 1 );
				}

				if( strField.GetLength() > ( _PRODUCT_DESCRIPTION_LENGTH + 2 ) )
				{
					HYSELECT_THROW( _T("'CDB_ThermostaticValve::Description' (%s) is too long (%i > %i)."), strField, strField.GetLength(), ( _PRODUCT_DESCRIPTION_LENGTH + 2 ) );
				}

				SetDescription( strField );
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_ThermostaticValve::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
	
}

void CDB_ThermostaticValve::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str, str1;
	
	// Write object header.
	if( true == IsClass( CLASS( CDB_ThermostaticValve ) ) )
	{
		CData::WriteText( outf, strTab );
	}
	
	// Opening bracket.
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	
	// Base class.
	strTab += _T("\t");
	CDB_ControlValve::WriteText( outf, strTab );

	// Infos.
	WriteFormatedStringW( outf, m_ThermoCharacteristicID, strTab );
	WriteFormatedStringW( outf, m_strDescription.c_str(), strTab, true );

	// Closing bracket..
	strTab.Delete( 0 );
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}

void CDB_ThermostaticValve::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_ThermostaticValve format
		// line 0 : open curve bracket and call base class.
		// line 1 : thermostatic curve ID
		// line 2 : description
		// line 3 : close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_ThermostaticValve *)idptr.MP )->Copy( this );
		
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );

			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_ControlValve::ReadText( inpf, pusLineCount );
		
			// Read the thermostatic curve ID.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Thermostatic curve ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			SetThermoCharacteristicID( ptcLine );
		
			// Read description.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			
			if( _T('\"') != *ptcLine )
			{
				HYSELECT_THROW( _T("Description must start with \" (pos: %i)."), *pusLineCount );
			}

			if( _T('\"') != ptcLine[_tcslen(ptcLine) - 1 ] )
			{
				HYSELECT_THROW( _T("Description must end with \" (pos: %i)."), *pusLineCount );
			}
			
			int iLength = _tcslen( ptcLine );

			if( iLength > ( _PRODUCT_DESCRIPTION_LENGTH + 2 ) )
			{
				HYSELECT_THROW( _T("Description (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), ( _PRODUCT_DESCRIPTION_LENGTH + 2 ), *pusLineCount );
			}

			ptcLine[iLength - 1] = _T('\0');
			m_strDescription = &ptcLine[1];
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_ThermostaticValve::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif 

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_FlowLimitedControlValve
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_FlowLimitedControlValve )

CDB_FlowLimitedControlValve::CDB_FlowLimitedControlValve( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_ControlValve( pDataBase, ID )
{
	*m_FLCVCharacteristicID = _T('\0');
	m_pFLCVCharacteristic = NULL;
	m_strDescription.clear();
	m_pStr = NULL;
}

CDB_FLCVCharacteristic *CDB_FlowLimitedControlValve::GetFLCVCharacteristic()
{
	HYSELECT_TRY
	{
		if( NULL == m_pFLCVCharacteristic )
		{
			if( _T('\0') !=  *m_FLCVCharacteristicID && 0 != IDcmp( m_FLCVCharacteristicID, _NO_ID ) )
			{
				IDPTR CharactPtr = GetDB()->Get( m_FLCVCharacteristicID );
			
				if( _T('\0') == *CharactPtr.ID )
				{
					HYSELECT_THROW_RETURNARG( _T("Internal error: Can't find flow limited control valve characteristic '%s' in the database."), NULL, m_FLCVCharacteristicID );
				}

				m_pFLCVCharacteristic = (CDB_FLCVCharacteristic*)( CharactPtr.MP );

				if( NULL != m_pFLCVCharacteristic )
				{
					m_pFLCVCharacteristic->Lock( GetIDPtr() );
				}
			}
		}
	
		return m_pFLCVCharacteristic;
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CDB_FlowLimitedControlValve::GetFLCVCharacteristic'.") )
}

LPCTSTR CDB_FlowLimitedControlValve::GetDescription()
{
	m_pStr = GetpXmlStrTab()->GetIDSStr( (LPCTSTR)m_strDescription.c_str() );

	if( NULL != m_pStr )
	{
		return m_pStr->c_str();
	}
	else
	{
		return (LPCTSTR)m_strDescription.c_str();
	}
}

void CDB_FlowLimitedControlValve::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_ControlValve::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( _T('\0') !=  *m_FLCVCharacteristicID && 0 != _tcscmp( _NO_ID, m_FLCVCharacteristicID ) )
		{
			IDPtr = GetDB()->Get( m_FLCVCharacteristicID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Flow limited control valve characteristic ID (%s) is defined but not found in the database."), m_FLCVCharacteristicID );
			}
		
			if( false == IDPtr.MP->IsClass( CLASS( CDB_FLCVCharacteristic ) ) )
			{
				HYSELECT_THROW( _T("Flow limited control valve characteristic ID (%s) is found in the database but it's not a 'CDB_FLCVCharacteristic' object."), m_FLCVCharacteristicID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_FlowLimitedControlValve::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

void CDB_FlowLimitedControlValve::SetFLCVCharacteristicID( LPCTSTR strCharacteristicID )
{
	ASSERT( _tcslen( strCharacteristicID ) <= _ID_LENGTH );
	_tcsncpy_s( m_FLCVCharacteristicID, SIZEOFINTCHAR( m_FLCVCharacteristicID ), (LPCTSTR)strCharacteristicID, SIZEOFINTCHAR( m_FLCVCharacteristicID ) - 1 );

	// Unlock if previous one exist.
	if( NULL != m_pFLCVCharacteristic )
	{
		m_pFLCVCharacteristic->Unlock( GetIDPtr() );
	}

	// Force a call to 'GetFLCVCharacteristic' to update 'm_pFLCVCharacteristic'.
	m_pFLCVCharacteristic = NULL;
	GetFLCVCharacteristic();
}

LPCTSTR CDB_FlowLimitedControlValve::SetDescription( LPCTSTR strDescription )
{
	Modified();

	int iLength = _tcslen( strDescription );
	ASSERT( iLength <= ( _PRODUCT_DESCRIPTION_LENGTH + 2 ) );

	m_strDescription = strDescription;
	return m_strDescription.c_str();
}

void CDB_FlowLimitedControlValve::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_FlowLimitedControlValve *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_FlowLimitedControlValve' object!") );
		}

		// Base class.
		CDB_ControlValve::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_FlowLimitedControlValve" class.
		CDB_FlowLimitedControlValve *pclDestinationFlowLimitedControlValve = (CDB_FlowLimitedControlValve *)pclDestination;

		pclDestinationFlowLimitedControlValve->SetFLCVCharacteristicID( m_FLCVCharacteristicID );
		pclDestinationFlowLimitedControlValve->SetDescription( m_strDescription.c_str() );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_FlowLimitedControlValve::Copy' method with the object '%s'."), GetIDPtr().ID )
}

void CDB_FlowLimitedControlValve::OnDatabaseDestroy()
{
	CDB_RegulatingValve::OnDatabaseDestroy();
	
	// Unlock the curve.
	if( NULL != GetFLCVCharacteristic() )
	{
		GetFLCVCharacteristic()->Unlock( GetIDPtr() );
	}
}

#define CDB_FLOWLIMITEDCONTROLVALVE_VERSION		1
void CDB_FlowLimitedControlValve::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_FLOWLIMITEDCONTROLVALVE_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_ControlValve::Write( outf );
	
	// Infos.
	// The curve ID.
	WriteString( outf, m_FLCVCharacteristicID );
	
	// Description.
	WriteString( outf, m_strDescription.c_str() );
}

bool CDB_FlowLimitedControlValve::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );
	
	if( Version < 1 || Version > CDB_FLOWLIMITEDCONTROLVALVE_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDB_ControlValve::Read( inpf ) )
	{
		return false;
	}

	// Infos.
	// Read the curve ID.
	if( false == ReadString( inpf, m_FLCVCharacteristicID, sizeof( m_FLCVCharacteristicID ) ) )
	{
		return false;
	}

	// Read description.
	if( false == ReadString( inpf, m_strDescription ) )
	{
		return false;
	}

	ASSERT( m_strDescription.size() <= ( _PRODUCT_DESCRIPTION_LENGTH + 2 ) );

	return true;
}

#ifndef TACBX 
void CDB_FlowLimitedControlValve::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( _T("CDB_FlowLimitedControlValve") );

		if( iPos < 0 )
		{
			CDB_ControlValve::InterpretInheritedData( pStr );
		}
		else
		{
			pStr->Delete( iPos, _tcsclen( _T("CDB_FlowLimitedControlValve") ) );
			int iEq = pStr->Find( _T("=") );

			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( _T("::FLCVCharID=") ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_FlowLimitedControlValve::FLCVCharID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetFLCVCharacteristicID( (LPCTSTR)strField );
			}
			else if( pStr->Find( _T("::Description=") ) > -1 )
			{
				if( _T('\"') == strField.GetAt( 0 ) )
				{
					strField.Delete( 0 );
				}

				if( _T('\"') == strField.GetAt( strField.GetLength() - 1 ) )
				{
					strField.Delete( strField.GetLength() - 1 );
				}

				if( strField.GetLength() > ( _PRODUCT_DESCRIPTION_LENGTH + 2 ) )
				{
					HYSELECT_THROW( _T("'CDB_FlowLimitedControlValve::Description' (%s) is too long (%i > %i)."), strField, strField.GetLength(), ( _PRODUCT_DESCRIPTION_LENGTH + 2 ) );
				}

				SetDescription( strField );
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_FlowLimitedControlValve::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_FlowLimitedControlValve::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str,str1;
	
	// Write object header.
	if( true == IsClass( CLASS( CDB_FlowLimitedControlValve ) ) )
	{
		CData::WriteText( outf, strTab );
	}
	
	// Opening bracket..
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	
	// Base class.
	strTab += _T("\t");
	CDB_ControlValve::WriteText( outf, strTab );

	// Data.
	WriteFormatedStringW( outf, m_FLCVCharacteristicID, strTab );
	WriteFormatedStringW( outf, m_strDescription.c_str(), strTab, true );

	// Closing bracket..
	strTab.Delete( 0 );
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}

void CDB_FlowLimitedControlValve::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_ThermostaticValve format
		// line 0 : open curve bracket and call base class.
		// line 1 : flow limited control valve curve ID
		// line 2 : description
		// line 3 : close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_FlowLimitedControlValve *)idptr.MP )->Copy( this );
		
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );
			
				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_ControlValve::ReadText( inpf, pusLineCount );

			// Read the flow limited control valve curve ID.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Curve ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			_tcsncpy_s( m_FLCVCharacteristicID, SIZEOFINTCHAR( m_FLCVCharacteristicID ), ptcLine, SIZEOFINTCHAR( m_FLCVCharacteristicID ) - 1  );
		
			// Read description.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			int iLength = _tcslen( ptcLine );

			if( iLength > ( _PRODUCT_DESCRIPTION_LENGTH + 2 ) )
			{
				HYSELECT_THROW( _T("Description (%s) is too long (%i > %i) (pos: %i)."), ptcLine, iLength, ( _PRODUCT_DESCRIPTION_LENGTH + 2 ), *pusLineCount );
			}

			if( _T('"') != *ptcLine )
			{
				HYSELECT_THROW( _T("Description must start with \" (pos: %i)."), *pusLineCount );
			}
			else if( _T('"') != ptcLine[iLength - 1] )
			{
				HYSELECT_THROW( _T("Description must end with \" (pos: %i)."), *pusLineCount );
			}

			ptcLine[iLength - 1] = _T('\0');
			m_strDescription = &ptcLine[1];
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_FlowLimitedControlValve::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif

#ifndef TACBX
////////////////////////////////////////////////////////////////
//
//		CDB_FloorHeatingManifold : Floor heating manifolds
//
////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_FloorHeatingManifold )

CDB_FloorHeatingManifold::CDB_FloorHeatingManifold( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_Product( pDataBase, ID )
{
	m_iHeatingCircuits = 0;
}

void CDB_FloorHeatingManifold::GetNameEx( _string *pStr, bool bWithUnit )
{
	std::wostringstream myStringStream;
	myStringStream << GetName() << _string( _T(" (") ) << GetHeatingCircuits() << _string( _T(")") );
	*pStr = myStringStream.str();
}

void CDB_FloorHeatingManifold::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_FloorHeatingManifold *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_FloorHeatingManifold' object!") );
		}

		// Base class.
		CDB_Product::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_FloorHeatingManifold" class.
		CDB_FloorHeatingManifold *pclDestinationFloorHeatingManifold = (CDB_FloorHeatingManifold *)pclDestination;

		pclDestinationFloorHeatingManifold->SetHeatingCircuits( m_iHeatingCircuits );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_FloorHeatingManifold::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_FLOORHEATINGMANIFOLD_VERSION	1
void CDB_FloorHeatingManifold::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_FLOORHEATINGMANIFOLD_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_Product::Write( outf );
	
	// Info.
	outf.write( (char *)&m_iHeatingCircuits, sizeof( m_iHeatingCircuits ) );
}

bool CDB_FloorHeatingManifold::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_FLOORHEATINGMANIFOLD_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_Product::Read( inpf ) )
	{
		return false;
	}
	
	// Infos.
	inpf.read( (char *)&m_iHeatingCircuits, sizeof( m_iHeatingCircuits ) );

	return true;
}

void CDB_FloorHeatingManifold::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( _T("CDB_FloorHeatingManifold") );

		if( iPos < 0 )
		{
			CDB_Product::InterpretInheritedData( pStr );
		}
		else
		{
			pStr->Delete( iPos, _tcsclen( _T("CDB_FloorHeatingManifold") ) );
			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );
		
			if( pStr->Find( _T("::HeatingCircuits=") ) > -1 )
			{
				m_iHeatingCircuits = _ttoi( (LPCTSTR)strField );
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_FloorHeatingManifold::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_FloorHeatingManifold::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str;
	
	// Write object header.
	if( true == IsClass(CLASS( CDB_FloorHeatingManifold ) ) )
	{
		CData::WriteText( outf, strTab );
	}
	
	// Opening bracket.
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");
	CDB_Product::WriteText( outf, strTab );
	
	// Data.
	str.Format( _T("\r\n%s%i"), strTab, m_iHeatingCircuits );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	
	// Closing bracket.
	strTab.Delete( 0 );
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}

void CDB_FloorHeatingManifold::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		//
		//	new:CDB_FloorHeatingManifold(ID)->CTRLVALV_TAB
		//	{
		//		--> CDB_Product	
		//		HeatingCircuits			Define the number of heating circuits.
		//	}
		//
		////////////////////////////////////////////////////////////////

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_FloorHeatingManifold *)idptr.MP )->Copy( this );

			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_Product::ReadText( inpf, pusLineCount );

			// Heating circuits.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_iHeatingCircuits = _tstoi( ptcLine );

			if( m_iHeatingCircuits < 0.0 )
			{
				HYSELECT_THROW( _T("Number heating circuits (%i) cann't be lower than 0 (pos: %i)."), m_iHeatingCircuits, *pusLineCount );
			}
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_TapWaterControl::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif 

#ifndef TACBX
////////////////////////////////////////////////////////////////
//
//		CDB_FloorHeatingValve : Floor heating control valves
//
////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_FloorHeatingValve )

CDB_FloorHeatingValve::CDB_FloorHeatingValve( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_Product( pDataBase, ID )
{
	m_iSupplyOrLockshield = 0;
	m_ConnectInletTypeIDptr = _NULL_IDPTR;
	m_ConnectInletSizeIDptr = _NULL_IDPTR;
	m_ConnectOutletTypeIDptr = _NULL_IDPTR;
	m_ConnectOutletSizeIDptr = _NULL_IDPTR;
	m_bHasHandwheel = false;
}

CString CDB_FloorHeatingValve::GetSupplyOrLockshieldString()
{
	CString strSupplyOrLockshield = _T("");

	if( 0 == m_iSupplyOrLockshield )
	{
		strSupplyOrLockshield = TASApp.LoadLocalizedString( IDS_FLOORHEATINGVALVE_SUPPLY );
	}
	else
	{
		strSupplyOrLockshield = TASApp.LoadLocalizedString( IDS_FLOORHEATINGVALVE_LOCKSHIELD );
	}

	return strSupplyOrLockshield;
}

const IDPTR &CDB_FloorHeatingValve::GetConnectInletTypeIDPtr()
{
	m_ConnectInletTypeIDptr.DB = GetDB();
	Extend( &m_ConnectInletTypeIDptr );
	return m_ConnectInletTypeIDptr;
}

CString CDB_FloorHeatingValve::GetConnectInletType()
{
	// Call 'GetConnectInletTypeIDPtr' to force 'Extend' if it is not already done.
	IDPTR ConnectInletTypeIDPtr = GetConnectInletTypeIDPtr();

	if( NULL != ConnectInletTypeIDPtr.MP )
	{
		CDB_StringID *pStr = (CDB_StringID *)( ConnectInletTypeIDPtr.MP );
		return pStr->GetString();
	}
	else
	{
		return _T("");
	}
}

const IDPTR &CDB_FloorHeatingValve::GetConnectInletSizeIDPtr()
{
	m_ConnectInletSizeIDptr.DB = GetDB();
	Extend( &m_ConnectInletSizeIDptr );
	return m_ConnectInletSizeIDptr;
}

CString CDB_FloorHeatingValve::GetConnectInletSize()
{
	// Call 'GetConnectInletSizeIDPtr' to force 'Extend' if it is not already done.
	IDPTR ConnectInletSizeIDPtr = GetConnectInletSizeIDPtr();

	if( NULL != ConnectInletSizeIDPtr.MP )
	{
		CDB_StringID *pStr = (CDB_StringID *)( ConnectInletSizeIDPtr.MP );
		return pStr->GetString();
	}
	else
	{
		return _T("");
	}
}

CString CDB_FloorHeatingValve::GetConnectInlet()
{
	CString strConnectInlet = GetConnectInletType() + _T(" ") + GetConnectInletSize();
	return strConnectInlet;
}

const IDPTR &CDB_FloorHeatingValve::GetConnectOutletTypeIDPtr()
{
	m_ConnectOutletTypeIDptr.DB = GetDB();
	Extend( &m_ConnectOutletTypeIDptr );
	return m_ConnectOutletTypeIDptr;
}

CString CDB_FloorHeatingValve::GetConnectOutletType()
{
	// Call 'GetConnectOutletTypeIDPtr' to force 'Extend' if it is not already done.
	IDPTR ConnectOutletTypeIDPtr = GetConnectOutletTypeIDPtr();

	if( NULL != ConnectOutletTypeIDPtr.MP )
	{
		CDB_StringID *pStr = (CDB_StringID *)( ConnectOutletTypeIDPtr.MP );
		return pStr->GetString();
	}
	else
	{
		return _T("");
	}
}

const IDPTR &CDB_FloorHeatingValve::GetConnectOutletSizeIDPtr()
{
	m_ConnectOutletSizeIDptr.DB = GetDB();
	Extend( &m_ConnectOutletSizeIDptr );
	return m_ConnectOutletSizeIDptr;
}

CString CDB_FloorHeatingValve::GetConnectOutletSize()
{
	// Call 'GetConnectOutletSizeIDPtr' to force 'Extend' if it is not already done.
	IDPTR ConnectOutletSizeIDPtr = GetConnectOutletSizeIDPtr();

	if( NULL != ConnectOutletSizeIDPtr.MP )
	{
		CDB_StringID *pStr = (CDB_StringID *)( ConnectOutletSizeIDPtr.MP );
		return pStr->GetString();
	}
	else
	{
		return _T("");
	}
}

CString CDB_FloorHeatingValve::GetConnectOutlet()
{
	CString strConnectOutlet = GetConnectOutletType() + _T(" ") + GetConnectOutletSize();
	return strConnectOutlet;
}

CString CDB_FloorHeatingValve::GetHasHandwheelString()
{
	CString strHasHandwheel = _T("");

	if( 0 == m_iSupplyOrLockshield )
	{
		if( false == m_bHasHandwheel )
		{
			strHasHandwheel = TASApp.LoadLocalizedString( IDS_FLOORHEATINGVALVE_WITHOUTHANDWHEEL );
		}
		else
		{
			strHasHandwheel = TASApp.LoadLocalizedString( IDS_FLOORHEATINGVALVE_WITHHANDWHEEL );
		}
	}

	return strHasHandwheel;
}

void CDB_FloorHeatingValve::SetConnectInletTypeID( LPCTSTR ptcConnectInletTypeID )
{ 
	memset( m_ConnectInletTypeIDptr.ID, 0, sizeof( m_ConnectInletTypeIDptr.ID ) );
	_tcsncpy_s( m_ConnectInletTypeIDptr.ID, SIZEOFINTCHAR( m_ConnectInletTypeIDptr.ID ), ptcConnectInletTypeID, SIZEOFINTCHAR( m_ConnectInletTypeIDptr.ID ) - 1 );
}

void CDB_FloorHeatingValve::SetConnectInletSizeID( LPCTSTR ptcConnectInletSizeID )
{ 
	memset( m_ConnectInletSizeIDptr.ID, 0, sizeof( m_ConnectInletSizeIDptr.ID ) );
	_tcsncpy_s( m_ConnectInletSizeIDptr.ID, SIZEOFINTCHAR( m_ConnectInletSizeIDptr.ID ), ptcConnectInletSizeID, SIZEOFINTCHAR( m_ConnectInletSizeIDptr.ID ) - 1 );
}

void CDB_FloorHeatingValve::SetConnectOutletTypeID( LPCTSTR ptcConnectOutletTypeID )
{
	memset( m_ConnectOutletTypeIDptr.ID, 0, sizeof( m_ConnectOutletTypeIDptr.ID ) );
	_tcsncpy_s( m_ConnectOutletTypeIDptr.ID, SIZEOFINTCHAR( m_ConnectOutletTypeIDptr.ID ), ptcConnectOutletTypeID, SIZEOFINTCHAR( m_ConnectOutletTypeIDptr.ID ) - 1 );
}

void CDB_FloorHeatingValve::SetConnectOutletSizeID( LPCTSTR ptcConnectOutletSizeID )
{
	memset( m_ConnectOutletSizeIDptr.ID, 0, sizeof( m_ConnectOutletSizeIDptr.ID ) );
	_tcsncpy_s( m_ConnectOutletSizeIDptr.ID, SIZEOFINTCHAR( m_ConnectOutletSizeIDptr.ID ), ptcConnectOutletSizeID, SIZEOFINTCHAR( m_ConnectOutletSizeIDptr.ID ) - 1 );
}

void CDB_FloorHeatingValve::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_FloorHeatingValve *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_FloorHeatingValve' object!") );
		}

		CDB_Product::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_FloorHeatingValve" class.
		CDB_FloorHeatingValve *pclDestinationFloorHeatingValve = (CDB_FloorHeatingValve *)pclDestination;

		pclDestinationFloorHeatingValve->SetSupplyOrLockshield( GetSupplyOrLockshield() );
		pclDestinationFloorHeatingValve->SetConnectInletTypeID( GetConnectInletTypeID() );
		pclDestinationFloorHeatingValve->SetConnectInletSizeID( GetConnectInletSizeID() );
		pclDestinationFloorHeatingValve->SetConnectOutletTypeID( GetConnectOutletTypeID() );
		pclDestinationFloorHeatingValve->SetConnectOutletSizeID( GetConnectOutletSizeID() );
		pclDestinationFloorHeatingValve->SetHasHandhweel( GetHasHandwheel() );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_FloorHeatingValve::Copy' method with the object '%s'."), GetIDPtr().ID )
}

void CDB_FloorHeatingValve::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_Product::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( _T('\0') != *m_ConnectInletTypeIDptr.ID && 0 != _tcscmp( _NO_ID, m_ConnectInletTypeIDptr.ID ) )
		{
			IDPtr = GetDB()->Get( m_ConnectInletTypeIDptr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Connect inlet type ID (%s) is defined but not found in the database."), m_ConnectInletTypeIDptr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_Connect ) ) )
			{
				HYSELECT_THROW( _T("Connect inlet type ID (%s) is found in the database but it's not a 'CDB_Connect' object."), m_ConnectInletTypeIDptr.ID );
			}
		}

		if( _T('\0') != *m_ConnectInletSizeIDptr.ID && 0 != _tcscmp( _NO_ID, m_ConnectInletSizeIDptr.ID ) )
		{
			IDPtr = GetDB()->Get( m_ConnectInletSizeIDptr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Connect inlet size ID (%s) is defined but not found in the database."), m_ConnectInletSizeIDptr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("Connect inlet size ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_ConnectInletSizeIDptr.ID );
			}
		}
	
		if( _T('\0') !=  *m_ConnectOutletTypeIDptr.ID && 0 != _tcscmp( _NO_ID, m_ConnectOutletTypeIDptr.ID ) )
		{
			IDPtr = GetDB()->Get( m_ConnectOutletTypeIDptr.ID );
		
			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Connect outlet type ID (%s) is defined but not found in the database."), m_ConnectOutletTypeIDptr.ID );
			}
		
			if( false == IDPtr.MP->IsClass( CLASS( CDB_Connect ) ) )
			{
				HYSELECT_THROW( _T("Connect outlet type ID (%s) is found in the database but it's not a 'CDB_Connect' object."), m_ConnectOutletTypeIDptr.ID );
			}
		}

		if( _T('\0') !=  *m_ConnectOutletSizeIDptr.ID && 0 != _tcscmp( _NO_ID, m_ConnectOutletSizeIDptr.ID ) )
		{
			IDPtr = GetDB()->Get( m_ConnectOutletSizeIDptr.ID );
		
			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Connect outlet size ID (%s) is defined but not found in the database."), m_ConnectOutletSizeIDptr.ID );
			}
		
			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("Connect outlet size ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_ConnectOutletSizeIDptr.ID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_FloorHeatingValve::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

#define CDB_FLOORHEATINGVALVE_VERSION	1
void CDB_FloorHeatingValve::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_FLOORHEATINGVALVE_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_Product::Write( outf );
	
	// Info.
	outf.write( (char *)&m_iSupplyOrLockshield, sizeof( m_iSupplyOrLockshield ) );
	WriteString( outf, m_ConnectInletTypeIDptr.ID );
	WriteString( outf, m_ConnectInletSizeIDptr.ID );
	WriteString( outf, m_ConnectOutletTypeIDptr.ID );
	WriteString( outf, m_ConnectOutletSizeIDptr.ID );
	outf.write( (char *)&m_bHasHandwheel, sizeof( m_bHasHandwheel ) );
}

bool CDB_FloorHeatingValve::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_FLOORHEATINGVALVE_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_Product::Read( inpf ) )
	{
		return false;
	}
	
	// Infos.
	inpf.read( (char *)&m_iSupplyOrLockshield, sizeof( m_iSupplyOrLockshield ) );

	if( false == ReadString( inpf, m_ConnectInletTypeIDptr.ID, sizeof( m_ConnectInletTypeIDptr.ID ) ) )
	{
		return false;     
	}

	if( false == ReadString( inpf, m_ConnectInletSizeIDptr.ID, sizeof( m_ConnectInletSizeIDptr.ID ) ) )
	{
		return false;     
	}

	if( false == ReadString( inpf, m_ConnectOutletTypeIDptr.ID, sizeof( m_ConnectOutletTypeIDptr.ID ) ) )
	{
		return false;     
	}

	if( false == ReadString( inpf, m_ConnectOutletSizeIDptr.ID, sizeof( m_ConnectOutletSizeIDptr.ID ) ) )
	{
		return false;     
	}
	
	inpf.read( (char *)&m_bHasHandwheel, sizeof( m_bHasHandwheel ) );

	return true;
}

#define FHV_SUPPLYORLOCKSHIELD			_T("::SupplyOrLockshield=")
#define FHV_CONNECTINLETTYPEID			_T("::ConnectInletTypeID=")
#define FHV_CONNECTINLETSIZEID			_T("::ConnectInletSizeID=")
#define FHV_CONNECTOUTLETTYPEID    		_T("::ConnectOutletTypeID=")
#define FHV_CONNECTOUTLETSIZEID    		_T("::ConnectOutletSizeID=")
#define FHV_HANDWHEEL    				_T("::Handwheel=")
void CDB_FloorHeatingValve::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( CLASS( CDB_FloorHeatingValve ) );

		if( pStr->Left(2) != _T("::") && iPos < 0 )
		{
			CDB_Product::InterpretInheritedData( pStr );
		}
		else
		{
			if( iPos >= 0 )
			{
				pStr->Delete( iPos, _tcsclen( CLASS( CDB_FloorHeatingValve ) ) );
			}

			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );
		
			if( pStr->Find( FHV_SUPPLYORLOCKSHIELD ) > -1 )
			{
				m_iSupplyOrLockshield = _ttoi( (LPCTSTR)strField );

				if( m_iSupplyOrLockshield != 0 && m_iSupplyOrLockshield != 1 )
				{
					HYSELECT_THROW( _T("'CDB_FloorHeatingValve::SupplyOrLockshield' (%s) must be 0 or 1."), strField, strField.GetLength(), _ID_LENGTH );
				}
			}
			else if( pStr->Find( FHV_CONNECTINLETTYPEID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_FloorHeatingValve::ConnectInletTypeID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetConnectInletTypeID( (LPCTSTR)strField );
			}
			else if( pStr->Find( FHV_CONNECTINLETSIZEID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_FloorHeatingValve::ConnectInletSizeID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetConnectInletSizeID( (LPCTSTR)strField );
			}
			else if( pStr->Find( FHV_CONNECTOUTLETTYPEID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_FloorHeatingValve::ConnectOutletTypeID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetConnectOutletTypeID( (LPCTSTR)strField );
			}
			else if( pStr->Find( FHV_CONNECTOUTLETSIZEID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_FloorHeatingValve::ConnectOutletSizeID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetConnectOutletSizeID( (LPCTSTR)strField );
			}
			else if( pStr->Find( FHV_HANDWHEEL ) > -1 )
			{
				m_bHasHandwheel = ( 0 == _ttoi( (LPCTSTR)strField ) ) ? false : true;
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_FloorHeatingValve::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_FloorHeatingValve::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str;
	
	// Write object header.
	if( true == IsClass(CLASS( CDB_FloorHeatingValve ) ) )
	{
		CData::WriteText( outf, strTab );
	}
	
	// Opening bracket.
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");
	CDB_Product::WriteText( outf, strTab );
	
	// Data.
	str.Format( _T("\r\n%s%i"), strTab, m_iSupplyOrLockshield );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	WriteFormatedStringW( outf, m_ConnectInletTypeIDptr.ID, strTab );
	WriteFormatedStringW( outf, m_ConnectInletSizeIDptr.ID, strTab );
	WriteFormatedStringW( outf, m_ConnectOutletTypeIDptr.ID, strTab );
	WriteFormatedStringW( outf, m_ConnectOutletSizeIDptr.ID, strTab );

	str.Format( _T("\r\n%s%i"), strTab, ( true == m_bHasHandwheel ) ? 1 : 0 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	
	// Closing bracket.
	strTab.Delete( 0 );
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}

void CDB_FloorHeatingValve::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		//
		//	new:CDB_FloorHeatingValve(ID)->CTRLVALV_TAB
		//	{
		//		--> CDB_Product	
		//		SupplyOrLockshield			0 = Supply, 1 = Lockshield
		//		ConnectInletTypeID			Connection inlet type ID.
		//		ConnectInletSizeID			Connection inlet size ID.
		// 		ConnectOutletTypeID			Connection outlet type ID.
		//		ConnectInletSizeID			Connection inlet size ID.
		//		Handwheel					0 = without handweel, 1 = with handwheel.
		//	}
		//
		////////////////////////////////////////////////////////////////

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_FloorHeatingValve *)idptr.MP )->Copy( this );

			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				CDB_FloorHeatingValve::InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_Product::ReadText( inpf, pusLineCount );

			CStringArray TxtHdr;
			TxtHdr.Add( FHV_SUPPLYORLOCKSHIELD );
			TxtHdr.Add( FHV_CONNECTINLETTYPEID );
			TxtHdr.Add( FHV_CONNECTINLETSIZEID );
			TxtHdr.Add( FHV_CONNECTOUTLETTYPEID );
			TxtHdr.Add( FHV_CONNECTOUTLETSIZEID );
			TxtHdr.Add( FHV_HANDWHEEL );
		
			for( int i = 0; i < TxtHdr.GetSize(); i++ )
			{
				ptcLine = ReadTextLine( inpf, pusLineCount );

				CString str = TxtHdr[i] + CString( ptcLine );
				CDB_FloorHeatingValve::InterpretInheritedData( &str );
			}
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_FloorHeatingValve::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif 

#ifndef TACBX
////////////////////////////////////////////////////////////////
//
//		CDB_FloorHeatingController : Floor heating controllers
//
////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_FloorHeatingController )

CDB_FloorHeatingController::CDB_FloorHeatingController( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_Product( pDataBase, ID )
{
}

void CDB_FloorHeatingController::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_FloorHeatingController *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_FloorHeatingController' object!") );
		}

		CDB_Product::Copy( pclDestination );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_FloorHeatingController::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_FLOORHEATINGCONTROLLER_VERSION	1
void CDB_FloorHeatingController::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_FLOORHEATINGCONTROLLER_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_Product::Write( outf );
	
	// Info.
}

bool CDB_FloorHeatingController::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_FLOORHEATINGCONTROLLER_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_Product::Read( inpf ) )
	{
		return false;
	}
	
	// Infos.
	return true;
}

void CDB_FloorHeatingController::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( _T("CDB_FloorHeatingController") );

		if( iPos < 0 )
		{
			CDB_Product::InterpretInheritedData( pStr );
		}
		else
		{
			pStr->Delete( iPos, _tcsclen( _T("CDB_FloorHeatingController") ) );
			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_FloorHeatingController::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_FloorHeatingController::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str;
	
	// Write object header.
	if( true == IsClass(CLASS( CDB_FloorHeatingController ) ) )
	{
		CData::WriteText( outf, strTab );
	}
	
	// Opening bracket.
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");
	CDB_Product::WriteText( outf, strTab );
	
	// Closing bracket.
	strTab.Delete( 0 );
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}

void CDB_FloorHeatingController::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		//
		//	new:CDB_FloorHeatingController(ID)->CTRLVALV_TAB
		//	{
		//		--> CDB_Product	
		//	}
		//
		////////////////////////////////////////////////////////////////

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_FloorHeatingController *)idptr.MP )->Copy( this );

			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_Product::ReadText( inpf, pusLineCount );
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_TapWaterControl::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif 

#ifndef TACBX
////////////////////////////////////////////////////////////////
//
//		CDB_TapWaterControl : Tap water control products
//
////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_TapWaterControl )

CDB_TapWaterControl::CDB_TapWaterControl( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_RegulatingValve( pDataBase, ID )
{
	m_dMinTempOfAdjustableRange = 0.0;
	m_dMaxTempOfAdjustableRange = 0.0;
	m_HotWaterMainsSizeIDPtr = _NULL_IDPTR;
}

IDPTR CDB_TapWaterControl::GetHotWaterMainsSizeIDPtr()
{
	m_HotWaterMainsSizeIDPtr.DB = GetDB();

	if( _T('\0') != *m_HotWaterMainsSizeIDPtr.ID && 0 != _tcscmp( _NO_ID, m_HotWaterMainsSizeIDPtr.ID ) && NULL != m_HotWaterMainsSizeIDPtr.DB )
	{
		Extend( &m_HotWaterMainsSizeIDPtr );
		return m_HotWaterMainsSizeIDPtr;
	}
	else
	{
		return _NULL_IDPTR;
	}
}

CString CDB_TapWaterControl::GetTempAdjustableRangeStr( bool bWithUnits )
{
	CString str;

	if( -273.15 < m_dMinTempOfAdjustableRange )
	{
		str = WriteCUDouble( _U_TEMPERATURE, m_dMinTempOfAdjustableRange, false );
	}
	else
	{
		str = _T("-");
	}
	
	str += _T("/");
	
	if( -273.15 < m_dMaxTempOfAdjustableRange )
	{
		str += WriteCUDouble( _U_TEMPERATURE, m_dMaxTempOfAdjustableRange, false );
	}
	else
	{
		str = _T("-");
	}

	if( true == bWithUnits )
	{
		str = str + L" " + GetNameOf( TASApp.GetpUnitDB()->GetDefaultUnit( _U_TEMPERATURE ) ).c_str();
	}
	
	return str;
}

void CDB_TapWaterControl::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_RegulatingValve::CrossVerifyID();

		if( _T('\0') !=  *m_HotWaterMainsSizeIDPtr.ID && 0 != _tcscmp( _NO_ID, m_HotWaterMainsSizeIDPtr.ID ) )
		{
			IDPTR IDPtr = GetDB()->Get( m_HotWaterMainsSizeIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Hot water main size ID (%s) is defined but not found in the database."), m_HotWaterMainsSizeIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("Hot water main size ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_HotWaterMainsSizeIDPtr.ID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_TapWaterControl::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

void CDB_TapWaterControl::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_TapWaterControl *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_TapWaterControl' object!") );
		}

		// Base class.
		CDB_RegulatingValve::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_TapWaterControl" class.
		CDB_TapWaterControl *pclDestinationTapWaterControl = (CDB_TapWaterControl *)pclDestination;

		pclDestinationTapWaterControl->SetMinTempOfAdjustableRange( m_dMinTempOfAdjustableRange );
		pclDestinationTapWaterControl->SetMaxTempOfAdjustableRange( m_dMaxTempOfAdjustableRange );
		pclDestinationTapWaterControl->SetHotWaterMainsSizeID( m_HotWaterMainsSizeIDPtr.ID );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_TapWaterControl::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_TAPWATERCONTROL_VERSION	1
void CDB_TapWaterControl::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_TAPWATERCONTROL_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_RegulatingValve::Write( outf );
	
	// Info.
	outf.write( (char *)&m_dMinTempOfAdjustableRange, sizeof( m_dMinTempOfAdjustableRange ) );
	outf.write( (char *)&m_dMaxTempOfAdjustableRange, sizeof( m_dMaxTempOfAdjustableRange ) );
	WriteString( outf, m_HotWaterMainsSizeIDPtr.ID );
}

bool CDB_TapWaterControl::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_TAPWATERCONTROL_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_RegulatingValve::Read( inpf ) )
	{
		return false;
	}
	
	// Infos.
	m_dMinTempOfAdjustableRange = ReadDouble( inpf );
	m_dMaxTempOfAdjustableRange = ReadDouble( inpf );

	m_HotWaterMainsSizeIDPtr = _NULL_IDPTR; 

	if( false == ReadString( inpf, m_HotWaterMainsSizeIDPtr.ID, sizeof( m_HotWaterMainsSizeIDPtr.ID ) ) )
	{
		return false;
	}

	return true;
}

void CDB_TapWaterControl::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( _T("CDB_TapWaterControl") );

		if( iPos < 0 )
		{
			CDB_RegulatingValve::InterpretInheritedData( pStr );
		}
		else
		{
			pStr->Delete( iPos, _tcsclen( _T("CDB_TapWaterControl") ) );
			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );
		
			if( pStr->Find( _T("::MinTemp=") ) > -1 )
			{
				if( RD_OK != ReadDouble( strField, &m_dMinTempOfAdjustableRange ) )
				{
					HYSELECT_THROW( _T("Can't convert 'CDB_TapWaterControl::MinTemp' (%s) in double."), strField );
				}
			}
			else if( pStr->Find( _T("::MaxTemp=") ) > -1 )
			{
				if( RD_OK != ReadDouble( strField, &m_dMaxTempOfAdjustableRange ) )
				{
					HYSELECT_THROW( _T("Can't convert 'CDB_TapWaterControl::MaxTemp' (%s) in double."), strField );
				}
			}
			else if( pStr->Find( _T("::HotWaterMainsSizeID=") ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_TapWaterControl::HotWaterMainsSizeID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetHotWaterMainsSizeID( (LPCTSTR)strField );
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_TapWaterControl::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_TapWaterControl::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str, str1;
	
	// Write object header.
	if( true == IsClass(CLASS( CDB_TapWaterControl ) ) )
	{
		CData::WriteText( outf, strTab );
	}
	
	// Opening bracket.
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");
	CDB_RegulatingValve::WriteText( outf, strTab );
	
	// Data.
	WriteFormatedStringW( outf, WriteDouble( m_dMinTempOfAdjustableRange, 2, 1 ), strTab );
	WriteFormatedStringW( outf, WriteDouble( m_dMaxTempOfAdjustableRange, 2, 1 ),strTab );
	WriteFormatedStringW( outf, m_HotWaterMainsSizeIDPtr.ID, strTab );
	
	// Closing bracket.
	strTab.Delete( 0 );
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}

void CDB_TapWaterControl::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		//
		//	new:CDB_TapWaterControl(ID)->CTRLVALV_TAB
		//	{
		//		--> RegulatingValve	
		//		MinTemp					Min. temperature of the adjustable range.
		//		MaxTemp					Max. temperature of the adjustable range.
		//      HotWaterMainsSizeID		Identifier of the hot water mains input size ID.
		//	}
		//
		////////////////////////////////////////////////////////////////

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_TapWaterControl *)idptr.MP )->Copy( this );

			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_RegulatingValve::ReadText( inpf, pusLineCount );

			TCHAR *ptcEndPtr;
		
			// Min. temperature of the adjustable range.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			m_dMinTempOfAdjustableRange = _tcstod( ptcLine, &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't convert min. temperature of the adjustable range value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
			}
		
			// Max. temperature of the adjustable range.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			m_dMaxTempOfAdjustableRange = _tcstod( ptcLine, &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't convert max. temperature of the adjustable range value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
			}
		
			// Close Off characteristic ID.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Close-off characteristic ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			_tcsncpy_s( m_HotWaterMainsSizeIDPtr.ID, SIZEOFINTCHAR( m_HotWaterMainsSizeIDPtr.ID ), ptcLine, SIZEOFINTCHAR( m_HotWaterMainsSizeIDPtr.ID) - 1 );
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_TapWaterControl::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif 

////////////////////////////////////////////////////////////////
//
//		CDB_DpCBCValve : Combined Dp Controller and Balancing & control valve.
//
////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_DpCBCValve )

CDB_DpCBCValve::CDB_DpCBCValve( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_ControlValve( pDataBase, ID )
{
	*m_DPCBCVCharacteristicID = _T('\0');
	m_pDpCBCVCharacteristic = NULL;
}

CDB_DpCBCVCharacteristic *CDB_DpCBCValve::GetDpCBCVCharacteristic()
{
	HYSELECT_TRY
	{
		if( NULL == m_pDpCBCVCharacteristic )
		{
			if( _T('\0') !=  *m_DPCBCVCharacteristicID && 0 != IDcmp( m_DPCBCVCharacteristicID, _NO_ID ) )
			{
				IDPTR CharactPtr = GetDB()->Get( m_DPCBCVCharacteristicID );
				
				if( _T('\0') == *CharactPtr.ID )
				{
					HYSELECT_THROW_RETURNARG( _T("Internal error: Can't find combined Dp controller, balancing & control valve characteristic '%s' in the database."), NULL, m_DPCBCVCharacteristicID );
				}

				m_pDpCBCVCharacteristic = (CDB_DpCBCVCharacteristic*)( CharactPtr.MP );
				m_pDpCBCVCharacteristic->Lock( GetIDPtr() );
			}
		}
	
		return m_pDpCBCVCharacteristic;
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CDB_DpCBCValve::GetDpCBCVCharacteristi'.") )
}

double CDB_DpCBCValve::GetDppmin( double dFlow, double dRho )
{
	if( dFlow <= 0.0 || dRho <= 0.0 || NULL == m_pDpCBCVCharacteristic )
	{
		return -1.0;
	}

	double dKvm = m_pDpCBCVCharacteristic->GetKvm();

	if( dKvm <= 0.0 )
	{
		return -1.0;
	}
	
	return CalcDp( dFlow, dKvm, dRho );
}

double CDB_DpCBCValve::GetDpk( double dFlow )
{
	if( NULL == m_pDpCBCVCharacteristic )
	{
		return -1.0;
	}

	return m_pDpCBCVCharacteristic->GetDpk( dFlow );
}

double CDB_DpCBCValve::GetHMin( double dFlow, double dRho )
{
	double dDpk = GetDpk( dFlow );

	if( -1.0 == dDpk )
	{
		return -1.0;
	}

	double dDppmin = GetDppmin( dFlow, dRho );

	if( -1.0 == dDppmin )
	{
		return -1.0;
	}

	return ( dDpk + dDppmin );
}

double CDB_DpCBCValve::GetDplmin()
{
	if( NULL == m_pDpCBCVCharacteristic )
	{
		return -1.0;
	}

	return m_pDpCBCVCharacteristic->GetDplmin();
}

double CDB_DpCBCValve::GetDplmax( double dFlow, double dRho )
{
	CDS_TechnicalParameter *pTADBTech = (CDS_TechnicalParameter *)( GetpTADB()->Get( _T("PARAM_TECH") ).MP );

	if( dFlow <= 0.0 || NULL == pTADBTech )
	{
		return -1.0;
	}

	double dDpk = GetDpk( dFlow );

	if( -1.0 == dDpk )
	{
		return -1.0;
	}

	double dDpcmin = pTADBTech->GetDpCBCVDpcmin();
	double dKvcAtMaxSetting = m_pDpCBCVCharacteristic->GetSettingKvcCurve()->GetYmax();
	double dDpcAtMaxSetting = CalcDp( dFlow, dKvcAtMaxSetting, dRho );

	if( dDpcmin <= 0.0 || dDpcAtMaxSetting <= 0.0 )
	{
		return -1.0;
	}

	if( dDpk <= max( dDpcmin, dDpcAtMaxSetting ) )
	{
		return -1.0;
	}

	return ( dDpk - max( dDpcmin, dDpcAtMaxSetting ) );
}

double CDB_DpCBCValve::GetDpc( double dFlow, double dDpl )
{
	CDS_TechnicalParameter *pTADBTech = (CDS_TechnicalParameter *)( GetpTADB()->Get( _T("PARAM_TECH") ).MP );

	double dDpk = GetDpk( dFlow );

	if( -1.0 == dDpk )
	{
		return -1.0;
	}

	if( dDpk - dDpl <= pTADBTech->GetDpCBCVDpcmin() )
	{
		return -1.0;
	}

	return ( dDpk - dDpl );
}

double CDB_DpCBCValve::GetDpmin( double dFlow, double dRho, double dDpl )
{
	double dDpmin = -1.0;

	double dDpp = GetDppmin( dFlow, dRho );
	double dDpc = GetDpc( dFlow, dDpl );

	if( dDpp > 0.0 && dDpc > 0.0 )
	{
		dDpmin = dDpp + dDpc;
	}

	return dDpmin;
}

double CDB_DpCBCValve::GetSetting( double dFlow, double dRho, double dDpl )
{
	if( NULL == m_pDpCBCVCharacteristic )
	{
		return -1.0;
	}

	double dDpc = GetDpc( dFlow, dDpl );

	if( -1.0 == dDpc )
	{
		return -1.0;
	}

	return m_pDpCBCVCharacteristic->GetSetting( dDpc, dFlow, dRho );
}

double CDB_DpCBCValve::GetMaxSetting()
{
	CDB_DpCBCVCharacteristic *pDpCBCValveCharacteristic = GetDpCBCVCharacteristic();
	
	if( NULL == pDpCBCValveCharacteristic )
	{
		return -1.0;
	}
	
	return pDpCBCValveCharacteristic->GetOpeningMax();
}

double CDB_DpCBCValve::GetQmax()
{
	double dQmax = -1.0;

	if( NULL != GetDpCBCVCharacteristic() )
	{
		dQmax = GetDpCBCVCharacteristic()->GetQmax();
	}
	
	return dQmax;
}

_string CDB_DpCBCValve::GetFormatedDplRange( double dFlow, double dRho, bool fWithUnit )
{
	_string strDplmin = ( -1.0 == GetDplmin() ) ? L"x" : WriteCUDouble( _U_DIFFPRESS, GetDplmin() );
	_string strDplmax = ( -1.0 == GetDplmax( dFlow, dRho ) ) ? L"x" : WriteCUDouble( _U_DIFFPRESS, GetDplmax( dFlow, dRho ) );

	_string str = _T("[") + strDplmin + _T("-") + strDplmax + _T("]");
	CUnitDatabase *pUnitDB = CDimValue::AccessUDB();
	
	if( true == fWithUnit )
	{
		str += _T(" ") + pUnitDB->GetNameOfDefaultUnit( _U_DIFFPRESS );
	}
	
	return str;
}

void CDB_DpCBCValve::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_ControlValve::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( _T('\0') !=  *m_DPCBCVCharacteristicID && 0 != _tcscmp( _NO_ID, m_DPCBCVCharacteristicID ) )
		{
			IDPtr = GetDB()->Get( m_DPCBCVCharacteristicID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("DpCBCV characteristic ID (%s) is defined but not found in the database."), m_DPCBCVCharacteristicID );
			}
		
			if( false == IDPtr.MP->IsClass( CLASS( CDB_DpCBCVCharacteristic ) ) )
			{
				HYSELECT_THROW( _T("DpCBCV characteristic ID (%s) is found in the database but it's not a 'CDB_DpCBCVCharacteristic' object."), m_DPCBCVCharacteristicID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_DpCBCValve::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

void CDB_DpCBCValve::SetDpCBCVCharacteristicID( LPCTSTR strDpCBCVCharacteristicID )
{
	ASSERT( _tcslen( strDpCBCVCharacteristicID ) <= _ID_LENGTH );
	_tcsncpy_s( m_DPCBCVCharacteristicID, SIZEOFINTCHAR( m_DPCBCVCharacteristicID ), (LPCTSTR)strDpCBCVCharacteristicID, SIZEOFINTCHAR( m_DPCBCVCharacteristicID ) - 1 );

	// Unlock if previous one exist.
	if( NULL != m_pDpCBCVCharacteristic )
	{
		m_pDpCBCVCharacteristic->Unlock( GetIDPtr() );
	}

	// Force a call to 'GetDpCBCVCharacteristic' to update 'm_pDpCBCVCharacteristic'.
	m_pDpCBCVCharacteristic = NULL;
	GetDpCBCVCharacteristic();
}

void CDB_DpCBCValve::OnDatabaseDestroy()
{
	CDB_ControlValve::OnDatabaseDestroy();
	
	// Unlock the PICV curve.
	if( NULL != GetDpCBCVCharacteristic() )
	{
		GetDpCBCVCharacteristic()->Unlock( GetIDPtr() );
	}
}

void CDB_DpCBCValve::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_DpCBCValve *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_DpCBCValve' object!") );
		}

		// Base class.
		CDB_ControlValve::Copy( pclDestination );

		// Copy now what it is common to the "CDB_DpCBCValve" class.
		CDB_DpCBCValve *pclDestinationDpCBCValve = (CDB_DpCBCValve *)pclDestination;

		pclDestinationDpCBCValve->SetDpCBCVCharacteristicID( m_DPCBCVCharacteristicID );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_DpCBCValve::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define  CDB_DPCONTROLLERBCVALVE_VERSION		1
void CDB_DpCBCValve::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_DPCONTROLLERBCVALVE_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_ControlValve::Write( outf );
	
	// Info.
	WriteString( outf, m_DPCBCVCharacteristicID );
}

bool CDB_DpCBCValve::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_DPCONTROLLERBCVALVE_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_ControlValve::Read( inpf ) )
	{
		return false;
	}
	
	// Info.
	if( false == ReadString( inpf, m_DPCBCVCharacteristicID, sizeof( m_DPCBCVCharacteristicID ) ) )
	{
		return false;
	}

	return true;
}

#ifndef TACBX
void CDB_DpCBCValve::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( _T("CDB_DpCBCValve") );

		if( iPos < 0 )
		{
			CDB_ControlValve::InterpretInheritedData( pStr );
		}
		else
		{
			pStr->Delete( iPos, _tcsclen( _T("CDB_DpCBCValve") ) );
			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );
		
			if( pStr->Find( _T("::DPCBCVCharID=") ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_DpCBCValve::DPCBCVCharID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetDpCBCVCharacteristicID( (LPCTSTR)strField );
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_DpCBCValve::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_DpCBCValve::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str, str1;
	
	// Write object header.
	if( true == IsClass( CLASS( CDB_DpCBCValve ) ) )
	{
		CData::WriteText( outf, strTab );
	}
	
	// Opening bracket.
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	// Base class.
	strTab += _T("\t");
	CDB_ControlValve::WriteText( outf, strTab );
	
	// Data.
	WriteFormatedStringW( outf, m_DPCBCVCharacteristicID, strTab );
	
	// Closing bracket.
	strTab.Delete( 0 );
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}

void CDB_DpCBCValve::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		//
		//	new:CDB_DpCBCValve(ID)->DPCBCVALV_TAB
		//	{
		//		--> Control valve
		//		DPCBCVCharID		Identifier of the DPCBCV characteristic
		//	}
		//
		////////////////////////////////////////////////////////////////

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_DpCBCValve *)idptr.MP )->Copy( this );
		
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );

			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_ControlValve::ReadText( inpf, pusLineCount );

			// Read the characteristic ID.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Characteristic ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			SetDpCBCVCharacteristicID( ptcLine );
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_DpCBCValve::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_FixedOrifice
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_FixedOrifice)

CDB_FixedOrifice::CDB_FixedOrifice( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_TAProduct( pDataBase, ID )
{
	*m_FixedOrificeCharacteristicID = _T('\0');
	m_pFixedOrificeCharacteristic = NULL;
}

CDB_FixOCharacteristic *CDB_FixedOrifice::GetFixedOrificeCharacteristic()
{
	HYSELECT_TRY
	{
		if( NULL == m_pFixedOrificeCharacteristic )
		{
			if( _T('\0') !=  *m_FixedOrificeCharacteristicID && 0 != IDcmp( m_FixedOrificeCharacteristicID, _NO_ID ) )
			{
				IDPTR CharactPtr = GetDB()->Get( m_FixedOrificeCharacteristicID );
				
				if( _T('\0') == *CharactPtr.ID )
				{
					HYSELECT_THROW_RETURNARG( _T("Internal error: Can't find fixed orifice characteristic '%s' in the database."), NULL, m_FixedOrificeCharacteristicID );
				}

				m_pFixedOrificeCharacteristic = (CDB_FixOCharacteristic*)( CharactPtr.MP );

				if( NULL != m_pFixedOrificeCharacteristic )
				{
					m_pFixedOrificeCharacteristic->Lock( GetIDPtr() );
				}
			}
		}
	
		return m_pFixedOrificeCharacteristic;
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CDB_FixedOrifice::GetFixedOrificeCharacteristic'.") )
}	

double CDB_FixedOrifice::GetKv()
{
	double dKv = -1.0;

	if( NULL != GetFixedOrificeCharacteristic() )
	{
		dKv = GetFixedOrificeCharacteristic()->GetKv();
	}

	return dKv;
}
	
double CDB_FixedOrifice::GetKvSignal()
{
	double dKvSignal = -1.0;

	if( NULL != GetFixedOrificeCharacteristic() )
	{
		dKvSignal = GetFixedOrificeCharacteristic()->GetKvSignal();
	}

	return dKvSignal;
}

void CDB_FixedOrifice::SetCharID( _string ID )
{
	ASSERT( ID.length() <= _ID_LENGTH );
	_tcsncpy_s( m_FixedOrificeCharacteristicID, SIZEOFINTCHAR( m_FixedOrificeCharacteristicID ), ID.c_str(), _ID_LENGTH );

	// Unlock if previous one exist.
	if( NULL != m_pFixedOrificeCharacteristic )
	{
		m_pFixedOrificeCharacteristic->Unlock( GetIDPtr() );
	}

	// Force a call to 'GetFixedOrificeCharacteristic' to update 'm_pFixedOrificeCharacteristic'.
	m_pFixedOrificeCharacteristic = NULL;
	GetFixedOrificeCharacteristic();
}

void CDB_FixedOrifice::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_TAProduct::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( _T('\0') !=  *m_FixedOrificeCharacteristicID && 0 != _tcscmp( _NO_ID, m_FixedOrificeCharacteristicID ) )
		{
			IDPtr = GetDB()->Get( m_FixedOrificeCharacteristicID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Fixed orifice characteristic ID (%s) is defined but not found in the database."), m_FixedOrificeCharacteristicID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_FixOCharacteristic ) ) )
			{
				HYSELECT_THROW( _T("Fixed orifice characteristic ID (%s) is found in the database but it's not a 'CDB_FixOCharacteristic' object."), m_FixedOrificeCharacteristicID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_FixedOrifice::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

void CDB_FixedOrifice::OnDatabaseDestroy()
{
	CDB_TAProduct::OnDatabaseDestroy();

	// Unlock the characteristic.
	if( NULL != GetFixedOrificeCharacteristic() )
	{
		GetFixedOrificeCharacteristic()->Unlock( GetIDPtr() );
	}
}

void CDB_FixedOrifice::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_FixedOrifice *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_FixedOrifice' object!") );
		}
	
		// Base class.
		CDB_TAProduct::Copy( pclDestination );

		// Copy now what it is common to the "CDB_FixedOrifice" class.
		CDB_FixedOrifice *pclDestinationFixedOrifice = (CDB_FixedOrifice *)pclDestination;

		pclDestinationFixedOrifice->SetCharID( m_FixedOrificeCharacteristicID );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_FixedOrifice::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_FIXEDORIFICE_VERSION	1
void CDB_FixedOrifice::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_FIXEDORIFICE_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_TAProduct::Write( outf );
	
	// Infos
	// The fixed orifice characteristic ID.
	WriteString( outf, m_FixedOrificeCharacteristicID );
}

bool CDB_FixedOrifice::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_FIXEDORIFICE_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_TAProduct::Read( inpf ) )
	{
		return false;
	}
	
	// Infos
	// The fixed orifice characteristic ID.
	if( false == ReadString( inpf, m_FixedOrificeCharacteristicID, sizeof( m_FixedOrificeCharacteristicID ) ) )
	{
		return false;
	}

	return true;
}

#ifndef TACBX 
void CDB_FixedOrifice::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class
		int iPos = pStr->Find( _T("CDB_FixedOrifice") );

		if( iPos < 0 )
		{
			CDB_TAProduct::InterpretInheritedData( pStr );
		}
		else
		{
			pStr->Delete( iPos, _tcsclen( _T("CDB_FixedOrifice") ) );
			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( _T("::FixOCharID=") ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_FixedOrifice::FixOCharID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetCharID( (LPCTSTR)strField );
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_FixedOrifice::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_FixedOrifice::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_FixedOrifice format
		// line 0 : open curve bracket and call base class.
		// line 1 : fixed orifice characteristic ID
		// line 2 : close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_FixedOrifice *)idptr.MP )->Copy( this );
			
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );
		
				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_TAProduct::ReadText( inpf, pusLineCount );
		
			// The fixed orifice characteristic ID.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Characteristic ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			_tcsncpy_s( m_FixedOrificeCharacteristicID, SIZEOFINTCHAR( m_FixedOrificeCharacteristicID ), ptcLine, SIZEOFINTCHAR( m_FixedOrificeCharacteristicID ) - 1 );
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_FixedOrifice::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_FixedOrifice::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str, str1, str2;

	// Write object header.
	if( true == IsClass( CLASS( CDB_FixedOrifice ) ) )
	{
		CData::WriteText( outf, strTab );
	}
	
	// Opening bracket.
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");
	CDB_TAProduct::WriteText( outf, strTab );
	
	// Data.
	
	// Fixed orifice characteristic ID.
	str1 = m_FixedOrificeCharacteristicID;
	str2 = _T("\"") + str1 + _T("\"");
	str.Format( _T("\r\n%s"), strTab + str2 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	
	// Closing bracket.
	strTab.Delete( 0 );
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}
#endif 

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_CommissioningSet
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_CommissioningSet )

CDB_CommissioningSet::CDB_CommissioningSet( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_TAProduct( pDataBase, ID )
{
	*m_FixOCharID = _T('\0');
	m_pFixOChar = NULL;
	*m_DrvCurveID = _T('\0');
	m_pDRVCurve = NULL;
}

CDB_ValveCharacteristic *CDB_CommissioningSet::GetDrvCurve()
{
	HYSELECT_TRY
	{
		if( NULL == m_pDRVCurve )
		{
			if( _T('\0') != *m_DrvCurveID && 0 != IDcmp( m_DrvCurveID, _NO_ID ) )
			{
				IDPTR CharactPtr = GetDB()->Get( m_DrvCurveID );
				
				if( _T('\0') == *CharactPtr.ID )
				{
					HYSELECT_THROW_RETURNARG( _T("Internal error: Can't find double regulating valve characteristic '%s' in the database."), NULL, m_DrvCurveID );
				}

				m_pDRVCurve = (CDB_ValveCharacteristic*)( CharactPtr.MP );

				if( NULL != m_pDRVCurve )
				{
					m_pDRVCurve->Lock( GetIDPtr() );
				}
			}
		}
	
		return m_pDRVCurve;
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CDB_CommissioningSet::GetDrvCurve'.") )
}

double CDB_CommissioningSet::GetKvSignal()
{
	double dKvSignal = -1.0;

	if( NULL != GetFixedOrificeCharacteristic() )
	{
		dKvSignal = GetFixedOrificeCharacteristic()->GetKvSignal();
	}

	return dKvSignal;
}
	
double CDB_CommissioningSet::GetKvFixO()
{
	double dKvFixO = -1.0;

	if( NULL != GetFixedOrificeCharacteristic() )
	{
		dKvFixO = GetFixedOrificeCharacteristic()->GetKv();
	}

	return dKvFixO;
}

double CDB_CommissioningSet::GetKvsDrv()
{
	if( NULL == GetFixedOrificeCharacteristic() || NULL == GetDrvCurve() )
	{
		return -1.0;
	}

	// Get the Kv of the fixed orifice characteristic and the Kvs of the double regulating valve characteristic.
	double dKvFixO = GetFixedOrificeCharacteristic()->GetKv();
	double dKvDRV = GetDrvCurve()->GetKvMax();

	if( -1.0 == dKvFixO || -1.0 == dKvDRV )
	{
		return -1.0;
	}

	// Return the Kvs resulting from these 2 Kv in series.
	return dKvFixO * dKvDRV / sqrt( dKvFixO * dKvFixO + dKvDRV * dKvDRV );
}

void CDB_CommissioningSet::SetCharID( _string ID )
{
	ASSERT( ID.length() <= _ID_LENGTH );
	_tcsncpy_s( m_FixOCharID, SIZEOFINTCHAR( m_FixOCharID ), ID.c_str(), _ID_LENGTH );
	
	// Unlock if previous one exist.
	if( NULL != m_pFixOChar )
	{
		m_pFixOChar->Unlock( GetIDPtr() );
	}
	
	// Force a call to 'GetFixedOrificeCharacteristic' to update 'm_pFixOChar'.
	m_pFixOChar = NULL;
	GetFixedOrificeCharacteristic();
}

void CDB_CommissioningSet::SetCurvID( _string ID )
{
	ASSERT( ID.length() <= _ID_LENGTH );
	_tcsncpy_s( m_DrvCurveID, SIZEOFINTCHAR( m_DrvCurveID ), ID.c_str(), _ID_LENGTH );

	// Unlock if previous one exist.
	if( NULL != m_pDRVCurve )
	{
		m_pDRVCurve->Unlock( GetIDPtr() );
	}
	
	// Force a call to 'GetDrvCurve' to update 'm_pFixOChar'.
	m_pDRVCurve = NULL;
	GetDrvCurve();
}

void CDB_CommissioningSet::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_TAProduct::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( _T('\0') !=  *m_FixOCharID && 0 != _tcscmp( _NO_ID, m_FixOCharID ) )
		{
			IDPtr = GetDB()->Get( m_FixOCharID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Fixed orifice characteristic ID (%s) is defined but not found in the database."), m_FixOCharID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_FixOCharacteristic ) ) )
			{
				HYSELECT_THROW( _T("Fixed orifice characteristic ID (%s) is found in the database but it's not a 'CDB_FixOCharacteristic' object."), m_FixOCharID );
			}
		}

		if( _T('\0') !=  *m_DrvCurveID && 0 != _tcscmp( _NO_ID, m_DrvCurveID ) )
		{
			IDPtr = GetDB()->Get( m_DrvCurveID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Double regulating valve characteristic ID (%s) is defined but not found in the database."), m_DrvCurveID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_ValveCharacteristic ) ) )
			{
				HYSELECT_THROW( _T("Double regulating valve characteristic ID (%s) is found in the database but it's not a 'CDB_ValveCharacteristic' object."), m_DrvCurveID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_CommissioningSet::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

CDB_FixOCharacteristic *CDB_CommissioningSet::GetFixedOrificeCharacteristic()
{
	HYSELECT_TRY
	{
		if( NULL == m_pFixOChar )
		{
			if( _T('\0') !=  *m_FixOCharID && 0 != IDcmp( m_FixOCharID, _NO_ID ) )
			{
				IDPTR CharactPtr = GetDB()->Get( m_FixOCharID );
				
				if( _T('\0') == *CharactPtr.ID )
				{
					HYSELECT_THROW_RETURNARG( _T("Internal error: Can't find fixed orifice characteristic '%s' in the database."), NULL, m_FixOCharID );
				}

				m_pFixOChar = (CDB_FixOCharacteristic*)( CharactPtr.MP );

				if( NULL != m_pFixOChar )
				{
					m_pFixOChar->Lock( GetIDPtr() );
				}
			}
		}
	
		return m_pFixOChar;
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CDB_CommissioningSet::GetFixedOrificeCharacteristic'.") )
}

void CDB_CommissioningSet::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_CommissioningSet *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_CommissioningSet' object!") );
		}

		// Base class.
		CDB_TAProduct::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_CommissioningSet" class.
		CDB_CommissioningSet *pclDestinationCommissioningSet = (CDB_CommissioningSet *)pclDestination;

		pclDestinationCommissioningSet->SetCharID( m_FixOCharID );
		pclDestinationCommissioningSet->SetCurvID( m_DrvCurveID );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_CommissioningSet::Copy' method with the object '%s'."), GetIDPtr().ID )
}

void CDB_CommissioningSet::OnDatabaseDestroy()
{
	CDB_TAProduct::OnDatabaseDestroy();
	
	// Unlock the fixed orifice characteristic.
	if( NULL != GetFixedOrificeCharacteristic() )
	{
		GetFixedOrificeCharacteristic()->Unlock( GetIDPtr() );
	}
	
	// Unlock the curve.
	if( NULL != GetDrvCurve() )
	{
		GetDrvCurve()->Unlock( GetIDPtr() );
	}
}

#define CDB_COMMISSIONINGSET_VERSION	1
void CDB_CommissioningSet::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_COMMISSIONINGSET_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_TAProduct::Write( outf );
	
	// Info.
	
	// The fixed orifice characteristic ID.
	WriteString( outf, m_FixOCharID );
	
	// The DRV curve ID.
	WriteString( outf, m_DrvCurveID );
}

bool CDB_CommissioningSet::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_COMMISSIONINGSET_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_TAProduct::Read( inpf ) )
	{
		return false;
	}
	
	// Info.
	// The fixed orifice characteristic ID.
	if( false == ReadString( inpf, m_FixOCharID, sizeof( m_FixOCharID ) ) )
	{
		return false;
	}
	
	// The DRV curve ID.
	if( false == ReadString( inpf, m_DrvCurveID, sizeof( m_DrvCurveID ) ) )
	{
		return false;
	}

	return true;
}

#ifndef TACBX 
void CDB_CommissioningSet::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( _T("CDB_CommissioningSet") );

		if( iPos < 0 )
		{
			CDB_TAProduct::InterpretInheritedData( pStr );
		}
		else
		{
			pStr->Delete( iPos, _tcsclen( _T("CDB_CommissioningSet") ) );
			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( _T("::FixOCharID=") ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_CommissioningSet::FixOCharID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetCharID( (LPCTSTR)strField );
			}
			else if( pStr->Find( _T("::DrvCurveID=") ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_CommissioningSet::DrvCurveID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetCurvID( (LPCTSTR)strField );
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_CommissioningSet::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_CommissioningSet::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_CommissioningSet format
		// line 0 : open curve bracket and call base class.
		// line 1 : fixed orifice charact ID
		// line 2 : double regulating valve curve ID
		// line 3 : close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_CommissioningSet *)idptr.MP )->Copy( this );
			
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );
			
				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_TAProduct::ReadText( inpf, pusLineCount );

			// The fixed orifice characteristic ID.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Fixed orifice characteristic ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			_tcsncpy_s( m_FixOCharID, SIZEOFINTCHAR( m_FixOCharID ), ptcLine, SIZEOFINTCHAR( m_FixOCharID ) - 1 );

			if( NULL == GetFixedOrificeCharacteristic() )
			{
				HYSELECT_THROW( _T("can't find fixed orifice characteristic ID (%s) in the database (pos: %i)."), m_FixOCharID, *pusLineCount );
			}
			else if( false == GetFixedOrificeCharacteristic()->IsClass( CLASS( CDB_FixOCharacteristic ) ) )
			{
				HYSELECT_THROW( _T("Fixed orifice characteristic ID (%s) is not a 'CDB_FixOCharacteristic' object (pos: %i)."), m_FixOCharID, *pusLineCount );
			}
					
			// The double regulating valve curve ID.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Double regulating valve curve ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			_tcsncpy_s( m_DrvCurveID, SIZEOFINTCHAR( m_DrvCurveID ), ptcLine, SIZEOFINTCHAR( m_DrvCurveID ) - 1 );

			if( NULL == GetDrvCurve() )
			{
				HYSELECT_THROW( _T("can't find double regulating valve curve ID (%s) in the database (pos: %i)."), m_DrvCurveID, *pusLineCount );
			}
			else if( false == GetDrvCurve()->IsClass( CLASS( CDB_ValveCharacteristic ) ) )
			{
				HYSELECT_THROW( _T("Double regulating valve curve ID (%s) is not a 'CDB_ValveCharacteristic' object (pos: %i)."), m_DrvCurveID, *pusLineCount );
			}
		}
	
		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_CommissioningSet::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_CommissioningSet::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str, str1, str2;
		
	// Write object header.
	if( true == IsClass( CLASS( CDB_CommissioningSet ) ) )
	{
		CData::WriteText( outf, strTab );
	}
	
	// Opening bracket.
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");
	CDB_TAProduct::WriteText( outf, strTab );
	
	// Infos.
	
	// m_FixOCharID.
	str1 = m_FixOCharID;
	str2 = _T("\"") + str1 + _T("\"");
	str.Format( _T("\r\n%s"), strTab + str2 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	
	// m_DrvCurveID.
	str1 = m_DrvCurveID;
	str2 = _T("\"") + str1 + _T("\"");
	str.Format( _T("\r\n%s"), strTab + str2 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	
	// Closing bracket.
	strTab.Delete( 0 );
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}
#endif 

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_VenturiValve
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_VenturiValve)

CDB_VenturiValve::CDB_VenturiValve( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_TAProduct( pDataBase, ID )
{
	*m_VenturiCharID = _T('\0');
	m_pVenturiChar = NULL;
	*m_VvCurveID = _T('\0');
	m_pVVCurve = NULL;
}

CDB_ValveCharacteristic *CDB_VenturiValve::GetVvCurve()
{
	HYSELECT_TRY
	{
		if( NULL == m_pVVCurve )
		{
			if( _T('\0') != *m_VvCurveID && 0 != IDcmp( m_VvCurveID, _NO_ID ) )
			{
				IDPTR CharactPtr = GetDB()->Get( m_VvCurveID );
				
				if( _T('\0') == *CharactPtr.ID )
				{
					HYSELECT_THROW_RETURNARG( _T("Internal error: Can't find venturi valve curve '%s' in the database."), NULL, m_VvCurveID );
				}

				m_pVVCurve = (CDB_ValveCharacteristic*)( CharactPtr.MP );

				if( NULL != m_pVVCurve )
				{
					m_pVVCurve->Lock( GetIDPtr() );
				}
			}
		}
	
		return m_pVVCurve;
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CDB_VenturiValve::GetVvCurve'.") )
}

double CDB_VenturiValve::GetKvSignal()
{
	double dKvSignal = -1.0;

	if( NULL != GetVenturiCharacteristic() )
	{
		dKvSignal = GetVenturiCharacteristic()->GetKvSignal();
	}

	return dKvSignal;
}
	
double CDB_VenturiValve::GetKvsVv()
{
	double dKvsVs = -1.0;

	if( NULL != GetVenturiCharacteristic() )
	{
		dKvsVs = GetVvCurve()->GetKvMax();
	}

	return dKvsVs;
}

void CDB_VenturiValve::SetCharID( _string ID )
{
	ASSERT( ID.length() <= _ID_LENGTH );
	_tcsncpy_s( m_VenturiCharID, SIZEOFINTCHAR( m_VenturiCharID ), ID.c_str(), _ID_LENGTH );

	// Unlock if previous one exist.
	if( NULL != m_pVenturiChar )
	{
		m_pVenturiChar->Unlock( GetIDPtr() );
	}

	// Force a call to 'GetVenturiCharacteristic' to update 'm_pVenturiChar'.
	m_pVenturiChar = NULL;
	GetVenturiCharacteristic();
}

void CDB_VenturiValve::SetCurvID( _string ID )
{
	ASSERT( ID.length() <= _ID_LENGTH );
	_tcsncpy_s( m_VvCurveID, SIZEOFINTCHAR( m_VvCurveID ), ID.c_str(), _ID_LENGTH );

	// Unlock if previous one exist.
	if( NULL != m_pVVCurve )
	{
		m_pVVCurve->Unlock( GetIDPtr() );
	}

	// Force a call to 'GetVvCurve' to update 'm_pVVCurve'.
	m_pVVCurve = NULL;
	GetVvCurve();
}

void CDB_VenturiValve::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_TAProduct::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( _T('\0') !=  *m_VvCurveID && 0 != _tcscmp( _NO_ID, m_VvCurveID ) )
		{
			IDPtr = GetDB()->Get( m_VvCurveID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Venturi characteristic ID (%s) is defined but not found in the database."), m_VvCurveID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_ValveCharacteristic ) ) )
			{
				HYSELECT_THROW( _T("Venturi characteristic ID (%s) is found in the database but it's not a 'CDB_ValveCharacteristic' object."), m_VvCurveID );
			}
		}

		if( _T('\0') !=  *m_VenturiCharID && 0 != _tcscmp( _NO_ID, m_VenturiCharID ) )
		{
			IDPtr = GetDB()->Get( m_VenturiCharID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Venturi valve curve ID (%s) is defined but not found in the database."), m_VenturiCharID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_VenturiCharacteristic ) ) )
			{
				HYSELECT_THROW( _T("Venturi valve curve ID (%s) is found in the database but it's not a 'CDB_VenturiCharacteristic' object."), m_VenturiCharID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_VenturiValve::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

CDB_VenturiCharacteristic *CDB_VenturiValve::GetVenturiCharacteristic()
{
	HYSELECT_TRY
	{
		if( NULL == m_pVenturiChar )
		{
			if( _T('\0') != *m_VenturiCharID && 0 != IDcmp( m_VenturiCharID, _NO_ID ) )
			{
				IDPTR CharactPtr = GetDB()->Get( m_VenturiCharID );
				
				if( _T('\0') == *CharactPtr.ID )
				{
					HYSELECT_THROW_RETURNARG( _T("Internal error: Can't find venturi valve characteristic '%s' in the database."), NULL, m_VenturiCharID );
				}

				m_pVenturiChar = (CDB_VenturiCharacteristic *)( CharactPtr.MP );

				if( NULL != m_pVenturiChar )
				{
					m_pVenturiChar->Lock( GetIDPtr() );
				}
			}
		}
	
		return m_pVenturiChar;
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CDB_VenturiValve::GetVenturiCharacteristic'.") )
}

void CDB_VenturiValve::OnDatabaseDestroy()
{
	CDB_TAProduct::OnDatabaseDestroy();
	
	// Unlock the venturi valve characteristic.
	if( NULL != GetVenturiCharacteristic() )
	{
		GetVenturiCharacteristic()->Unlock( GetIDPtr() );
	}
	
	// Unlock the curve.
	if( NULL != GetVvCurve() )
	{
		GetVvCurve()->Unlock( GetIDPtr() );
	}
}

void CDB_VenturiValve::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_VenturiValve *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_VenturiValve' object!") );
		}

		// Base class.
		CDB_TAProduct::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_VenturiValve" class.
		CDB_VenturiValve *pclDestinationVenturiValve = (CDB_VenturiValve *)pclDestination;

		pclDestinationVenturiValve->SetCharID( m_VenturiCharID );
		pclDestinationVenturiValve->SetCurvID( m_VvCurveID );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_VenturiValve::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_VENTURIVALVE_VERSION	1
void CDB_VenturiValve::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_VENTURIVALVE_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_TAProduct::Write( outf );
	
	// Infos.
	// The venturi characteristic ID.
	WriteString( outf, m_VenturiCharID );
	
	// The VV curve ID.
	WriteString( outf, m_VvCurveID );
}

bool CDB_VenturiValve::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_VENTURIVALVE_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_TAProduct::Read( inpf ) )
	{
		return false;
	}
	
	// Infos.
	
	// The Venturi characteristic ID.
	if( false == ReadString( inpf, m_VenturiCharID, sizeof( m_VenturiCharID ) ) )
	{
		return false;
	}
	
	// The VV curve ID.
	if( false == ReadString( inpf, m_VvCurveID, sizeof( m_VvCurveID ) ) )
	{
		return false;
	}

	return true;
}

#ifndef TACBX 
void CDB_VenturiValve::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( _T("CDB_VenturiValve") );

		if( iPos < 0 )
		{
			CDB_TAProduct::InterpretInheritedData( pStr );
		}
		else
		{
			pStr->Delete( iPos, _tcsclen( _T("CDB_VenturiValve") ) );
			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( _T("::VenturiCharID=") ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_VenturiValve::VenturiCharID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetCharID( (LPCTSTR)strField );
			}
			else if( pStr->Find( _T("::VvCurveID=") ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_VenturiValve::VvCurveID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetCurvID( (LPCTSTR)strField );
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_VenturiValve::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_VenturiValve::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str, str1, str2;
	
	// Write object header.
	if( true == IsClass( CLASS( CDB_VenturiValve ) ) )
	{
		CData::WriteText( outf, strTab );
	}
	
	// Opening bracket.
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");
	CDB_TAProduct::WriteText( outf, strTab );
	
	// Infos.
	// m_VenturiCharID.
	str1 = m_VenturiCharID;
	str2 = _T("\"") + str1 + _T("\"");
	str.Format( _T("\r\n%s"), strTab + str2 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	
	// m_VvCurveID.
	str1 = m_VvCurveID;
	str2 = _T("\"") + str1 + _T("\"");
	str.Format( _T("\r\n%s"), strTab + str2 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	
	// Closing bracket.
	strTab.Delete( 0 );
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}

void CDB_VenturiValve::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_FixedOrifice format
		// line 0 : open curve bracket and call base class.
		// line 1 : Venturi characteristic ID
		// line 2 : Venturi valve curve ID
		// line 3 : close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;
	
		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_VenturiValve *)idptr.MP )->Copy( this );
			
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );
			
				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_TAProduct::ReadText( inpf, pusLineCount );

			// The Venturi characteristic ID.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Characteristic ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			_tcsncpy_s( m_VenturiCharID, SIZEOFINTCHAR( m_VenturiCharID ), ptcLine, SIZEOFINTCHAR( m_VenturiCharID ) - 1 );
		
			// The Venturi valve curve ID.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Curve ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			_tcsncpy_s( m_VvCurveID, SIZEOFINTCHAR( m_VvCurveID ), ptcLine, SIZEOFINTCHAR( m_VvCurveID) - 1 );
		}
	
		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_VenturiValve::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif 

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_ShutoffValve
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_ShutoffValve)

CDB_ShutoffValve::CDB_ShutoffValve( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_TAProduct( pDataBase, ID )
{
	*m_ValveCurveID = _T('\0');
	m_pCurve = NULL;
	m_ActuatorGroupIDPtr = _NULL_IDPTR;
}

void CDB_ShutoffValve::SetValveCurveID( LPCTSTR pID )
{
	ASSERT( _tcslen( pID ) <= _ID_LENGTH );
	_tcsncpy_s( m_ValveCurveID, SIZEOFINTCHAR( m_ValveCurveID ), (LPCTSTR)pID, SIZEOFINTCHAR( m_ValveCurveID ) - 1 );

	// Unlock if previous one exist.
	if( NULL != m_pCurve )
	{
		m_pCurve->Unlock( GetIDPtr() );
	}

	// Force a call to 'GetValveCharacteristic' to update 'm_pCurve'.
	m_pCurve = NULL;
	GetValveCharacteristic();
}

double CDB_ShutoffValve::GetKvs()
{
	double dKvs = -1.0;

	if( NULL != GetValveCharacteristic() )
	{
		dKvs = GetValveCharacteristic()->GetKvMax();
	}

	return dKvs;
}

double CDB_ShutoffValve::GetDp( double dQ, double dRho )
{
	ASSERT( 0.0 != dQ && 0.0 != dRho );

	if( 0.0 == dQ || 0.0 == dRho )
	{
		return 0.0;
	}
	
	double dDp = 0;
	double dKvs = GetKvs();

	if( -1.0 == dKvs )
	{
		return -1.0;
	}
	
	dDp = CalcDp( dQ, dKvs, dRho );
	return dDp;
}

CDB_ValveCharacteristic *CDB_ShutoffValve::GetValveCharacteristic()
{
	HYSELECT_TRY
	{
		if( NULL == m_pCurve )
		{
			if( _T('\0') != *m_ValveCurveID && 0 != IDcmp( m_ValveCurveID, _NO_ID ) )
			{
				IDPTR CharactPtr = GetDB()->Get( m_ValveCurveID );
				
				if( _T('\0') == *CharactPtr.ID )
				{
					HYSELECT_THROW_RETURNARG( _T("Internal error: Can't find shut-off valve characteristic '%s' in the database."), NULL, m_ValveCurveID );
				}

				m_pCurve = (CDB_ValveCharacteristic*)( CharactPtr.MP );

				if( NULL != m_pCurve )
				{
					m_pCurve->Lock( GetIDPtr() );
				}
			}
		}

		return m_pCurve;
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CDB_ShutoffValve::GetValveCharacteristic'.") )
}

void CDB_ShutoffValve::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_TAProduct::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( _T('\0') !=  *m_ValveCurveID && 0 != _tcscmp( _NO_ID, m_ValveCurveID ) )
		{
			IDPtr = GetDB()->Get( m_ValveCurveID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Valve curve ID (%s) is defined but not found in the database."), m_ValveCurveID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_ValveCharacteristic ) ) )
			{
				HYSELECT_THROW( _T("Valve curve ID (%s) is found in the database but it's not a 'CDB_ValveCharacteristic' object."), m_ValveCurveID );
			}
		}

		if( _T('\0') !=  *m_ActuatorGroupIDPtr.ID && 0 != _tcscmp( _NO_ID, m_ActuatorGroupIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_ActuatorGroupIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Actuator group ID (%s) is defined but not found in the database."), m_ActuatorGroupIDPtr.ID );
			}
		
			if( false == IDPtr.MP->IsClass( CLASS( CTable ) ) )
			{
				HYSELECT_THROW( _T("Actuator group ID (%s) is found in the database but it's not a 'CTable' object."), m_ActuatorGroupIDPtr.ID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_ShutoffValve::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

IDPTR CDB_ShutoffValve::GetActuatorGroupIDPtr()
{
	m_ActuatorGroupIDPtr.DB = GetDB();

	if( _T('\0') !=  *m_ActuatorGroupIDPtr.ID && 0 != _tcscmp( _NO_ID, m_ActuatorGroupIDPtr.ID ) && NULL != m_ActuatorGroupIDPtr.DB )
	{
		Extend( &m_ActuatorGroupIDPtr );
		return m_ActuatorGroupIDPtr;
	}
	else
	{
		return _NULL_IDPTR;
	}
}

void CDB_ShutoffValve::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_ShutoffValve *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_ShutoffValve' object!") );
		}
	
		// Base class.
		CDB_TAProduct::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_ShutoffValve" class.
		CDB_ShutoffValve *pclDestinationShutoffValve = (CDB_ShutoffValve *)pclDestination;

		pclDestinationShutoffValve->SetValveCurveID( m_ValveCurveID );
		pclDestinationShutoffValve->SetActuatorGroupID( m_ActuatorGroupIDPtr.ID );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_ShutoffValve::Copy' method with the object '%s'."), GetIDPtr().ID )
}

void CDB_ShutoffValve::OnDatabaseDestroy()
{
	CDB_TAProduct::OnDatabaseDestroy();

	// Unlock the curve and control properties.
	if( NULL != GetValveCharacteristic() )
	{
		GetValveCharacteristic()->Unlock( GetIDPtr() );
	}
}

#define CDB_SHUTOFFVALVE_VERSION	2
// Version 2: 2018-08-10: 'm_ActuatorGroupIDPtr' variable added.
void CDB_ShutoffValve::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_SHUTOFFVALVE_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_TAProduct::Write( outf );
	
	// Info.
	// The curve ID.
	WriteString( outf, m_ValveCurveID );

	// Version 2.
	WriteString( outf, m_ActuatorGroupIDPtr.ID );
}

bool CDB_ShutoffValve::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_SHUTOFFVALVE_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_TAProduct::Read( inpf ) )
	{
		return false;
	}
	
	// Info.
	// The curve ID.
	if( false == ReadString( inpf, m_ValveCurveID, sizeof( m_ValveCurveID ) ) )
	{
		return false;
	}

	if( Version < 2 )
	{
		return true;
	}

	m_ActuatorGroupIDPtr = _NULL_IDPTR;

	if( false == ReadString( inpf, m_ActuatorGroupIDPtr.ID, sizeof( m_ActuatorGroupIDPtr.ID ) ) )
	{
		return false;
	}

	return true;
}

#ifndef TACBX 
void CDB_ShutoffValve::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( _T("CDB_ShutoffValve") );

		if( iPos < 0 )
		{
			CDB_TAProduct::InterpretInheritedData( pStr );
		}
		else
		{
			pStr->Delete( iPos, _tcsclen( _T("CDB_ShutoffValve") ) );
			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( _T("::ValveCurveID=") ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_ShutoffValve::ValveCurveID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetValveCurveID( (LPCTSTR)strField );
			}
			else if( pStr->Find( _T("::ActuatorGroupID=") ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_ShutoffValve::ActuatorGroupID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetActuatorGroupID( (LPCTSTR)strField );
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_ShutoffValve::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_ShutoffValve::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str, str1, str2;
	
	// Write object header.
	if( true == IsClass( CLASS( CDB_ShutoffValve ) ) )
	{
		CData::WriteText( outf, strTab );
	}
	
	// Opening bracket.
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");
	CDB_TAProduct::WriteText( outf, strTab );
	
	// Data.
	// 'm_ValveCurveID.'
	str1 = m_ValveCurveID;
	str2 = _T("\"") + str1 + _T("\"");
	str.Format( _T("\r\n%s"), strTab + str2 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	WriteFormatedStringW( outf, m_ActuatorGroupIDPtr.ID, strTab );
	
	// Closing bracket.
	strTab.Delete( 0 ); // Delete one \t
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}

void CDB_ShutoffValve::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		//	new:CDB_ShutoffValve(ID)->tableID	Common CData syntax
		//	{
		//		--> CDB_TAProduct
		//		CharactID				Identifier of the shut-off valve characteristic
		//		ActuatorGroupID			Identifier of the actuator group
		//	}

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_ShutoffValve *)idptr.MP )->Copy( this );
		
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_TAProduct::ReadText( inpf, pusLineCount );

			// The regulating valve characteristic ID.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Characteristic ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			SetValveCurveID( ptcLine );

			// ActuatorGroup ID.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Actuator group ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			_tcsncpy_s( m_ActuatorGroupIDPtr.ID, SIZEOFINTCHAR( m_ActuatorGroupIDPtr.ID ), ptcLine, SIZEOFINTCHAR( m_ActuatorGroupIDPtr.ID ) - 1 );
		}
	
		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_ShutoffValve::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif 

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_DpController
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_DpController )

CDB_DpController::CDB_DpController( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_TAProduct( pDataBase, ID )
{
	*m_DpCCharacteristicID = _T('\0');
	m_pDpCCharacteristic = NULL;
	m_DpCLoc = DpCLocDownStream;
}

CDB_DpCCharacteristic *CDB_DpController::GetDpCCharacteristic()
{
	HYSELECT_TRY
	{
		if( NULL == m_pDpCCharacteristic )
		{
			if( _T('\0') != *m_DpCCharacteristicID && 0 != IDcmp( m_DpCCharacteristicID, _NO_ID ) )
			{
				IDPTR CharactPtr = GetDB()->Get( m_DpCCharacteristicID );
				
				if( _T('\0') == *CharactPtr.ID )
				{
					HYSELECT_THROW_RETURNARG( _T("Internal error: Can't find Dp controller characteristic '%s' in the database."), NULL, m_DpCCharacteristicID );
				}

				m_pDpCCharacteristic = (CDB_DpCCharacteristic*)( CharactPtr.MP );

				if( NULL != m_pDpCCharacteristic )
				{
					m_pDpCCharacteristic->Lock( GetIDPtr() );
				}
			}
		}
	
		return m_pDpCCharacteristic;
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CDB_DpController::GetDpCCharacteristic'.") )
}

double CDB_DpController::GetKvmin()
{
	double dKvmin = -1.0;

	if( NULL != GetDpCCharacteristic() )
	{
		dKvmin = GetDpCCharacteristic()->GetKvmin();
	}

	return dKvmin;
}
	
double CDB_DpController::GetKvm()
{
	double dKvm = -1.0;

	if( NULL != GetDpCCharacteristic() )
	{
		dKvm = GetDpCCharacteristic()->GetKvm();
	}

	return dKvm;
}
	
double CDB_DpController::GetDplmin()
{
	double dDplmin = -1.0;
	
	if( NULL != GetDpCCharacteristic() )
	{
		dDplmin = GetDpCCharacteristic()->GetDplmin();
	}

	return dDplmin;
}
	
double CDB_DpController::GetDplmax()
{
	double dDplmax = -1.0;
	
	if( NULL != GetDpCCharacteristic() )
	{
		dDplmax = GetDpCCharacteristic()->GetDplmax();
	}

	return dDplmax;
}

_string CDB_DpController::GetFormatedDplRange( bool bWithUnit )
{
	_string strDplmin = ( -1.0 == GetDplmin() ) ? L"x" : WriteCUDouble( _U_DIFFPRESS, GetDplmin() );
	_string strDplmax = ( -1.0 == GetDplmax() ) ? L"x" : WriteCUDouble( _U_DIFFPRESS, GetDplmax() );

	_string str = _T("[") + strDplmin + _T("-") + strDplmax + _T("]");

	if( true == bWithUnit )
	{
		CUnitDatabase *pUnitDB = CDimValue::AccessUDB();
		str += _T(" ") + pUnitDB->GetNameOfDefaultUnit( _U_DIFFPRESS );
	}

	return str;
}

void CDB_DpController::GetNameEx( _string *pStr, bool bWithUnit )
{
	*pStr = GetName() + _string( _T(" ") ) + GetFormatedDplRange( bWithUnit );
}

void CDB_DpController::SetCharID( _string ID )
{
	ASSERT( ID.length() <= _ID_LENGTH );
	_tcsncpy_s( m_DpCCharacteristicID, SIZEOFINTCHAR( m_DpCCharacteristicID ), ID.c_str(), _ID_LENGTH );
	
	// Unlock if previous one exist.
	if( NULL != m_pDpCCharacteristic )
	{
		m_pDpCCharacteristic->Unlock( GetIDPtr() );
	}

	// Force a call to 'GetDpCCharacteristic' to update 'm_pDpCCharacteristic'.
	m_pDpCCharacteristic = NULL;
	GetDpCCharacteristic();
}

void CDB_DpController::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_TAProduct::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;
	
		if( _T('\0') !=  *m_DpCCharacteristicID && 0 != _tcscmp( _NO_ID, m_DpCCharacteristicID ) )
		{
			IDPtr = GetDB()->Get( m_DpCCharacteristicID );
		
			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Dp controller characteristic ID (%s) is defined but not found in the database."), m_DpCCharacteristicID );
			}
		
			if( false == IDPtr.MP->IsClass( CLASS( CDB_DpCCharacteristic ) ) )
			{
				HYSELECT_THROW( _T("Dp controller characteristic ID (%s) is found in the database but it's not a 'CDB_DpCCharacteristic' object."), m_DpCCharacteristicID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_DpController::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

void CDB_DpController::OnDatabaseDestroy()
{
	CDB_TAProduct::OnDatabaseDestroy();

	// Unlock the characteristic.
	if( NULL != GetDpCCharacteristic() )
	{
		GetDpCCharacteristic()->Unlock( GetIDPtr() );
	}
	
	// Unlock Inlet and Outlet if necessary.
	if( true == IsConnTabUsed() )
	{
		if( NULL != GetDB()->Get( GetConnectID() ).MP )
		{
			( (CDB_Component*)( GetDB()->Get( GetConnectID() ).MP ) )->Unlock( GetIDPtr() );
		}
		
		if( NULL != GetDB()->Get( GetConn2ID() ).MP )
		{
			( (CDB_Component*)( GetDB()->Get( GetConn2ID() ).MP ) )->Unlock( GetIDPtr() );
		}
	}
}

void CDB_DpController::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_DpController *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_DpController' object!") );
		}

		// Base class.
		CDB_TAProduct::Copy( pclDestination );

		// Copy now what it is common to the "CDB_DpController" class.
		CDB_DpController *pclDestinationDpController = (CDB_DpController *)pclDestination;
		
		pclDestinationDpController->SetCharID( m_DpCCharacteristicID );
		pclDestinationDpController->SetDpCLoc( GetDpCLoc() );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_DpController::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_DPCONTROLLER_VERSION	2
void CDB_DpController::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_DPCONTROLLER_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_TAProduct::Write( outf );
	
	// Infos.
	// The characteristic ID.
	WriteString( outf, m_DpCCharacteristicID );
	outf.write( (char *)&m_DpCLoc, sizeof( m_DpCLoc ) );
}

bool CDB_DpController::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );
	
	if( Version < 1 || Version > CDB_DPCONTROLLER_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_TAProduct::Read( inpf ) )
	{
		return false;
	}
	
	// Infos.
	
	// The characteristic ID.
	if( false == ReadString( inpf, m_DpCCharacteristicID, sizeof( m_DpCCharacteristicID ) ) )
	{
		return false;
	}
	
	if( Version < 2 )
	{
		return true;
	}
	
	inpf.read( (char *)&m_DpCLoc, sizeof( m_DpCLoc ) );
	
	return true;
}

#ifndef TACBX 
void CDB_DpController::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( _T("CDB_DpController") );

		if( iPos < 0 )
		{
			CDB_TAProduct::InterpretInheritedData( pStr );
		}
		else
		{
			pStr->Delete( iPos, _tcsclen( _T("CDB_DpController") ) );
			int iEq = pStr->Find( _T("=") );

			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( _T("::CharactID=") ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_DpController::CharactID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetCharID( (LPCTSTR)strField );
			}
			else if( pStr->Find( _T("::DpCLoc=") ) > -1 )
			{
				int iValue = ReadEnum( strField );

				if( iValue != eDpCLoc::DpCLocDownStream && iValue != eDpCLoc::DpCLocUpStream && iValue != eDpCLoc::DpCLocNone )
				{
					HYSELECT_THROW( _T("'CDB_DpController::DpCLoc' value must be one of these values: '#eDpCLoc_DownStream', '#eDpCLoc_UpStream' or '#eDpCLoc_None'.") );
				}

				m_DpCLoc = (eDpCLoc)iValue;
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_DpController::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_DpController::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_DpController format
		// line 0 : open curve bracket and call base class.
		// line 1 : DpC charact ID.
		// line 2 : DpC location.
		// line 3 : close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_DpController *)idptr.MP )->Copy( this );
			
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );

			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_TAProduct::ReadText( inpf, pusLineCount );

			// The characteristic ID.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Characteristic ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			_tcsncpy_s( m_DpCCharacteristicID, SIZEOFINTCHAR( m_DpCCharacteristicID ), ptcLine, SIZEOFINTCHAR( m_DpCCharacteristicID ) - 1 );
		
			// m_eDpCLoc.
			int iValue = ReadEnumLine( inpf, pusLineCount );

			if( iValue != eDpCLoc::DpCLocDownStream && iValue != eDpCLoc::DpCLocUpStream && iValue != eDpCLoc::DpCLocNone )
			{
				HYSELECT_THROW( _T("Dpc location value must be one of these values: '#eDpCLoc_DownStream', '#eDpCLoc_UpStream' or '#eDpCLoc_None' (pos: %i)."), *pusLineCount );
			}

			m_DpCLoc = (eDpCLoc)iValue;
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_DpController::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_DpController::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str, str1;
	
	// Write object header.
	if( true == IsClass( CLASS( CDB_DpController ) ) )
	{
		CData::WriteText( outf, strTab );
	}
	
	// Opening bracket.
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");
	CDB_TAProduct::WriteText( outf, strTab );
	
	// Data.
	WriteFormatedStringW( outf, m_DpCCharacteristicID, strTab );

	if( eDpCLoc::DpCLocDownStream == m_DpCLoc )
	{
		str1 = _T("#eDpCLoc_DownStream");
	}
	else if( eDpCLoc::DpCLocUpStream == m_DpCLoc )
	{
		str1 = _T("#eDpCLoc_UpStream");
	}
	else if( eDpCLoc::DpCLocNone == m_DpCLoc )
	{
		str1 = _T("#eDpCLoc_None");
	}
	
	WriteFormatedStringW( outf, str1, strTab );
	
	// Closing bracket.
	strTab.Delete( 0 );
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}

double CDB_DpController::GetDpStabCorrectedWithPBfactor( double dDpStab )
{
	if( 0 == TASApp.GetpTADS()->GetpTechParams()->GetCVUseDpCBand() )
	{
		return dDpStab;
	}
	
	double dPB = GetDpCCharacteristic()->GetProportionalBand( dDpStab );

	// Bdesign = DpCV (fo@Qd) / Dpstab
	// With bypass BV Bmin will be slightly better w/o bypass Bv
	// w/o bypass BV q will increase stabilized Dpl will decrease (PB) Bmin will increase
	if( true == GetDpCCharacteristic()->IsProportionalBandAbsolute() )
	{
		return ( dDpStab + dPB );
	}
	else
	{
		return ( ( 1.0 + dPB ) * dDpStab );
	}
	
	return -1;
}

// Return value of Dp you have to request to DpC to get a corrected value that match your request
// Used in HMcalc to evaluate DpC dp to avoid a dead loop
double CDB_DpController::EvaluateDpStabWithoutPBfactor( double dDpStabCorrectedWithPBFactor )
{
	double dDpStab = dDpStabCorrectedWithPBFactor;

	if( 0 == TASApp.GetpTADS()->GetpTechParams()->GetCVUseDpCBand() )
	{
		return dDpStab;
	}

	double dPB = GetDpCCharacteristic()->GetProportionalBand( dDpStab );

	if( true == GetDpCCharacteristic()->IsProportionalBandAbsolute() )
	{
		return ( dDpStab - dPB );
	}
	else
	{
		return ( dDpStab / ( 1.0 + dPB ) );
	}
	
	return -1;
}
#endif 

#ifndef TACBX 
///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_DpReliefValve -> ONLY FOR DIRECT SELECTION
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_DpReliefValve )

CDB_DpReliefValve::CDB_DpReliefValve( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_TAProduct( pDataBase, ID )
{
	m_dMinSettingDp = 0.0;
	m_dMaxSettingDp = 0.0;
}

void CDB_DpReliefValve::GetNameEx( _string *pStr, bool bWithUnit )
{
	*pStr = GetName() + _string( _T(" [") ) + (LPCTSTR)GetAdjustableRange( false ) + _string( _T("]") );

	if( true == bWithUnit )
	{
		CUnitDatabase *pUnitDB = CDimValue::AccessUDB();
		*pStr += _T(" ") + pUnitDB->GetNameOfDefaultUnit( _U_DIFFPRESS );
	}
}

CString CDB_DpReliefValve::GetAdjustableRange( bool bWithUnit )
{
	CString str;

	str = WriteCUDouble( _U_DIFFPRESS, m_dMinSettingDp, false );
	str += _T("-");
	str += WriteCUDouble( _U_DIFFPRESS, m_dMaxSettingDp, false );

	if( true == bWithUnit )
	{
		str = str + L" " + GetNameOf( TASApp.GetpUnitDB()->GetDefaultUnit( _U_DIFFPRESS ) ).c_str();
	}
	
	return str;
}

void CDB_DpReliefValve::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_DpReliefValve *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_DpReliefValve' object!") );
		}

		// Base class.
		CDB_TAProduct::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_DpReliefValve" class.
		CDB_DpReliefValve *pclDestinationDpReliefValve = (CDB_DpReliefValve *)pclDestination;

		pclDestinationDpReliefValve->SetMinSettingDp( GetMinSettingDp() );
		pclDestinationDpReliefValve->SetMaxSettingDp( GetMaxSettingDp() );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_DpReliefValve::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_DPRELIEFVALVE_VERSION	1
void CDB_DpReliefValve::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_DPRELIEFVALVE_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_TAProduct::Write( outf );
	
	// Infos.
	WriteDouble( outf, m_dMinSettingDp );
	WriteDouble( outf, m_dMaxSettingDp );
}

bool CDB_DpReliefValve::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );
	
	if( Version < 1 || Version > CDB_DPRELIEFVALVE_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_TAProduct::Read( inpf ) )
	{
		return false;
	}
	
	// Infos.
	m_dMinSettingDp = ReadDouble( inpf );
	m_dMaxSettingDp = ReadDouble( inpf );

	return true;
}

#define DPRELIEFVALVE_MINSETTINGDP		_T("::MinSettingDp=")
#define DPRELIEFVALVE_MAXSETTINGDP		_T("::MaxSettingDp=")
void CDB_DpReliefValve::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( CLASS( CDB_DpReliefValve ) );

		if( pStr->Left(2) != _T("::") && iPos < 0 )
		{
			CDB_TAProduct::InterpretInheritedData( pStr );
		}
		else
		{
			if( iPos >= 0 )
			{
				pStr->Delete( iPos, _tcsclen( CLASS( CDB_DpReliefValve ) ) );
			}

			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );
		
			if( pStr->Find( DPRELIEFVALVE_MINSETTINGDP ) > -1 )
			{
				m_dMinSettingDp = _ttof( (LPCTSTR)strField );
			}
			else if( pStr->Find( DPRELIEFVALVE_MAXSETTINGDP ) > -1 )
			{
				m_dMaxSettingDp = _ttof( (LPCTSTR)strField );
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_DpReliefValve::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_DpReliefValve::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_DpReliefValve format
		// line 0 : open curve bracket and call base class.
		// line 1 : Minimum preset differential pressure.
		// line 2 : Maximum preset differential pressure.
		// line 3 : close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_DpReliefValve *)idptr.MP )->Copy( this );
			
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );

			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_TAProduct::ReadText( inpf, pusLineCount );

			CStringArray TxtHdr;
			TxtHdr.Add( DPRELIEFVALVE_MINSETTINGDP );
			TxtHdr.Add( DPRELIEFVALVE_MAXSETTINGDP );

			for( int i = 0; i < TxtHdr.GetSize(); i++ )
			{
				ptcLine = ReadTextLine( inpf, pusLineCount );

				CString str = TxtHdr[i] + CString( ptcLine );
				CDB_DpReliefValve::InterpretInheritedData( &str );
			}
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_DpReliefValve::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_DpReliefValve::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str, str1;
	
	// Write object header.
	if( true == IsClass( CLASS( CDB_DpReliefValve ) ) )
	{
		CData::WriteText( outf, strTab );
	}
	
	// Opening bracket.
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");
	CDB_TAProduct::WriteText( outf, strTab );
	
	// Data.
	WriteFormatedStringW( outf, WriteDouble( m_dMinSettingDp, 3, 1 ), strTab );
	WriteFormatedStringW( outf, WriteDouble( m_dMaxSettingDp, 3, 1 ), strTab );

	// Closing bracket.
	strTab.Delete( 0 );
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}
#endif 


////////////////////////////////////////////////////////////////
//
//		CDB_ControlValve : Control valves
//
////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_ControlValve )

CDB_ControlValve::CDB_ControlValve( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_RegulatingValve( pDataBase, ID )
{
	m_dKvs = 0.0;
	m_dStroke = 0.0;
	m_dRangeability = 0.0;
	m_dLeakageRate = 0.0;
	m_CloseOffCharIDPtr = _NULL_IDPTR;
	m_ActuatorGroupIDPtr = _NULL_IDPTR;
	m_CvAdapterGroupIDPtr = _NULL_IDPTR;
	m_CtrlPropIDPtr = _NULL_IDPTR;
	m_eAdapterListMode = almNotApplicable;
}

IDPTR CDB_ControlValve::GetCloseOffCharIDPtr()
{
	m_CloseOffCharIDPtr.DB = GetDB();

	if( _T('\0') !=  *m_CloseOffCharIDPtr.ID && 0 != _tcscmp( _NO_ID, m_CloseOffCharIDPtr.ID ) && NULL != m_CloseOffCharIDPtr.DB )
	{
		Extend( &m_CloseOffCharIDPtr );
		return m_CloseOffCharIDPtr;
	}
	else
	{
		return _NULL_IDPTR;
	}
}

IDPTR CDB_ControlValve::GetActuatorGroupIDPtr()
{
	m_ActuatorGroupIDPtr.DB = GetDB();

	if( _T('\0') !=  *m_ActuatorGroupIDPtr.ID && 0 != _tcscmp( _NO_ID, m_ActuatorGroupIDPtr.ID ) && NULL != m_ActuatorGroupIDPtr.DB )
	{
		Extend( &m_ActuatorGroupIDPtr );
		return m_ActuatorGroupIDPtr;
	}
	else
	{
		return _NULL_IDPTR;
	}
}

IDPTR CDB_ControlValve::GetAdapterGroupIDPtr()
{
	m_CvAdapterGroupIDPtr.DB = GetDB();

	if( _T('\0') !=  *m_CvAdapterGroupIDPtr.ID && 0 != _tcscmp( _NO_ID, m_CvAdapterGroupIDPtr.ID ) && NULL != m_CvAdapterGroupIDPtr.DB )
	{
		Extend( &m_CvAdapterGroupIDPtr );
		return m_CvAdapterGroupIDPtr;
	}
	else
	{
		return _NULL_IDPTR;
	}
}

IDPTR CDB_ControlValve::GetCtrlPropIDPtr()
{
	m_CtrlPropIDPtr.DB = GetDB();

	if( _T('\0') !=  *m_CtrlPropIDPtr.ID && 0 != _tcscmp( _NO_ID, m_CtrlPropIDPtr.ID ) && NULL != m_CtrlPropIDPtr.DB )
	{
		Extend( &m_CtrlPropIDPtr );
		return m_CtrlPropIDPtr;
	}
	else
	{
		return _NULL_IDPTR;
	}
}

#ifndef TACBX
int CDB_ControlValve::GetCharacteristicImageID()
{
	int iImageID = -1;
	CDB_ControlProperties::eCTRLCHAR CtrlChar = GetCtrlProp()->GetCvCtrlChar();
		
	if( CDB_ControlProperties::Linear == CtrlChar )
	{
		iImageID = IDI_CHARACTLIN;
	}
	else if( CDB_ControlProperties::EqualPc == CtrlChar )
	{
		iImageID = IDI_CHARACTEQM;
	}
	else
	{
		iImageID = IDI_CHARACTNONE;
	}

	return iImageID;
}

int CDB_ControlValve::GetPushPullCloseImageID()
{
	int iImageID = -1;
	CDB_ControlProperties::ePushOrPullToClose PushClose = GetCtrlProp()->GetCvPushClose();
		
	if( CDB_ControlProperties::PushToClose == PushClose )
	{
		iImageID = IDI_PUSHCLOSE;
	}
	else if( CDB_ControlProperties::PullToClose == PushClose )
	{
		iImageID = IDI_PUSHOPEN;
	}

	return iImageID;
}

CString CDB_ControlValve::GetStrokeString()
{
	CString strStroke;
	CDB_CloseOffChar *pCloseOffChar = (CDB_CloseOffChar *)( GetCloseOffCharIDPtr().MP );
		
	if( NULL != pCloseOffChar )
	{
		if( CDB_CloseOffChar::eOpenType::Linear == pCloseOffChar->GetOpenType() )
		{
			strStroke = WriteCUDouble( _U_DIAMETER, GetStroke() );
		}
		else
		{
			strStroke = WriteDouble( GetStroke(), 0, 0);
		}
	}
	else
	{
		strStroke = WriteCUDouble( _U_DIAMETER, GetStroke() ); 
	}

	return strStroke;
}

CDB_ControlValve::DRPFunction CDB_ControlValve::GetCompatibleDRPFunction( int iDRP )
{
	CDB_ElectroActuator::DefaultReturnPosition eDefaultReturnPos = (CDB_ElectroActuator::DefaultReturnPosition )iDRP;
	
	if( eDefaultReturnPos < CDB_ElectroActuator::None || eDefaultReturnPos > CDB_ElectroActuator::Configurable )
	{
		return DRPFunction::drpfNone;
	}
	
	CDB_ControlProperties *pclControlProperties = GetCtrlProp();
	
	if( NULL == pclControlProperties )
	{
		return DRPFunction::drpfNone;
	}

	// Allow to retrieve what is the default return position function compatible for the current control valve and the default return position mode of the actuator.
	
	// For example, if the current control valve has the property "Push to close", that simply means that we need to push to close (yep!).
	// If actuator has the fail safe mode 'Retracting', that means if there is no more power supply, the actuator string will force the actuator
	// to retract. That means if the actuator retracts with this kind of control valve, the control valve will open. This method will return
	// 'DRPFunction::drpfOpening'. That simply means that actuator in fail safe mode (without power supply) will open the control valve.

	DRPFunction eReturn = DRPFunction::drpfNone;

	switch( pclControlProperties->GetCvPushClose() )
	{
		case CDB_ControlProperties::ePushOrPullToClose::Undef:
			break;

		// Valve needs to be pulled to close.
		case CDB_ControlProperties::ePushOrPullToClose::PullToClose:

			if( CDB_ElectroActuator::Retracting == eDefaultReturnPos )
			{
				eReturn = DRPFunction::drpfClosing;
			}
			else if( CDB_ElectroActuator::Extending == eDefaultReturnPos )
			{
				eReturn = DRPFunction::drpfOpening;
			}
			else if( CDB_ElectroActuator::Configurable == eDefaultReturnPos )
			{
				eReturn = DRPFunction::drpfOpeningOrClosing;
			}

			break;

		// Valve needs to be pushed to close.
		case CDB_ControlProperties::ePushOrPullToClose::PushToClose:

			if( CDB_ElectroActuator::DefaultReturnPosition::Retracting == eDefaultReturnPos )
			{
				eReturn = DRPFunction::drpfOpening;
			}
			else if( CDB_ElectroActuator::Extending == eDefaultReturnPos )
			{
				eReturn = DRPFunction::drpfClosing;
			}
			else if( CDB_ElectroActuator::Configurable == eDefaultReturnPos )
			{
				eReturn = DRPFunction::drpfOpeningOrClosing;
			}

			break;
	}
	
	return eReturn;
}

int CDB_ControlValve::GetCompatibleActuatorDRP( CDB_ControlValve::DRPFunction eDRPFunction )
{
	if( eDRPFunction < DRPFunction::drpfNone || eDRPFunction > DRPFunction::drpfAll )
	{
		return (int)CDB_ElectroActuator::DefaultReturnPosition::Undefined;
	}
	
	CDB_ControlProperties* pclControlProperties = GetCtrlProp();
	
	if( NULL == pclControlProperties )
	{
		return (int)CDB_ElectroActuator::DefaultReturnPosition::Undefined;
	}

	// Allow to retrieve what is the actuator fail safe mode compatible with the current control valve.

	CDB_ElectroActuator::DefaultReturnPosition eReturn = CDB_ElectroActuator::DefaultReturnPosition::None;

	switch( pclControlProperties->GetCvPushClose() )
	{
		case CDB_ControlProperties::ePushOrPullToClose::Undef:
			break;

		// Valve needs to be pulled to close.
		case CDB_ControlProperties::ePushOrPullToClose::PullToClose:

			if( DRPFunction::drpfClosing == eDRPFunction )
			{
				eReturn = CDB_ElectroActuator::DefaultReturnPosition::Retracting;
			}
			else if( DRPFunction::drpfOpening == eDRPFunction )
			{
				eReturn = CDB_ElectroActuator::DefaultReturnPosition::Extending;
			}
			else if( DRPFunction::drpfOpeningOrClosing == eDRPFunction )
			{
				eReturn = CDB_ElectroActuator::DefaultReturnPosition::Configurable;
			}

			break;

		// Valve needs to be pushed to close.
		case CDB_ControlProperties::ePushOrPullToClose::PushToClose:

			if( DRPFunction::drpfClosing == eDRPFunction )
			{
				eReturn = CDB_ElectroActuator::DefaultReturnPosition::Extending;
			}
			else if( DRPFunction::drpfOpening == eDRPFunction )
			{
				eReturn = CDB_ElectroActuator::DefaultReturnPosition::Retracting;
			}
			else if( DRPFunction::drpfOpeningOrClosing == eDRPFunction )
			{
				eReturn = CDB_ElectroActuator::DefaultReturnPosition::Configurable;
			}

			break;
	}

	return (int)eReturn;
}

CDB_ControlValve::ControlValveTable CDB_ControlValve::GetCVParentTable( void )
{
	ControlValveTable eReturn = ControlValveTable::Undefined;
	
	if( NULL != GetIDPtr().MP )
	{
		if( true == GetIDPtr().MP->FindOwner( _T("CTRLVALV_TAB") ) )
		{
			eReturn = ControlValveTable::CV;
		}
		else if( true == GetIDPtr().MP->FindOwner( _T("BALCTRLVALV_TAB") ) )
		{
			eReturn = ControlValveTable::BCV;
		}
		else if( true == GetIDPtr().MP->FindOwner( _T("PICTRLVALV_TAB") ) )
		{
			eReturn = ControlValveTable::PICV;
		}
		else if( true == GetIDPtr().MP->FindOwner( _T("TRVALV_TAB") ) )
		{
			eReturn = ControlValveTable::TRV;
		}
		else if( true == GetIDPtr().MP->FindOwner( _T("DPCBALCTRLVALV_TAB") ) )
		{
			eReturn = ControlValveTable::DPCBCV;
		}
	}

	return eReturn;
}

CTableSet *CDB_ControlValve::GetTableSet( )
{
	CTableSet *pTabSet = NULL;
	pTabSet = dynamic_cast<CTableSet *>( (GetDB()->Get( L"CVACTSET_TAB" ) ).MP );
	 
	// HYS-1579: A combination of CVFunc is possible.
	if( ( CDB_ControlProperties::PresetPT & GetCtrlProp()->GetCvFunc() ) == GetCtrlProp()->GetCvFunc() )
	{
		pTabSet = dynamic_cast<CTableSet *>( ( GetDB()->Get( L"BCVACTSET_TAB" ) ).MP );
	}

	ASSERT( NULL != pTabSet );
	return pTabSet;
}	

bool CDB_ControlValve::IsActuatorFit(CDB_Actuator *pActr)
{
	CTable *pRTab = dynamic_cast<CTable *>( GetActuatorGroupIDPtr().MP );

	if( NULL != pRTab )
	{
		IDPTR idptr = pRTab->Get( pActr->GetIDPtr().ID );
	
		if( _T('\0') !=  *idptr.ID )
		{
			return true;
		}
	}

	return false;
}

CDB_Product *CDB_ControlValve::GetMatchingAdapter( CDB_Actuator *pclActuator, bool bOnlyForSet )
{
	if( NULL == pclActuator )
	{
		return NULL;
	}

	CDB_Product *pclAdapter = NULL;

	if( false == bOnlyForSet || false == IsPartOfaSet() )
	{
		CDB_RuledTable *pRTadaptCV, *pRTadaptActr;
		pRTadaptCV = dynamic_cast<CDB_RuledTable *>( GetAdapterGroupIDPtr().MP );
		pRTadaptActr = dynamic_cast<CDB_RuledTable *>( pclActuator->GetActAdapterGroupIDPtr().MP );
		
		if( NULL == pRTadaptActr || NULL == pRTadaptCV )
		{
			return NULL;
		}

		// Find matching adapter.
		// For each CV adapter test each actuator adapter.
		for( IDPTR idptrCVadapt = pRTadaptCV->GetFirst(); NULL != idptrCVadapt.MP; idptrCVadapt = pRTadaptCV->GetNext( idptrCVadapt.MP ) )
		{
			for( IDPTR idptrActrAdapt = pRTadaptActr->GetFirst(); NULL != idptrActrAdapt.MP; idptrActrAdapt = pRTadaptActr->GetNext( idptrActrAdapt.MP ) )
			{
				if( idptrCVadapt.MP == idptrActrAdapt.MP )
				{
					// HYS-1018
					if( eProdUse::eAccessory == ( dynamic_cast<CDB_Product *>( idptrCVadapt.MP ) )->GetProductUseFlag() )
					{
						return ( dynamic_cast<CDB_Product *>( idptrCVadapt.MP ) );
					}
					else
					{
						return NULL;
					}
				}
			}
		}
	}
	else
	{
		// Find set that contain the control valve and the actuator.
		std::set<CDB_Set *> CVActSetArray;
		CTableSet *pCVActTableSet = GetTableSet();

		if( NULL == pCVActTableSet )
		{
			ASSERTA_RETURN( NULL );
		}

		int iCDBSetCount = pCVActTableSet->FindCompatibleSet( &CVActSetArray, GetIDPtr().ID, pclActuator->GetIDPtr().ID );

		if( 0 == iCDBSetCount )
		{
			return NULL;
		}

		// Normally here we MUST have only 1 set!
		ASSERT( 1 == iCDBSetCount );

		// Take the first one.
		CDB_Set *pCVActSet = *CVActSetArray.begin();
		IDPTR AdapterIDPtr = pCVActSet->GetAccGroupIDPtr();

		if( AdapterIDPtr.MP != NULL )
		{
			// Adapter is defined in the set.
			// HYS-1018
			CDB_Product *pclAdapterInSet = dynamic_cast<CDB_Product *>( AdapterIDPtr.MP );

			if( ( pclAdapterInSet != NULL ) && ( eProdUse::eAccessory == pclAdapterInSet->GetProductUseFlag() ) && ( true == pclAdapterInSet->IsSelectable(true) ) )
			{
				pclAdapter = pclAdapterInSet;
			}
		}
		else
		{
			CDB_RuledTable *pclCVAdapterGroup = (CDB_RuledTable *)( GetAdapterGroupIDPtr().MP );

			if( NULL == pclCVAdapterGroup )
			{
				return NULL;
			}

			CDB_RuledTable *pclActuatorAdapterTable = (CDB_RuledTable *)( pclActuator->GetActAdapterGroupIDPtr().MP );

			if( NULL == pclActuatorAdapterTable )
			{
				return NULL;
			}

			// Run all adapters linked to the CV.
			for( IDPTR CVAdapterIDPtr = pclCVAdapterGroup->GetFirst(); CVAdapterIDPtr.MP != NULL && NULL == pclAdapter; CVAdapterIDPtr = pclCVAdapterGroup->GetNext( CVAdapterIDPtr.MP ) )
			{
				// Run all adapters link on current actuator.
				for( IDPTR ActuatorAdapterIDPtr = pclActuatorAdapterTable->GetFirst(); ActuatorAdapterIDPtr.MP != NULL && NULL == pclAdapter; ActuatorAdapterIDPtr = pclActuatorAdapterTable->GetNext( ActuatorAdapterIDPtr.MP ) )
				{
					if( 0 == IDcmp( CVAdapterIDPtr.ID, ActuatorAdapterIDPtr.ID ) )
					{
						// HYS-1018
						CDB_Product *pclAdapterInGroup = dynamic_cast<CDB_Product *>( CVAdapterIDPtr.MP );

						if( ( NULL == pclAdapterInGroup ) || ( eProdUse::eAccessory != pclAdapterInGroup->GetProductUseFlag() ) )
						{
							continue;
						}

						if( false == pclAdapterInGroup->IsSelectable(true) )
						{
							continue;
						}

						pclAdapter = pclAdapterInGroup;
					}
				}
			}
		}
	}

	return pclAdapter;
}

int CDB_ControlValve::ExtractPackageCompliantActr( std::multimap< double, CDB_Actuator *> *pOrgActrList, std::multimap< double, CDB_Actuator *> *pPackageCompliantList )
{
	if( NULL == pOrgActrList || NULL == pPackageCompliantList )
	{
		return 0;
	}
	
	// Verify if actuators present into 'pOrgActrList' actuator list are compatibles?
	CTable *pActrTab = (CTable *) ( GetActuatorGroupIDPtr().MP );

	if( NULL != pActrTab )
	{
		std::multimap< double, CDB_Actuator *>::iterator IterActr;

		// For each actuator present into the actuator group table, verify the existence into the ActrFullList.
		for( IDPTR idptr = pActrTab->GetFirst(); NULL != idptr.MP; idptr = pActrTab->GetNext( idptr.MP ) )
		{
			// Is this actuator present into the full list add it into pPackageCompliantList.
			for( IterActr = pOrgActrList->begin(); IterActr != pOrgActrList->end(); IterActr++ )
			{
				if( IterActr->second == idptr.MP )
				{
					pPackageCompliantList->insert( std::pair<double,CDB_Actuator *>( IterActr->first, IterActr->second ) );
					break;
				}
			}
		}
	}
	
	return pPackageCompliantList->size();
}
#endif

void CDB_ControlValve::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_RegulatingValve::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( _T('\0') !=  *m_CloseOffCharIDPtr.ID && 0 != _tcscmp( _NO_ID, m_CloseOffCharIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_CloseOffCharIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Close-off characteristic ID (%s) is defined but not found in the database."), m_CloseOffCharIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_CloseOffChar ) ) )
			{
				HYSELECT_THROW( _T("Close-off characteristic ID (%s) is found in the database but it's not a 'CDB_CloseOffChar' object."), m_CloseOffCharIDPtr.ID );
			}
		}

		if( _T('\0') !=  *m_ActuatorGroupIDPtr.ID && 0 != _tcscmp( _NO_ID, m_ActuatorGroupIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_ActuatorGroupIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Actuator group ID (%s) is defined but not found in the database."), m_ActuatorGroupIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CTable ) ) )
			{
				HYSELECT_THROW( _T("Actuator group ID (%s) is found in the database but it's not a 'CTable' object."), m_ActuatorGroupIDPtr.ID );
			}
		}

		if( _T('\0') !=  *m_CvAdapterGroupIDPtr.ID && 0 != _tcscmp( _NO_ID, m_CvAdapterGroupIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_CvAdapterGroupIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Control valve adapter group ID (%s) is defined but not found in the database."), m_CvAdapterGroupIDPtr.ID );
			}
		
			if( false == IDPtr.MP->IsClass( CLASS( CDB_RuledTable ) ) )
			{
				HYSELECT_THROW( _T("Control valve adapter group ID (%s) is found in the database but it's not a 'CDB_RuledTable' object."), m_CvAdapterGroupIDPtr.ID );
			}
		}

		if( _T('\0') !=  *m_CtrlPropIDPtr.ID && 0 != _tcscmp( _NO_ID, m_CtrlPropIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_CtrlPropIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Control properties ID (%s) is defined but not found in the database."), m_CtrlPropIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_ControlProperties ) ) )
			{
				HYSELECT_THROW( _T("Control properties ID (%s) is found in the database but it's not a 'CDB_ControlProperties' object."), m_CtrlPropIDPtr.ID );
			}
		}

		if( NULL != GetValveCharacteristic() && true == GetValveCharacteristic()->HasKvCurve() )
		{
			if( GetKvs() > 0 && GetValveCharacteristic()->GetKvMax() != GetKvs() )
			{
				HYSELECT_THROW( _T("Kvs (%f) is defined but is not the same as the Kv max (%f) from the valve characteristic."), GetKvs(), GetValveCharacteristic()->GetKvMax() );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_ControlValve::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

void CDB_ControlValve::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_ControlValve *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_ControlValve' object!") );
		}

		// Base class.
		CDB_RegulatingValve::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_ControlValve" class.
		CDB_ControlValve *pclDestinationControlValve = (CDB_ControlValve *)pclDestination;

		pclDestinationControlValve->SetKvs( m_dKvs );
		pclDestinationControlValve->SetStroke( m_dStroke );
		pclDestinationControlValve->SetRangeability( m_dRangeability );
		pclDestinationControlValve->SetstrRangeability( m_strRangeability );
		pclDestinationControlValve->SetLeakageRate( m_dLeakageRate );
		pclDestinationControlValve->SetCloseOffCharID( m_CloseOffCharIDPtr.ID );
		pclDestinationControlValve->SetActuatorGroupID( m_ActuatorGroupIDPtr.ID );
		pclDestinationControlValve->SetCvAdapterGroupID ( m_CvAdapterGroupIDPtr.ID );
		pclDestinationControlValve->SetCtrlPropID( m_CtrlPropIDPtr.ID );
		pclDestinationControlValve->SetAdapterListMode( m_eAdapterListMode );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_ControlValve::Copy' method with the object '%s'."), GetIDPtr().ID )
}

void CDB_ControlValve::OnDatabaseDestroy()
{
	CDB_RegulatingValve::OnDatabaseDestroy();
	
	// Unlock control properties.
	CDB_ControlValve::GetCtrlProp()->Unlock( GetIDPtr() );
}

#define CDB_CONTROLVALVE_VERSION	3
// Version 3: 'm_eAdapterListMode' variable added.
void CDB_ControlValve::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version =CDB_CONTROLVALVE_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_RegulatingValve::Write( outf );
	
	// Info.
	outf.write( (char *)&m_dKvs, sizeof( m_dKvs ) );
	outf.write( (char *)&m_dStroke, sizeof( m_dStroke ) );
	WriteString( outf, m_strRangeability.c_str() );
	outf.write( (char *)&m_dLeakageRate, sizeof( m_dLeakageRate ) );
	WriteString( outf, m_CloseOffCharIDPtr.ID );
	WriteString( outf, m_ActuatorGroupIDPtr.ID );
	WriteString( outf, m_CvAdapterGroupIDPtr.ID );
	WriteString( outf, m_CtrlPropIDPtr.ID );
	outf.write( (char *)&m_eAdapterListMode, sizeof( m_eAdapterListMode ) );
}

bool CDB_ControlValve::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_CONTROLVALVE_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_RegulatingValve::Read( inpf ) )
	{
		return false;
	}
	
	// Infos.
	m_dKvs = ReadDouble( inpf );
	m_dStroke = ReadDouble( inpf );

	if( false == ReadString( inpf, m_strRangeability ) )
	{
		return false;
	}
	
	TCHAR *ptcEndPtr;
	_string str = m_strRangeability;
	size_t pos = str.find( _T('>') );

	if( string::npos != pos )
	{
		str.erase( pos, 1 );
	}

	m_dRangeability = _tcstod( str.c_str(), &ptcEndPtr );
	ASSERT( _T('\0') == *ptcEndPtr ); 

	m_dLeakageRate = ReadDouble( inpf );
	
	m_CloseOffCharIDPtr = _NULL_IDPTR; 

	if( false == ReadString( inpf, m_CloseOffCharIDPtr.ID, sizeof( m_CloseOffCharIDPtr.ID ) ) )
	{
		return false;
	}

	m_ActuatorGroupIDPtr = _NULL_IDPTR;

	if( false == ReadString( inpf, m_ActuatorGroupIDPtr.ID, sizeof( m_ActuatorGroupIDPtr.ID ) ) )
	{
		return false;
	}
	
	m_CvAdapterGroupIDPtr = _NULL_IDPTR;

	if( Version > 1 )
	{
		if( false == ReadString( inpf, m_CvAdapterGroupIDPtr.ID, sizeof( m_CvAdapterGroupIDPtr.ID ) ) )
		{
			return false;
		}
	}

	m_CtrlPropIDPtr = _NULL_IDPTR;     

	if( false == ReadString( inpf, m_CtrlPropIDPtr.ID, sizeof( m_CtrlPropIDPtr.ID ) ) )
	{
		return false;
	}
	
	inpf.read( (char *)&m_eAdapterListMode, sizeof( m_eAdapterListMode ) );
	
	m_CloseOffCharIDPtr.DB = GetDB();
	m_ActuatorGroupIDPtr.DB = GetDB();
	m_CtrlPropIDPtr.DB = GetDB();
	SetAccessGroupDB( GetDB() );
	
	return true;
}

double CDB_ControlValve::GetKvs()
{
	if( NULL != GetValveCharacteristic() && true == GetValveCharacteristic()->HasKvCurve() )
	{
		return GetValveCharacteristic()->GetKvMax();
	}
	
	return m_dKvs;
}

#ifndef TACBX 
void CDB_ControlValve::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( _T("CDB_ControlValve"));

		if( iPos < 0 )
		{
			CDB_RegulatingValve::InterpretInheritedData( pStr );
		}
		else
		{
			pStr->Delete( iPos, _tcsclen( _T("CDB_ControlValve") ) );
			int iEq = pStr->Find( _T("=") );

			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( _T("::Kvs=") ) > -1 )
			{
				if( RD_OK != ReadDouble( strField, &m_dKvs ) )
				{
					HYSELECT_THROW( _T("Can't convert 'CDB_ControlValve::Kvs' (%s) in double."), strField );
				}
			}
			else if( pStr->Find( _T("::Stroke=") ) > -1 )
			{
				if( RD_OK != ReadDouble( strField, &m_dStroke ) )
				{
					HYSELECT_THROW( _T("Can't convert 'CDB_ControlValve::Stroke' (%s) in double."), strField );
				}
			}
			else if( pStr->Find( _T("::Rangeability=") ) > -1 )
			{
				TCHAR *ptcEndPtr;
				CString str = strField;
				str.Remove('\"');
				m_strRangeability = str;
				str.Remove('>');
				m_dRangeability = _tcstod( (LPCTSTR)str, &ptcEndPtr );
			
				if( _T('\0') != *ptcEndPtr )
				{
					HYSELECT_THROW( _T("Can't convert 'CDB_ControlValve::Rangeability' (%s) in double."), str );
				}
			}
			else if( pStr->Find( _T("::LeakageRate=") ) > -1 )
			{
				if( RD_OK != ReadDouble( strField, &m_dLeakageRate ) )
				{
					HYSELECT_THROW( _T("Can't convert 'CDB_ControlValve::LeakageRate' (%s) in double."), strField );
				}
			}
			else if( pStr->Find( _T("::CloseOffCharID=") ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_ControlValve::CloseOffCharID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetCloseOffCharID( (LPCTSTR)strField );
			}
			else if( pStr->Find( _T("::ActuatorGroupID=") ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_ControlValve::ActuatorGroupID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetActuatorGroupID( (LPCTSTR)strField );
			}
			else if( pStr->Find( _T("::CvAdapterGroupID=") ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_ControlValve::CvAdapterGroupID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetCvAdapterGroupID( (LPCTSTR)strField );
			}
			else if( pStr->Find( _T("::CtrlPropID=") ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_ControlValve::CtrlPropID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetCtrlPropID( (LPCTSTR)strField );
			}
			else if( pStr->Find( _T("::AdapterListMode") ) > -1 )
			{
				int iValue = ReadEnum( strField );

				if( iValue != almNotApplicable && iValue != almNormal && iValue != almSpecial )
				{
					HYSELECT_THROW( _T("'CDB_ControlValve::AdapterListMode' value must be one of these values: '#eCVAdapterListNA', '#eCVAdapterListNormal' or '#eCVAdapterListSpecial'.") );
				}

				m_eAdapterListMode = (AdapterListMode)iValue;
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_ControlValve::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_ControlValve::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str, str1;
	
	// Write object header.
	if( true == IsClass(CLASS( CDB_ControlValve ) ) )
	{
		CData::WriteText( outf, strTab );
	}
	
	// Opening bracket.
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");
	CDB_RegulatingValve::WriteText( outf, strTab );
	
	// Data.
	WriteFormatedStringW( outf, WriteDouble( m_dKvs, 2, 1 ), strTab );
	WriteFormatedStringW( outf, WriteDouble( m_dStroke, 2, 1 ),strTab );
	WriteFormatedStringW( outf, m_strRangeability.c_str(), strTab );
	WriteFormatedStringW( outf, WriteDouble( m_dLeakageRate, 2, 1 ), strTab );
	WriteFormatedStringW( outf, m_CloseOffCharIDPtr.ID, strTab );
	WriteFormatedStringW( outf, m_ActuatorGroupIDPtr.ID, strTab );
	WriteFormatedStringW( outf, m_CvAdapterGroupIDPtr.ID, strTab );
	WriteFormatedStringW( outf, m_CtrlPropIDPtr.ID, strTab );
	
	if( AdapterListMode::almNotApplicable == m_eAdapterListMode )
	{
		str1 = _T("#eCVAdapterListNA");
	}
	else if( AdapterListMode::almNormal == m_eAdapterListMode )
	{
		str1 = _T("#eCVAdapterListNormal");
	}
	else if( AdapterListMode::almSpecial == m_eAdapterListMode )
	{
		str1 = _T("#eCVAdapterListSpecial");
	}

	WriteFormatedStringW( outf, str1, strTab );
	
	// Closing bracket.
	strTab.Delete( 0 );
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}

void CDB_ControlValve::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		//
		//	new:CDB_ControlValve(ID)->CTRLVALV_TAB
		//	{
		//		--> RegulatingValve	
		//		Kvs					Kvs of the CV
		//		Stroke				Stroke of the CV
		//		Rangeability		Rangeability of the CV
		//		LeakageRate			Leakage rate of the CV as a fraction of Kvs
		//		CloseOffCharID		Identifier of the close-off characteristic
		//		ActuatorGroupID		Identifier of the actuator group
		//		CvAdapterGroupID	Identifier of the CV adapter group
		//		CtrlPropID			Identifier of the control properties
		//		AdapterListMode		Set what is the method to use to retrieve adapter list linked to this control valve (#eCVAdapterListNormal or #eCVAdapterListSpecial).
		//							(see enum in 'tadb.txt' for more description).
		//	}
		//
		////////////////////////////////////////////////////////////////

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_ControlValve *)idptr.MP )->Copy( this );
			
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );
			
				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_RegulatingValve::ReadText( inpf, pusLineCount );
		
			TCHAR *ptcEndPtr;
		
			// Kvs.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_dKvs = _tcstod( ptcLine, &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't convert Kvs value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
			}
		
			// Stroke.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_dStroke = _tcstod( ptcLine, &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't convert stroke value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
			}
		
			// Rangeability.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			CString str = ptcLine;
			str.Remove('\"');
			m_strRangeability = str;

			str.Remove('>');
			m_dRangeability = _tcstod( (LPCTSTR)str, &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't convert rangeability value (%s) in double (pos: %i)."), str, *pusLineCount );
			}
		
			// Leakage Rate.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_dLeakageRate = _tcstod( ptcLine, &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't convert leakage rate value (%s) in double (pos: %i)."), str, *pusLineCount );
			}
		
			// Close Off characteristic ID.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Close-off characteristic ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			_tcsncpy_s( m_CloseOffCharIDPtr.ID, SIZEOFINTCHAR( m_CloseOffCharIDPtr.ID ), ptcLine, SIZEOFINTCHAR( m_CloseOffCharIDPtr.ID) - 1 );
		
			// ActuatorGroup ID.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Actuator group ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			_tcsncpy_s( m_ActuatorGroupIDPtr.ID, SIZEOFINTCHAR( m_ActuatorGroupIDPtr.ID ), ptcLine, SIZEOFINTCHAR( m_ActuatorGroupIDPtr.ID ) - 1 );
		
			// CvAdapterGroup ID.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Control valve adapter group ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			_tcsncpy_s( m_CvAdapterGroupIDPtr.ID, SIZEOFINTCHAR( m_CvAdapterGroupIDPtr.ID ), ptcLine, SIZEOFINTCHAR( m_CvAdapterGroupIDPtr.ID ) - 1 );
		
			// CtrlProp ID.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Control valve property ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			_tcsncpy_s( m_CtrlPropIDPtr.ID, SIZEOFINTCHAR( m_CtrlPropIDPtr.ID ), ptcLine, SIZEOFINTCHAR( m_CtrlPropIDPtr.ID ) - 1 );

			// Read the adapter list mode.
			int iValue = ReadEnumLine( inpf, pusLineCount );

			if( iValue != almNotApplicable && iValue != almNormal && iValue != almSpecial )
			{
				HYSELECT_THROW( _T("'CDB_ValveCharacteristic::PBType' value must be one of these values: '#eCVAdapterListNA', '#eCVAdapterListNormal' or '#eCVAdapterListSpecial' (pos: %i)."), *pusLineCount );
			}

			m_eAdapterListMode = (AdapterListMode)iValue;
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_ControlValve::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

#endif 

////////////////////////////////////////////////////////////////
//
//		CDB_PIControlValve : Pressure independent control valves
//
////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_PIControlValve )

CDB_PIControlValve::CDB_PIControlValve( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_ControlValve( pDataBase, ID )
{
	*m_PICVCharacteristicID = _T('\0');
	m_pPICVCharacteristic = NULL;
}

CDB_PICVCharacteristic *CDB_PIControlValve::GetPICVCharacteristic()
{
	HYSELECT_TRY
	{
		if( NULL == m_pPICVCharacteristic )
		{
			if( _T('\0') != *m_PICVCharacteristicID && 0 != IDcmp( m_PICVCharacteristicID, _NO_ID ) )
			{
				IDPTR CharactPtr = GetDB()->Get( m_PICVCharacteristicID );
				
				if( _T('\0') == *CharactPtr.ID )
				{
					HYSELECT_THROW_RETURNARG( _T("Internal error: Can't find pressure independent balancing & control valve characteristic '%s' in the database."), NULL, m_PICVCharacteristicID );
				}

				m_pPICVCharacteristic = (CDB_PICVCharacteristic*)( CharactPtr.MP );
				m_pPICVCharacteristic->Lock( GetIDPtr() );	
			}
		}
	
		return m_pPICVCharacteristic;
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CDB_PIControlValve::GetPICVCharacteristic'.") )
}

double CDB_PIControlValve::GetDpmin( double dFlow, double dDensity )
{
	if( dFlow > GetQmax() )
	{
		return -1.0;
	}
	
	CDB_PICVCharacteristic *pPICVCharacteristic = GetPICVCharacteristic();
	
	if( NULL == pPICVCharacteristic )
	{
		return -1.0;
	}

	double dDpmin = -1.0;

	if( true == pPICVCharacteristic->DpminCharGiven() )
	{
		// A 'Dpmin' characteristic exists.
		dDpmin = pPICVCharacteristic->GetDpmin( pPICVCharacteristic->GetSettingFromQmax( dFlow ) );
	}
	else
	{
		if( -1.0 == GetFc() || -1.0 == GetKvd() )
		{
			return -1.0;
		}
		
		// No 'Dpmin' characteristic exists, use 'Fc' and 'Kvd' to calculate 'Dpmin'.
		dDpmin = GetFc() + CalcDp( dFlow, GetKvd(), dDensity );
	}
	
	return dDpmin;
}

double CDB_PIControlValve::GetMaxSetting()
{
	CDB_PICVCharacteristic *pPICVCharacteristic = GetPICVCharacteristic();

	if( NULL == pPICVCharacteristic )
	{
		return -1.0;
	}
	
	double dMaxSetting = -1.0;

	if( true == pPICVCharacteristic->QmaxCharGiven() )
	{
		// A 'qmax' characteristic exists.
		dMaxSetting = pPICVCharacteristic->GetSettingMax();
	}
	else
	{
		// No 'qmax' characteristic exists, interpolate the Kv characteristic.
		dMaxSetting = pPICVCharacteristic->GetOpeningMax();
	}
	
	return dMaxSetting;
}

double CDB_PIControlValve::GetPresetting( double dFlow, double dDensity, double dViscosity )
{
	if( dFlow > GetQmax() )
	{
		return -1.0;
	}
	
	CDB_PICVCharacteristic *pPICVCharacteristic = GetPICVCharacteristic();

	if( NULL == pPICVCharacteristic )
	{
		return -1.0;
	}
	
	double dPresetting = -1.0;
	
	if( true == pPICVCharacteristic->QmaxCharGiven() )
	{
		// A 'qmax' characteristic exists.

		// If flow is below published 'Qmax' but above flow at max setting...
		if( dFlow > pPICVCharacteristic->GetQmaxMax() )
		{
			dPresetting = pPICVCharacteristic->GetSettingMax();
		}
		else
		{
			dPresetting = pPICVCharacteristic->GetSettingFromQmax( dFlow );
		}
	}
	else
	{
		// No 'qmax' characteristic exists, interpolate the Kv characteristic.
		double dFlowAtMaxSetting = 0.0;
		
		// Returns -1.0 in 'dFlowAtMaxSetting' if error.
		pPICVCharacteristic->GetValveQ( &dFlowAtMaxSetting, GetFc(), pPICVCharacteristic->GetOpeningMax(), dDensity, dViscosity );
		
		// If flow is below published 'Qmax' but above flow at max setting...
		if( dFlowAtMaxSetting >= 0.0 && dFlow > dFlowAtMaxSetting )
		{
			dPresetting = pPICVCharacteristic->GetOpeningMax();
		}
		else
		{
			int iRounding = ( eb3True == pPICVCharacteristic->IsDiscrete() ) ? 2 : 1;
			pPICVCharacteristic->GetValveOpening( dFlow, GetFc(), &dPresetting, dDensity, dViscosity, iRounding );
		}
	}
	
	return dPresetting;
}

double CDB_PIControlValve::GetKvd()
{
	double dKvd = -1.0;
	
	if( NULL != GetPICVCharacteristic() )
	{
		dKvd = GetPICVCharacteristic()->GetKvd();
	}

	return dKvd;
}

double CDB_PIControlValve::GetFc()
{
	double dFc = -1.0;
	
	if( NULL != GetPICVCharacteristic() )
	{
		dFc = GetPICVCharacteristic()->GetFc();
	}

	return dFc;
}

double CDB_PIControlValve::GetQmax()
{
	double dQmax = -1.0;
	
	if( NULL != GetPICVCharacteristic() )
	{
		dQmax = GetPICVCharacteristic()->GetQmax();
	}

	return dQmax;
}

void CDB_PIControlValve::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_ControlValve::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;
	
		if( _T('\0') != *m_PICVCharacteristicID && 0 != _tcscmp( _NO_ID, m_PICVCharacteristicID ) )
		{
			IDPtr = GetDB()->Get( m_PICVCharacteristicID );
		
			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("PIBCV characteristic ID (%s) is defined but not found in the database."), m_PICVCharacteristicID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_PICVCharacteristic ) ) )
			{
				HYSELECT_THROW( _T("PIBCV characteristic ID (%s) is found in the database but it's not a 'CDB_PICVCharacteristic' object."), m_PICVCharacteristicID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_PIControlValve::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

void CDB_PIControlValve::SetPICVCharacteristicID( LPCTSTR strCharacteristicID )
{
	ASSERT( _tcslen( strCharacteristicID ) <= _ID_LENGTH );
	_tcsncpy_s( m_PICVCharacteristicID, SIZEOFINTCHAR( m_PICVCharacteristicID ), (LPCTSTR)strCharacteristicID, SIZEOFINTCHAR( m_PICVCharacteristicID ) - 1 );

	// Unlock if previous one exist.
	if( NULL != m_pPICVCharacteristic )
	{
		m_pPICVCharacteristic->Unlock( GetIDPtr() );
	}

	// Force a call to 'GetPICVCharacteristic' to update 'm_pPICVCharacteristic'.
	m_pPICVCharacteristic = NULL;
	GetPICVCharacteristic();
}

void CDB_PIControlValve::OnDatabaseDestroy()
{
	CDB_ControlValve::OnDatabaseDestroy();
	
	// Unlock 'Inlet' and 'Outlet' if necessary.
	if( true == IsConnTabUsed() )
	{
		if( NULL != GetDB()->Get( GetConnectID() ).MP )
		{
			( (CDB_Component*)( GetDB()->Get( GetConnectID() ).MP ) )->Unlock( GetIDPtr() );
		}

		if( NULL != GetDB()->Get( GetConn2ID() ).MP )
		{
			( (CDB_Component*)( GetDB()->Get( GetConn2ID() ).MP ) )->Unlock( GetIDPtr() );
		}
	}
	
	// Unlock the PICV curve.
	if( NULL != GetPICVCharacteristic() )
	{
		GetPICVCharacteristic()->Unlock( GetIDPtr() );
	}
}

void CDB_PIControlValve::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_PIControlValve *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_PIControlValve' object!") );
		}

		// Base class.
		CDB_ControlValve::Copy( pclDestination );

		// Copy now what it is common to the "CDB_PIControlValve" class.
		CDB_PIControlValve *pclDestinationPIControlValve = (CDB_PIControlValve *)pclDestination;

		pclDestinationPIControlValve->SetPICVCharacteristicID( m_PICVCharacteristicID );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_PIControlValve::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define  CDB_PICONTROLVALVE_VERSION		3
void CDB_PIControlValve::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_PICONTROLVALVE_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_ControlValve::Write( outf );
	
	// Info.
	WriteString( outf, m_PICVCharacteristicID );
}

bool CDB_PIControlValve::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );
	
	if( Version < 1 || Version > CDB_PICONTROLVALVE_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_ControlValve::Read( inpf ) )
	{
		return false;
	}
	
	// Info.
	if( false == ReadString( inpf, m_PICVCharacteristicID, sizeof( m_PICVCharacteristicID ) ) )
	{
		return false;
	}

	return true;
}

#ifndef TACBX
CTableSet *CDB_PIControlValve::GetTableSet( )
{
	CTableSet *pTabSet = NULL;
	// HYS-1877: Use GetTableSetID() instead of _T("PICVACTSET_TAB") if it is not "NO_ID".
	if( 0 != StringCompare( GetTableSetID(), _T( "NO_ID" ) ) )
	{
		pTabSet = dynamic_cast<CTableSet*>(GetDB()->Get( GetTableSetID() ).MP);
	}
	else
	{
		pTabSet = dynamic_cast<CTableSet*>(GetDB()->Get( _T( "PICVACTSET_TAB" ) ).MP);
	}

	ASSERT( NULL != pTabSet );

	return pTabSet;
}

void CDB_PIControlValve::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( _T("CDB_PIControlValve") );

		if( iPos < 0 )
		{
			CDB_ControlValve::InterpretInheritedData( pStr );
		}
		else
		{
			pStr->Delete( iPos, _tcsclen( _T("CDB_PIControlValve") ) );
			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );
		
			if( pStr->Find( _T("::PICVCharID=") ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_PIControlValve::PICVCharID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetPICVCharacteristicID( (LPCTSTR)strField );
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_PIControlValve::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_PIControlValve::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str, str1;
	
	// Write object header.
	if( true == IsClass( CLASS( CDB_PIControlValve ) ) )
	{
		CData::WriteText( outf, strTab );
	}
	
	// Opening bracket.
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	// Base class.
	strTab += _T("\t");
	CDB_ControlValve::WriteText( outf, strTab );
	
	// Data.
	WriteFormatedStringW( outf, m_PICVCharacteristicID, strTab );
	
	// Closing bracket.
	strTab.Delete( 0 );
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}

void CDB_PIControlValve::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		//
		//	new:CDB_PIControlValve(ID)->PICTRLVALV_TAB
		//	{
		//		--> Control valve
		//		PICVCharID		Identifier of the PICV characteristic
		//	}
		//
		////////////////////////////////////////////////////////////////

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_PIControlValve *)idptr.MP )->Copy( this );
		
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_ControlValve::ReadText( inpf, pusLineCount );

			// Read the curve ID.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Curve ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			SetPICVCharacteristicID( ptcLine );
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_PIControlValve::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif

#ifndef TACBX 
////////////////////////////////////////////////////////////////
//
//		CDB_6WayValve : 6 way control valve
//
////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_6WayValve )

CDB_6WayValve::CDB_6WayValve( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_ControlValve( pDataBase, ID )
{
	m_dQmax = 0;
	m_PICVGroupTabIDPtr = _NULL_IDPTR;
	m_BVFamilyGroupTabIDPtr = _NULL_IDPTR;
}

IDPTR CDB_6WayValve::GetPicvGroupTableIDPtr()
{
	m_PICVGroupTabIDPtr.DB = GetDB();

	if( _T('\0') !=  *m_PICVGroupTabIDPtr.ID && 0 != _tcscmp( _NO_ID, m_PICVGroupTabIDPtr.ID ) && NULL != m_PICVGroupTabIDPtr.DB )
	{
		Extend( &m_PICVGroupTabIDPtr );
		return m_PICVGroupTabIDPtr;
	}
	else
	{
		return _NULL_IDPTR;
	}
}

IDPTR CDB_6WayValve::GetBvFamiliesGroupTableIDPtr()
{
	m_BVFamilyGroupTabIDPtr.DB = GetDB();

	if( _T('\0') !=  *m_BVFamilyGroupTabIDPtr.ID && 0 != _tcscmp( _NO_ID, m_BVFamilyGroupTabIDPtr.ID ) && NULL != m_BVFamilyGroupTabIDPtr.DB )
	{
		Extend( &m_BVFamilyGroupTabIDPtr );
		return m_BVFamilyGroupTabIDPtr;
	}
	else
	{
		return _NULL_IDPTR;
	}
}

void CDB_6WayValve::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_ControlValve::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( _T('\0') != *m_PICVGroupTabIDPtr.ID && 0 != _tcscmp( _NO_ID, m_PICVGroupTabIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_PICVGroupTabIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("PIBCV group table ID (%s) is defined but not found in the database."), m_PICVGroupTabIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CTable ) ) )
			{
				HYSELECT_THROW( _T("PIBCV group table ID (%s) is found in the database but it's not a 'CTable' object."), m_PICVGroupTabIDPtr.ID );
			}
		}

		if( _T('\0') != *m_BVFamilyGroupTabIDPtr.ID && 0 != _tcscmp( _NO_ID, m_BVFamilyGroupTabIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_BVFamilyGroupTabIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("BV family group table ID (%s) is defined but not found in the database."), m_BVFamilyGroupTabIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CTable ) ) )
			{
				HYSELECT_THROW( _T("BV family group table ID (%s) is found in the database but it's not a 'CTable' object."), m_BVFamilyGroupTabIDPtr.ID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_6WayValve::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

void CDB_6WayValve::SetPicvGroupTableIDPtr( _string ID )
{
	if( ID.compare( m_PICVGroupTabIDPtr.ID ) )
	{
		_tcscpy_s( m_PICVGroupTabIDPtr.ID, _ID_LENGTH + 1, ID.c_str() ); 
		Modified();
	}
}

void CDB_6WayValve::SetBvFamiliesGroupTableIDPtr( _string ID )
{
	if( ID.compare( m_BVFamilyGroupTabIDPtr.ID ) )
	{
		_tcscpy_s( m_BVFamilyGroupTabIDPtr.ID, _ID_LENGTH + 1, ID.c_str() ); 
		Modified();
	}
}

void CDB_6WayValve::OnDatabaseDestroy()
{
	CDB_ControlValve::OnDatabaseDestroy();

	// Unlock 'Inlet' and 'Outlet' if necessary.
	if( true == IsConnTabUsed() )
	{
		if( NULL != GetDB()->Get( GetConnectID() ).MP )
		{
			( (CDB_Component*)( GetDB()->Get( GetConnectID() ).MP ) )->Unlock( GetIDPtr() );
		}

		if( NULL != GetDB()->Get( GetConn2ID() ).MP )
		{
			( (CDB_Component*)( GetDB()->Get( GetConn2ID() ).MP ) )->Unlock( GetIDPtr() );
		}
	}
}

void CDB_6WayValve::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_6WayValve *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_6WayValve' object!") );
		}
	
		// Base class.
		CDB_ControlValve::Copy( pclDestination );

		// Copy now what it is common to the "CDB_6WayValve" class.
		CDB_6WayValve *pclDestination6WayValve = (CDB_6WayValve *)pclDestination;

		pclDestination6WayValve->SetQmax( m_dQmax );
		pclDestination6WayValve->SetPicvGroupTableIDPtr( m_PICVGroupTabIDPtr.ID );
		pclDestination6WayValve->SetBvFamiliesGroupTableIDPtr( m_BVFamilyGroupTabIDPtr.ID );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_6WayValve::Copy' method with the object '%s'."), GetIDPtr().ID )
}

CTableSet* CDB_6WayValve::GetTableSet()
{
	CTableSet* pTabSet = NULL;
	pTabSet = dynamic_cast<CTableSet*>(GetDB()->Get( _T( "6WAYCTRLVALVSET_TAB" ) ).MP);
	ASSERT( NULL != pTabSet );

	return pTabSet;
}

#define  CDB_6WAYVALVE_VERSION		2
// Version 2: 2019-11-07: HYS-1152: add a table for compatible BV families that can be selected with the 6-way valves.
void CDB_6WayValve::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_6WAYVALVE_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CDB_ControlValve::Write( outf );

	// Info.
	WriteDouble( outf, m_dQmax );

	WriteString( outf, m_PICVGroupTabIDPtr.ID );

	// Version 2.
	WriteString( outf, m_BVFamilyGroupTabIDPtr.ID );
}

bool CDB_6WayValve::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_6WAYVALVE_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDB_ControlValve::Read( inpf ) )
	{
		return false;
	}

	// Info.

	m_dQmax = ReadDouble( inpf );

	if( false == ReadString( inpf, m_PICVGroupTabIDPtr.ID, sizeof( m_PICVGroupTabIDPtr.ID ) ) )
	{
		return false;
	}

	if( Version < 2 )
	{
		return true;
	}

	if( false == ReadString( inpf, m_BVFamilyGroupTabIDPtr.ID, sizeof( m_BVFamilyGroupTabIDPtr.ID ) ) )
	{
		return false;
	}

	return true;
}

void CDB_6WayValve::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( _T("CDB_6WayValve") );

		if( iPos < 0 )
		{
			CDB_ControlValve::InterpretInheritedData( pStr );
		}
		else
		{
			pStr->Delete( iPos, _tcsclen( _T("CDB_6WayValve") ) );
			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( _T("::Qmax=") ) > -1 )
			{
				m_dQmax = _ttof( (LPCTSTR)strField );

				if( m_dQmax <= 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_6WayValve::Qmax' (%f) can't be lower or equal than 0."), m_dQmax );
				}
			}
			else if( pStr->Find( _T("::PicvGroupID=") ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_6WayValve::PicvGroupID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				_tcscpy( m_PICVGroupTabIDPtr.ID, (LPCTSTR)strField );
			}
			else if( pStr->Find( _T("::BvFamiliesGroupID=") ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_6WayValve::BvFamiliesGroupID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				_tcscpy( m_BVFamilyGroupTabIDPtr.ID, (LPCTSTR)strField );
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_6WayValve::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_6WayValve::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str, str1;

	// Write object header.
	if( true == IsClass( CLASS( CDB_6WayValve ) ) )
	{
		CData::WriteText( outf, strTab );
	}

	// Opening bracket.
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	// Base class.
	strTab += _T("\t");
	CDB_ControlValve::WriteText( outf, strTab );

	// Data.
	WriteFormatedStringW( outf, WriteDouble( m_dQmax, 3, 1 ), strTab );
	WriteFormatedStringW( outf, m_PICVGroupTabIDPtr.ID, strTab );
	WriteFormatedStringW( outf, m_BVFamilyGroupTabIDPtr.ID, strTab );

	// Closing bracket.
	strTab.Delete( 0 );
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}

void CDB_6WayValve::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		//
		//	new:CDB_6WayValve(ID)->6WAYCTRLVALV_TAB
		//	{
		//		--> Control valve
		//		PicvGroupID				Table that contains IDs of all the PIBCV that can be used with this 6 way valve
		//		BvFamiliesGroupID		Table that contains IDs of all the BV family IDs that can be used with this 6 way valve
		//	}
		//
		////////////////////////////////////////////////////////////////

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_6WayValve *)idptr.MP )->Copy( this );

			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );

			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_ControlValve::ReadText( inpf, pusLineCount );

			// Qmax.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_dQmax = _tstof( ptcLine );

			if( m_dQmax <= 0.0 )
			{
				HYSELECT_THROW( _T("Qmax (%f) can't be lower or equal than 0."), m_dQmax );
			}

			// Read tab picvID.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("PIBCV group ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			_tcscpy( m_PICVGroupTabIDPtr.ID, ptcLine );

			// Read the 'BvFamiliesGroupID' variable.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("BV families group ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			_tcscpy( m_BVFamilyGroupTabIDPtr.ID, ptcLine );
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_6WayValve::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif 

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_SmartValveCharacteristic
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_SmartValveCharacteristic )

CDB_SmartValveCharacteristic::CDB_SmartValveCharacteristic( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_Characteristic( pDataBase, ID )
{
	m_dKvs = -1.0;
	m_dMinAdjustableFlow = -1.0;
	m_dQnom = -1.0;
	m_dMinAdjustablePower = -1.0;
	m_dPowerNom = -1.0;
}

double CDB_SmartValveCharacteristic::GetMinAdjustableFlow()
{
	return m_dMinAdjustableFlow;
}

double CDB_SmartValveCharacteristic::GetQnom()
{
	return m_dQnom;
}

double CDB_SmartValveCharacteristic::GetMinAdjustablePower()
{
	return m_dMinAdjustablePower;
}

double CDB_SmartValveCharacteristic::GetPowerNom()
{
	return m_dPowerNom;
}

#define CDB_SMARTVALVECHARACTERISTIC_VERSION	2
// Version 2: HYS-1678: Add power characteristic.
void CDB_SmartValveCharacteristic::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_SMARTVALVECHARACTERISTIC_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_Characteristic::Write( outf );
	
	// Infos.
	outf.write( (char *)&m_dKvs, sizeof( m_dKvs ) );
	outf.write( (char *)&m_dMinAdjustableFlow, sizeof( m_dMinAdjustableFlow ) );
	outf.write( (char *)&m_dQnom, sizeof( m_dQnom ) );

	// Version 2.
	outf.write( (char *)&m_dMinAdjustablePower, sizeof( m_dMinAdjustablePower ) );
	outf.write( (char *)&m_dPowerNom, sizeof( m_dPowerNom ) );
}

bool CDB_SmartValveCharacteristic::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_SMARTVALVECHARACTERISTIC_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_Characteristic::Read( inpf ) )
	{
		return false;
	}
	
	// Infos.
	m_dKvs = ReadDouble( inpf );
	m_dMinAdjustableFlow = ReadDouble( inpf );
	m_dQnom = ReadDouble( inpf );

	if( Version < 2 )
	{
		return true;
	}

	// Version 2.
	m_dMinAdjustablePower = ReadDouble( inpf );
	m_dPowerNom = ReadDouble( inpf );

	return true;
}

#ifndef TACBX 
void CDB_SmartValveCharacteristic::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_QDpCharacteristic format
		// line 0 : open curve bracket and call base class.
		// line 1 : Kvs
		// line 2 : Minimum adjustable max flow
		// line 3 : Nominal flow
		// line 4 : Minimum adjustable max power
		// line 5 : Nominal power
		// line 6 : close curve bracket.
	
		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Read base.
		CDB_Characteristic::ReadText( inpf, pusLineCount );

		TCHAR *ptcEndPtr;

		// Kvs.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_dKvs = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Cant read 'CDB_SmartValveCharacteristic::Kvs' (%s) (pos: %i)."), ptcLine, *pusLineCount );
		}

		if( m_dKvs < 0.0 )
		{
			HYSELECT_THROW( _T("'CDB_SmartValveCharacteristic::Kvs' (%f) can't be lower than 0.0 (pos: %i)."), m_dKvs, *pusLineCount );
		}
	
		// Minimum adjustable flow.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		m_dMinAdjustableFlow = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Cant read 'CDB_SmartValveCharacteristic::MinAdjustableFlow' (%s) (pos: %i)."), ptcLine, *pusLineCount );
		}

		if( m_dMinAdjustableFlow < 0.0 )
		{
			HYSELECT_THROW( _T("'CDB_SmartValveCharacteristic::MinAdjustableFlow' (%f) can't be lower than 0.0 (pos: %i)."), m_dMinAdjustableFlow, *pusLineCount );
		}

		// Qnom.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_dQnom = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Cant read 'CDB_SmartValveCharacteristic::Qnom' (%s) (pos: %i)."), ptcLine, *pusLineCount );
		}

		if( m_dQnom < 0.0 )
		{
			HYSELECT_THROW( _T("'CDB_SmartValveCharacteristic::Qnom' (%f) can't be lower than 0.0 (pos: %i)."), m_dQnom, *pusLineCount );
		}

		// Minimum adjustable power.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		m_dMinAdjustablePower = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Cant read 'CDB_SmartValveCharacteristic::MinAdjustablePower' (%s) (pos: %i)."), ptcLine, *pusLineCount );
		}

		if( m_dMinAdjustablePower < 0.0 )
		{
			HYSELECT_THROW( _T("'CDB_SmartValveCharacteristic::MinAdjustablePower' (%f) can't be lower than 0.0 (pos: %i)."), m_dMinAdjustablePower, *pusLineCount );
		}

		// PowerNom.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_dPowerNom = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Cant read 'CDB_SmartValveCharacteristic::PowerNom' (%s) (pos: %i)."), ptcLine, *pusLineCount );
		}

		if( m_dPowerNom < 0.0 )
		{
			HYSELECT_THROW( _T("'CDB_SmartValveCharacteristic::PowerNom' (%f) can't be lower than 0.0 (pos: %i)."), m_dPowerNom, *pusLineCount );
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_SmartValveCharacteristic::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif

////////////////////////////////////////////////////////////////
//
//		CDB_SmartControlValve : TA-Smart
//
////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_SmartControlValve )

CDB_SmartControlValve::CDB_SmartControlValve( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_RegulatingValve( pDataBase, ID )
{
	m_eSmartValveType = SmartValveTypeUndefined;
	m_dStroke = 0.0;
	m_dRangeability = 0.0;
	m_strRangeability = _T("");
	m_dLeakageRate = 0.0;
	m_CtrlPropIDPtr = _NULL_IDPTR;
	m_strInternalActuatorName = _T("");
	m_SmartValveCharacteristicID[0] = _T('\0');
	m_dRemoteTempSensorCableLength = 0.0;
	m_pSmartValveCharacteristic = NULL;
	m_DpSensorGroupIDPtr = _NULL_IDPTR;

	// HYS-1660: Add new information.
#ifndef TACBX
	m_arInputSignals.RemoveAll();
	m_arOutputSignals.RemoveAll();
	m_arPowerSupplies.RemoveAll();
#endif
}

IDPTR CDB_SmartControlValve::GetCtrlPropIDPtr()
{
	m_CtrlPropIDPtr.DB = GetDB();

	if( _T('\0') !=  *m_CtrlPropIDPtr.ID && 0 != _tcscmp( _NO_ID, m_CtrlPropIDPtr.ID ) && NULL != m_CtrlPropIDPtr.DB )
	{
		Extend( &m_CtrlPropIDPtr );
		return m_CtrlPropIDPtr;
	}
	else
	{
		return _NULL_IDPTR;
	}
}

CDB_SmartValveCharacteristic *CDB_SmartControlValve::GetSmartValveCharacteristic()
{
	HYSELECT_TRY
	{
		if( NULL == m_pSmartValveCharacteristic )
		{
			if( _T('\0') != *m_SmartValveCharacteristicID && 0 != IDcmp( m_SmartValveCharacteristicID, _NO_ID ) )
			{
				IDPTR CharactPtr = GetDB()->Get( m_SmartValveCharacteristicID );

				if( _T('\0') == *CharactPtr.ID )
				{
					HYSELECT_THROW_RETURNARG( _T("Internal error: Can't find characteristic '%s' in the database."), NULL, m_SmartValveCharacteristicID );
				}

				m_pSmartValveCharacteristic = (CDB_SmartValveCharacteristic *)( CharactPtr.MP );

				if( NULL != m_pSmartValveCharacteristic )
				{
					m_pSmartValveCharacteristic->Lock( GetIDPtr() );
				}
			}
		}

	return m_pSmartValveCharacteristic;
	}
		HYSELECT_CATCH( clHySelectException, _T("Error in 'CDB_RegulatingValve::GetValveCharacteristic'.") )
}

IDPTR CDB_SmartControlValve::GetDpSensorGroupIDPtr()
{
	m_DpSensorGroupIDPtr.DB = GetDB();

	if( _T('\0') !=  *m_DpSensorGroupIDPtr.ID && 0 != _tcscmp( _NO_ID, m_DpSensorGroupIDPtr.ID ) && NULL != m_DpSensorGroupIDPtr.DB )
	{
		Extend( &m_DpSensorGroupIDPtr );
		return m_DpSensorGroupIDPtr;
	}
	else
	{
		return _NULL_IDPTR;
	}
}

double CDB_SmartControlValve::GetMinAdjustableFlow()
{
	double dMinAdjustableFlow = -1.0;

	CDB_SmartValveCharacteristic *pclSmartControlValveCharacteristic = GetSmartValveCharacteristic();

	if( NULL != pclSmartControlValveCharacteristic )
	{
		dMinAdjustableFlow = pclSmartControlValveCharacteristic->GetMinAdjustableFlow();
	}

	return dMinAdjustableFlow;
}

double CDB_SmartControlValve::GetQNom()
{
	double dQNom = -1.0;

	CDB_SmartValveCharacteristic *pclSmartControlValveCharacteristic = GetSmartValveCharacteristic();

	if( NULL != pclSmartControlValveCharacteristic )
	{
		dQNom = pclSmartControlValveCharacteristic->GetQnom();
	}

	return dQNom;
}

double CDB_SmartControlValve::GetMinAdjustablePower()
{
	double dMinAdjustablePower = -1.0;

	CDB_SmartValveCharacteristic *pclSmartControlValveCharacteristic = GetSmartValveCharacteristic();

	if( NULL != pclSmartControlValveCharacteristic )
	{
		dMinAdjustablePower = pclSmartControlValveCharacteristic->GetMinAdjustablePower();
	}

	return dMinAdjustablePower;
}

double CDB_SmartControlValve::GetPNom()
{
	double dPNom = -1.0;

	CDB_SmartValveCharacteristic *pclSmartControlValveCharacteristic = GetSmartValveCharacteristic();

	if( NULL != pclSmartControlValveCharacteristic )
	{
		dPNom = pclSmartControlValveCharacteristic->GetPowerNom();
	}

	return dPNom;
}

double CDB_SmartControlValve::GetKvs()
{
	double dKvs = -1.0;

	CDB_SmartValveCharacteristic *pclSmartControlValveCharacteristic = GetSmartValveCharacteristic();

	if( NULL != pclSmartControlValveCharacteristic )
	{
		dKvs = pclSmartControlValveCharacteristic->GetKvs();
	}

	return dKvs;
}

double CDB_SmartControlValve::GetDpMin( double dFlow, double dRho )
{
	double dKvs = GetKvs();
	double dDpMin = -1.0;

	if( dKvs != -1.0 && dFlow > 0.0 && dRho > 0.0 )
	{
		dDpMin = CalcDp( dFlow, dKvs, dRho );
	}

	return dDpMin;
}

void CDB_SmartControlValve::SetSmartValveCharacteristicID( _string ID )
{
	ASSERT( ID.length() <= _ID_LENGTH );
	_tcsncpy_s( m_SmartValveCharacteristicID, SIZEOFINTCHAR( m_SmartValveCharacteristicID ), ID.c_str(), _ID_LENGTH );

	// Unlock if previous one exist.
	if( NULL != m_pSmartValveCharacteristic )
	{
		m_pSmartValveCharacteristic->Unlock( GetIDPtr() );
	}

	// Force a call to 'GetSmartValveCharacteristic' to update 'm_pSmartValveCharacteristic'.
	m_pSmartValveCharacteristic = NULL;
	GetSmartValveCharacteristic();
}

#ifndef TACBX
CString CDB_SmartControlValve::GetStrokeString()
{
	CString strStroke = WriteDouble( GetStroke(), 0, 0);
	return strStroke;
}

// HYS-1660
IDPTR CDB_SmartControlValve::GetPowerSupplyIDPtr( unsigned int index )
{
	if( index >= (unsigned int)m_arPowerSupplies.GetCount() )
	{
		ASSERTA_RETURN( _NULL_IDPTR );
	}

	IDPTR idptr = m_arPowerSupplies.GetAt( index );
	idptr.DB = GetDB();
	Extend( &idptr );
	m_arPowerSupplies.SetAt( index, idptr );
	return idptr;
}

CString CDB_SmartControlValve::GetPowerSupplyStr( CString strSeparator )
{
	CString str, strOut;
	unsigned int iCount = (int)m_arPowerSupplies.GetCount();

	for( unsigned int i = 0; i < iCount; i++ )
	{
		IDPTR idptr = GetPowerSupplyIDPtr( i );
		str = ( (CDB_StringID*)idptr.MP )->GetString();

		if( false == strOut.IsEmpty() )
		{
			strOut += strSeparator;
		}

		strOut += str;
	}

	return strOut;
}

IDPTR CDB_SmartControlValve::GetInputSignalIDPtr( unsigned int index )
{
	if( index >= (unsigned int)m_arInputSignals.GetCount() )
	{
		ASSERTA_RETURN( _NULL_IDPTR );
	}

	IDPTR idptr = m_arInputSignals.GetAt( index );
	idptr.DB = GetDB();
	Extend( &idptr );
	m_arInputSignals.SetAt( index, idptr );
	return idptr;
}

IDPTR CDB_SmartControlValve::GetOutputSignalIDPtr( unsigned int index )
{
	if( index >= (unsigned int)m_arOutputSignals.GetCount() )
	{
		ASSERTA_RETURN( _NULL_IDPTR );
	}

	IDPTR idptr = m_arOutputSignals.GetAt( index );
	idptr.DB = GetDB();
	Extend( &idptr );
	m_arOutputSignals.SetAt( index, idptr );
	return idptr;
}

CString CDB_SmartControlValve::GetInOutSignalsStr( bool bInput, CString strSeparator )
{
	CArray<IDPTR>* pArray;
	int iCount;

	if( true == bInput )
	{
		pArray = &m_arInputSignals;
		iCount = (int)m_arInputSignals.GetCount();
	}
	else
	{
		pArray = &m_arOutputSignals;
		iCount = (int)m_arOutputSignals.GetCount();
	}

	// SIG_ON-OFF \ SIG_3POINT \ SIG_0-10V \ SIG_2-10V \ SIG_0-20mA \ SIG_4-20mA \ SIG_KNX \ SIG_MODBUS_RTU \ SIG_BACNET_MSTP
	// SIG_MODBUS_TCP \ SIG_BACNET_IP
	CString str, str1, str2, strOut;
	std::map< CString, short > mapSignalTypeCount;

	for( int i = 0; i < iCount; i++ )
	{
		CString IDstr;

		if( true == bInput )
		{
			IDstr = GetInputSignalIDPtr( i ).ID;
		}
		else
		{
			IDstr = GetOutputSignalIDPtr( i ).ID;
		}

		if( IDstr != _T("NO_ID") )
		{
			mapSignalTypeCount[IDstr] = i;
		}
	}

	// If the signal is not define, return "-".
	if( 0 == (int)mapSignalTypeCount.size() )
	{
		return _T("-");
	}

	strOut.Empty();

	// SIG_ON-OFF.
	if( mapSignalTypeCount.count( CString( _T("SIG_ON-OFF") ) ) > 0 )
	{
		strOut = ( (CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_ON-OFF") )] ).MP )->GetString();
	}

	// SIG_3POINT.
	str.Empty();

	if( mapSignalTypeCount.count( CString( _T("SIG_3POINT") ) ) > 0 )
	{
		str = ( (CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_3POINT") )] ).MP )->GetString();
	}

	if( false == strOut.IsEmpty() && false == str.IsEmpty() )
	{
		strOut += strSeparator;
	}

	strOut += str;

	// SIG_0-10V and SIG_2-10V.
	// HYS-905: Add 0-5V 10-2V 5-0V 10-2V 10-0V 10-5V and 5-10V signals
	str.Empty();

	if( mapSignalTypeCount.count( CString( _T("SIG_0-10V") ) ) > 0 )
	{
		str = ( (CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_0-10V") )] ).MP )->GetString();

		if( mapSignalTypeCount.count( CString( _T("SIG_2-10V") ) ) > 0 )
		{
			str1 = ( (CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_2-10V") )] ).MP )->GetString();
			str2.Format( _T("(%C)"), str1.GetAt( 0 ) );
			str.Replace( _T("%1"), str2 );
		}
		else
		{
			str.Replace( _T("%1" ), _T( "") );
		}
	}
	else
	{
		if( mapSignalTypeCount.count( CString( _T("SIG_2-10V") ) ) > 0 )
		{
			str = ( (CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_2-10V") )] ).MP )->GetString();
		}
		if( mapSignalTypeCount.count( CString( _T("SIG_10-2V") ) ) > 0 )
		{
			str = ( (CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_10-2V") )] ).MP )->GetString();
		}
		if( mapSignalTypeCount.count( CString( _T("SIG_10-0V") ) ) > 0 )
		{
			str = ( (CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_10-0V") )] ).MP )->GetString();
		}
		if( mapSignalTypeCount.count( CString( _T("SIG_5-10V") ) ) > 0 )
		{
			str = ( (CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_5-10V") )] ).MP )->GetString();
		}
		if( mapSignalTypeCount.count( CString( _T("SIG_10-5V") ) ) > 0 )
		{
			str = ( (CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_10-5V") )] ).MP )->GetString();
		}
		if( mapSignalTypeCount.count( CString( _T("SIG_5-0V") ) ) > 0 )
		{
			str = ( (CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_5-0V") )] ).MP )->GetString();
		}
		if( mapSignalTypeCount.count( CString( _T("SIG_0-5V") ) ) > 0 )
		{
			str = ( (CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_0-5V") )] ).MP )->GetString();
		}
	}

	if( false == strOut.IsEmpty() && false == str.IsEmpty() )
	{
		strOut += strSeparator;
	}

	strOut += str;

	// SIG_0-20mA and SIG_4-20mA.
	// HYS-905: Add  20-4mA 
	str.Empty();

	if( mapSignalTypeCount.count( CString( _T("SIG_0-20mA") ) ) > 0 )
	{
		str = ( (CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_0-20mA") )] ).MP )->GetString();

		if( mapSignalTypeCount.count( CString( _T("SIG_4-20mA") ) ) > 0 )
		{
			str1 = ( (CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_4-20mA") )] ).MP )->GetString();
			str2.Format( _T("(%C)"), str1.GetAt( 0 ) );
			str.Replace( _T("%1"), str2 );
		}
		else
		{
			str.Replace( _T("%1" ), _T( "") );
		}
	}
	else
	{
		if( mapSignalTypeCount.count( CString( _T("SIG_4-20mA") ) ) > 0 )
		{
			str = ( (CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_4-20mA") )] ).MP )->GetString();
		}
		if( mapSignalTypeCount.count( CString( _T("SIG_20-4mA") ) ) > 0 )
		{
			str = ( (CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_20-4mA") )] ).MP )->GetString();
		}
	}

	if( false == strOut.IsEmpty() && false == str.IsEmpty() )
	{
		strOut += strSeparator;
	}

	strOut += str;

	// SIG_KNX
	str.Empty();

	if( mapSignalTypeCount.count( CString( _T("SIG_KNX") ) ) > 0 )
	{
		str = ( (CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_KNX") )] ).MP )->GetString();
	}

	if( false == strOut.IsEmpty() && false == str.IsEmpty() )
	{
		strOut += strSeparator;
	}

	strOut += str;

	// SIG_MODBUS_RTU
	str.Empty();

	if( mapSignalTypeCount.count( CString( _T("SIG_MODBUS_RTU") ) ) > 0 )
	{
		str = ( (CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_MODBUS_RTU") )] ).MP )->GetString();
	}

	if( false == strOut.IsEmpty() && false == str.IsEmpty() )
	{
		strOut += strSeparator;
	}

	strOut += str;

	// SIG_BACNET_MSTP
	str.Empty();

	if( mapSignalTypeCount.count( CString( _T("SIG_BACNET_MSTP") ) ) > 0 )
	{
		str = ( (CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_BACNET_MSTP") )] ).MP )->GetString();
	}

	if( false == strOut.IsEmpty() && false == str.IsEmpty() )
	{
		strOut += strSeparator;
	}

	strOut += str;

	// SIG_MODBUS_TCP
	str.Empty();

	if( mapSignalTypeCount.count( CString( _T("SIG_MODBUS_TCP") ) ) > 0 )
	{
		str = ( (CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_MODBUS_TCP") )] ).MP )->GetString();
	}

	if( false == strOut.IsEmpty() && false == str.IsEmpty() )
	{
		strOut += strSeparator;
	}

	strOut += str;

	// SIG_BACNET_IP
	str.Empty();

	if( mapSignalTypeCount.count( CString( _T("SIG_BACNET_IP") ) ) > 0 )
	{
		str = ( (CDB_StringID*)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_BACNET_IP") )] ).MP )->GetString();
	}

	if( false == strOut.IsEmpty() && false == str.IsEmpty() )
	{
		strOut += strSeparator;
	}

	strOut += str;

	return strOut;
}

void CDB_SmartControlValve::SetPowerSupplyIDPtr( CDB_SmartControlValve* pclCopySrc )
{
	m_arPowerSupplies.RemoveAll();

	for( UINT i = 0; i < pclCopySrc->GetNumberOfPowerSupplyIDPtr(); i++ )
	{
		m_arPowerSupplies.Add( pclCopySrc->GetPowerSupplyIDPtr( i ) );
	}
}

void CDB_SmartControlValve::SetInputSignalIDPtr( CDB_SmartControlValve* pclCopySrc )
{
	m_arInputSignals.RemoveAll();

	for( UINT i = 0; i < pclCopySrc->GetNumberOfInputSignalIDPtr(); i++ )
	{
		m_arInputSignals.Add( pclCopySrc->GetInputSignalIDPtr( i ) );
	}
}

void CDB_SmartControlValve::SetOutputSignalIDPtr( CDB_SmartControlValve* pclCopySrc )
{
	m_arOutputSignals.RemoveAll();

	for( UINT i = 0; i < pclCopySrc->GetNumberOfOutputSignalIDPtr(); i++ )
	{
		m_arOutputSignals.Add( pclCopySrc->GetOutputSignalIDPtr( i ) );
	}
}

CString CDB_SmartControlValve::GetControlModeString( SmartValveControlMode eControlMode )
{
	CString strControlMode = _T("");

	if( SmartValveControlMode::SCVCM_Flow == eControlMode )
	{
		strControlMode = TASApp.LoadLocalizedString( IDS_SMARTCONTROLVALVE_CONTROLMODE_FLOW );
	}
	else if( SmartValveControlMode::SCVCM_Power == eControlMode )
	{
		strControlMode = TASApp.LoadLocalizedString( IDS_SMARTCONTROLVALVE_CONTROLMODE_POWER );
	}
	else if( SmartValveControlMode::SCVCM_Position == eControlMode )
	{
		strControlMode = TASApp.LoadLocalizedString( IDS_SMARTCONTROLVALVE_CONTROLMODE_POSITION );
	}
	else
	{
		strControlMode = TASApp.LoadLocalizedString( IDS_SMARTCONTROLVALVE_CONTROLMODE_UNDEFINED );
	}

	return strControlMode;
}

CString CDB_SmartControlValve::GetLocalizationString( SmartValveLocalization eLocalization )
{
	CString strLocalization = _T("");

	if( SmartValveLocalization::SmartValveLocSupply == eLocalization )
	{
		strLocalization = TASApp.LoadLocalizedString( IDS_SMARTVALVE_LOCATION_SUPPLY );
	}
	else if( SmartValveLocalization::SmartValveLocReturn == eLocalization )
	{
		strLocalization = TASApp.LoadLocalizedString( IDS_SMARTVALVE_LOCATION_RETURN );
	}
	else
	{
		strLocalization = TASApp.LoadLocalizedString( IDS_SMARTVALVE_LOCATION_UNDEFINED );
	}

	return strLocalization;
}

#endif

void CDB_SmartControlValve::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_RegulatingValve::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( _T('\0') !=  *m_CtrlPropIDPtr.ID && 0 != _tcscmp( _NO_ID, m_CtrlPropIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_CtrlPropIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Control properties ID (%s) is defined but not found in the database."), m_CtrlPropIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_ControlProperties ) ) )
			{
				HYSELECT_THROW( _T("Control properties ID (%s) is found in the database but it's not a 'CDB_ControlProperties' object."), m_CtrlPropIDPtr.ID );
			}
		}

		if( _T('\0') !=  *m_SmartValveCharacteristicID && 0 != _tcscmp( _NO_ID, m_SmartValveCharacteristicID ) )
		{
			IDPtr = GetDB()->Get( m_SmartValveCharacteristicID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Smart valve characteristic ID (%s) is defined but not found in the database."), m_SmartValveCharacteristicID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_SmartValveCharacteristic ) ) )
			{
				HYSELECT_THROW( _T("Smart valve characteristic ID (%s) is found in the database but it's not a 'CDB_SmartValveCharacteristic' object."), m_SmartValveCharacteristicID );
			}
		}

		if( _T('\0') !=  *m_DpSensorGroupIDPtr.ID && 0 != _tcscmp( _NO_ID, m_DpSensorGroupIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_DpSensorGroupIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Dp sensor group ID (%s) is defined but not found in the database."), m_DpSensorGroupIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_RuledTable ) ) )
			{
				HYSELECT_THROW( _T("Dp sensor group ID (%s) is found in the database but it's not a 'CDB_RuledTable' object."), m_DpSensorGroupIDPtr.ID );
			}
		}

// HYS-1660
#ifndef TACBX

		if( m_arPowerSupplies.GetCount() > 0 )
		{
			for( int i = 0; i < m_arPowerSupplies.GetCount(); i++ )
			{
				if( _T( '\0' ) != *m_arPowerSupplies[i].ID && 0 != _tcscmp( _NO_ID, m_arPowerSupplies[i].ID ) )
				{
					IDPtr = GetDB()->Get( m_arPowerSupplies[i].ID );

					if( NULL == IDPtr.MP )
					{
						HYSELECT_THROW( _T("Power supply ID (%s) is defined but not found in the database."), m_arPowerSupplies[i].ID );
					}

					if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
					{
						HYSELECT_THROW( _T("Power supply ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_arPowerSupplies[i].ID );
					}
				}
			}
		}

		if( m_arInputSignals.GetCount() > 0 )
		{
			for( int i = 0; i < m_arInputSignals.GetCount(); i++ )
			{
				if( _T( '\0' ) != *m_arInputSignals[i].ID && 0 != _tcscmp( _NO_ID, m_arInputSignals[i].ID ) )
				{
					IDPtr = GetDB()->Get( m_arInputSignals[i].ID );

					if( NULL == IDPtr.MP )
					{
						HYSELECT_THROW( _T("Input signal ID (%s) is defined but not found in the database."), m_arInputSignals[i].ID );
					}

					if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
					{
						HYSELECT_THROW( _T("Input signal ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_arInputSignals[i].ID );
					}
				}
			}
		}

		if( m_arOutputSignals.GetCount() > 0 )
		{
			for( int i = 0; i < m_arOutputSignals.GetCount(); i++ )
			{
				if( _T( '\0' ) != *m_arOutputSignals[i].ID && 0 != _tcscmp( _NO_ID, m_arOutputSignals[i].ID ) )
				{
					IDPtr = GetDB()->Get( m_arOutputSignals[i].ID );

					if( NULL == IDPtr.MP )
					{
						HYSELECT_THROW( _T("Output signal ID (%s) is defined but not found in the database."), m_arOutputSignals[i].ID );
					}

					if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
					{
						HYSELECT_THROW( _T("Output signal ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_arOutputSignals[i].ID );
					}
				}
			}
		}
#endif // TACBX
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_SmartControlValve::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

void CDB_SmartControlValve::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_SmartControlValve *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_SmartControlValve' object!") );
		}

		CDB_RegulatingValve::Copy( pclDestination );

		// Copy now what it is common to the "CDB_SmartControlValve" class.
		CDB_SmartControlValve *pclDestinationSmartControlValve = (CDB_SmartControlValve *)pclDestination;
		
		pclDestinationSmartControlValve->SetSmartValveType( m_eSmartValveType );
		pclDestinationSmartControlValve->SetStroke( m_dStroke );
		pclDestinationSmartControlValve->SetRangeability( m_dRangeability );
		pclDestinationSmartControlValve->SetstrRangeability( m_strRangeability );
		pclDestinationSmartControlValve->SetLeakageRate( m_dLeakageRate );
		pclDestinationSmartControlValve->SetCtrlPropID( m_CtrlPropIDPtr.ID );
		pclDestinationSmartControlValve->SetInternalActuatorName( m_strInternalActuatorName );
		pclDestinationSmartControlValve->SetSmartValveCharacteristicID( m_SmartValveCharacteristicID );
		pclDestinationSmartControlValve->SetRemoteTempSensorCableLength( m_dRemoteTempSensorCableLength );
		pclDestinationSmartControlValve->SetDpSensorGroupID( m_DpSensorGroupIDPtr.ID );

// HYS-1660.
#ifndef TACBX
		pclDestinationSmartControlValve->SetPowerSupplyIDPtr( this );
		pclDestinationSmartControlValve->SetInputSignalIDPtr( this );
		pclDestinationSmartControlValve->SetOutputSignalIDPtr( this );
#endif
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_SmartControlValve::Copy' method with the object '%s'."), GetIDPtr().ID )
}

void CDB_SmartControlValve::OnDatabaseDestroy()
{
	CDB_RegulatingValve::OnDatabaseDestroy();

	// Unlock control properties.
	CDB_SmartControlValve::GetCtrlProp()->Unlock( GetIDPtr() );

	if( NULL != GetSmartValveCharacteristic() )
	{
		GetSmartValveCharacteristic()->Unlock( GetIDPtr() );
	}
}

// Version 2: 2021-04-20 - Add new information for TA-Smart. Input signal, output signal and power supply
// Version 3: 2022-07-04 - Add 'm_eSmartValveType' and 'm_DpSensorGroupIDPtr' variables.
#define CDB_SMARTCONTROLVALVE_VERSION	3
void CDB_SmartControlValve::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_SMARTCONTROLVALVE_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CDB_RegulatingValve::Write( outf );

	// Info.
	outf.write( (char *)&m_dStroke, sizeof( m_dStroke ) );
	WriteString( outf, m_strRangeability.c_str() );
	outf.write( (char *)&m_dLeakageRate, sizeof( m_dLeakageRate ) );
	WriteString( outf, m_CtrlPropIDPtr.ID );
	WriteString( outf, m_strInternalActuatorName.c_str() );
	WriteString( outf, m_SmartValveCharacteristicID );
	outf.write( (char *)&m_dRemoteTempSensorCableLength, sizeof( m_dRemoteTempSensorCableLength ) );

	// HYS-1660
	// Version 2
#ifndef TACBX
	int iCount = 0;
	// Power Supply.
	iCount = m_arPowerSupplies.GetCount();
	outf.write( (char*)&iCount, sizeof( iCount ) );

	for( int i = 0; i < iCount; i++ )
	{
		IDPTR idptr = m_arPowerSupplies.GetAt( i );
		WriteString( outf, idptr.ID );
	}

	// Input signals.
	iCount = m_arInputSignals.GetCount();
	outf.write( (char*)&iCount, sizeof( iCount ) );

	for( int i = 0; i < iCount; i++ )
	{
		IDPTR idptr = m_arInputSignals.GetAt( i );
		WriteString( outf, idptr.ID );
	}

	// Output signals.
	iCount = m_arOutputSignals.GetCount();
	outf.write( (char*)&iCount, sizeof( iCount ) );
	for( int i = 0; i < iCount; i++ )
	{
		IDPTR idptr = m_arOutputSignals.GetAt( i );
		WriteString( outf, idptr.ID );
	}
#endif // TACBX

	// Version 3.
	outf.write( (char*)&m_eSmartValveType, sizeof( m_eSmartValveType ) );
	WriteString( outf, m_DpSensorGroupIDPtr.ID );
}

bool CDB_SmartControlValve::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_SMARTCONTROLVALVE_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDB_RegulatingValve::Read( inpf ) )
	{
		return false;
	}

	// Infos.
	m_dStroke = ReadDouble( inpf );

	if( false == ReadString( inpf, m_strRangeability ) )
	{
		return false;
	}

	TCHAR *ptcEndPtr;
	_string str = m_strRangeability;
	size_t pos = str.find( _T('>') );

	if( string::npos != pos )
	{
		str.erase( pos, 1 );
	}

	m_dRangeability = _tcstod( str.c_str(), &ptcEndPtr );
	ASSERT( _T('\0') == *ptcEndPtr ); 

	m_dLeakageRate = ReadDouble( inpf );

	m_CtrlPropIDPtr = _NULL_IDPTR;     

	if( false == ReadString( inpf, m_CtrlPropIDPtr.ID, sizeof( m_CtrlPropIDPtr.ID ) ) )
	{
		return false;
	}

	m_CtrlPropIDPtr.DB = GetDB();

	if( false == ReadString( inpf, m_strInternalActuatorName ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_SmartValveCharacteristicID, sizeof( m_SmartValveCharacteristicID ) ) )
	{
		return false;
	}

	m_dRemoteTempSensorCableLength = ReadDouble( inpf );

	// HYS-1660
	if( Version < 2 )
	{
		return true;
	}

	// Version 2
#ifndef TACBX
	// Power Supply.
	int count = 0;
	inpf.read( (char*)&count, sizeof( count ) );
	m_arPowerSupplies.SetSize( count );

	for( int i = 0; i < count; i++ )
	{
		IDPTR idptr = _NULL_IDPTR;

		if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
		{
			return false;
		}

		idptr.DB = GetDB();
		m_arPowerSupplies.SetAt( i, idptr );
	}

	// Input signals.
	inpf.read( (char*)&count, sizeof( count ) );
	m_arInputSignals.SetSize( count );

	for( int i = 0; i < count; i++ )
	{
		IDPTR idptr = _NULL_IDPTR;

		if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
		{
			return false;
		}

		idptr.DB = GetDB();
		m_arInputSignals.SetAt( i, idptr );
	}

	// Output signals.
	inpf.read( (char*)&count, sizeof( count ) );
	m_arOutputSignals.SetSize( count );

	for( int i = 0; i < count; i++ )
	{
		IDPTR idptr = _NULL_IDPTR;

		if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
		{
			return false;
		}

		idptr.DB = GetDB();
		m_arOutputSignals.SetAt( i, idptr );
	}
#endif // TACBX

	if( Version < 3 )
	{
		return true;
	}

	inpf.read( (char *)&m_eSmartValveType, sizeof( m_eSmartValveType ) );

	m_DpSensorGroupIDPtr = _NULL_IDPTR;     

	if( false == ReadString( inpf, m_DpSensorGroupIDPtr.ID, sizeof( m_DpSensorGroupIDPtr.ID ) ) )
	{
		return false;
	}

	m_DpSensorGroupIDPtr.DB = GetDB();

	return true;
}

#ifndef TACBX 
void CDB_SmartControlValve::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( _T("CDB_SmartControlValve") );

		if( iPos < 0 )
		{
			CDB_RegulatingValve::InterpretInheritedData( pStr );
		}
		else
		{
			pStr->Delete( iPos, _tcsclen( _T("CDB_SmartControlValve") ) );
			int iEq = pStr->Find( _T("=") );

			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( _T("::SmartValveType=") ) > -1 )
			{
				m_eSmartValveType = (SmartValveType)ReadEnum( strField );

				if( m_eSmartValveType != SmartValveTypeControl && m_eSmartValveType != SmartValveTypeDpC )
				{
					HYSELECT_THROW( _T("'CDB_SmartControlValve::SmartValveType' value must be one of these values: '#SmartValveTypeControl' or '#SmartValveTypeDpC'.") );
				}
			}
			else if( pStr->Find( _T("::Stroke=") ) > -1 )
			{
				if( RD_OK != ReadDouble( strField, &m_dStroke ) )
				{
					HYSELECT_THROW( _T("Can't convert 'CDB_SmartControlValve::Stroke' (%s) in double."), strField );
				}
			}
			else if( pStr->Find( _T("::Rangeability=") ) > -1 )
			{
				TCHAR *ptcEndPtr;
				CString str = strField;
				str.Remove('\"');
				m_strRangeability = str;
				str.Remove('>');
				m_dRangeability = _tcstod( (LPCTSTR)str, &ptcEndPtr );

				if( _T('\0') != *ptcEndPtr )
				{
					HYSELECT_THROW( _T("Can't convert 'CDB_SmartControlValve::Rangeability' (%s) in double."), str );
				}
			}
			else if( pStr->Find( _T("::LeakageRate=") ) > -1 )
			{
				if( RD_OK != ReadDouble( strField, &m_dLeakageRate ) )
				{
					HYSELECT_THROW( _T("Can't convert 'CDB_SmartControlValve::LeakageRate' (%s) in double."), strField );
				}
			}
			else if( pStr->Find( _T("::CtrlPropID=") ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_SmartControlValve::CtrlPropID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetCtrlPropID( (LPCTSTR)strField );
			}
			else if( pStr->Find( _T("::InternalActuatorName=") ) > -1 )
			{
				strField.Remove('\"');
				SetInternalActuatorName( (LPCTSTR)strField );
			}
			else if( pStr->Find( _T("::CharactID=") ) > -1 )
			{
				SetSmartValveCharacteristicID( (LPCTSTR)strField );
			}
			else if( pStr->Find( _T("::RemoteTempSensorCableLength=") ) > -1 )
			{
				if( RD_OK != ReadDouble( strField, &m_dRemoteTempSensorCableLength ) )
				{
					HYSELECT_THROW( _T("Can't convert 'CDB_SmartControlValve::RemoteTempSensorCableLength' (%s) in double."), strField );
				}
			}
			// HYS-1660
			else if( pStr->Find( _T("::PowerSupplyIDs=") ) > -1 )
			{
				ParseIDList( &m_arPowerSupplies, strField );
			}
			else if( pStr->Find( _T("::InputSignalIDs=") ) > -1 )
			{
				ParseIDList( &m_arInputSignals, strField );
			}
			else if( pStr->Find( _T("::OutputSignalIDs=") ) > -1 )
			{
				ParseIDList( &m_arOutputSignals, strField );
			}
			else if( pStr->Find( _T("::DpSensorGroupID=") ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_SmartControlValve::DpSensorGroupID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetDpSensorGroupID( (LPCTSTR)strField );
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_SmartControlValve::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_SmartControlValve::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str, str1;

	// Write object header.
	if( true == IsClass(CLASS( CDB_SmartControlValve ) ) )
	{
		CData::WriteText( outf, strTab );
	}

	// Opening bracket.
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");
	CDB_RegulatingValve::WriteText( outf, strTab );

	// Data.
	// Smart valve type.
	if( SmartValveTypeControl == m_eSmartValveType )
	{
		str1 = _T("SmartValveTypeControl");
	}
	else if( SmartValveTypeDpC == m_eSmartValveType )
	{
		str1 = _T("SmartValveTypeDpC");
	}
	else
	{
		str1 = _T("SmartValveTypeUndefined");
	}

	WriteFormatedStringW( outf, m_strRangeability.c_str(), strTab );

	WriteFormatedStringW( outf, WriteDouble( m_dStroke, 2, 1 ),strTab );
	WriteFormatedStringW( outf, m_strRangeability.c_str(), strTab );
	WriteFormatedStringW( outf, WriteDouble( m_dLeakageRate, 2, 1 ), strTab );
	WriteFormatedStringW( outf, m_CtrlPropIDPtr.ID, strTab );
	WriteFormatedStringW( outf, m_strInternalActuatorName.c_str(), strTab );
	WriteFormatedStringW( outf, m_SmartValveCharacteristicID, strTab );
	WriteFormatedStringW( outf, WriteDouble( m_dRemoteTempSensorCableLength, 2, 1 ), strTab );

	// HYS-1660
	// version 2
	str1 = _T("");
	INT_PTR Number = m_arPowerSupplies.GetCount();

	for( int i = 0; i < Number; i++ )
	{
		if( i != 0 )
		{
			str1 += _T(" \\ ");
		}

		str1 += m_arPowerSupplies.GetAt( i ).ID;
	}

	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char*)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	str1 = _T("");
	Number = m_arInputSignals.GetCount();

	for( int i = 0; i < Number; i++ )
	{
		if( i != 0 )
		{
			str1 += _T(" \\ ");
		}

		str1 += m_arInputSignals.GetAt( i ).ID;
	}

	if( (INT_PTR)0 == Number )
	{
		str1 = _T("NO_ID");
	}

	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char*)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	str1 = _T("");
	Number = m_arOutputSignals.GetCount();

	for( int i = 0; i < Number; i++ )
	{
		if( i != 0 )
		{
			str1 += _T(" \\ ");
		}

		str1 += m_arOutputSignals.GetAt( i ).ID;
	}

	if( (INT_PTR)0 == Number )
	{
		str1 = _T("NO_ID");
	}

	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char*)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	// Version 3.
	WriteFormatedStringW( outf, m_DpSensorGroupIDPtr.ID, strTab );

	// Closing bracket.
	strTab.Delete( 0 );
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}

void CDB_SmartControlValve::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		//
		//	new:CDB_SmartControlValve(ID)->CTRLVALV_TAB
		//	{
		//		--> RegulatingValve	
		//		Stroke							Stroke of the CV
		//		Rangeability					Rangeability of the CV
		//		LeakageRate						Leakage rate of the CV as a fraction of Kvs
		//		CtrlPropID						Identifier of the control properties
		//		InternalActuatorName			Internal actuator name.
		//		CharactID						Identifier of the smart control valve characteristic.
		//		RemoteTempSensorCableLength		Define the remote temperature sensor cable length.
		//		Power supply			        List of accepted Power supplies separated by "\"
		//		Input signals			        List of accepted input control signals separated by "\"
		//		Output signals			        List of accepted output control signals separated by "\"
		//		DpSensorGroupID					Identifier of the Dp sensor group.
		//	}
		//
		////////////////////////////////////////////////////////////////

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_SmartControlValve *)idptr.MP )->Copy( this );

			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );

			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_RegulatingValve::ReadText( inpf, pusLineCount );

			TCHAR *ptcEndPtr;

			// Stroke.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_dStroke = _tcstod( ptcLine, &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't convert stroke value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
			}

			// Rangeability.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			CString str = ptcLine;
			str.Remove('\"');
			m_strRangeability = str;

			str.Remove('>');
			m_dRangeability = _tcstod( (LPCTSTR)str, &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't convert rangeability value (%s) in double (pos: %i)."), str, *pusLineCount );
			}

			// Leakage Rate.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_dLeakageRate = _tcstod( ptcLine, &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't convert leakage rate value (%s) in double (pos: %i)."), str, *pusLineCount );
			}

			// CtrlProp ID.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Control property ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			_tcsncpy_s( m_CtrlPropIDPtr.ID, SIZEOFINTCHAR( m_CtrlPropIDPtr.ID ), ptcLine, SIZEOFINTCHAR( m_CtrlPropIDPtr.ID ) - 1 );

			// Internal actuator name.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			str = ptcLine;
			str.Remove('\"');
			m_strInternalActuatorName = str;

			// The smart control valve characteristic ID.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Smart control valve characteristic ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			_tcsncpy_s( m_SmartValveCharacteristicID, SIZEOFINTCHAR( m_SmartValveCharacteristicID ), ptcLine, SIZEOFINTCHAR( m_SmartValveCharacteristicID ) - 1 );

			// Remote temperature sensor cable length.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_dRemoteTempSensorCableLength = _tcstod( ptcLine, &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't convert the remote temperature sensor cable length value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
			}

			// HYS-1660
			// Version 2
			// Power supply.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			ParseIDList( &m_arPowerSupplies, ptcLine );


			// Input signals.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			ParseIDList( &m_arInputSignals, ptcLine );

			// Output signals.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			ParseIDList( &m_arOutputSignals, ptcLine );

			// TA_Link group ID.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Dp sensor group ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			_tcsncpy_s( m_DpSensorGroupIDPtr.ID, SIZEOFINTCHAR( m_DpSensorGroupIDPtr.ID ), ptcLine, SIZEOFINTCHAR( m_DpSensorGroupIDPtr.ID ) - 1 );
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}

		if( 0 == _tcscmp( GetTypeID(), _T("SMARTCTRLVALVETYPE") ) )
		{
			m_eSmartValveType = SmartValveType::SmartValveTypeControl;
		}
		else if( 0 == _tcscmp( GetTypeID(), _T("SMARTDPCTYPE") ) )
		{
			m_eSmartValveType = SmartValveType::SmartValveTypeDpC;
		}
		else
		{
			HYSELECT_THROW( _T("For the moment there is only 'SMARTCTRLVALVETYPE' and 'SMARTDPCTYPE' for smart valve types!") );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_SmartControlValve::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif 


////////////////////////////////////////////////////////////////
//
//		CDB_RuledTableBase : 
//	Inherit from CTable
//	Each ID can 'Implic' or 'Exclude'
////////////////////////////////////////////////////////////////
IMPLEMENT_DATA( CDB_RuledTableBase )

CDB_RuledTableBase::CDB_RuledTableBase( CDataBase *pDataBase, LPCTSTR ID )
	: CTable( pDataBase, ID )
{
	SetTACBXVer( 0 );				// Skipped by default
	_Clear();
}

bool CDB_RuledTableBase::AddItem( _string strKeyID, IDPTR ObjectIDPtr, MMapName eMapName )
{
	HYSELECT_TRY
	{
		IDPTR IDPtr = _NULL_IDPTR;
		_tcsncpy_s( IDPtr.ID, _ID_LENGTH + 1, (LPCTSTR)( strKeyID.c_str() ), _ID_LENGTH );
		IDPtr.DB = GetDB();
		
		// Assert is done in Extend function if ID doesn't exist.
		Extend( &IDPtr );

		// Check first if ID exist in the CTable.
		if( _NULL_IDPTR == Get( strKeyID.c_str() ) )
		{
			Insert( IDPtr, false );
		}

		RuledTableItem rRuledTableItem;
		rRuledTableItem.IDPtr = ObjectIDPtr;
		rRuledTableItem.fByPair = false;
		rRuledTableItem.fDistributed = false;

		// Check if the rule is not already exist in other table (To avoid contradictory rules)
		if( Excluded == eMapName )
		{
			if( true == IsRuleExist( MapPair( strKeyID, rRuledTableItem ), Implicated, true ) )
			{
				return false;
			}

			if( true == IsRuleExist( MapPair( strKeyID, rRuledTableItem ), BuiltIn, true ) )
			{
				return false;
			}
		}
		else if( Implicated == eMapName || BuiltIn == eMapName )
		{
			if( true == IsRuleExist( MapPair( strKeyID, rRuledTableItem ), Excluded, true ) )
			{
				return false;
			}
		}

		// Check if rule is not already exist in the same table.
		if( false == IsRuleExist( MapPair( strKeyID, rRuledTableItem ), eMapName, true ) )
		{
			m_armapList[eMapName].insert( MapPair( strKeyID, rRuledTableItem ) );
		}

		return true;
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CDB_RuledTableBase::AddItem'.") )
}

bool CDB_RuledTableBase::AddItem( _string strKeyID, RuledTableItem rRuledTableItem, MMapName eMapName )
{
	HYSELECT_TRY
	{
		IDPTR IDPtr = _NULL_IDPTR;
		_tcsncpy_s( IDPtr.ID, _ID_LENGTH + 1, (LPCTSTR)( strKeyID.c_str() ), _ID_LENGTH );
		IDPtr.DB = GetDB();
		
		// Assert is done in Extend function if ID doesn't exist.
		Extend( &IDPtr );

		// Check first if ID exist in the CTable.
		if( _NULL_IDPTR == Get( strKeyID.c_str() ) )
		{
			Insert( IDPtr, false );
		}

		// Check if the rule is not already exist in other table (To avoid contradictory rules)
		if( Excluded == eMapName )
		{
			if( true == IsRuleExist( MapPair( strKeyID, rRuledTableItem ), Implicated ) )
			{
				return false;
			}

			if( true == IsRuleExist( MapPair( strKeyID, rRuledTableItem ), BuiltIn ) )
			{
				return false;
			}
		}
		else if( Implicated == eMapName || BuiltIn == eMapName )
		{
			if( true == IsRuleExist( MapPair( strKeyID, rRuledTableItem ), Excluded ) )
			{
				return false;
			}
		}

		// Check if rule is not already exist in the same table.
		if( false == IsRuleExist( MapPair( strKeyID, rRuledTableItem ), eMapName ) )
		{
			m_armapList[eMapName].insert( MapPair( strKeyID, rRuledTableItem ) );
		}

		return true;
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CDB_RuledTableBase::AddItem'.") )
}

int CDB_RuledTableBase::GetExcluded( CData *pKey, std::vector<CData *> *pSet )
{
	return _GetMMap( &m_armapList[Excluded], pKey, pSet );
}

int CDB_RuledTableBase::GetImplicate( CData *pKey, std::vector<CData *> *pSet )
{
	return _GetMMap( &m_armapList[Implicated], pKey, pSet );
}

int CDB_RuledTableBase::GetBuiltIn( std::vector<CData *> *pSet )
{
	return _GetMMap( &m_armapList[BuiltIn], NULL, pSet );
}

bool CDB_RuledTableBase::IsExcluded( CData *pKey )
{
	bool bExcluded = false;

	if( NULL != pKey )
	{
		for( MMIter iter = m_armapList[Excluded].begin(); iter != m_armapList[Excluded].end() && false == bExcluded; iter++ )
		{
			if( iter->second.IDPtr == pKey->GetIDPtr() )
			{
				bExcluded = true;
			}
		}
	}
	
	return bExcluded;
}

bool CDB_RuledTableBase::IsImplicate( CData *pKey )
{
	bool bImplicate = false;

	if( NULL != pKey )
	{
		for( MMIter iter = m_armapList[Implicated].begin(); iter != m_armapList[Implicated].end() && false == bImplicate; iter++ )
		{
			if( iter->second.IDPtr == pKey->GetIDPtr() )
			{
				bImplicate = true;
			}
		}
	}
	
	return bImplicate;
}

bool CDB_RuledTableBase::IsBuiltIn( CData *pKey )
{
	bool bBuiltIn = false;

	if( NULL != pKey )
	{
		for( MMIter iter = m_armapList[BuiltIn].begin(); iter != m_armapList[BuiltIn].end() && false == bBuiltIn; iter++ )
		{
			if( iter->second.IDPtr == pKey->GetIDPtr() )
			{
				bBuiltIn = true;
			}
		}
	}
	
	return bBuiltIn;
}

bool CDB_RuledTableBase::IsACrossingAcc( CData *pKey )
{
	bool bCrossing = false;

	if( NULL != pKey )
	{
		for( MMIter iter = m_armapList[Crossing].begin(); iter != m_armapList[Crossing].end() && false == bCrossing; iter++ )
		{
			// HYS-1244: verify crossing accessory data
			Extend( &(iter->second.IDPtr) );

			if( iter->second.IDPtr == pKey->GetIDPtr() )
			{
				bCrossing = true;
			}
		}
	}
	
	return bCrossing;
}

bool CDB_RuledTableBase::IsACrossingAccDisplayed( CData *pKey )
{
	bool bCrossing = false;

	if( NULL != pKey )
	{
		for( MMIter iter = m_armapList[CrossingDisp].begin(); iter != m_armapList[CrossingDisp].end() && false == bCrossing; iter++ )
		{
			// HYS-1244: verify crossing accessory data
			Extend( &( iter->second.IDPtr ) );

			if( iter->second.IDPtr == pKey->GetIDPtr() )
			{
				bCrossing = true;
			}
		}
	}
	
	return bCrossing;
}

bool CDB_RuledTableBase::IsRuleExist( MapPair rule, MMapName eMapName, bool fCompareOnlyIDPtr )
{
	MMap *pMap = &m_armapList[eMapName];

	if( pMap->end() != pMap->find( rule.first ) )
	{
		std::pair<MMIter, MMIter> rangeIter;
		rangeIter = pMap->equal_range( rule.first );

		for( MMIter iter = rangeIter.first; iter != rangeIter.second; ++iter )
		{
			if( 0 == _tcscmp( iter->second.IDPtr.ID, rule.second.IDPtr.ID ) )
			{
				if( true == fCompareOnlyIDPtr )
				{
					return true;
				}
				else if( iter->second.fByPair == rule.second.fByPair &&	iter->second.fDistributed == rule.second.fDistributed )
				{
					return true;
				}
			}
		}
	}

	return false;
}

int CDB_RuledTableBase::GetVector( MMapName eMapName, CData *pKey, std::vector<CData *> *pSet )
{
	return _GetMMap( &m_armapList[eMapName], pKey, pSet );
}

bool CDB_RuledTableBase::IsByPair( _string ID )
{
	bool bByPair = false;

	if( m_mapAccessoryByPairFlag.count( ID ) > 0 )
	{
		bByPair = m_mapAccessoryByPairFlag[ID];
	}

	return bByPair;
}

bool CDB_RuledTableBase::IsDistributed( _string ID )
{
	bool bDistributed = false;

	if( m_mapAccessoryByDistributedFlag.count( ID ) > 0 )
	{
		bDistributed = m_mapAccessoryByDistributedFlag[ID];
	}

	return bDistributed;
}

bool CDB_RuledTableBase::MergeWith( CDB_RuledTableBase *pclRuledTableSrc )
{
	HYSELECT_TRY
	{
		if( NULL == pclRuledTableSrc )
		{
			return false;
		}

		if( m_eTableType != pclRuledTableSrc->GetTableType() )
		{
			return false;
		}

		if( 0 == GetItemCount() )
		{
			// If there is no item in the current ruled table, we can directly copy 'pclRuledTable'.
			CopyFrom( pclRuledTableSrc );
		}
		else
		{
			IDPTR RuledTableTempIDPtr;
			GetpTADB()->CreateObject( RuledTableTempIDPtr, CLASS( CDB_RuledTableBase ), _T("RULEDTABLETEMP") );
			GetpTADB()->Access().Insert( RuledTableTempIDPtr );

			CDB_RuledTableBase *pclRuledTableTempDst = (CDB_RuledTableBase *)( RuledTableTempIDPtr.MP );
			pclRuledTableTempDst->CopyFrom( this );

			for( IDPTR IDPtr = pclRuledTableSrc->GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = pclRuledTableSrc->GetNext( IDPtr.MP ) )
			{
				if( _NULL_IDPTR == pclRuledTableTempDst->Get( IDPtr.ID ) )
				{
					// If object is not yet in the destination ruled table, we can copy it.
					pclRuledTableTempDst->Insert( IDPtr );

					for( int iLoop = Excluded; iLoop < Last; iLoop++ )
					{
						MMap *pMapDst = pclRuledTableTempDst->GetMap( (MMapName)iLoop );

						if( NULL == pMapDst )
						{
							GetpTADB()->DeleteObject( RuledTableTempIDPtr );
							return false;
						}

						MMap *pMapSrc = pclRuledTableSrc->GetMap( (MMapName)iLoop );
						
						if( NULL == pMapSrc )
						{
							GetpTADB()->DeleteObject( RuledTableTempIDPtr );
							return false;
						}
						
						MMIter SrcIter = pMapSrc->find( IDPtr.ID );

						if( SrcIter == pMapSrc->end() )
						{
							continue;
						}

						std::pair<MMIter, MMIter> rangeIterSrc;
						rangeIterSrc = pMapSrc->equal_range( IDPtr.ID );

						for( SrcIter = rangeIterSrc.first; SrcIter != rangeIterSrc.second; ++SrcIter )
						{
							pMapDst->insert( MapPair( SrcIter->first, SrcIter->second ) );
						}
					}
				}
				else
				{
					// If object is already exist, we don't insert it.

					// First we check if there is no mismatch between 'ByPair' and 'Distributed' flags.
					if( ( IsByPair( IDPtr.ID ) != pclRuledTableSrc->IsByPair( IDPtr.ID ) )
							|| ( IsDistributed( IDPtr.ID ) != pclRuledTableSrc->IsDistributed( IDPtr.ID ) ) )
					{
						GetpTADB()->DeleteObject( RuledTableTempIDPtr );
						return false;
					}

					// We need also to verify if there are no new rules from 'pclRuledTable'.
					for( int iLoopSrc = Excluded; iLoopSrc < Last; iLoopSrc++ )
					{
						MMap *pMapSrc = pclRuledTableSrc->GetMap( (MMapName)iLoopSrc );

						if( NULL == pMapSrc )
						{
							GetpTADB()->DeleteObject( RuledTableTempIDPtr );
							return false;
						}

						MMIter SrcIter = pMapSrc->find( IDPtr.ID );

						if( SrcIter == pMapSrc->end() )
						{
							continue;
						}

						std::pair<MMIter, MMIter> rangeSrcIter;
						rangeSrcIter = pMapSrc->equal_range( IDPtr.ID );

						// Run all keys with the same ID.
						for( SrcIter = rangeSrcIter.first; SrcIter != rangeSrcIter.second; ++SrcIter )
						{
							if( false == pclRuledTableTempDst->AddItem( SrcIter->first, SrcIter->second, (MMapName)iLoopSrc ) )
							{
								GetpTADB()->DeleteObject( RuledTableTempIDPtr );
								return false;
							}
						}
					}
				}
			}

			// All is done, we can now copy the temporary table in this one.
			_Clear();
			this->CopyFrom( pclRuledTableTempDst );
			
			// Delete the temporary table.
			GetpTADB()->Access().Remove( RuledTableTempIDPtr );
			GetpTADB()->DeleteObject( RuledTableTempIDPtr );
		}

		return true;
	}
	HYSELECT_CATCH( clHySelectException, _T("Error in 'CDB_RuledTableBase::MergeWith'.") )
}

#ifndef TACBX
void CDB_RuledTableBase::Export( CString strFileName )
{
	FILE *pFile = NULL;
	_wfopen_s( &pFile, (LPCTSTR)strFileName, _T("w") );

	if( NULL == pFile )
	{
		ASSERT_RETURN( 0 );
	}

	for( IDPTR IDPtr = GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = GetNext( IDPtr.MP ) )
	{
		fwprintf( pFile, _T("%s\n"), IDPtr.ID );
	}

	fwprintf( pFile, _T("\n") );
	
	for( int iLoop = MMapName::Excluded; iLoop < Last; iLoop++ )
	{
		if( MMapName::Excluded == iLoop )
		{
			fwprintf( pFile, _T("Exluded map\n") );
		}
		else if( MMapName::Implicated == iLoop )
		{
			fwprintf( pFile, _T("Implicated map\n") );
		}
		else
		{
			fwprintf( pFile, _T("BuiltIn map\n") );
		}

		for( MMIter iter = m_armapList[(MMapName)iLoop].begin(); iter != m_armapList[(MMapName)iLoop].end(); iter++ )
		{
			fwprintf( pFile, _T("\tKey: %s - ID: %s - ByPair: %u - Distributed: %u\n"), iter->first.c_str(), iter->second.IDPtr.ID, iter->second.fByPair, iter->second.fDistributed );
		}
	}
	
	fclose( pFile );
}
#endif

void CDB_RuledTableBase::OnDatabaseDestroy()
{
	m_armapList[Excluded].clear();
	m_armapList[Implicated].clear();
	m_armapList[BuiltIn].clear();
	CTable::OnDatabaseDestroy();
}

int CDB_RuledTableBase::CopyMMap( MMapName eMapName, MMap *pDestinationMap )
{
	MMap::const_iterator cIt;

	for( cIt = m_armapList[eMapName].begin(); cIt != m_armapList[eMapName].end(); ++cIt )
	{
		pDestinationMap->insert( MapPair( cIt->first, cIt->second ) );
	}

	return (int)pDestinationMap->size();
}

void CDB_RuledTableBase::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_RuledTableBase *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_RuledTableBase' object!") );
		}

		// Base class.
		CTable::Copy( pclDestination );

		// Copy now what it is common to the "CDB_RuledTableBase".
		CDB_RuledTableBase *pclDestinationRuledTableBase = (CDB_RuledTableBase *)pclDestination;

		// Insert objects.
		for( IDPTR IDPtr = GetFirst(); _T('\0') != *IDPtr.ID; IDPtr = GetNext( IDPtr.MP ) )
		{
			pclDestinationRuledTableBase->Insert( IDPtr );
		}

		pclDestinationRuledTableBase->SetTableType( m_eTableType );

		// Insert Included, Excluded and Implicated objects.
		for( int iLoopMap = Excluded; iLoopMap < Last; iLoopMap++ )
		{
			CopyMMap( (MMapName)iLoopMap, pclDestinationRuledTableBase->GetMap( (MMapName)iLoopMap ) );
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_RuledTableBase::Copy' method with the object '%s'."), GetIDPtr().ID )
}

int CDB_RuledTableBase::_GetMMap( MMap *pMap, CData *pKey, std::vector<CData *> *pSet )
{
	MMIter cIter;
	pSet->clear();
	_string strID;

	if( NULL != pKey )
	{
		strID = pKey->GetIDPtr().ID;		
		cIter = pMap->find( strID );
	}
	else
	{
		cIter = pMap->begin();
	}

	// Specific treatment for excluding table.
	if( pMap == &m_armapList[Excluded] && erttExcluding == GetTableType() )
	{
		for( IDPTR idptr = GetFirst(); _T('\0') != *idptr.ID; idptr = GetNext() )
		{
			if( NULL != pKey && idptr.MP == pKey )
			{
				continue;
			}

			pSet->push_back( idptr.MP );
		}
	}	
	else
	{
		while( cIter != pMap->end() )
		{
			if( false == strID.empty() && cIter->first != strID )
			{
				break;
			}

			Extend( &(cIter->second.IDPtr) );
			pSet->push_back( (CData *)cIter->second.IDPtr.MP );
			cIter++;
		}
	}
	
	return (int)pSet->size();
}

void CDB_RuledTableBase::_Clear( void )
{
	MakeEmpty();

	m_eTableType = erttDefault;

	for( int iLoop = Excluded; iLoop < Last; iLoop++ )
	{
		m_armapList[(MMapName)iLoop].clear();
	}

	m_mapAccessoryByPairFlag.clear();
	m_mapAccessoryByDistributedFlag.clear();
}

////////////////////////////////////////////////////////////////
//
//		CDB_RuledTable : 
//	Inherit from CDB_RuledTableBase
//	Each ID can 'Implic' or 'Exclude'
////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_RuledTable )

CDB_RuledTable::CDB_RuledTable( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_RuledTableBase( pDataBase, ID )
{
}

#define CDB_RULEDTABLE_VERSION 5
// Version 5: "distributed" flag added.
// Version 4: "by pair flag" fix issue not correctly saved in binary DB 
// Version 3: add a new character function '*' to tell that item is sold by pair.
//            This can be wrote: *^ITEM1 \ !ITEM2 or ^*ITEM1 \ !ITEM2
void CDB_RuledTable::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_RULEDTABLE_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CTable::Write( outf );
	
	// Infos.
	outf.write( (char *)&m_eTableType, sizeof( m_eTableType ) );
	MMap *pMap;

	for( int iLoopMap = Excluded; iLoopMap < Last; iLoopMap++ )
	{
		pMap = &m_armapList[iLoopMap];
		int iSize = (int)pMap->size();
		outf.write( (char *)&iSize, sizeof( iSize ) );
		
		if( iSize > 0 )
		{
			MMIter Iter;
			
			// For each key.
			for( Iter = pMap->begin(); Iter != pMap->end(); Iter++ )
			{
				// Write Key ID.
				WriteString( outf, Iter->first.c_str() );
				
				// Write associated ID.
				WriteString( outf, Iter->second.IDPtr.ID );
				
				// Write flag 'fByPair'.
				outf.write( (char *)&Iter->second.fByPair, sizeof( Iter->second.fByPair ) );
			}
		}
	}
	
	// Write map size.
	int iSize = m_mapAccessoryByPairFlag.size();
	outf.write( (char *)&iSize, sizeof( iSize ) );
	
	for( std::map<_string, bool>::iterator It = m_mapAccessoryByPairFlag.begin(); It != m_mapAccessoryByPairFlag.end(); ++It )
	{
		// Write Key ID.
		WriteString( outf, It->first.c_str() );
		
		// Write flag 'fByPair'.
		outf.write( (char *)&It->second, sizeof( It->second ) );
	}

	// Write distributed map.
	iSize = m_mapAccessoryByDistributedFlag.size();
	outf.write( (char *)&iSize, sizeof( iSize ) );
	
	for( std::map<_string, bool>::iterator It = m_mapAccessoryByDistributedFlag.begin(); It != m_mapAccessoryByDistributedFlag.end(); ++It )
	{
		// Write Key ID.
		WriteString( outf, It->first.c_str() );
		
		// Write flag 'fDistributed'.
		outf.write( (char *)&It->second, sizeof( It->second ) );
	}
}

bool CDB_RuledTable::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version = CDB_RULEDTABLE_VERSION;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_RULEDTABLE_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CTable::Read( inpf ) )
	{
		return false;
	}
	
	// Info.
	if( Version >= 1 )
	{
		inpf.read( (char *)&m_eTableType, sizeof( m_eTableType ) );
	}
	
	MMap *pMap;
	m_armapList[Excluded].clear();
	m_armapList[Implicated].clear();

	for( int iLoopMap = Excluded; iLoopMap < Last; iLoopMap++ )
	{
		pMap = &m_armapList[iLoopMap];
		
		// Read full map size.
		int iSize = 0;
		inpf.read( (char *)&iSize, sizeof( iSize ) );
		
		for( int i = 0; i < iSize; i++ )
		{
			RuledTableItem rRuledTableItem;

			// Read key.
			IDPTR KeyIDPtr = _NULL_IDPTR;			

			if( false == ReadString( inpf, KeyIDPtr.ID, sizeof( KeyIDPtr.ID ) ) )
			{
				return false;
			}

			KeyIDPtr.DB = GetDB();

			IDPTR idptr = _NULL_IDPTR;

			if( false == ReadString( inpf, rRuledTableItem.IDPtr.ID, sizeof( rRuledTableItem.IDPtr.ID ) ) )
			{
				return false;
			}

			rRuledTableItem.IDPtr.DB = GetDB();

			rRuledTableItem.fByPair = false;
			
			if( Version >= 3 )
			{
				// Read the 'fByPair' flag.
				inpf.read( (char *)&rRuledTableItem.fByPair, sizeof( rRuledTableItem.fByPair ) );
			}
			
			// Save entry.
			pMap->insert( MapPair( KeyIDPtr.ID, rRuledTableItem ) );
		}
	}
	
	if( Version < 4 )
	{
		return true;
	}

	int iSize = 0;
	m_mapAccessoryByPairFlag.clear();

	// Read by pair map.
	inpf.read( (char *)&iSize, sizeof( iSize ) );
	
	for ( ; iSize > 0; --iSize)
	{
		// Write Key ID.
		IDPTR idptr;
		idptr.Read( inpf, (CTADatabase *)this->GetIDPtr().DB );
	
		// Read flag 'fByPair'.
		bool bByPair = false;
		inpf.read( (char *)&bByPair, sizeof( bByPair ) );
		m_mapAccessoryByPairFlag[idptr.ID] = bByPair;
	}
	
	if( Version < 5 )
	{
		return true;
	}

	// Read distributed map.
	inpf.read( (char *)&iSize, sizeof( iSize ) );

	for ( ; iSize > 0; --iSize)
	{
		// Write Key ID.
		IDPTR idptr;
		idptr.Read( inpf, (CTADatabase *)this->GetIDPtr().DB );
		
		// Read flag 'fDistributed'.
		bool bDistributed = true;
		inpf.read( (char *)&bDistributed, sizeof( bDistributed ) );
		m_mapAccessoryByDistributedFlag[idptr.ID] = bDistributed;
	}

	return true;
}

#ifndef TACBX 

#define RULEDTABLE		_T("::Rule=")

void CDB_RuledTable::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( CLASS( CDB_RuledTable ) );

		if( pStr->Left( 2 ) != _T("::") && iPos < 0 )
		{
			CTable::InterpretInheritedData( pStr );
		}
		else
		{
			if( iPos >= 0 ) 
			{
				pStr->Delete( iPos, _tcsclen( _T("CDB_RuledTable") ) );
			}

			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );
		
			if( pStr->Find( _T("::Rule=") ) > -1 )
			{
				_ReadIDText( strField );
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_RuledTable::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_RuledTable::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID);

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_RuledTable *)idptr.MP )->Copy( this );
		
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );
			
				InterpretInheritedData( &str );
			}
		
			// Read the close curve bracket.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _T('}') != *ptcLine )
			{
				HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
			}
		}
		else
		{
			// Read base.
			// HYS-1301: We change to have a true inheritance!
			CTable::ReadText( inpf, pusLineCount );

			// Read the ID which are members of the table.
			m_eTableType = erttDefault;
		
			do 
			{
				ptcLine = ReadTextLine( inpf, pusLineCount );

				if( _T('}') == *ptcLine )
				{
					break;
				}

				CString str = RULEDTABLE + CString( ptcLine );
			
				CDB_RuledTable::InterpretInheritedData( &str );

			}while( 1 );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_RuledTable::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_RuledTable::_ReadIDText( CString strID )
{
	try
	{
		int iField = 0;
		TCHAR **pptcField;
		_string IDstr;
		pptcField = ParseTextLine( (LPTSTR)(LPCTSTR)strID, &iField );
	
		if( erttExcluding == m_eTableType && iField > 1 )
		{
			HYSELECT_THROW( _T("When a field exclude all others, we must have only this field on the line (%s)."), strID );
		}
	
		// Loop all fields on the line.
		for( int i = 0; i < iField; i++ )
		{
			RuledTableItem rRuledTableItem;
			rRuledTableItem.IDPtr = _NULL_IDPTR;
			rRuledTableItem.fByPair = false;
			rRuledTableItem.fDistributed = false;
			CString str = pptcField[i];
			MMap *pMMap = NULL;
		
			// HYS-1108: Manage stem heater with cross tables
			MMap *pMMapCrossing = NULL;
			MMap *pMMapCrossingDisp = NULL;
		
			bool bReadPrefix = true;
			bool bAtLeastOnePrefix = false;

			while( true == bReadPrefix )
			{
				switch( str.GetAt( 0 ) )
				{
					case CDB_RTCHAR_IMPLICATED:
						pMMap = &m_armapList[Implicated];
						bAtLeastOnePrefix = true;
						break;

					case CDB_RTCHAR_EXCLUDED:
						pMMap = &m_armapList[Excluded];
						bAtLeastOnePrefix = true;
						break;

					case CDB_RTCHAR_BUILTIN:

						if( 0 == i )
						{
							pMMap = &m_armapList[BuiltIn];
							bAtLeastOnePrefix = true;
						}

						break;

					case CDB_RTCHAR_EXCLUDEALL:

						// This Item will exclude all other items (other lines)
						if( 0 == i )
						{
							// Exclusive table.
							m_eTableType = erttExcluding;
							bAtLeastOnePrefix = true;
						}

						break;

					case CDB_RTCHAR_BYPAIR:

						if( 0 == i )
						{
							rRuledTableItem.fByPair = true;
						}
						else
						{
							// 'CDB_RTCHAR_BYPAIR' allowed only for the first field!
							HYSELECT_THROW( _T("The operator '*' (By pair) is allowed only for the first field (%s)."), strID );
						}

						break;

					case CDB_RTCHAR_DISTRIBUTED:

						if( 0 == i )
						{
							rRuledTableItem.fDistributed = true;
						}
						else
						{
							// 'CDB_RTCHAR_DISTRIBUTED' allowed only for the first field!
							HYSELECT_THROW( _T("The operator '#' (Distributed) is allowed only for the first field (%s)."), strID );
						}

						break;
				
					// HYS-1108: The shared accessory is displayed once (only the ++ACCXXXID is displayed) except in DirSel
					case CDB_RTCHAR_INTERSECTION:
					
						if( str.GetLength() > 1 && CDB_RTCHAR_INTERSECTION == str.GetAt( 1 ) )
						{
							pMMapCrossingDisp = &m_armapList[CrossingDisp];// only for compare
							str.Delete( 0 );
						}
						else
						{
							pMMapCrossing = &m_armapList[Crossing];
						}
						bAtLeastOnePrefix = true;

						break;

					default:

						if( i > 0 && false == bAtLeastOnePrefix )
						{
							HYSELECT_THROW( _T("At least '!' (Excluded) or '&' (Implicated) must be defined for second and following fields (%s)."), strID );
						}
						else
						{
							bReadPrefix = false;
						}

						break;
				}

				if( true == bReadPrefix )
				{
					str.Delete( 0 );
				}
			}

			if( str.GetLength() > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Field ID (%s) is too long (%i > %i)."), str, str.GetLength(), _ID_LENGTH );
			}
		
			_tcsncpy_s( rRuledTableItem.IDPtr.ID, _ID_LENGTH + 1, (LPCTSTR)str, _ID_LENGTH );
			rRuledTableItem.IDPtr.DB = GetDB();
		
			// Assert is done in Extend function if ID doesn't exist.
			Extend( &rRuledTableItem.IDPtr );

			if( 0 == i )// Table entry
			{
				if( NULL == rRuledTableItem.IDPtr.MP )
				{
					// It can happen if 'CDB_RuledTable' is read before the object pointed by ID.
					HYSELECT_THROW( _T("Field ID (%s) is not found in the database."), rRuledTableItem.IDPtr.ID );
				}
			
				// Initialize Obj PP only when the object itself is read.
				Insert( rRuledTableItem.IDPtr, false );
				IDstr = rRuledTableItem.IDPtr.ID;

				if( pMMap != NULL )	// Builtin exist
				{
					pMMap->insert( MapPair( IDstr, rRuledTableItem ) );
				}
			
				// HYS-1108
				if( pMMapCrossing != NULL )	// Crossing exist
				{
					pMMapCrossing->insert( MapPair( IDstr, rRuledTableItem ) );
				}
				else if( pMMapCrossingDisp != NULL )	// Crossing exist and displayed
				{
					pMMapCrossingDisp->insert( MapPair( IDstr, rRuledTableItem ) );
				}
			}
			else
			{
				pMMap->insert( MapPair( IDstr, rRuledTableItem ) );
			
				// HYS-1108
				if( pMMapCrossing != NULL )	// Crossing exist
				{
					pMMapCrossing->insert( MapPair( IDstr, rRuledTableItem ) );
				}
				else if( pMMapCrossingDisp != NULL )	// Crossing exist and displayed
				{
					pMMapCrossingDisp->insert( MapPair( IDstr, rRuledTableItem ) );
				}
			}

			if( 0 == i )
			{
				// Add now (for optimization) the pair IDPtr of accessory and its 'fByPair' flag.
				m_mapAccessoryByPairFlag[rRuledTableItem.IDPtr.ID] = rRuledTableItem.fByPair;

				// Add now (for optimization) the pair IDPtr of accessory and its 'fDistributed' flag.
				m_mapAccessoryByDistributedFlag[rRuledTableItem.IDPtr.ID] = rRuledTableItem.fDistributed;
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_RuledTable::_ReadIDText'."), __LINE__, __FILE__ );
		throw;
	}
}
#endif

#ifndef TACBX 
////////////////////////////////////////////////////////////////
//
//		CDB_Actuator : 
//
////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_Actuator)

CDB_Actuator::CDB_Actuator( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_Product( pDataBase, ID )
{
	m_eOpeningType = CDB_CloseOffChar::eOpenType::Linear;
	m_ardMaxForceTorque.RemoveAll();
	m_dMinLimitedStroke = 0.0;
	m_eLimitedStrokeMode = LimitedStrokeMode::LSM_No;
	m_dMaxStroke = 0.0;
	m_ActAdapterGroupIDPtr = _NULL_IDPTR;
	m_TmaxAmbiant = 0.0;
	m_TminAmbiant = 0.0;

	SetTACBXVer(0);				// Skipped by default
}

double CDB_Actuator::GetOrderKey( void )
{
	// Sort first by priority level. An actuator with a low level priority has the higher commercial priority.
	double dKey = 1e9 * ( 10 - GetPriorityLevel() );

	// Sort by the lowest max force/torque to the highest. An actuator with a low max force/torque is cheaper than the others with 
	// higher max force/torque
	dKey += ( 1e7 - GetMaxForceTorque() );

	return dKey;
}

double CDB_Actuator::GetMaxForceTorque( int iIndex )
{
	if( iIndex < 0 || iIndex > m_ardMaxForceTorque.GetCount() - 1 )
	{
		return -1.0;
	}

	return m_ardMaxForceTorque.GetAt( iIndex );
}

CString CDB_Actuator::GetMaxForceTorqueStr( bool bWithUnit, int iIndex )
{
	if( iIndex < 0 || iIndex > m_ardMaxForceTorque.GetCount() - 1 )
	{
		return _T("-");
	}

	CUnitDatabase *pUnitDB = CDimValue::AccessUDB();
	ASSERT( NULL != pUnitDB );

	CString outStr = _T("-");
	
	if( m_ardMaxForceTorque.GetAt( iIndex ) > 0.0 )
	{
		if( CDB_CloseOffChar::eOpenType::Linear == m_eOpeningType )
		{
			outStr = WriteCUDouble( _U_FORCE, m_ardMaxForceTorque.GetAt( iIndex ), bWithUnit );
		}
		else
		{
			outStr = WriteCUDouble( _U_TORQUE, m_ardMaxForceTorque.GetAt( iIndex ), bWithUnit );
		}
	}
	
	return outStr;
}

IDPTR CDB_Actuator::GetActAdapterGroupIDPtr()
{
	m_ActAdapterGroupIDPtr.DB = GetDB();
	Extend( &m_ActAdapterGroupIDPtr );
	
	return m_ActAdapterGroupIDPtr;
}	

void CDB_Actuator::OnDatabaseDestroy()
{
	CDB_Product::OnDatabaseDestroy();
}

void CDB_Actuator::SetMaxForceTorque( CArray<double> &ardMaxForceTorque )
{
	m_ardMaxForceTorque.RemoveAll();

	for( int i = 0; i < ardMaxForceTorque.GetCount(); i++ )
	{
		m_ardMaxForceTorque.Add( ardMaxForceTorque.GetAt( i ) );
	}
}

void CDB_Actuator::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_Actuator *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_Actuator' object!") );
		}

		// Base class.
		CDB_Product::Copy( pclDestination );

		// Copy now what it is common to the "CDB_Actuator" class.
		CDB_Actuator *pclDestinationActuator = (CDB_Actuator *)pclDestination;

		pclDestinationActuator->SetOpeningType( m_eOpeningType );
		pclDestinationActuator->SetMaxForceTorque( m_ardMaxForceTorque );
		pclDestinationActuator->SetMinLimitedStroke( m_dMinLimitedStroke );
		pclDestinationActuator->SetLimitedStrokeMode( m_eLimitedStrokeMode );
		pclDestinationActuator->SetMaxStroke( m_dMaxStroke );
		pclDestinationActuator->SetActAdapterGroupID( m_ActAdapterGroupIDPtr.ID );
		pclDestinationActuator->SetTmaxAmbiant( m_TmaxAmbiant );
		pclDestinationActuator->SetTminAmbiant( m_TminAmbiant );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_Actuator::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_ACTUATOR_VERSION		8
// Version 8: 2020-09-28: HYS-1389: Add limited stroke mode to know if we must verify with EMO-TM when linked for example TA-Compact-P.
// Version 7: 2020-03-20: HYS-1355: Add minimum limited stroke to be able to choose TA-Compact-P/TA-Modulator with TA-6-way valves in low flow.
// Version 6: 2019-01-15: HYS-726: CDB_Actuator now inherits from CDB_Product instead of CDB_Thing 
// Version 5: 2018-02-21: 'm_CatFilID' and 'm_QrsFileID' variables removed.
// Version 4: 2017-02-08: Priority level added as it it the case for the 'CDB_Product' object.
// Version 3: 2016-05-25: We can have now more than on max force/torque.
void CDB_Actuator::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_ACTUATOR_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_Product::Write( outf );
	
	// Info.
	outf.write( (char *)&m_eOpeningType, sizeof( m_eOpeningType ) );
	outf.write( (char *)&m_dMaxStroke, sizeof( m_dMaxStroke ) );
	WriteString( outf, m_ActAdapterGroupIDPtr.ID );

	// Version 3.
	int iNumberOfMaxForceTorque = m_ardMaxForceTorque.GetCount();
	outf.write( (char *)&iNumberOfMaxForceTorque, sizeof( iNumberOfMaxForceTorque ) );

	for( int i = 0; i < iNumberOfMaxForceTorque; i++ )
	{
		double dMaxForceTorque = m_ardMaxForceTorque.GetAt( i );
		WriteDouble( outf, dMaxForceTorque );
	}

	// Version 4.

	// Version 6.
	outf.write( (char *)&m_TminAmbiant, sizeof( m_TminAmbiant ) );
	outf.write( (char *)&m_TmaxAmbiant, sizeof( m_TmaxAmbiant ) );

	// Version 7.
	// HYS-1355: Add minimum limited stroke to be able to choose TA-Compact-P/TA-Modulator with TA-6-way valves in low flow.
	outf.write( (char*)&m_dMinLimitedStroke, sizeof( m_dMinLimitedStroke ) );

	// Version8.
	outf.write( (char*)&m_eLimitedStrokeMode, sizeof( m_eLimitedStrokeMode ) );
}

bool CDB_Actuator::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_ACTUATOR_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_Product::Read( inpf ) )
	{
		return false;
	}

	// Info.
	inpf.read( (char *)&m_eOpeningType, sizeof( m_eOpeningType ) );

	if( Version < 3 )
	{
		m_ardMaxForceTorque.Add( ReadDouble( inpf ) );
	}
	
	m_dMaxStroke = ReadDouble( inpf );
	m_ActAdapterGroupIDPtr = _NULL_IDPTR;

	if( Version > 1)
	{
		if( false == ReadString( inpf, m_ActAdapterGroupIDPtr.ID, sizeof( m_ActAdapterGroupIDPtr.ID ) ) )
		{
			return false;
		}
	}

	if( Version < 3 )
	{
		return true;
	}

	m_ardMaxForceTorque.RemoveAll();
	int iNumberOfMaxForceTorque = 0;
	inpf.read( (char *)&iNumberOfMaxForceTorque, sizeof( iNumberOfMaxForceTorque ) );

	for( int i = 0; i < iNumberOfMaxForceTorque; i++ )
	{
		m_ardMaxForceTorque.Add( ReadDouble( inpf ) );
	}

	if( Version < 4 )
	{
		return true;
	}

	if( Version >= 6 )
	{
		
		inpf.read( (char *)&m_TminAmbiant, sizeof( m_TminAmbiant ) );
		inpf.read( (char *)&m_TmaxAmbiant, sizeof( m_TmaxAmbiant ) );
	}

	if( Version < 7 )
	{
		return true;
	}

	// Version 7.
	// HYS-1355: Add minimum limited stroke to be able to choose TA-Compact-P/TA-Modulator with TA-6-way valves in low flow.
	m_dMinLimitedStroke = ReadDouble( inpf );

	if( Version < 8 )
	{
		return true;
	}

	// Version 8.
	inpf.read( (char *)&m_eLimitedStrokeMode, sizeof( m_eLimitedStrokeMode ) );

	return true;
}

void CDB_Actuator::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str, str1, str2;
	
	// Write object header.
	if( true == IsClass( CLASS( CDB_Actuator ) ) )
	{
		CData::WriteText( outf, strTab );
	}
	
	// Opening bracket..
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");
	CDB_Product::WriteText( outf, strTab );
	
	// Data.	
	if( CDB_CloseOffChar::eOpenType::Linear == m_eOpeningType )
	{
		str1 = _T("#eOPENTYPE_Linear");
	}
	else if( CDB_CloseOffChar::eOpenType::Circular == m_eOpeningType )
	{
		str1 = _T("#eOPENTYPE_Circular");
	}
	
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	CString strForceTorque = _T("");
	
	if( m_ardMaxForceTorque.GetCount() > 0 )
	{
		for( int i = 0; i < m_ardMaxForceTorque.GetCount(); i++ )
		{
			if( i > 0 )
			{
				strForceTorque += _T(" \\ ");
			}

			strForceTorque += WriteDouble( m_ardMaxForceTorque.GetAt( i ), 2, 1 );
		}
	}
	
	WriteFormatedStringW( outf, strForceTorque, strTab );
	
	WriteFormatedStringW( outf, WriteDouble( m_dMinLimitedStroke, 2, 1 ), strTab );

	str1 = _T("");

	if( LimitedStrokeMode::LSM_No == m_eLimitedStrokeMode )
	{
		str1 = _T("#eLimitedStrokeMode_No");
	}
	else if( LimitedStrokeMode::LSM_Electronic == m_eLimitedStrokeMode )
	{
		str1 = _T("#eLimitedStrokeMode_Electronic");
	}
	else if( LimitedStrokeMode::LSM_Mechanic == m_eLimitedStrokeMode )
	{
		str1 = _T("#eLimitedStrokeMode_Mechanic");
	}
	
	WriteFormatedStringW( outf, str1, strTab );

	WriteFormatedStringW( outf, WriteDouble( m_dMaxStroke, 2, 1 ), strTab );
	
	WriteFormatedStringW( outf, m_ActAdapterGroupIDPtr.ID, strTab );

	// Water temp.
	WriteFormatedStringW( outf, WriteDouble( m_TminAmbiant, 3, 1 ), strTab );
	WriteFormatedStringW( outf, WriteDouble( m_TmaxAmbiant, 3, 1 ), strTab );
	
	// Closing bracket..
	strTab.Delete( 0 ); // Delete one \t
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}

#define ACTUATOR_OPENINGTYPE		_T("::OpeningType=")
#define ACTUATOR_MAXFORCETORQUE		_T("::MaxForceTorque=")
#define ACTUATOR_MINLIMITEDSTROKE	_T("::MinLimitedStroke=")
#define ACTUATOR_LIMITEDSTROKEMODE	_T("::LimitedStrokeMode=")
#define ACTUATOR_MAXSTROKE			_T("::MaxStroke=")
#define ACTUATOR_ACTADAPTERGROUPID	_T("::ActAdapterGroupID=")
#define ACTUATOR_MINAMBIENTTEMP		_T("::MinEnvTemp=")
#define ACTUATOR_MAXAMBIENTTEMP		_T("::MaxEnvTemp=")

void CDB_Actuator::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( CLASS( CDB_Actuator ) );

		if( pStr->Left( 2 ) != _T("::") && iPos < 0 )
		{
			CDB_Product::InterpretInheritedData( pStr );
		}
		else
		{
			if( iPos >= 0 )
			{
				pStr->Delete( iPos, _tcsclen( CLASS( CDB_Actuator ) ) );
			}

			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( ACTUATOR_OPENINGTYPE ) > -1 )
			{
				int iValue = GetDB()->ReadEnum( strField );

				if( iValue != CDB_CloseOffChar::eOpenType::Linear && iValue != CDB_CloseOffChar::eOpenType::Circular )
				{
					HYSELECT_THROW( _T("'CDB_Actuator::OpeningType' value must be one of these values: '#eOPENTYPE_Linear' or '#eOPENTYPE_Circular'.") );
				}

				m_eOpeningType = (enum CDB_CloseOffChar::eOpenType)iValue;
			}
			else if( pStr->Find( ACTUATOR_MAXFORCETORQUE ) > -1 )
			{
				ParseDoubleList( &m_ardMaxForceTorque, strField );
			}
			else if( pStr->Find( ACTUATOR_MINLIMITEDSTROKE ) > -1 )
			{
				if( RD_OK != ReadDouble( strField, &m_dMinLimitedStroke ) )
				{
					HYSELECT_THROW( _T("Can't convert 'CDB_Actuator::MinLimitedStroke' (%s) in double."), strField );
				}
			}
			else if( pStr->Find( ACTUATOR_LIMITEDSTROKEMODE ) > -1 )
			{
				int iValue = GetDB()->ReadEnum( strField );

				if( iValue != LimitedStrokeMode::LSM_No && iValue != LimitedStrokeMode::LSM_Electronic && iValue != LimitedStrokeMode::LSM_Mechanic )
				{
					HYSELECT_THROW( _T("'CDB_Actuator::LimitedStrokeMode' value must be one of these values: '#eLimitedStrokeMode_No', '#eLimitedStrokeMode_Electronic' or 'eLimitedStrokeMode_Mechanic'.") );
				}

				m_eLimitedStrokeMode = (enum LimitedStrokeMode)iValue;
			}
			else if( pStr->Find( ACTUATOR_MAXSTROKE ) > -1 )
			{
				if( RD_OK != ReadDouble( strField, &m_dMaxStroke ) )
				{
					HYSELECT_THROW( _T("Can't convert 'CDB_Actuator::MaxStroke' (%s) in double."), strField );
				}
			}
			else if( pStr->Find( ACTUATOR_ACTADAPTERGROUPID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_Actuator::ActAdapterGroupID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}
			
				m_ActAdapterGroupIDPtr = _NULL_IDPTR;
				_tcsncpy_s( m_ActAdapterGroupIDPtr.ID, _ID_LENGTH + 1, (LPCTSTR)strField, _ID_LENGTH );
				m_ActAdapterGroupIDPtr.DB = GetDB();
			}
			else if( pStr->Find( ACTUATOR_MINAMBIENTTEMP ) > -1 )
			{
				m_TminAmbiant = _ttoi( (LPCTSTR)strField );
			
				if( m_TminAmbiant < -273.15 )
				{
					HYSELECT_THROW( _T("'CDB_Actuator::MinEnvTemp' can't be lower than -273.15.") );
				}
			}
			else if( pStr->Find( ACTUATOR_MAXAMBIENTTEMP ) > -1 )
			{
				m_TmaxAmbiant = _ttoi( (LPCTSTR)strField );

				if( m_TmaxAmbiant < -273.15 )
				{
					HYSELECT_THROW( _T("'CDB_Actuator::MaxEnvTemp' can't be lower than -273.15.") );
				}
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Actuator::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_Actuator::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		//	new:CDB_Actuator(ID)->ACTUATOR_TAB
		//	{
		//		--> CDB_Thing
		//		--> CDB_HydroThing
		//		--> CDB_Product
		//		OpeningType			Opening type (Linear or Circular)
		//		MaxForceTorque		Max force or torque developed by the actuator
		//		MinLimitedStroke	Min limited stroke of the actuator
		//		LimitedStrokeMode	Limited stroke mode of the actuator
		//		MaxStroke			Max stroke of the actuator (in m for #eOPENTYPE_Linear; in  for #eOPENTYPE_Circ)
		//		ActAdapterGroupID	Identifier of the actuator adapter group
		//		MinEnvTemp			Min temperature for operating environment in C
		//		MaxEnvTemp			Max temperature for operating environment in C	
		//	}
		//
		////////////////////////////////////////////////////////////////

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;
	
		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_Actuator *)idptr.MP )->Copy( this );
		
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );
				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_Product::ReadText( inpf, pusLineCount );
		
			CStringArray TxtHdr;
			TxtHdr.Add( ACTUATOR_OPENINGTYPE );
			TxtHdr.Add( ACTUATOR_MAXFORCETORQUE );
			TxtHdr.Add( ACTUATOR_MINLIMITEDSTROKE );
			TxtHdr.Add( ACTUATOR_LIMITEDSTROKEMODE );
			TxtHdr.Add( ACTUATOR_MAXSTROKE );
			TxtHdr.Add( ACTUATOR_ACTADAPTERGROUPID );
			TxtHdr.Add( ACTUATOR_MINAMBIENTTEMP );
			TxtHdr.Add( ACTUATOR_MAXAMBIENTTEMP );

			for( int i = 0; i < TxtHdr.GetSize(); i++ )
			{
				ptcLine = ReadTextLine( inpf, pusLineCount );

				CString str = TxtHdr[i] + CString( ptcLine );
				CDB_Actuator::InterpretInheritedData( &str );
			}
		}
	
		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Actuator::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif 

#ifndef TACBX 
////////////////////////////////////////////////////////////////
//
//		CDB_ElectroActuator : 
//
////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_ElectroActuator )

CDB_ElectroActuator::CDB_ElectroActuator( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_Actuator( pDataBase, ID )
{
	m_ActTimeDefaultIndex = 0;
	m_ArrayActTimes.RemoveAll();
	m_IPxxAuto[0] = _T('\0');
	m_IPxxManual[0] = _T('\0');
	m_PowerSupplyIDPtr.RemoveAll();
	m_FrequencyIDPtr = _NULL_IDPTR;
	m_InputSignals.RemoveAll();
	m_OutputSignals.RemoveAll();
	m_eFailSafe = FailSafeType::eFSTypeNone;
	m_bOnOffPossible = true;		// By default almost all actuators can work in On/Off mode.
	m_RelayIDPtr = _NULL_IDPTR;
	m_iBinaryInputNumber = 0;
	m_eDefaultReturnPos = DefaultReturnPosition::None;

	SetTACBXVer( 0 );				// Skipped by default
}

bool CDB_ElectroActuator::IsActuatorFit( CString strPowerSupplyID, CString strInputSignalID, int iFailSafeFct, CDB_ControlValve::DRPFunction eDRPFunctionToCheck,
	CDB_ControlValve::DRPFunction eControlValveDRPFct, CDB_ControlProperties::CvCtrlType CvCtrlType, bool bDowngradeActuatorFunctionality,
	CString strRelayID, int iBinaryInputNumber )
{
	if( CDB_ControlValve::DRPFunction::drpfUndefined == eDRPFunctionToCheck || CDB_ControlValve::DRPFunction::drpfLast == eDRPFunctionToCheck
			|| CDB_ControlValve::DRPFunction::drpfUndefined == eControlValveDRPFct || CDB_ControlValve::DRPFunction::drpfLast == eControlValveDRPFct )
	{
		return false;
	}

	// Test power supply ID.
	bool bIsFitPowerSupply = true;
	
	if( 0 != strPowerSupplyID.Compare( _T("\0") ) )
	{
		// Run alls entries for power supply.
		bIsFitPowerSupply = false;
		
		for( int iLoop = 0; iLoop < (int)GetNumOfPowerSupplyIDptr(); iLoop++ )
		{
			IDPTR IDPtr = GetPowerSupplyIDPtr( iLoop );
			
			if( 0 == strPowerSupplyID.Compare( IDPtr.ID ) )
			{
				bIsFitPowerSupply = true;
				break;
			}
		}
	}

	// Test input signal ID.
	bool bIsFitInputSignal = true;

	// If user has chosen an input signal, we must strictly match with his choice.
	if( 0 != strInputSignalID.Compare( _T("\0") ) )
	{
		// Run alls entries for input signal.
		bIsFitInputSignal = false;
		
		for( int iLoop = 0; iLoop < (int)GetNumOfInputSignalsIDptr(); iLoop++ )
		{
			IDPTR IDPtr = GetInputSignalsIDPtr( iLoop );
			
			if( 0 == strInputSignalID.Compare( IDPtr.ID ) )
			{
				bIsFitInputSignal = true;
				break;
			}
		}
	}
	else
	{
		// If user has not specified a specific input signal, we simply verify if current actuator can work in the control type mode specified.
		// At now, we force downgrade functionality to 'false'.
		bIsFitInputSignal = IsActuatorControlFit( CvCtrlType, false );
	}

	// Test fail safe function.
	bool bIsFitFailSafeFct = true;

 	if( BST_CHECKED == iFailSafeFct )
	{
		// HYS-1458 : If fail-safe checkbox is checked we have to get a fail-safe type.
		if( FailSafeType::eFSTypeNone == GetFailSafe() )
		{
			bIsFitFailSafeFct = false;
		}
	}
	else
	{
		// HYS-1458 : If the checkbox is not checked we have to get No fail-safe. 
		if( GetFailSafe() >= FailSafeType::eFSTypeElectronic && GetFailSafe() < FailSafeType::eFSTypeLast )
		{
			bIsFitFailSafeFct = false;
		}
	}

	bool bIsFitDRPFct = false;

	// We accept in these cases:
	//   1 - if user wants all default return positions
	//   2 - if user wants exactly what the control valve is.
	//   3 - if control valve can go to opening or closing for default return position, the user choice must be either 
	//       'Closing' or 'Opening' for the default return position.
	if( CDB_ControlValve::DRPFunction::drpfAll == eDRPFunctionToCheck || eDRPFunctionToCheck == eControlValveDRPFct 
		|| ( eControlValveDRPFct == CDB_ControlValve::DRPFunction::drpfOpeningOrClosing 
		    && ( eDRPFunctionToCheck == CDB_ControlValve::DRPFunction::drpfClosing 
		       || eDRPFunctionToCheck == CDB_ControlValve::DRPFunction::drpfOpening ) ) )
	{
		bIsFitDRPFct = true;
	}

	// Test relay type.
	bool bIsFitRelayType = false;

	if( true == strRelayID.IsEmpty() || strRelayID == GetRelayID() )
	{
		bIsFitRelayType = true;
	}

	// Test binary input number.
	bool bIsFitBinaryInputNumber = false;

	if( -1 == iBinaryInputNumber || iBinaryInputNumber == GetBinaryInputNumber() )
	{
		bIsFitBinaryInputNumber = true;
	}

	bool bIsFit = false;

	// In the function which called this one if no solution found, the variable bDowngradeActuatorFunctionality is false then true then true and fail-safe all
	if( true == bIsFitPowerSupply && true == bIsFitInputSignal && true == bIsFitFailSafeFct && true == bIsFitDRPFct && true == bIsFitRelayType
			&& true == bIsFitBinaryInputNumber )
	{
		// Perfectly match.
		bIsFit = true;
	}
	else if( true == bIsFitPowerSupply && true == bIsFitInputSignal && false == bIsFitFailSafeFct && true == bDowngradeActuatorFunctionality )
	{
		bIsFit = true;
	}
	else if( true == bIsFitPowerSupply && false == bIsFitInputSignal && true == bIsFitDRPFct && true == bIsFitRelayType
			&& true == bIsFitBinaryInputNumber && true == bDowngradeActuatorFunctionality )
	{
		// If no solution and we can downgrade actuator functionality...
		// Remark: we test to 'false' the 'Input Signal' because it's on this criteria that 'IsActuatorControlFit' runs.
		bIsFit = IsActuatorControlFit( CvCtrlType, true );
	}

	return bIsFit;
}

bool CDB_ElectroActuator::IsActuatorControlFit( CDB_ControlProperties::CvCtrlType CvCtrlType, bool bDowngradeActuatorFunctionality )
{
	bool bIsFit = false;

	for( int iLoop = 0; iLoop < (int)GetNumOfInputSignalsIDptr(); iLoop++ )
	{
		IDPTR IDPtr = GetInputSignalsIDPtr( iLoop );
		CDB_StringID *pInputSignal = (CDB_StringID *)IDPtr.MP;
		
		if( NULL == pInputSignal )
		{
			continue;
		}

		// Notes: 'CvCtrlType' is the type of the control that user wants to apply on the control valve.
		//        Typically, it's for example the combo 'Ctrl Type' in 'CDlgIndSelBCV'.
		//        Actuator can work in a 'On/Off', a '3 points' or a 'Proportional' mode.
		//
		// 2017-02-17: Following a skype call with Jean-Christophe, it has been decided that an actuator proportional can't 
		//             work for a 3pts control type.
		//             To summarize: - If user chooses the 'Proportional' control type we must show only proportional actuators.
		//                           - If user chooses the '3 points' control type we must show only 3 points actuators.
		//                           - If user chooses the 'On/Off' control type we display first On/Off actuators. If there is no On/Off
		//                             actuators, we can show '3 points' or 'Proportional' actuators except if these ones have the 'm_bOnOffPossible'
		//                             variable set to 'false'.
		//
		//      Control type: | On/Off | 3 point | Proportional
		// ------------------------------------------------------
		// Actuator:   On/Off | 1      | 0       | 0
		//           3 points | 0/1    | 1       | 0
		//       Proportional | 0/1    | 0       | 1
		//
		// - Actuator with the 'On/Off' input signal type can work only for the 'On/Off' control type.
		// - Actuator with the '3 points' input signal type can work for the '3 points' control type but not for the 
		//   'Proportional' control type. It can also work for the 'On/Off' control type only if user wants it ('fDowngradeActuatorFunctionality'
		//   set to 'true').
		// - Actuator with the 'Proportional' input signal type can work with the 'Proportional' control type. It can also work for the 'On/Off' 
		//   control type only if user wants it ('fDowngradeActuatorFunctionality' set to 'true').
		//   AND it the actuator can work in On/Off ("OnOffPossible" variable set to 1).
		//
		// !!! REMARK: In individual selection, we must show alternative actuators (with downgraded functionality) ONLY if there is no other actuators.
			 
		int iActuatorCtrlType;
		pInputSignal->GetIDstrAs<int>( 0, iActuatorCtrlType );

		switch( (CDB_ControlProperties::CvCtrlType)iActuatorCtrlType )
		{
			case CDB_ControlProperties::CvCtrlType::eCvOnOff:

				if( (CDB_ControlProperties::CvCtrlType)iActuatorCtrlType == CvCtrlType )
				{	
					bIsFit = true;
					break;
				}
				
				break;

			case CDB_ControlProperties::CvCtrlType::eCv3point:
				
				if( CDB_ControlProperties::CvCtrlType::eCv3point == CvCtrlType )
				{
					bIsFit = true;
				}
				else if( CDB_ControlProperties::CvCtrlType::eCvOnOff == CvCtrlType && true == bDowngradeActuatorFunctionality && 
						true == m_bOnOffPossible )
				{
					bIsFit = true;
				}

				break;
				
			case CDB_ControlProperties::CvCtrlType::eCvProportional:

				if( CDB_ControlProperties::CvCtrlType::eCvProportional == CvCtrlType )
				{
					bIsFit = true;
				}
				else if( CDB_ControlProperties::CvCtrlType::eCvOnOff == CvCtrlType && true == bDowngradeActuatorFunctionality &&
					true == m_bOnOffPossible )
				{
					bIsFit = true;
				}

				break;
		}
	}
	
	return bIsFit;
}

double CDB_ElectroActuator::GetOrderKey( void )
{
	// Priory level: 1 digit.
	// Max force/torque: 7 digits.
	// Input signal: 2 digits (1=SIG_ON-OFF; 2=SIG_3POINT; 3=SIG_0-10V; 4=SIG_2-10V; 5=SIG_0-20mA; 6=SIG_4-20mA; 7=SIG_KNX;
	//                         8=SIG_MODBUS_RTU; 9=SIG_BACNET_MSTP; 10=SIG_MODBUS_TCP; 11=SIG_BACNET_IP).
	// Output signal: 2 digits.
	// Relay: 1 digit (1=RELAY_NO; 2=RELAY_CO; 3=RELAY_24V; 4=RELAY_220V).
	// Fail safe: 1 digit (2=No; 1=retracting; 0=extending).
	// Power supply: 1 digit (1=POW24VAC; 2=POW_24VDC; 3=POW_115VAC; 4=POW_230VAC; 5=POW_400VAC).
	// Sort int key: 2 digits.

	// This code is largely inspired by 'CTAPSortKey' class.

	// Double mantises is only 52 bits
	//					values		nbr bits	Mask		  Bit pos in double
	// Priority level   16          4           0x00078000    H 15
	//                              15          0x00007FFF    H 0
	// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	// (9 in L and 15 in H)         9           0xFF800000    L 23
	// Max force/torque 16777216    24          
	// Input signal     16          4           0x00780000    L 19
	// Output signal    16          4           0x00078000    L 15
	// Relay            8           3           0x00007000    L 12
	// Fail safe        4           2           0x00000C00    L 10
	// Power supply     8           3           0x00000380    L 7
	// Sort int key     128         7           0x0000007F    L 0
	//						Total:  51

	const unsigned int uiPLNbrBits = 4;
	const unsigned int uiPLLeftShift = 15;
	const unsigned int uiPLMaxValue = ( 1 << uiPLNbrBits ) - 1;

	const unsigned int uiMaxForceNbrBitsH = 15;
	const unsigned int uiMaxForceLeftShiftH = 0;
	const unsigned int uiMaxForceNbrBitsL = 9;
	const unsigned int uiMaxForceLeftShiftL = 23;
	const unsigned int uiMaxForceMaxValue = ( 1 << 24 ) - 1;

	const unsigned int uiInputSignalNbrBits = 4;
	const unsigned int uiInputSignalLeftShift = 19;
	const unsigned int uiInputSignalMaxValue = ( 1 << uiInputSignalNbrBits ) - 1;

	const unsigned int uiOutputSignalNbrBits = 4;
	const unsigned int uiOutputSignalLeftShift = 15;
	const unsigned int uiOutputSignalMaxValue = ( 1 << uiOutputSignalNbrBits ) - 1;

	const unsigned int uiRelayNbrBits = 3;
	const unsigned int uiRelayLeftShift = 12;
	const unsigned int uiRelayMaxValue = ( 1 << uiRelayNbrBits ) - 1;

	const unsigned int uiFailSafeNbrBits = 2;
	const unsigned int uiFailSafeLeftShift = 10;
	const unsigned int uiFailSafeMaxValue = ( 1 << uiFailSafeNbrBits ) - 1;

	const unsigned int uiPowerSupplyNbrBits = 3;
	const unsigned int uiPowerSupplyLeftShift = 7;
	const unsigned int uiPowerSupplyMaxValue = ( 1 << uiPowerSupplyNbrBits ) - 1;

	const unsigned int uiSortIntNbrBits = 7;
	const unsigned int uiSortIntLeftShift = 0;
	const unsigned int uiSortIntMaxValue = ( 1 << uiSortIntNbrBits ) - 1;

	struct sLL
	{
		unsigned long L;
		unsigned long H;
	};

	union uSortingKey
	{
		sLL LL;
		unsigned char ar[sizeof( sLL )];
	}usKey;

	usKey.LL.L = 0;
	usKey.LL.H = 0;

	// Sort first by priority level. An actuator with a low level priority has the higher commercial priority.
	// Max 4 bits (0 to 15).
	usKey.LL.H += ( uiPLMaxValue - GetPriorityLevel() ) << uiPLLeftShift;
	ASSERT( uiPLMaxValue - GetPriorityLevel() >= 0 );

	// Sort by the lowest max force/torque to the highest. An actuator with a low max force/torque is cheaper than the others with 
	// higher max force/torque.
	// Take first the two highest bits.
	// Max 24 bits (0 to 16777215).
	int iMaxForce =  uiMaxForceMaxValue - (int)GetMaxForceTorque();
	ASSERT( iMaxForce >= 0 );

	// Set 15 bits in H.
	usKey.LL.H += ( ( iMaxForce & 0x00FFFE00 ) >> 9 );

	// Set 9 bits in L.
	usKey.LL.L += ( ( iMaxForce & 0x00007FFF ) << uiMaxForceLeftShiftL );

	// Add now the input signal (Helps to sort TA-Slider).
	// Remark: we will take the highest input signal because this often this one that allows us to discriminate between
	//         TA-Slider.
	int iHigherInputSignal = 0;

	for( unsigned int uiInputsignal = 0; uiInputsignal < GetNumOfInputSignalsIDptr(); uiInputsignal++ )
	{
		CDB_StringID *pStringID = dynamic_cast<CDB_StringID*>( GetInputSignalsIDPtr( uiInputsignal ).MP );

		if( NULL == pStringID )
		{
			continue;
		}

		int iNbr = _ttoi( pStringID->GetIDstr2() );

		if( iHigherInputSignal < iNbr )
		{
			iHigherInputSignal = iNbr;
		}
	}

	// Max 4 bits (0 to 15).
	usKey.LL.L += ( ( uiInputSignalMaxValue - iHigherInputSignal ) << uiInputSignalLeftShift );
	ASSERT( uiInputSignalMaxValue - iHigherInputSignal >= 0 );

	// Add now the output signal (Helps to sort TA-Slider).
	// Remark: we will take the highest input signal because this often this one that allows us to discriminate between
	//         TA-Slider.
	int iHigherOutputSignal = 0;

	for( unsigned int uiOutputsignal = 0; uiOutputsignal < GetNumOfOutputSignalsIDptr(); uiOutputsignal++ )
	{
		CDB_StringID *pStringID = dynamic_cast<CDB_StringID*>( GetOutputSignalsIDPtr( uiOutputsignal ).MP );

		if( NULL == pStringID )
		{
			continue;
		}

		int iNbr = _ttoi( pStringID->GetIDstr2() );

		if( iHigherOutputSignal < iNbr )
		{
			iHigherOutputSignal = iNbr;
		}
	}

	// Max 4 bits (0 to 15).
	usKey.LL.L += ( ( uiOutputSignalMaxValue - iHigherOutputSignal ) << uiOutputSignalLeftShift );
	ASSERT( uiOutputSignalMaxValue - iHigherOutputSignal >= 0 );

	// Add now the relay (Helps to sort TA-Slider).
	int iRelay = 7;
	CDB_StringID *pRelayID = dynamic_cast<CDB_StringID*>( GetRelayIDPtr().MP );

	if( NULL != pRelayID )
	{
		iRelay = _ttoi( pRelayID->GetIDstr() );
	}

	// Max 3 bits (0 to 7).
	usKey.LL.L += ( ( uiRelayMaxValue - iRelay ) << uiRelayLeftShift );
	ASSERT( uiRelayMaxValue - iRelay >= 0 );
	
	// Sort by fail-safe Electronic, Spring return or None
	ASSERT( (int)m_eFailSafe >= 0 );
	usKey.LL.L += ( (int)m_eFailSafe << uiFailSafeLeftShift );

	// Search what is the lower power supply.
	int iLowerPowerSupply = 7;
	
	for( int iLoop = 0; iLoop < (int)GetNumOfPowerSupplyIDptr(); iLoop++ )
	{
		IDPTR PowerSupplyIDPtr = GetPowerSupplyIDPtr( iLoop );
		CDB_StringID *pPowerSupply = (CDB_StringID *)PowerSupplyIDPtr.MP;
		
		if( NULL == pPowerSupply )
		{
			continue;
		}
		
		int iPowerKey;
		pPowerSupply->GetIDstrAsInt( 0, iPowerKey );
		
		if( iPowerKey < iLowerPowerSupply )
		{
			iLowerPowerSupply = iPowerKey;
		}
	}

	// Max 3 bits (0 to 7).
	usKey.LL.L += ( ( uiPowerSupplyMaxValue - iLowerPowerSupply ) << uiPowerSupplyLeftShift );
	ASSERT( uiPowerSupplyMaxValue - iLowerPowerSupply >= 0 );

	// Set the 'CDB_Thing::SortInt' if exist (For the moment limited to 127).
	usKey.LL.L += ( uiSortIntMaxValue - GetSortInt() );
	ASSERT( uiSortIntMaxValue - GetSortInt() >= 0 );

	double dKey = ( (double)usKey.LL.H );
	dKey *= 0x10000;			// Split in two for CBX compatibility
	dKey *= 0x10000;			// Split in two for CBX compatibility
	dKey += usKey.LL.L;

	return dKey;
}

double CDB_ElectroActuator::GetDefaultActuatingTime()
{
	return GetActuatingTime( m_ActTimeDefaultIndex );
}

double CDB_ElectroActuator::GetActuatingTime( int iPos )
{
	double dReturn = -1.0;

	if( iPos < m_ArrayActTimes.GetCount() )
	{
		dReturn = m_ArrayActTimes.GetAt( iPos );
	}

	return dReturn;
}

CString CDB_ElectroActuator::GetActuatingTimesStr( double dStroke, bool bWithUnit, CString strSeparator )
{
	CUnitDatabase *pUnitDB = CDimValue::AccessUDB();
	ASSERT( NULL != pUnitDB );
	
	CString UnitStr = GetNameOf( pUnitDB->GetDefaultUnit( _U_TIME ) ).c_str();
	
	if( dStroke <= 0.0 )
	{
		dStroke = 1.0;
		
		if( CDB_CloseOffChar::eOpenType::Linear == m_eOpeningType )
		{
			// For linear stroke actuating time is given in s/m.
			dStroke = 0.001;
			_string *_str = GetpXmlStrTab()->GetIDSStr( L"IDS_ACTUATING_TIME_SMM" );
			
			if( NULL != _str )
			{
				UnitStr = _str->c_str();
			}
		}
		else
		{
			_string *_str = GetpXmlStrTab()->GetIDSStr( L"IDS_ACTUATING_TIME_SDEG" );

			if( NULL != _str )
			{
				UnitStr = _str->c_str();
			}
		}
	}
	
	CString outStr;

	for( int pos = 0; pos < m_ArrayActTimes.GetCount(); pos++ )
	{
		CString str;

		if( pos > 0 )
		{
			str += strSeparator;
		}
		
		double dVal = m_ArrayActTimes.GetAt( pos ) * dStroke;
		str += WriteCUDouble( _U_TIME, dVal );
		
		if( pos == m_ActTimeDefaultIndex && m_ArrayActTimes.GetCount() > 1 )
		{
			str += _T("*");
		}
		
		outStr += str;
	}

	if( true == bWithUnit )
	{
		outStr += _T(" ") + UnitStr;
	}

	return outStr;
}

CString CDB_ElectroActuator::GetIPxxFull()
{ 
	if( false == GetIPxxManual().IsEmpty() )
	{
		return ( GetIPxxAuto() + _T("(") + GetIPxxManual() + _T(")") );
	}

	return GetIPxxAuto();
}

IDPTR CDB_ElectroActuator::GetPowerSupplyIDPtr( unsigned int index )
{
	if( index >= GetNumOfPowerSupplyIDptr() )
	{
		ASSERTA_RETURN( _NULL_IDPTR );
	}
	
	IDPTR idptr = m_PowerSupplyIDPtr.GetAt( index );
	idptr.DB = GetDB();
	Extend( &idptr );
	m_PowerSupplyIDPtr.SetAt( index, idptr );
	return idptr;
}

CString CDB_ElectroActuator::GetPowerSupplyStr( CString strSeparator )
{
	CString str, strOut;

	for( unsigned int i = 0; i < GetNumOfPowerSupplyIDptr(); i++ )
	{
		str = ( (CDB_StringID *)GetPowerSupplyIDPtr( i ).MP )->GetString();
	
		if( false == strOut.IsEmpty() )
		{
			strOut += strSeparator;
		}
		
		strOut += str;
	}

	return strOut;
}

IDPTR CDB_ElectroActuator::GetFrequencyIDPtr()
{
	m_FrequencyIDPtr.DB = GetDB();
	Extend( &m_FrequencyIDPtr );
	return m_FrequencyIDPtr;
}

IDPTR CDB_ElectroActuator::GetInputSignalsIDPtr( unsigned int index )
{
	if( index >= GetNumOfInputSignalsIDptr() )
	{
		ASSERTA_RETURN( _NULL_IDPTR );
	}
	
	IDPTR idptr = m_InputSignals.GetAt( index );
	idptr.DB = GetDB();
	Extend( &idptr );
	m_InputSignals.SetAt( index, idptr );
	return idptr;
}

CString CDB_ElectroActuator::GetInOutSignalsStr( bool bInput, CString strSeparator )
{
	CArray<IDPTR> *pArray;
	int iCount;

	if( true == bInput )
	{
		pArray = &m_InputSignals;
		iCount = GetNumOfInputSignalsIDptr();
	}
	else
	{
		pArray = &m_OutputSignals;
		iCount = GetNumOfOutputSignalsIDptr();
	}
	
	// SIG_ON-OFF \ SIG_3POINT \ SIG_0-10V \ SIG_2-10V \ SIG_0-20mA \ SIG_4-20mA \ SIG_KNX \ SIG_MODBUS_RTU \ SIG_BACNET_MSTP
	// SIG_MODBUS_TCP \ SIG_BACNET_IP
	CString str, str1, str2, strOut;
	std::map< CString, short > mapSignalTypeCount;
	
	for( int i = 0; i < iCount; i++ )
	{
		CString IDstr;
		
		if( true == bInput )
		{
			IDstr = GetInputSignalsIDPtr( i ).ID;
		}
		else
		{
			IDstr = GetOutputSignalsIDPtr( i ).ID;
		}

		if( IDstr != _T("NO_ID") )
		{
			mapSignalTypeCount[IDstr] = i;
		}
	}
	
	// If the signal is not define, return "-".
	if( 0 == (int)mapSignalTypeCount.size() )
	{
		return _T("-");
	}

	strOut.Empty();
	
	// SIG_ON-OFF.
	if( mapSignalTypeCount.count( CString( _T("SIG_ON-OFF") ) ) > 0 )
	{
		strOut = ( (CDB_StringID *)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_ON-OFF") )] ).MP )->GetString();
	}

	// SIG_3POINT.
	str.Empty();
	
	if( mapSignalTypeCount.count( CString( _T("SIG_3POINT") ) ) > 0 )
	{
		str = ( (CDB_StringID *)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_3POINT") )] ).MP )->GetString();
	}
	
	if( false == strOut.IsEmpty() && false == str.IsEmpty() )
	{
		strOut += strSeparator;
	}

	strOut += str;

	// SIG_0-10V and SIG_2-10V.
	// HYS-905: Add 0-5V 10-2V 5-0V 10-2V 10-0V 10-5V and 5-10V signals
	str.Empty();

	if( mapSignalTypeCount.count( CString( _T("SIG_0-10V") ) ) > 0 )
	{
		str = ( (CDB_StringID *)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_0-10V") )] ).MP )->GetString();
		
		if( mapSignalTypeCount.count( CString( _T("SIG_2-10V") ) ) > 0 )
		{
			str1 = ( (CDB_StringID *)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_2-10V") )] ).MP )->GetString();
			str2.Format( _T("(%C)" ), str1.GetAt( 0 ) );
			str.Replace( _T("%1" ), str2 );
		}
		else
		{
			str.Replace( _T("%1"), _T("") );
		}
	}
	else
	{
		if(  mapSignalTypeCount.count( CString( _T("SIG_2-10V") ) ) > 0 )
		{
			str = ( (CDB_StringID *)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_2-10V") )] ).MP )->GetString();
		}
		if( mapSignalTypeCount.count( CString( _T("SIG_10-2V") ) ) > 0 )
		{
			str = ( (CDB_StringID *)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_10-2V") )] ).MP )->GetString();
		}
		if( mapSignalTypeCount.count( CString( _T("SIG_10-0V") ) ) > 0 )
		{
			str = ( (CDB_StringID *)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_10-0V") )] ).MP )->GetString();
		}
		if( mapSignalTypeCount.count( CString( _T("SIG_5-10V") ) ) > 0 )
		{
			str = ( (CDB_StringID *)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_5-10V") )] ).MP )->GetString();
		}
		if( mapSignalTypeCount.count( CString( _T("SIG_10-5V") ) ) > 0 )
		{
			str = ( (CDB_StringID *)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_10-5V") )] ).MP )->GetString();
		}
		if( mapSignalTypeCount.count( CString( _T("SIG_5-0V") ) ) > 0 )
		{
			str = ( (CDB_StringID *)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_5-0V") )] ).MP )->GetString();
		}
		if( mapSignalTypeCount.count( CString( _T("SIG_0-5V") ) ) > 0 )
		{
			str = ( (CDB_StringID *)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_0-5V") )] ).MP )->GetString();
		}
	}

	if( false == strOut.IsEmpty() && false == str.IsEmpty() )
	{
		strOut += strSeparator;
	}

	strOut += str;
	
	// SIG_0-20mA and SIG_4-20mA.
	// HYS-905: Add  20-4mA 
	str.Empty();

	if( mapSignalTypeCount.count( CString( _T("SIG_0-20mA") ) ) > 0 )
	{
		str = ( (CDB_StringID *)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_0-20mA") )] ).MP )->GetString();
		
		if( mapSignalTypeCount.count( CString( _T("SIG_4-20mA") ) ) > 0 )
		{
			str1 = ( (CDB_StringID *)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_4-20mA") )] ).MP )->GetString();
			str2.Format( _T("(%C)"), str1.GetAt( 0 ) );
			str.Replace( _T("%1"), str2 );
		}
		else
		{
			str.Replace( _T("%1"), _T("") );
		}
	}
	else
	{
		if( mapSignalTypeCount.count( CString( _T("SIG_4-20mA") ) ) > 0 )
		{
			str = ( (CDB_StringID *)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_4-20mA") )] ).MP )->GetString();
		}
		if( mapSignalTypeCount.count( CString( _T("SIG_20-4mA") ) ) > 0 )
		{
			str = ( (CDB_StringID *)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_20-4mA") )] ).MP )->GetString();
		}
	}
	
	if( false == strOut.IsEmpty() && false == str.IsEmpty() )
	{
		strOut += strSeparator;
	}

	strOut += str;

	// SIG_KNX
	str.Empty();

	if( mapSignalTypeCount.count( CString( _T("SIG_KNX") ) ) > 0 )
	{
		str = ( (CDB_StringID *)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_KNX") )] ).MP )->GetString();
	}
	
	if( false == strOut.IsEmpty() && false == str.IsEmpty() )
	{
		strOut += strSeparator;
	}

	strOut += str;

	// SIG_MODBUS_RTU
	str.Empty();

	if( mapSignalTypeCount.count( CString( _T("SIG_MODBUS_RTU") ) ) > 0 )
	{
		str = ( (CDB_StringID *)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_MODBUS_RTU") )] ).MP )->GetString();
	}
	
	if( false == strOut.IsEmpty() && false == str.IsEmpty() )
	{
		strOut += strSeparator;
	}

	strOut += str;

	// SIG_BACNET_MSTP
	str.Empty();

	if( mapSignalTypeCount.count( CString( _T("SIG_BACNET_MSTP") ) ) > 0 )
	{
		str = ( (CDB_StringID *)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_BACNET_MSTP") )] ).MP )->GetString();
	}
	
	if( false == strOut.IsEmpty() && false == str.IsEmpty() )
	{
		strOut += strSeparator;
	}

	strOut += str;

	// SIG_MODBUS_TCP
	str.Empty();

	if( mapSignalTypeCount.count( CString( _T("SIG_MODBUS_TCP") ) ) > 0 )
	{
		str = ( (CDB_StringID *)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_MODBUS_TCP") )] ).MP )->GetString();
	}
	
	if( false == strOut.IsEmpty() && false == str.IsEmpty() )
	{
		strOut += strSeparator;
	}

	strOut += str;

	// SIG_BACNET_IP
	str.Empty();

	if( mapSignalTypeCount.count( CString( _T("SIG_BACNET_IP") ) ) > 0 )
	{
		str = ( (CDB_StringID *)pArray->GetAt( mapSignalTypeCount[CString( _T("SIG_BACNET_IP") )] ).MP )->GetString();
	}
	
	if( false == strOut.IsEmpty() && false == str.IsEmpty() )
	{
		strOut += strSeparator;
	}

	strOut += str;
	
	return strOut;
}

IDPTR CDB_ElectroActuator::GetOutputSignalsIDPtr( unsigned int index )
{
	if( index >= GetNumOfOutputSignalsIDptr() )
	{
		ASSERTA_RETURN( _NULL_IDPTR );
	}
	
	IDPTR idptr = m_OutputSignals.GetAt( index );
	idptr.DB = GetDB();
	Extend( &idptr );
	m_OutputSignals.SetAt( index, idptr );
	return idptr;
}

_string CDB_ElectroActuator::GetDefaultReturnPosStr( DefaultReturnPosition eDefaultReturnPos )
{
	static _string str, *pstr = NULL;

	switch( eDefaultReturnPos )
	{
		case DefaultReturnPosition::None:

			str = _T("IDS_ELECTROACTRDRP_NONE");
			pstr = GetpXmlStrTab()->GetIDSStr( str );			
			break;
		
		case DefaultReturnPosition::Extending:

			str = _T("IDS_ELECTROACTRDRP_EXT");
			pstr = GetpXmlStrTab()->GetIDSStr( str.c_str() );
			break;
		
		case DefaultReturnPosition::Retracting:

			str = _T("IDS_ELECTROACTRDRP_RET");
			pstr = GetpXmlStrTab()->GetIDSStr( str.c_str() );
			break;

		case DefaultReturnPosition::Configurable:

			str = TASApp.LoadLocalizedString(IDS_ELECTROACTRDRP_CONF);
			pstr = NULL;
			break;

		case DefaultReturnPosition::Undefined:
		default:
			str = _T("");
			pstr = NULL;
			break;
	}
	
	if( NULL != pstr )
	{
		str = *pstr;
	}

	return str;
}

IDPTR CDB_ElectroActuator::GetRelayIDPtr()
{
	m_RelayIDPtr.DB = GetDB();
	Extend( &m_RelayIDPtr );
	return m_RelayIDPtr;
}

CString CDB_ElectroActuator::GetRelayID()
{
	return GetRelayIDPtr().ID;
}

CString CDB_ElectroActuator::GetRelayStr()
{
	CDB_StringID *pStringID = dynamic_cast<CDB_StringID*>( GetRelayIDPtr().MP );

	if( NULL == pStringID )
	{
		return _T("");
	}

	return CString( pStringID->GetString() );
}

void CDB_ElectroActuator::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_ElectroActuator *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_ElectroActuator' object!") );
		}

		// Base class.
		CDB_Actuator::Copy( pclDestination );

		// Copy now what it is common to the "CDB_ElectroActuator" class.
		CDB_ElectroActuator *pclDestinationElectroActuator = (CDB_ElectroActuator *)pclDestination;

		pclDestinationElectroActuator->SetActTimeDefaultIndex( m_ActTimeDefaultIndex );
		pclDestinationElectroActuator->SetArrayActTimes( m_ArrayActTimes );
		pclDestinationElectroActuator->SetIPxxAuto( m_IPxxAuto );
		pclDestinationElectroActuator->SetIPxxManual( m_IPxxManual );
		pclDestinationElectroActuator->SetPowerSupplyIDPtr( m_PowerSupplyIDPtr );
		pclDestinationElectroActuator->SetFrequencyID( CString( m_FrequencyIDPtr.ID ) );
		pclDestinationElectroActuator->SetInputSignals( m_InputSignals );
		pclDestinationElectroActuator->SetOutputSignals( m_OutputSignals );
		pclDestinationElectroActuator->SetFailSafeType( m_eFailSafe );
		pclDestinationElectroActuator->SetOnOffPossible( m_bOnOffPossible );
		pclDestinationElectroActuator->SetRelayID( CString( m_RelayIDPtr.ID ) );
		pclDestinationElectroActuator->SetBinaryInputNumber( m_iBinaryInputNumber );
		pclDestinationElectroActuator->SetDefaultReturnPosition( m_eDefaultReturnPos );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_ElectroActuator::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_ELECTROACTUATOR_VERSION		4
// Version 4: 2019-08-19: 'm_eDefaultReturnPos' variable added
// Version 3: 2018-08-06: 'm_RelayIDPtr' and 'm_iBinaryInputNumber' variable added.
// Version 2: 2017-02-17: 'OnOffPossible' variable added.
void CDB_ElectroActuator::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_ELECTROACTUATOR_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CDB_Actuator::Write( outf );

	// ActuatingTime.
	outf.write( (char *)&m_ActTimeDefaultIndex, sizeof( m_ActTimeDefaultIndex ) );
	int iCount = m_ArrayActTimes.GetCount();
	outf.write( (char *)&iCount, sizeof( iCount ) );
	
	for( int i = 0; i < iCount; i++ )
	{
		double dVal = m_ArrayActTimes.GetAt( i );
		outf.write( (char *)&dVal, sizeof( dVal ) );
	}

	// IP.
	WriteString( outf, m_IPxxAuto );
	WriteString( outf, m_IPxxManual );

	// Power Supply.
	iCount = m_PowerSupplyIDPtr.GetCount();
	outf.write( (char *)&iCount, sizeof( iCount ) );
	
	for( int i = 0; i < iCount; i++ )
	{
		IDPTR idptr = m_PowerSupplyIDPtr.GetAt( i );
		WriteString( outf, idptr.ID );
	}

	WriteString( outf, m_FrequencyIDPtr.ID );

	// Input signals.
	iCount = m_InputSignals.GetCount();
	outf.write( (char *)&iCount, sizeof( iCount ) );
	
	for( int i = 0; i < iCount; i++ )
	{
		IDPTR idptr = m_InputSignals.GetAt( i );
		WriteString( outf, idptr.ID );
	}
	
	// Output signals.
	iCount = m_OutputSignals.GetCount();
	outf.write( (char *)&iCount, sizeof( iCount ) );
	for( int i = 0; i < iCount; i++ )
	{
		IDPTR idptr = m_OutputSignals.GetAt( i );
		WriteString( outf, idptr.ID );
	}

	// Fail safe.
	outf.write( (char *)&m_eFailSafe, sizeof( m_eFailSafe ) );

	// Version 2.
	outf.write( (char *)&m_bOnOffPossible, sizeof( m_bOnOffPossible ) );

	// Version 3.
	WriteString( outf, m_RelayIDPtr.ID );
	outf.write( (char *)&m_iBinaryInputNumber, sizeof( m_iBinaryInputNumber ) );
	
	// Version 4.
	outf.write( (char *)&m_eDefaultReturnPos, sizeof( m_eDefaultReturnPos ) );
}

bool CDB_ElectroActuator::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_ELECTROACTUATOR_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_Actuator::Read( inpf ) )
	{
		return false;
	}

	// ActuatingTime.
	int iCount;
	inpf.read( (char *)&m_ActTimeDefaultIndex, sizeof( m_ActTimeDefaultIndex ) );
	inpf.read( (char *)&iCount, sizeof( iCount ) );
	m_ArrayActTimes.SetSize( iCount );
	
	for( int i = 0; i < iCount; i++ )
	{
		double dVal = ReadDouble( inpf );
		m_ArrayActTimes.SetAt( i, dVal );
	}

	// IP.
	if( false == ReadString( inpf, m_IPxxAuto, sizeof( m_IPxxAuto ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_IPxxManual, sizeof( m_IPxxManual ) ) )
	{
		return false;
	}
	
	// Power Supply.
	int count = 0;
	inpf.read( (char *)&count, sizeof( count ) );
	m_PowerSupplyIDPtr.SetSize( count );
	
	for( int i = 0; i < count; i++ )
	{
		IDPTR idptr = _NULL_IDPTR;
		
		if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
		{
			return false;
		}

		idptr.DB = GetDB();
		m_PowerSupplyIDPtr.SetAt( i, idptr );
	}

	// Frequency.
	m_FrequencyIDPtr = _NULL_IDPTR;
	
	if( false == ReadString( inpf, m_FrequencyIDPtr.ID, sizeof( m_FrequencyIDPtr.ID ) ) )
	{
		return false;
	}

	m_FrequencyIDPtr.DB = GetDB();
	
	// Input signals.
	inpf.read( (char *)&count, sizeof( count ) );
	m_InputSignals.SetSize( count );
	
	for( int i = 0; i < count; i++ )
	{
		IDPTR idptr = _NULL_IDPTR;
		
		if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
		{
			return false;
		}

		idptr.DB = GetDB();
		m_InputSignals.SetAt( i, idptr );
	}
	
	// Output signals.
	inpf.read( (char *)&count, sizeof( count ) );
	m_OutputSignals.SetSize( count );
	
	for( int i = 0; i < count; i++ )
	{
		IDPTR idptr = _NULL_IDPTR;
		
		if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
		{
			return false;
		}

		idptr.DB = GetDB();
		m_OutputSignals.SetAt( i, idptr );
	}

	// Fail safe.
	bool isDRPReaded = false;
	if( Version >= 4 )
	{
		inpf.read( (char *)&m_eFailSafe, sizeof( m_eFailSafe ) );
	}
	else
	{
		inpf.read( (char *)&m_eDefaultReturnPos, sizeof( m_eDefaultReturnPos ) );
		isDRPReaded = true;
	}

	if( Version < 2 )
	{
		return true;
	}

	// Version 2.
	inpf.read( (char *)&m_bOnOffPossible, sizeof( m_bOnOffPossible ) );

	if( Version < 3 )
	{
		return true;
	}

	// Relay.
	m_RelayIDPtr = _NULL_IDPTR;

	if( false == ReadString( inpf, m_RelayIDPtr.ID, sizeof( m_RelayIDPtr.ID ) ) )
	{
		return false;
	}

	m_RelayIDPtr.DB = GetDB();

	// Binary input number.
	inpf.read( (char *)&m_iBinaryInputNumber, sizeof( m_iBinaryInputNumber ) );

	if( Version < 4 )
	{
		return true;
	}

	// Version 4.
	if( false == isDRPReaded )
	{
		inpf.read( (char *)&m_eDefaultReturnPos, sizeof( m_eDefaultReturnPos ) );
	}

	return true;
}

void CDB_ElectroActuator::SetArrayActTimes( CArray<double> &ArrayActTimes )
{
	m_ArrayActTimes.RemoveAll();

	for( int i = 0; i < ArrayActTimes.GetCount(); i++ )
	{
		m_ArrayActTimes.Add( ArrayActTimes.GetAt( i ) );
	}
}

void CDB_ElectroActuator::SetPowerSupplyIDPtr( CArray <IDPTR> &arPowerSupplyIDPtr )
{
	m_PowerSupplyIDPtr.RemoveAll();

	for( int i = 0; i < arPowerSupplyIDPtr.GetCount(); i++ )
	{
		IDPTR IDPtr;
		IDPtr.SetID( arPowerSupplyIDPtr.GetAt( i ).ID );
		m_PowerSupplyIDPtr.Add( IDPtr.ID );
	}
}

void CDB_ElectroActuator::SetInputSignals( CArray <IDPTR> &arInputSignals )
{
	m_InputSignals.RemoveAll();

	for( int i = 0; i < arInputSignals.GetCount(); i++ )
	{
		IDPTR IDPtr;
		IDPtr.SetID( arInputSignals.GetAt( i ).ID );
		m_InputSignals.Add( IDPtr.ID );
	}
}

void CDB_ElectroActuator::SetOutputSignals( CArray <IDPTR> &arOutputSignals )
{
	m_OutputSignals.RemoveAll();

	for( int i = 0; i < arOutputSignals.GetCount(); i++ )
	{
		IDPTR IDPtr;
		IDPtr.SetID( arOutputSignals.GetAt( i ).ID );
		m_OutputSignals.Add( IDPtr.ID );
	}
}

void CDB_ElectroActuator::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_Actuator::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;
	
		if( m_PowerSupplyIDPtr.GetCount() > 0 )
		{
			for( int i = 0; i < m_PowerSupplyIDPtr.GetCount(); i++ )
			{
				if( _T('\0') != *m_PowerSupplyIDPtr[i].ID && 0 != _tcscmp( _NO_ID, m_PowerSupplyIDPtr[i].ID ) )
				{
					IDPtr = GetDB()->Get( m_PowerSupplyIDPtr[i].ID );
				
					if( NULL == IDPtr.MP )
					{
						HYSELECT_THROW( _T("Power supply ID (%s) is defined but not found in the database."), m_PowerSupplyIDPtr[i].ID );
					}

					if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
					{
						HYSELECT_THROW( _T("Power supply ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_PowerSupplyIDPtr[i].ID );
					}
				}
			}
		}

		if( _T('\0') != *m_FrequencyIDPtr.ID && 0 != _tcscmp( _NO_ID, m_FrequencyIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_FrequencyIDPtr.ID );
		
			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Frequency ID (%s) is defined but not found in the database."), m_FrequencyIDPtr.ID );
			}
		
			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("Frequency ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_FrequencyIDPtr.ID );
			}
		}
	
		if( m_InputSignals.GetCount() > 0 )
		{
			for( int i = 0; i < m_InputSignals.GetCount(); i++ )
			{
				if( _T('\0') != *m_InputSignals[i].ID && 0 != _tcscmp( _NO_ID, m_InputSignals[i].ID ) )
				{
					IDPtr = GetDB()->Get( m_InputSignals[i].ID );
				
					if( NULL == IDPtr.MP )
					{
						HYSELECT_THROW( _T("Input signal ID (%s) is defined but not found in the database."), m_InputSignals[i].ID );
					}
				
					if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
					{
						HYSELECT_THROW( _T("Input signal ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_InputSignals[i].ID );
					}
				}
			}
		}

		if( m_OutputSignals.GetCount() > 0 )
		{
			for( int i = 0; i < m_OutputSignals.GetCount(); i++ )
			{
				if( _T('\0') != *m_OutputSignals[i].ID && 0 != _tcscmp( _NO_ID, m_OutputSignals[i].ID ) )
				{
					IDPtr = GetDB()->Get( m_OutputSignals[i].ID );
				
					if( NULL == IDPtr.MP )
					{
						HYSELECT_THROW( _T("Output signal ID (%s) is defined but not found in the database."), m_OutputSignals[i].ID );
					}
				
					if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
					{
						HYSELECT_THROW( _T("Output signal ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_OutputSignals[i].ID );
					}
				}
			}
		}

		if( _T('\0') != *m_RelayIDPtr.ID && 0 != _tcscmp( _NO_ID, m_RelayIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_RelayIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Relay ID (%s) is defined but not found in the database."), m_RelayIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("Relay ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_RelayIDPtr.ID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_ElectroActuator::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

void CDB_ElectroActuator::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str, str1, str2;

	// Write object header.
	if( true == IsClass( CLASS( CDB_ElectroActuator ) ) )
	{
		CData::WriteText( outf, strTab );
	}

	// Opening bracket..
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");
	CDB_Actuator::WriteText( outf, strTab );
	
	// Data.
	str1 = _T("");
	INT_PTR Number = m_ArrayActTimes.GetCount();
	
	for( int i = 0; i < Number;i++ )
	{
		if( i != 0 )
		{
			str1 += _T(" \\ ");
		}

		str1 += WriteDouble( m_ArrayActTimes.GetAt( i ), 2, 1 );

		// Add the star to the default actuating time index.
		if( i != 0)
		{
			if( GetDefaultActuatingTimeIndex() == i )
			{
				str1 += _T("*");
			}
		}
	}

	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	WriteFormatedStringW( outf, m_IPxxAuto, strTab, true );
	WriteFormatedStringW( outf, m_IPxxManual, strTab, true );

	str1 = _T("");
	Number = m_PowerSupplyIDPtr.GetCount();
	
	for( int i = 0; i < Number; i++ )
	{
		if( i != 0 )
		{
			str1 += _T(" \\ ");
		}

		str1 += m_PowerSupplyIDPtr.GetAt( i ).ID;
	}
	
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	
	WriteFormatedStringW( outf, m_FrequencyIDPtr.ID, strTab );
	
	str1 = _T("");
	Number = m_InputSignals.GetCount();
	
	for( int i = 0; i < Number;i++ )
	{
		if( i != 0 )
		{
			str1 += _T(" \\ ");
		}

		str1 += m_InputSignals.GetAt( i ).ID;
	}
	
	if( (INT_PTR)0 == Number )
	{
		str1 = _T("NO_ID");
	}
	
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	str1 = _T("");
	Number = m_OutputSignals.GetCount();
	
	for( int i = 0; i < Number;i++ )
	{
		if( i != 0 )
		{
			str1 += _T(" \\ ");
		}

		str1 += m_OutputSignals.GetAt(i).ID;
	}
	
	if( (INT_PTR)0 == Number )
	{
		str1 = _T("NO_ID");
	}

	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	// Fail-Safe type.
	if( (int)m_eFailSafe == 0 )
	{
		str1 = TASApp.LoadLocalizedString( IDS_NO );
	}
	else if( (int)m_eFailSafe == 1 )
	{
		str1 = TASApp.LoadLocalizedString( IDS_STRELECFAILSAFE );
	}
	else if( (int)m_eFailSafe == 2 )
	{
		str1 = TASApp.LoadLocalizedString( IDS_STRSPRINGFAILSAFE );
	}
	else
	{
		str1 = _T("Undefined");
	}

	str.Format( _T("\r\n%s" ), str1 );
	WriteFormatedStringW( outf, str, strTab );

	// OnOffPossible.
	str.Format( _T("\r\n%s"), ( true == m_bOnOffPossible ) ? _T("1") : _T("0") );
	WriteFormatedStringW( outf, str, strTab );

	// Relay.
	WriteFormatedStringW( outf, m_RelayIDPtr.ID, strTab );

	// Binary input.
	str.Format( _T("\r\n%s%i"), strTab, m_iBinaryInputNumber );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	// Default return position
	str = CString( GetDefaultReturnPosStr( m_eDefaultReturnPos ).c_str() );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	// Closing bracket.
	strTab.Delete( 0 ); // Delete one \t
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}

void CDB_ElectroActuator::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		//		ActuatingTimes		List of actuating times separated by \ with default setting followed by * (in s/m for #eOPENTYPE_Linear; in s/90 for #eOPENTYPE_Circ)
		//		IPxxAuto			Enclosure protection of the actuator in auto mode
		//		IPxxManual			Enclosure protection of the actuator when using manual override
		//		Power supply		List of accepted Power supplies separated by '\'
		//		Frequency			Accepted frequency
		//		Input signals		List of accepted input control signals separated by '\'
		//		Output signals		List of accepted output control signals separated by '\'
		//		Fail safe			yes, no.
		//		Default return position			eDRP_None, eDRP_Extending, eDRP_Retracting or eDRP_Configurable.
		//		OnOffPossible		1 if a 3 points  or proportional actuator can work in On/Off mode.
		//		RelayID				Type of relay.
		//      Binary input		Number of binary input.

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_ElectroActuator *)idptr.MP)->Copy( this );
		
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_Actuator::ReadText( inpf, pusLineCount );

			// ActuatingTime.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			_ParseActuatingTimesList( &m_ArrayActTimes, m_ActTimeDefaultIndex, ptcLine );

			// IPxxAuto.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			int iLength = _tcslen( ptcLine );

			if( iLength >= ( SIZEOFINTCHAR( m_IPxxAuto ) + 2 ) )
			{
				HYSELECT_THROW( _T("Enclosure protection in auto mode (%s) is too long (%i > %i) (pos: %i)."), ptcLine, iLength, ( SIZEOFINTCHAR( m_IPxxAuto ) + 2 ), *pusLineCount );
			}

			if( _T('"') != *ptcLine )
			{
				HYSELECT_THROW( _T("Enclosure protection in auto mode variable must start with \" (pos: %i)."), *pusLineCount );
			}
			else if( _T('"') != ptcLine[iLength - 1] )
			{
				HYSELECT_THROW( _T("Enclosure protection in auto mode variable must end with \" (pos: %i)."), *pusLineCount );
			}

			ptcLine[iLength - 1] = _T('\0');
			_tcsncpy_s( m_IPxxAuto, SIZEOFINTCHAR( m_IPxxAuto ), ptcLine + 1, SIZEOFINTCHAR( m_IPxxAuto ) - 1 );

			// IPxxManual.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			iLength = _tcslen( ptcLine );

			if( iLength >= ( SIZEOFINTCHAR( m_IPxxManual ) + 2 ) )
			{
				HYSELECT_THROW( _T("Enclosure protection in manual mode (%s) is too long (%i > %i) (pos: %i)."), ptcLine, iLength, ( SIZEOFINTCHAR( m_IPxxManual ) + 2 ), *pusLineCount );
			}

			if( _T('"') != *ptcLine )
			{
				HYSELECT_THROW( _T("Enclosure protection in manual mode variable must start with \" (pos: %i)."), *pusLineCount );
			}
			else if( _T('"') != ptcLine[iLength - 1] )
			{
				HYSELECT_THROW( _T("Enclosure protection in manual mode variable must end with \" (pos: %i)."), *pusLineCount );
			}

			ptcLine[iLength - 1] = _T('\0');
			_tcsncpy_s( m_IPxxManual, SIZEOFINTCHAR( m_IPxxManual ), ptcLine + 1, SIZEOFINTCHAR( m_IPxxManual ) - 1 );
		
			// Power supply.
			ptcLine = ReadTextLine( inpf, pusLineCount);
			ParseIDList( &m_PowerSupplyIDPtr, ptcLine );

			// Frequency.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Frequency ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			m_FrequencyIDPtr = _NULL_IDPTR;
			_tcsncpy_s( m_FrequencyIDPtr.ID, _ID_LENGTH + 1, ptcLine, _ID_LENGTH );
			m_FrequencyIDPtr.DB = GetDB();
		
			// Input signals.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			ParseIDList( &m_InputSignals, ptcLine );

			// Output signals.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			ParseIDList( &m_OutputSignals, ptcLine );

			// Read fail safe.
			int iFSTypeValue = ReadEnumLine( inpf, pusLineCount );
			m_eFailSafe = (FailSafeType)iFSTypeValue;

			if( m_eFailSafe < FailSafeType::eFSTypeNone || m_eFailSafe >= FailSafeType::eFSTypeLast )
			{
				HYSELECT_THROW( _T("Fail-Safe type (%i) value must be 0 (No fail-safe), 1 (Electronic fail-safe) or 2 (Spring return fail-safe) (pos: %i)."), (int)m_eFailSafe, *pusLineCount );
			}

			// On-Off possible.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_bOnOffPossible = ( 0 == _ttoi( ptcLine ) ) ? false : true;

			// Relay.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Relay ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			m_RelayIDPtr = _NULL_IDPTR;
			_tcsncpy_s( m_RelayIDPtr.ID, _ID_LENGTH + 1, ptcLine, _ID_LENGTH );
			m_RelayIDPtr.DB = GetDB();

			// Binary input number.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_iBinaryInputNumber = _tstoi( ptcLine );

			if( m_iBinaryInputNumber < 0.0 )
			{
				HYSELECT_THROW( _T("Binary input (%i) cann't be lower than 0 (pos: %i)."), m_iBinaryInputNumber, *pusLineCount );
			}

			// Default return position.
			int iValue = ReadEnumLine( inpf, pusLineCount );

			if( iValue != DefaultReturnPosition::None && iValue != DefaultReturnPosition::Extending && iValue != DefaultReturnPosition::Retracting && iValue != DefaultReturnPosition::Configurable )
			{
				HYSELECT_THROW( _T("Default return position value must be one of these values: '#eDRP_None', '#eDRP_Extending', 'eDRP_Retracting' or '#eDRP_Configurable' (pos: %i)."), *pusLineCount );
			}

			m_eDefaultReturnPos = (DefaultReturnPosition)iValue;
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_ElectroActuator::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_ElectroActuator::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( _T("CDB_ElectroActuator") );
	
		if( iPos < 0 )
		{
			CDB_Actuator::InterpretInheritedData( pStr );
		}
		else
		{
			pStr->Delete( iPos, _tcsclen( _T("CDB_ElectroActuator") ) );
			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( _T("::ActuatingTimes=") ) > -1 )
			{
				_ParseActuatingTimesList( &m_ArrayActTimes, m_ActTimeDefaultIndex, strField );
			}
			else if( pStr->Find( _T("::IPxxAuto=") ) > -1 )
			{
				if( strField.GetLength() >= ( SIZEOFINTCHAR( m_IPxxAuto ) + 2 ) )
				{
					HYSELECT_THROW( _T("'CDB_ElectroActuator::IPxxAuto' (%s) is too long (%i > %i)."), strField, strField.GetLength(), ( SIZEOFINTCHAR( m_IPxxAuto ) + 2 ) );
				}

				if( _T('"') != strField.GetAt( 0 ) )
				{
					HYSELECT_THROW( _T("'CDB_ElectroActuator::IPxxAuto' (%s) must start with \"."), strField );
				}
				else if( _T('"') != strField.GetAt( strField.GetLength() - 1 ) )
				{
					HYSELECT_THROW( _T("'CDB_ElectroActuator::IPxxAuto' (%s) must end with \"."), strField );
				}

				// IPxxAuto.
				strField.Remove('\"');
				_tcsncpy_s( m_IPxxAuto, SIZEOFINTCHAR( m_IPxxAuto ), strField, SIZEOFINTCHAR( m_IPxxAuto ) - 1 );
			}
			else if( pStr->Find( _T("::IPxxManual=") ) > -1 )
			{
				if( strField.GetLength() >= ( SIZEOFINTCHAR( m_IPxxManual ) + 2 ) )
				{
					HYSELECT_THROW( _T("'CDB_ElectroActuator::IPxxManual' (%s) is too long (%i > %i)."), strField, strField.GetLength(), ( SIZEOFINTCHAR( m_IPxxManual ) + 2 ) );
				}

				if( _T('"') != strField.GetAt( 0 ) )
				{
					HYSELECT_THROW( _T("'CDB_ElectroActuator::IPxxManual' (%s) must start with \"."), strField );
				}
				else if( _T('"') != strField.GetAt( strField.GetLength() - 1 ) )
				{
					HYSELECT_THROW( _T("'CDB_ElectroActuator::IPxxManual' (%s) must end with \"."), strField );
				}

				// IPxxManual.
				strField.Remove('\"');
				_tcsncpy_s( m_IPxxManual, SIZEOFINTCHAR( m_IPxxManual ), strField, SIZEOFINTCHAR( m_IPxxManual ) - 1 );
			}
			else if( pStr->Find( _T("::PowerSupplyIDs=") ) > -1 )
			{
				ParseIDList( &m_PowerSupplyIDPtr, strField );
			}
			else if( pStr->Find( _T("::FrequencyID=") ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_ElectroActuator::FrequencyID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				m_FrequencyIDPtr = _NULL_IDPTR;
				_tcsncpy_s( m_FrequencyIDPtr.ID, _ID_LENGTH + 1, (LPCTSTR)strField, _ID_LENGTH );
				m_FrequencyIDPtr.DB = GetDB();
			}
			else if( pStr->Find( _T("::InputSignalIDs=") ) > -1 )
			{
				ParseIDList( &m_InputSignals, strField );
			}
			else if( pStr->Find( _T("::OutputSignalIDs=") ) > -1 )
			{
				ParseIDList( &m_OutputSignals, strField );
			}
			else if( pStr->Find( _T("::FailSafeType=") ) > -1 )
			{
				int iFSTypeValue = ReadEnum( strField );
				m_eFailSafe = (FailSafeType)iFSTypeValue;

				if( m_eFailSafe < FailSafeType::eFSTypeNone || m_eFailSafe >= FailSafeType::eFSTypeLast )
				{
					HYSELECT_THROW( _T("'CDB_ElectroActuator::FailSafeType' (%i) value must be 0 (No fail-safe), 1 (Electronic fail-safe) or 2 (Spring return fail-safe)."), (int)m_eFailSafe );
				}
			}
			else if( pStr->Find( _T("::OnOffPossible=") ) > -1 )
			{
				m_bOnOffPossible = ( 0 == _tstoi( (LPCTSTR)strField ) ) ? false : true;
			}
			else if( pStr->Find( _T("::RelayID=") ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_ElectroActuator::RelayID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				m_RelayIDPtr = _NULL_IDPTR;
				_tcsncpy_s( m_RelayIDPtr.ID, _ID_LENGTH + 1, (LPCTSTR)strField, _ID_LENGTH );
				m_RelayIDPtr.DB = GetDB();
			}
			else if( pStr->Find( _T("::BinaryInput=") ) > -1 )
			{
				m_iBinaryInputNumber = _tstoi( (LPCTSTR)strField );

				if( m_iBinaryInputNumber < 0 )
				{
					HYSELECT_THROW( _T("'CDB_ElectroActuator::RelayID' (%i) can't be lower than 0."), m_iBinaryInputNumber );
				}
			}
			else if( pStr->Find( _T("::DefaultReturnPosition=") ) > -1 )
			{
				int iValue = ReadEnum( strField );

				if( iValue != DefaultReturnPosition::None && iValue != DefaultReturnPosition::Extending && iValue != DefaultReturnPosition::Retracting && iValue != DefaultReturnPosition::Configurable )
				{
					HYSELECT_THROW( _T("'CDB_ElectroActuator::DefaultReturnPosition' value must be one of these values: '#eDRP_None', '#eDRP_Extending', 'eDRP_Retracting' or '#eDRP_Configurable'.") );
				}

				m_eDefaultReturnPos = (DefaultReturnPosition)iValue;
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_ElectroActuator::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

CData::CheckFilterReturnValue CDB_ElectroActuator::CheckFilter( CFilterTab* pclFilter, CString strFilter )
{
	try
	{
		//	Filter string
		//  CDB_ClassName;TABLE;ID;EDIT;FAMILY;VERSION;POWER;Availability;Mask & Value;Priority
		//	Field 0			1	2	3	4		5		6	        7		     8        9

		if( true == strFilter.IsEmpty() )
		{
			HYSELECT_THROW( _T("Filter line can't be empty.") );
		}

		int iFieldNumber = pclFilter->GetNumberOfFields( strFilter );

		if( 10 != iFieldNumber )
		{
			HYSELECT_THROW( _T("Number of fields (%i) must be 10."), iFieldNumber );
		}

		// Family.
		CString str = pclFilter->GetField( 4, strFilter );

		if( false == str.IsEmpty() )
		{
			if( 0 != _tcscmp( (LPCTSTR)str, GetFamilyIDPtr().ID ) )
			{
				return CData::CFRV_FilterNotApplied;
			}
		}

		// Version.
		str = pclFilter->GetNextField( strFilter );

		if( false == str.IsEmpty() )
		{
			if( 0 != _tcscmp( (LPCTSTR)str, GetVersionIDPtr().ID ) )
			{
				return CData::CFRV_FilterNotApplied;
			}
		}

		// Power.
		// HYS-1569 : If we need to filter more than one power supply separate it by "\"
		str = pclFilter->GetNextField( strFilter ); // List of power in the filter tab. Ex : "POWER_230VAC \ POWER_115VAC" or "POWER_24VAC"

		if( false == str.IsEmpty() )
		{
			bool bFoundToFilter = false;
			bool bFoundOtherValues = false;
			CArray <IDPTR> PowerSupplyIDPtr; 
			ParseIDList( &PowerSupplyIDPtr, str );
			int iFilterIndex = 0;
			int iPowerCount = PowerSupplyIDPtr.GetCount();
			bool bApplyFilter = false;
			// If the product has more than one power supply the filter is applied only if all powers are represented
			// in the filter tab line (in str value)
			for( unsigned int i = 0; i < GetNumOfPowerSupplyIDptr(); i++ )
			{
				bFoundToFilter = false;
				iFilterIndex = 0;
				// Look filter
				while( iFilterIndex < iPowerCount )
				{
					if( 0 == _tcscmp( (LPCTSTR)( PowerSupplyIDPtr.GetAt( iFilterIndex ) ).ID, GetPowerSupplyIDPtr( i ).ID ) )
					{
						// The current Power is in the filtertab
						bFoundToFilter = true;
						break;
					}
					iFilterIndex++;
				}
				if(false == bFoundToFilter )
				{
					// The current power is not filtered
					bFoundOtherValues = true;
					break;
				}
			}
			
			if( false == bFoundToFilter || true == bFoundOtherValues )
			{
				return CData::CFRV_FilterNotApplied;
			}
		}

		// All Field checked do modifications.
		// Availability.
		str = pclFilter->GetNextField( strFilter );

		if( false == str.IsEmpty() )
		{
			if( _T( '0' ) == str[0] )
			{
				SetAvailable( 0 );
			}

			if( _T( '1' ) == str[0] )
			{
				SetAvailable( 1 );
			}

			if( _T( '0' ) == str[2] )
			{
				SetHidden( 0 );
			}

			if( _T( '1' ) == str[2] )
			{
				SetHidden( 1 );
			}
		}

		// Some flags with a mask					// Mask and value integers
		// The first integer contains mask bits, the second contains the values, 
		// mask integer and value integer are separated by a comma.
		// Both are coded in Hexadecimal like 0x....
		// Only value bit with a mask bit set to 1 will be taken into account 
		str = pclFilter->GetNextField( strFilter );

		if( false == str.IsEmpty() )
		{
			// Split Mask and Value into two integers.
			CString strMask = str.Left( str.Find( _T( ',' ) ) );
			CString strVal = str.Right( str.GetLength() - ( str.Find( _T( ',' ) ) + 1 ) );

			unsigned int uiMask, uiNVal;
			_stscanf_s( (LPCTSTR)strMask, _T("%x"), &uiMask );
			_stscanf_s( (LPCTSTR)strVal, _T("%x"), &uiNVal );

			// Set or reset non masked bit.
			unsigned int uiInt1 = GetInt1();

			//          set bits				reset bits
			uiInt1 = ( uiInt1 | ( uiMask & uiNVal ) ) & ~( uiMask & ~uiNVal );
			SetInt1( uiInt1 );
		}

		// Priority.
		str = pclFilter->GetNextField( strFilter );

		if( false == str.IsEmpty() )
		{
			int priority = _tcstol( (LPCTSTR)str, 0, 10 );
			SetPriorityLevel( priority );
		}

		return CData::CFRV_FilterApplied;
	}
	catch( CHySelectException& clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Product::CheckFilter' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		clHySelectException.AddMessage( _T("  -> Filter: '%s'."), __LINE__, __FILE__, strFilter );
		throw;
	}
}

void CDB_ElectroActuator::_ParseActuatingTimesList( CArray<double> *pAr, int &pos, CString list )
{
	try
	{
		int nField = 0;
		TCHAR **pptcField = ParseTextLine( (LPTSTR)(LPCTSTR)list, &nField );

		pAr->RemoveAll();
		pAr->SetSize( nField );
		
		for( int i = 0; i < nField; i++ )
		{
			TCHAR *ptcEndPtr;
			double dVal = 0.0;
			CString str = pptcField[i];
			
			if( _T('*') == str.GetAt( str.GetLength() - 1 ) )
			{
				str.Delete( str.GetLength() - 1 );
				pos = i;
			}

			dVal = _tcstod( (LPCTSTR)str, &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't convert actuating time value (%s) at position %i in double."), str, i );
			}
			
			// Actuating Times are expressed as second/m & second/90; make de convertion to have s/m; s/deg.
			if( CDB_CloseOffChar::eOpenType::Linear == GetOpeningType() )
			{
				dVal /= 1.0;
			}
			else if( CDB_CloseOffChar::eOpenType::Circular == GetOpeningType() )
			{
				dVal /= 90.0;
			}

			pAr->SetAt( i, dVal );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_ElectroActuator::_ParseActuatingTimesList'."), __LINE__, __FILE__ );
		throw;
	}
}

bool CDB_ElectroActuator::IsPowerSupplyAvailable( IDPTR idptr )
{
	for (int i = 0; i < (int)GetNumOfPowerSupplyIDptr(); i++)
	{
		if( GetPowerSupplyIDPtr(i).MP == idptr.MP )
		{
			return true;
		}
	}
	
	return false;
}

bool CDB_ElectroActuator::IsInputSignalAvailable( IDPTR idptr )
{
	for (int i = 0; i < (int)GetNumOfInputSignalsIDptr(); i++)
	{
		if( GetInputSignalsIDPtr(i).MP == idptr.MP ) 
		{
			return true;
		}
	}
	
	return false;
}

bool CDB_ElectroActuator::IsOutputSignalAvailable( IDPTR idptr )
{
	for (int i = 0; i < (int)GetNumOfOutputSignalsIDptr(); i++)
	{
		if( GetOutputSignalsIDPtr(i).MP == idptr.MP ) 
		{
			return true;
		}
	}
	return false;
}

#endif 

#ifndef TACBX 
////////////////////////////////////////////////////////////////
//
//		CDB_ThermostaticActuator : 
//
////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_ThermostaticActuator )

CDB_ThermostaticActuator::CDB_ThermostaticActuator( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_Actuator( pDataBase, ID )
{
	m_iMinSetting = -1;
	m_iMaxSetting = -1;
	m_iCapillaryLength = -1;
	m_dHysteresis = -1.0;
	m_iFrostProtection = -1;
	
	SetTACBXVer( 0 );				// Skipped by default
}

double CDB_ThermostaticActuator::GetOrderKey()
{
	CString strKey;
	StrCleanArticleNumber( GetArtNum(), &strKey );

	TCHAR *ptcStopChar = NULL;
	double dKey = 1.0e10 - _tcstod( strKey, &ptcStopChar );
	return dKey;
}

void CDB_ThermostaticActuator::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_ThermostaticActuator *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_ThermostaticActuator' object!") );
		}
	
		// Base class.
		CDB_Actuator::Copy( pclDestination );

		// Copy now what it is common to the "CDB_ThermostaticActuator" class.
		CDB_ThermostaticActuator *pclDestinationThermostaticActuator = (CDB_ThermostaticActuator *)pclDestination;

		pclDestinationThermostaticActuator->SetMinSetting( m_iMinSetting );
		pclDestinationThermostaticActuator->SetMaxSetting( m_iMaxSetting );
		pclDestinationThermostaticActuator->SetCapillaryLength( m_iCapillaryLength );
		pclDestinationThermostaticActuator->SetHysteresis( m_dHysteresis );
		pclDestinationThermostaticActuator->SetFrostProtection( m_iFrostProtection );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_ThermostaticActuator::Copy' method with the object '%s'."), GetIDPtr().ID )
}

void CDB_ThermostaticActuator::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = 1;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CDB_Actuator::Write( outf );

	// Infos.
	outf.write( (char *)&m_iMinSetting, sizeof( m_iMinSetting ) );
	outf.write( (char *)&m_iMaxSetting, sizeof( m_iMaxSetting ) );
	outf.write( (char *)&m_iCapillaryLength, sizeof( m_iCapillaryLength ) );
	outf.write( (char *)&m_dHysteresis, sizeof( m_dHysteresis ) );
	outf.write( (char *)&m_iFrostProtection, sizeof( m_iFrostProtection ) );

}

bool CDB_ThermostaticActuator::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > 1 )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_Actuator::Read( inpf ) )
	{
		return false;
	}

	// Infos.
	inpf.read( (char *)&m_iMinSetting, sizeof( m_iMinSetting ) );
	inpf.read( (char *)&m_iMaxSetting, sizeof( m_iMaxSetting ) );
	inpf.read( (char *)&m_iCapillaryLength, sizeof( m_iCapillaryLength ) );
	inpf.read( (char *)&m_dHysteresis, sizeof( m_dHysteresis ) );
	inpf.read( (char *)&m_iFrostProtection, sizeof( m_iFrostProtection ) );

	return true;
}

void CDB_ThermostaticActuator::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str, str1;

	// Write object header.
	if( true == IsClass( CLASS( CDB_ThermostaticActuator ) ) )
	{
		CData::WriteText( outf, strTab );
	}

	// Opening bracket..
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");
	CDB_Actuator::WriteText( outf, strTab );
	
	// Data.
	str1 = _T("");
	str1.Format( _T("%d"), m_iMinSetting );
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	str1.Format( _T("%d"), m_iMaxSetting );
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	str1.Format( _T("%d"), m_iCapillaryLength );
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	str1.Format( _T("%f"), m_dHysteresis );
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	str1.Format( _T("%d"), m_iFrostProtection );
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	// Closing bracket..
	strTab.Delete( 0 ); // Delete one \t
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}

void CDB_ThermostaticActuator::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		//		MinSetting			Min setting temperature (C)
		//		MaxSetting			Max setting temperature (C)
		//		CapillaryLength		Length of the capillary tube if exist
		//		Hysteresis			Hysteresis in K
		//		FrostProtection		Frost protection temperature (C)

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;

		if( InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_ThermostaticActuator *)idptr.MP)->Copy( this );
			
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );

			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );
			
				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_Actuator::ReadText( inpf, pusLineCount );

			// Minimum measurable setting.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_iMinSetting = _tstoi( ptcLine );

			if( m_iMinSetting < 0.0 && m_iMinSetting != -1 )
			{
				HYSELECT_THROW( _T("Minimum measurable setting (%i) must be either -1 or higher or equal to 0 (pos: %i)."), m_iMinSetting, *pusLineCount );
			}
		
			// Maximum measurable setting.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_iMaxSetting = _tstoi( ptcLine );

			if( m_iMaxSetting < 0.0 && m_iMaxSetting != -1 )
			{
				HYSELECT_THROW( _T("Maximum measurable setting (%i) must be either -1 or higher or equal to 0 (pos: %i)."), m_iMaxSetting, *pusLineCount );
			}
		
			// Capillary tube length.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_iCapillaryLength = _tstoi( ptcLine );

			if( m_iCapillaryLength < 0.0 && m_iCapillaryLength != -1 )
			{
				HYSELECT_THROW( _T("Capillary tube length (%i) must be either -1 or higher or equal to 0 (pos: %i)."), m_iCapillaryLength, *pusLineCount );
			}

			// Hysteresis.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_dHysteresis = _tstof( ptcLine );

			if( m_dHysteresis < 0.0 && m_dHysteresis != -1.0 )
			{
				HYSELECT_THROW( _T("Hysteresis (%f) must be either -1.0 or higher or equal to 0.0 (pos: %i)."), m_dHysteresis, *pusLineCount );
			}

			// Frost protection.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_iFrostProtection = _tstoi( ptcLine );

			if( m_iFrostProtection < 0.0 && m_iFrostProtection != -1 )
			{
				HYSELECT_THROW( _T("Frost protection (%i) must be either -1 or higher or equal to 0 (pos: %i)."), m_iFrostProtection, *pusLineCount );
			}
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_ThermostaticActuator::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_ThermostaticActuator::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( _T("CDB_ThermostaticActuator") );

		if( iPos < 0 )
		{
			CDB_Actuator::InterpretInheritedData( pStr );
		}
		else
		{
			pStr->Delete( iPos, _tcsclen( _T("CDB_ThermostaticActuator") ) );
			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( _T("::MinSetting=") ) > -1 )
			{
				m_iMinSetting = _tstoi( (LPCTSTR)strField );

				if( m_iMinSetting < 0 && m_iMinSetting != -1 )
				{
					HYSELECT_THROW( _T("CDB_ThermostaticActuator::MinSetting (%i) must be either -1 or higher or equal to 0."), m_iMinSetting );
				}
			}
			else if( pStr->Find( _T("::MaxSetting=") ) > -1 )
			{
				m_iMaxSetting = _tstoi( (LPCTSTR)strField );

				if( m_iMaxSetting < 0 && m_iMaxSetting != -1 )
				{
					HYSELECT_THROW( _T("CDB_ThermostaticActuator::MaxSetting (%i) must be either -1 or higher or equal to 0."), m_iMaxSetting );
				}
			}
			else if( pStr->Find( _T("::CapillaryLength=") ) > -1 )
			{
				m_iCapillaryLength = _tstoi( (LPCTSTR)strField );

				if( m_iCapillaryLength < 0 && m_iCapillaryLength != -1 )
				{
					HYSELECT_THROW( _T("CDB_ThermostaticActuator::MaxSetting (%i) must be either -1 or higher or equal to 0."), m_iMaxSetting );
				}
			}
			else if( pStr->Find( _T("::Hysteresis=") ) > -1 )
			{
				m_dHysteresis = _tstof( (LPCTSTR)strField );

				if( m_dHysteresis < 0.0 && m_dHysteresis != -1.0 )
				{
					HYSELECT_THROW( _T("CDB_ThermostaticActuator::Hysteresis (%f) must be either -1 or higher or equal to 0."), m_dHysteresis );
				}
			}
			else if( pStr->Find( _T("::FrostProtection=") ) > -1 )
			{
				m_iFrostProtection = _tstoi( (LPCTSTR)strField );

				if( m_iFrostProtection < 0.0 && m_iFrostProtection != -1 )
				{
					HYSELECT_THROW( _T("CDB_ThermostaticActuator::FrostProtection (%i) must be either -1 or higher or equal to 0."), m_iFrostProtection );
				}
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_ThermostaticActuator::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif 

#ifndef TACBX 
////////////////////////////////////////////////////////////////
//
//		CTableSet : Control valve actuator set table 
//
////////////////////////////////////////////////////////////////
IMPLEMENT_DATA(CTableSet)

CTableSet::CTableSet( CDataBase *pDataBase, LPCTSTR ID )
	: CTable( pDataBase, ID )
{
}

// Return an array of CDB_Set *
// For CV/Actuator set
//		FirstID	  -> Identifier of the control valve
//		SecondID  -> Identifier of the actuator
// For DpC/MV set:
//		FirstID	  -> Identifier of the DpC
//		SecondID  -> Identifier of the MV
//  HYS-1381 : For Set in direct selection we have to show compatible actuators even if it's deleted.
// HYS-1877: For TA-6-way valve or for Set with more than 2 products
//		FirstID	  -> Identifier of the control valve
//		SecondID  -> Identifier of the actuator
//		...
//		NextID  -> Identifier of the next ID to consider can be Set ID, Group ID, Product ID etc... (Not checked here)
int CTableSet::FindCompatibleSet( std::set<CDB_Set *> *pSet, CString strFirstID, CString strSecondID, int iFilterSelection )
{
	int iCount = 0;
	pSet->clear();
	CTADatabase::FilterSelection eFilterSelection = ( CTADatabase::FilterSelection )iFilterSelection;

	bool bDoNotCheckDeleted = true;
	if( CTADatabase::FilterSelection::ForDirSel == eFilterSelection )
	{
		bDoNotCheckDeleted = false;
	}

	// HYS-1877: To manage 6-way valve kit. Condition to exclude PIBCV set from _T( "6WAYCTRLVALVSET_TAB" ).
	bool bIsFor6WayValveSetTab = false;
	if( 0 == IDcmp( GetIDPtr().ID, _T( "6WAYCTRLVALVSET_TAB" ) ) )
	{
		bIsFor6WayValveSetTab = true;
	}

	for( IDPTR idptr = GetFirst(); _T('\0') != *idptr.ID; idptr = GetNext() )
	{
		CDB_Set *pTemp = dynamic_cast<CDB_Set *>( idptr.MP );

		if( NULL == pTemp || false == pTemp->IsSelectable( bDoNotCheckDeleted ) )
		{
			continue;
		}

		if( false == strFirstID.IsEmpty() && IDcmp( pTemp->GetFirstIDPtr().ID, (LPCTSTR)strFirstID ) != 0 )
		{
			continue;
		}

		if( false == strSecondID.IsEmpty() && IDcmp( pTemp->GetSecondIDPtr().ID, (LPCTSTR)strSecondID ) != 0 )
		{
			continue;
		}

		if( NULL != dynamic_cast<CData *>( pTemp->GetFirstIDPtr().MP ) )
		{
			CData *pFirst = dynamic_cast<CData *>( pTemp->GetFirstIDPtr().MP );
			
			if( false == pFirst->IsSelectable( bDoNotCheckDeleted ) )
			{
				continue;
			}
		}

		if( NULL != dynamic_cast<CData *>( pTemp->GetSecondIDPtr().MP ) )
		{
			CData *pSecond = dynamic_cast<CData *>( pTemp->GetSecondIDPtr().MP );
			
			if( false == pSecond->IsSelectable( bDoNotCheckDeleted ) )
			{
				continue;
			}
		}

		// HYS-1877: PIBCV set from 6WAYCTRLVALVSET_TAB has no article number
		if( true == bIsFor6WayValveSetTab && 0 == StringCompare( _T( "-" ), pTemp->GetArtNum() ) )
		{
			continue;
		}

		pSet->insert( pTemp );
		iCount ++;
	}
	
	return iCount;
}

// HYS-1877
// Return a CDB_Set *
// For 6-way valve/Actuator set
//		FirstID	  -> Identifier of the control valve
//		SecondID  -> Identifier of the actuator
//		...
//		NextID (ID of PIBCV set)  -> Identifier of the next ID to consider can be Set ID, Group ID, Product ID etc... (Not checked here)
// For PIBCV/ACT set:
//		FirstID	  -> Identifier of the pibcv
//		SecondID  -> Identifier of the act
//    	NextID (NO_ID)-> Identifier of 6-way valve
CDB_Set* CTableSet::FindCompatibleSet6WayValve( CString strFirstID, CString strSecondID )
{
	// Only for 6-way valve set tab.
	if( 0 != IDcmp( GetIDPtr().ID, _T( "6WAYCTRLVALVSET_TAB" ) ) )
	{
		return NULL;
	}

	// This function is for PIBCV set linked with a 6-way valve set. Other functions can be used
	// for the 6-way valve set part.
	for( IDPTR idptr = GetFirst(); _T('\0') != *idptr.ID; idptr = GetNext() )
	{
		CDB_Set *pTemp = dynamic_cast<CDB_Set *>( idptr.MP );

		if( NULL == pTemp || false == pTemp->IsSelectable( true ) )
		{
			continue;
		}

		if( 0 == StringCompare( _T( "NO_ID" ), pTemp->GetNextID() ) )
		{
			// We first get the 6-way valve set
			continue;
		}

		// Get the set displayed in Next_ID field.
		CDB_Set* pclPibcvSet = dynamic_cast<CDB_Set*>(GetpTADB()->Get( pTemp->GetNextID() ).MP);

		if( NULL == pclPibcvSet )
		{
			continue;
		}

		if( false == strFirstID.IsEmpty() && IDcmp( pclPibcvSet->GetFirstIDPtr().ID, (LPCTSTR)strFirstID ) != 0 )
		{
			continue;
		}

		if( false == strSecondID.IsEmpty() && IDcmp( pclPibcvSet->GetSecondIDPtr().ID, (LPCTSTR)strSecondID ) != 0 )
		{
			continue;
		}

		if( NULL != dynamic_cast<CData *>(pclPibcvSet->GetFirstIDPtr().MP ) )
		{
			CData *pFirst = dynamic_cast<CData *>(pclPibcvSet->GetFirstIDPtr().MP );
			
			if( false == pFirst->IsSelectable( true ) )
			{
				continue;
			}
		}

		if( NULL != dynamic_cast<CData *>(pclPibcvSet->GetSecondIDPtr().MP ) )
		{
			CData *pSecond = dynamic_cast<CData *>(pclPibcvSet->GetSecondIDPtr().MP );
			
			if( false == pSecond->IsSelectable( true ) )
			{
				continue;
			}
		}

		return pclPibcvSet;
	}
	
	return NULL;
}

CDB_Set *CTableSet::FindCompatibleSet( CString strFirstID, CString strSecondID )
{
	// HYS-1877: To manage 6-way valve kit. Condition to exclude PIBCV set from _T( "6WAYCTRLVALVSET_TAB" ).
	bool bIsFor6WayValveTab = false;

	if( 0 == IDcmp( GetIDPtr().ID, _T( "6WAYCTRLVALVSET_TAB" ) ) )
	{
		bIsFor6WayValveTab = true;
	}

	for( IDPTR idptr = GetFirst(); _T('\0') != *idptr.ID; idptr = GetNext() )
	{
		CDB_Set *pCvActSet = dynamic_cast<CDB_Set *>( idptr.MP );

		if( NULL == pCvActSet || false == pCvActSet->IsAvailable() )
		{
			continue;
		}

		// We offer now the possibility to search in any order.
		if( false == strFirstID.IsEmpty() && 0 != IDcmp( pCvActSet->GetFirstIDPtr().ID, (LPCTSTR)strFirstID ) 
				&& 0 != IDcmp( pCvActSet->GetSecondIDPtr().ID, (LPCTSTR)strFirstID ) )
		{
			continue;
		}

		if( false == strSecondID.IsEmpty() && 0 != IDcmp( pCvActSet->GetSecondIDPtr().ID, (LPCTSTR)strSecondID ) 
				&& 0 != IDcmp( pCvActSet->GetFirstIDPtr().ID, (LPCTSTR)strSecondID ) )
		{
			continue;
		}

		// HYS-1877: PIBCV set from 6WAYCTRLVALVSET_TAB has no article number
		if( true == bIsFor6WayValveTab && 0 == StringCompare( _T( "-" ), pCvActSet->GetArtNum() ) )
		{
			continue;
		}

		return pCvActSet;
	}

	return NULL;
}

CDB_Set *CTableSet::FindSet( CString strFirstID, CString strSecondID )
{
	// HYS-1877: To manage 6-way valve kit. Condition to exclude PIBCV set from _T( "6WAYCTRLVALVSET_TAB" ).
	bool bIsFor6WayValveTab = false;

	if( 0 == IDcmp( GetIDPtr().ID, _T( "6WAYCTRLVALVSET_TAB" ) ) )
	{
		bIsFor6WayValveTab = true;
	}

	for( IDPTR idptr = GetFirst(); _T( '\0' ) != *idptr.ID; idptr = GetNext() )
	{
		CDB_Set* pCvActSet = dynamic_cast<CDB_Set*>( idptr.MP );

		if( NULL == pCvActSet )
		{
			continue;
		}

		// We offer now the possibility to search in any order.
		if( false == strFirstID.IsEmpty() && 0 != IDcmp( pCvActSet->GetFirstIDPtr().ID, (LPCTSTR)strFirstID ) 
				&& 0 != IDcmp( pCvActSet->GetSecondIDPtr().ID, (LPCTSTR)strFirstID ) )
		{
			continue;
		}

		if( false == strSecondID.IsEmpty() && 0 != IDcmp( pCvActSet->GetSecondIDPtr().ID, (LPCTSTR)strSecondID )
				&& 0 != IDcmp( pCvActSet->GetFirstIDPtr().ID, (LPCTSTR)strSecondID ) )
		{
			continue;
		}

		// HYS-1877: PIBCV set from 6WAYCTRLVALVSET_TAB has no article number
		if( true == bIsFor6WayValveTab && 0 == StringCompare( _T( "-" ), pCvActSet->GetArtNum() ) )
		{
			continue;
		}

		return pCvActSet;
	}

	return NULL;
}

////////////////////////////////////////////////////////////////
//
//		CDB_Set : Accessories
//
////////////////////////////////////////////////////////////////
IMPLEMENT_DATA( CDB_Set)

CDB_Set::CDB_Set( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_Thing( pDataBase, ID )
{
	m_strReference.Empty();
	m_strName.Empty();
	m_FirstDPtr = _NULL_IDPTR;
	m_SecondIDPtr = _NULL_IDPTR;
	m_AccGroupIDPtr = _NULL_IDPTR;
	m_strParameter.Empty();
	m_strNextID.Empty();
	m_pStr = NULL;

	SetTACBXVer( 0 );				// Skipped by default
}

IDPTR CDB_Set::GetMbrIDPtr( IDPTR &idptr )
{
	if( _T('\0') != *idptr.ID )
	{
		if( NULL == idptr.MP )
		{
			idptr.DB = GetpTADB();
			Extend( &idptr );
		}
	}
	else
	{
		return _NULL_IDPTR;
	}

	return idptr;
}

CString CDB_Set::GetReference()
{
	m_pStr = GetpXmlStrTab()->GetIDSStr( (LPCTSTR)m_strReference );

	if( NULL != m_pStr )
	{
		return m_pStr->c_str();
	}
	else
	{
		return m_strReference;
	}
}

// HYS-1877: To get localized string name.
CString CDB_Set::GetName()
{
	m_pStr = GetpXmlStrTab()->GetIDSStr( (LPCTSTR)m_strName );

	if( NULL != m_pStr )
	{
		return m_pStr->c_str();
	}
	else
	{
		return m_strName;
	}
}

void CDB_Set::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_Thing::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;
		bool bFirstIDAvailable = false;
		bool bSecondIDAvailable = false;
	
		if( _T('\0') != *m_FirstDPtr.ID && 0 != _tcscmp( _NO_ID, m_FirstDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_FirstDPtr.ID );
		
			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("First ID (%s) is defined but not found in the database."), m_FirstDPtr.ID );
			}
		
			bFirstIDAvailable = IDPtr.MP->IsAvailable();
	
			// Try to cast in a 'CDB_TAProduct' to set 'PartOfaSet' flag if possible.
			CDB_TAProduct *pTAP = dynamic_cast<CDB_TAProduct*>( IDPtr.MP );
		
			// If the set is deleted, but not product, probably the 'PartOfaSet' flag of the product is reset to '#ePartOfaSetNo'.
			// In that case we don't have to verify. This is why the first condition.
			if( false == IsDeleted() && NULL != pTAP )
			{
				if( ePartOfaSetNo == pTAP->GetPartOfaSet() )
				{
					HYSELECT_THROW( _T("Object (%s) belongs to a the set but is not flagged as a part of a set: 'CDB_Product::PartOfaSet' = ePartOfaSetNo."), m_FirstDPtr.ID );
				}
			}
		}

		if( _T('\0') !=  *m_SecondIDPtr.ID && 0 != _tcscmp( _NO_ID, m_SecondIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_SecondIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Second ID (%s) is defined but not found in the database."), m_SecondIDPtr.ID );
			}

			bSecondIDAvailable = IDPtr.MP->IsAvailable();
		
			// Try to cast in a 'CDB_TAProduct' to set 'PartOfaSet' flag if possible.
			// Remark: it's a 'CDB_TAProduct' when Dpc - Bv set for example.
			CDB_TAProduct *pTAP = dynamic_cast<CDB_TAProduct*>( IDPtr.MP );

			// If the set is deleted, but not product, probably the 'PartOfaSet' flag of the product is reset to '#ePartOfaSetNo'.
			// In that case we don't have to verify. This is why the first condition.
			if( false == IsDeleted() && NULL != pTAP )
			{
				if( ePartOfaSetNo == pTAP->GetPartOfaSet() )
				{
					HYSELECT_THROW( _T("Object (%s) belongs to a the set but is not flagged as a part of a set: 'CDB_Product::PartOfaSet' = ePartOfaSetNo."), m_FirstDPtr.ID );
				}
			}
		}
	
		// First ID and Second ID should be available together
		if( bFirstIDAvailable != bSecondIDAvailable )
		{
			SetAvailable( false );
		}

		if( _T('\0') !=  *m_AccGroupIDPtr.ID && 0 != _tcscmp( _NO_ID, m_AccGroupIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_AccGroupIDPtr.ID );
		
			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Accessory group ID (%s) is defined but not found in the database."),m_AccGroupIDPtr.ID );
			}
		
			if( false == IDPtr.MP->IsClass( CLASS( CDB_RuledTable ) ) )
			{
				HYSELECT_THROW( _T("Accessory group ID (%s) is found in the database but it's not a 'CDB_RuledTable' object."), m_AccGroupIDPtr.ID );
			}
		}

		// HYS-1877: Verify m_strNextID
		if( 0 != StringCompare( _T("NO_ID"), m_strNextID ) )
		{
			IDPtr = GetDB()->Get( m_strNextID );
		
			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("NextID (%s) is defined but not found in the database."), m_strNextID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_Set::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

void CDB_Set::OnDatabaseDestroy()
{
	CDB_Thing::OnDatabaseDestroy();
}

void CDB_Set::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_Set *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_Set' object!") );
		}

		// Base class.
		CDB_Thing::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_Set" class.
		CDB_Set *pclDestinationSet = (CDB_Set *)pclDestination;

		pclDestinationSet->SetReference( m_strReference );
		pclDestinationSet->SetName( m_strName );
		pclDestinationSet->SetFirstID( m_FirstDPtr.ID );
		pclDestinationSet->SetSecondID( m_SecondIDPtr.ID );
		pclDestinationSet->SetAccGroupID( m_AccGroupIDPtr.ID );
		pclDestinationSet->SetParameter( m_strParameter );
		
		// HYS-1877.
		pclDestinationSet->SetNextID( m_strNextID );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_Set::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_SET_VERSION		3
// Version 3: 2022-04-20: HYS-1877: Add 'm_strNextID' to allow us to use a kit with more than 2 products.
// Version 2: 2016-05-25: Add 'm_strParameter' to allow us to use filtering on the set.
void CDB_Set::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_SET_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_Thing::Write( outf );
	
	// Info.
	WriteString( outf, (LPCTSTR)m_strReference );
	WriteString( outf, (LPCTSTR)m_strName );
	WriteString( outf, (LPCTSTR)m_FirstDPtr.ID );
	WriteString( outf, (LPCTSTR)m_SecondIDPtr.ID );
	WriteString( outf, (LPCTSTR)m_AccGroupIDPtr.ID );
	WriteString( outf, (LPCTSTR)m_strParameter );
	WriteString( outf, (LPCTSTR)m_strNextID );
}

bool CDB_Set::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_SET_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDB_Thing::Read( inpf ) )
	{
		return false;
	}

	// Info.
	if( false == ReadString( inpf, m_strReference ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_strName ) )
	{
		return false;
	}

	m_FirstDPtr = _NULL_IDPTR;
	m_FirstDPtr.DB = GetDB();

	if( false == ReadString( inpf, m_FirstDPtr.ID, sizeof( m_FirstDPtr.ID ) ) )
	{
		return false;
	}
	
	m_SecondIDPtr = _NULL_IDPTR;
	m_SecondIDPtr.DB = GetDB();

	if( false == ReadString( inpf, m_SecondIDPtr.ID, sizeof( m_SecondIDPtr.ID ) ) )
	{
		return false;
	}

	m_AccGroupIDPtr = _NULL_IDPTR; 

	if( false == ReadString( inpf, m_AccGroupIDPtr.ID, sizeof( m_AccGroupIDPtr.ID ) ) )
	{
		return false;
	}

	if( Version < 2 )
	{
		return true;
	}

	// Version 2: Add 'm_strParameter' to allow us to use filtering on the set.
	if( false == ReadString( inpf, m_strParameter ) )
	{
		return false;
	}

	if( Version < 3 )
	{
		return true;
	}

	// HYS-1877: Version 3, add 'm_strNextID'.
	if( false == ReadString( inpf, m_strNextID ) )
	{
		return false;
	}

	return true;
}

void CDB_Set::InterpretInheritedData( CString *pStr )
{
	try
	{
		int iPos = pStr->Find( CLASS( CDB_Set ) );

		if( _T("::") != pStr->Left( 2 ) && iPos < 0 )
		{
			CDB_Thing::InterpretInheritedData( pStr );
		}
		else
		{
			if( iPos >= 0 )
			{
				pStr->Delete( iPos,_tcsclen( _T("CDB_Set") ) );
			}

			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( _T("::Reference=") ) > -1 )
			{
				if( _T('"') != strField.GetAt( 0 ) )
				{
					HYSELECT_THROW( _T("'CDB_Set::Reference' (%s) must start with \"."), strField );
				}
				else if( _T('"') != strField.GetAt( strField.GetLength() - 1 ) )
				{
					HYSELECT_THROW( _T("'CDB_Set::Reference' (%s) must end with \"."), strField );
				}

				strField = strField.Mid( 1, strField.GetLength() - 2 );
				m_strReference = strField;
			}
			else if( pStr->Find( _T("::Name=") ) > -1 )
			{
				if( _T('"') != strField.GetAt( 0 ) )
				{
					HYSELECT_THROW( _T("'CDB_Set::Name' (%s) must start with \"."), strField );
				}
				else if( _T('"') != strField.GetAt( strField.GetLength() - 1 ) )
				{
					HYSELECT_THROW( _T("'CDB_Set::Name' (%s) must end with \"."), strField );
				}

				strField = strField.Mid( 1, strField.GetLength() - 2 );
				m_strName = strField;
			}
			else if( pStr->Find( _T("::FirstID=") ) > -1 )
			{
				m_FirstDPtr = _NULL_IDPTR;

				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_Set::FirstID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				_tcsncpy_s( m_FirstDPtr.ID, _ID_LENGTH + 1, (LPCTSTR)strField, _ID_LENGTH );
			}
			else if( pStr->Find( _T("::SecondID=") ) > -1 )
			{
				m_SecondIDPtr = _NULL_IDPTR;

				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_Set::SecondID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}
			
				_tcsncpy_s( m_SecondIDPtr.ID, _ID_LENGTH + 1, (LPCTSTR)strField, _ID_LENGTH );
			}
			else if( pStr->Find( _T("::AccGroupID=") ) > -1 )
			{
				m_AccGroupIDPtr = _NULL_IDPTR;

				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_Set::AccGroupID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}
			
				_tcsncpy_s( m_AccGroupIDPtr.ID, _ID_LENGTH + 1, (LPCTSTR)strField, _ID_LENGTH );
			}
			else if( pStr->Find( _T("::Parameter=") ) > -1 )
			{
				if( _T('"') != strField.GetAt( 0 ) )
				{
					HYSELECT_THROW( _T("'CDB_Set::Parameter' (%s) must start with \"."), strField );
				}
				else if( _T('"') != strField.GetAt( strField.GetLength() - 1 ) )
				{
					HYSELECT_THROW( _T("'CDB_Set::Parameter' (%s) must end with \"."), strField );
				}

				strField = strField.Mid( 1, strField.GetLength() - 2 );
				m_strParameter = strField;
			}
			// HYS-1877
			else if( pStr->Find( _T("::NextID=") ) > -1 )
			{
				if( _T('"') != strField.GetAt( 0 ) )
				{
					HYSELECT_THROW( _T("'CDB_Set::NextID' (%s) must start with \"."), strField );
				}
				else if( _T('"') != strField.GetAt( strField.GetLength() - 1 ) )
				{
					HYSELECT_THROW( _T("'CDB_Set::NextID' (%s) must end with \"."), strField );
				}

				strField = strField.Mid( 1, strField.GetLength() - 2 );
				m_strNextID = strField;
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Set::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_Set::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		//
		//	new:CDB_Set(ID)
		//	{
		//		--> CDB_Thing
		//		"Reference"			Reference to the TA Product
		//		"Name"				Name of the product
		//		CVID				Identifier of the control valve
		//		ACTID				Identifier of the actuator
		//		AccessGroupID		Identifier of the accessory group
		//		"Parameter"			String to allow to apply some filter.
		//		"NextID"			Identifier of the next ID to consider can be Set ID, Group ID, Product ID etc...
		//	}
		//
		////////////////////////////////////////////////////////////////

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_Set *)idptr.MP )->Copy( this );
		
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_Thing::ReadText( inpf, pusLineCount );

			// Reference.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_strReference = ptcLine;

			if( _T('"') != m_strReference.GetAt( 0 ) )
			{
				HYSELECT_THROW( _T("Reference must start with \" (pos: %i)."), *pusLineCount );
			}
		
			if( _T('"') != m_strReference.GetAt( m_strReference.GetLength() - 1 ) )
			{
				HYSELECT_THROW( _T("Reference must end with \" (pos: %i)."), *pusLineCount );
			}

			m_strReference.Remove('\"');

			// Name.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_strName = ptcLine;

			if( _T('"') != m_strName.GetAt( 0 ) )
			{
				HYSELECT_THROW( _T("Name must start with \" (pos: %i)."), *pusLineCount );
			}
		
			if( _T('"') != m_strName.GetAt( m_strName.GetLength() - 1 ) )
			{
				HYSELECT_THROW( _T("Name must end with \" (pos: %i)."), *pusLineCount );
			}

			m_strName.Remove('\"');

			// m_FirstDPtr.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("First ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			m_FirstDPtr = _NULL_IDPTR;
			_tcsncpy_s( m_FirstDPtr.ID, _ID_LENGTH + 1, ptcLine, _ID_LENGTH );
			GetFirstIDPtr();

			// m_SecondIDPtr.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Second ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			m_SecondIDPtr = _NULL_IDPTR;
			_tcsncpy_s( m_SecondIDPtr.ID, _ID_LENGTH + 1, ptcLine, _ID_LENGTH );
			GetSecondIDPtr();

			// m_AccGroupIDPtr.
			ptcLine = ReadTextLine( inpf, pusLineCount );

			if( _tcslen( ptcLine ) > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Accessory group ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
			}

			m_AccGroupIDPtr = _NULL_IDPTR;
			_tcsncpy_s( m_AccGroupIDPtr.ID, _ID_LENGTH + 1, ptcLine, _ID_LENGTH );
			GetAccGroupIDPtr();

			// Parameter.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_strParameter = ptcLine;

			if( _T('"') != m_strParameter.GetAt( 0 ) )
			{
				HYSELECT_THROW( _T("Parameter must start with \" (pos: %i)."), *pusLineCount );
			}
		
			if( _T('"') != m_strParameter.GetAt( m_strParameter.GetLength() - 1 ) )
			{
				HYSELECT_THROW( _T("Parameter must end with \" (pos: %i)."), *pusLineCount );
			}

			m_strParameter.Remove('\"');

			// HYS-1877: NextID.
			ptcLine = ReadTextLine( inpf, pusLineCount );
			m_strNextID = ptcLine;

			if( _T('"') != m_strNextID.GetAt( 0 ) )
			{
				HYSELECT_THROW( _T("NextID must start with \" (pos: %i)."), *pusLineCount );
			}
		
			if( _T('"') != m_strNextID.GetAt( m_strNextID.GetLength() - 1 ) )
			{
				HYSELECT_THROW( _T("NextID must end with \" (pos: %i)."), *pusLineCount );
			}

			m_strNextID.Remove('\"');
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Set::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_Set::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str, str1, str2;
	
	// Write object header.
	if( true == IsClass( CLASS( CDB_Set ) ) )
	{
		CData::WriteText( outf, strTab );
	}

	// Opening bracket.
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");
	CDB_Thing::WriteText( outf, strTab );
	
	// Data.
	str1 = m_strReference;
	str2 = _T("\"") + str1 + _T("\"");
	str.Format( _T("\r\n%s"), strTab + str2 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	str1 = m_strName;
	str2 = _T("\"") + str1 + _T("\"");
	str.Format( _T("\r\n%s"), strTab + str2 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	str1 = m_FirstDPtr.ID;
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	str1 = m_SecondIDPtr.ID;
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	str1 = m_AccGroupIDPtr.ID;
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	str1 = m_strParameter;
	str2 = _T("\"") + str1 + _T("\"");
	str.Format( _T("\r\n%s"), strTab + str2 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	// HYS-1877
	str1 = m_strNextID;
	str2 = _T("\"") + str1 + _T("\"");
	str.Format( _T("\r\n%s"), strTab + str2 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	// Closing bracket.
	strTab.Delete( 0 ); // Delete one \t
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}

CData::CheckFilterReturnValue CDB_Set::CheckFilter( CFilterTab *pFilter, CString strFilter )
{
	try
	{
		// ClassName; Table ; ID 	; EDIT ; Parameter	; a,h
		// 0		; 1	    ; 2     ; 3    ; 4          ; 5      

		if( true == strFilter.IsEmpty() )
		{
			HYSELECT_THROW( _T("Filter line can't be empty.") );
		}

		int iFieldNumber = pFilter->GetNumberOfFields( strFilter );

		if( 6 != iFieldNumber )
		{
			HYSELECT_THROW( _T("Number of fields (%i) must be 6."), iFieldNumber );
		}
		
		// Retrieve the command.
		CString str = pFilter->GetField( 3, strFilter );
		
		if( 0 != str.CompareNoCase( _T("EDIT") ) )
		{
			return CData::CFRV_FilterNotApplied;
		}

		// Parameter.
		str = pFilter->GetField( 4, strFilter );

		if( true == str.IsEmpty() )
		{
			return CData::CFRV_FilterNotApplied;
		}

		if( 0 != str.CompareNoCase( m_strParameter ) )
		{
			return CData::CFRV_FilterNotApplied;
		}
		
		// Availability.
		str = pFilter->GetNextField( strFilter );

		if( false == str.IsEmpty() )
		{
			if( _T('0') == str[0] )
			{
				SetAvailable( false );
			}

			if( _T('1') == str[0] )
			{
				SetAvailable( true );
			}

			if( _T('0') == str[2] )
			{
				SetHidden( false );
			}

			if( _T('1') == str[2] )
			{
				SetHidden( true );
			}
		}

		return CData::CFRV_FilterApplied;
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Set::CheckFilter'."), __LINE__, __FILE__ );
		throw;
	}
}

void CDB_Set::DeleteArticle()
{
	CData::DeleteArticle();

	m_strReference = DeleteArticleNumber( m_strReference );
}

#endif 

#ifndef TACBX 
///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_PageField
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_PageField )

CDB_PageField::CDB_PageField( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_String( pDataBase, ID )
{
	memset( m_Field, 0, sizeof( PageField_struct ) );
	SetPredefStyle( PAGESTYLECOMPLETE );
	SetTACBXVer( 0 );				// Skipped by default
}

void CDB_PageField::SetPredefStyle( int iStyle )
{
	// Before any change, don't hesitate to read all the comments in the "DataBObj.h" file for the "CDB_PageField" class and what is following.

	// When we are in the "Result page", we can show/hide some information. In the left tab, we have the "Format columns..." button under the "Displayed information" title.
	// In the "Display fields" dialog that appears, user can either choose to hide/show information with the three or he can choose a predefined style thanks to the 
	// combo below. This is here that we defined predefined style.
	// To ease the read of each array, we return to the line each time we begin a new group defined in the "PageField_enum" enum.
	// For example shut-off valve, the definition is like this:
	//		epfSVINFO,
	//			epfSVINFOPRODUCT,
	//				epfSVINFOPRODUCTNAME,
	//				epfSVINFOPRODUCTSIZE,
	//				epfSVINFOPRODUCTCONNECTION,
	//				epfSVINFOPRODUCTVERSION,
	//				epfSVINFOPRODUCTPN,
	//			epfSVTECHINFO,
	//				epfSVTECHINFOFLOW,
	//			epfSVTECHINFODP,
	//
	// In the line for the shut-off valve below we have: 1,1,1,1,1,1,1,1,1,1,
	// In the description in the "PageField_enum" enum we have well 10 lines, so here we must defined if we show (1) or not (0) for the all 10 cases.
	// 
	// When added new information, be carefull where to add the '1' and '0'.
	// If we take the example in the "DataBObj.h", step 2, case 1, a), we insert a new group before the 'epfSAFETYVALVETECHINFOCOLLECTOR' enum.
	// If must then add a new line just between "Water make-up info" an "Safety valve:
	//
	//		1,1,1,1,1,1,1,									// Water make-up info
	//		1,1,1,1,1,										// New produt
	//		1,1,1,1,1,1,1,1,1,1,1,1,1,						// Safety valve
	// 
	// We have five '1' because in the definition of the "epfNEWPRODUCTINFO" group in the "PageField_enum" enum we have well 5 lines.
	// Now we can take the example in the "DataBObj.h", step 2, case 1, b), we add a new variable in the "epfBLOWTANKINFOPRODUCTPN" existing group.
	// At the moment for the "Blow tank" line we have: 1,1,1,1,1,1,
	// Pay attention that each position is linked to the same variable defined in the "PageField_enum" enum.
	//		Pos. 1	->	epfBLOWTANKINFO
	//		Pos. 2	->		epfBLOWTANKINFOPRODUCT
	//		Pos. 3	->			epfBLOWTANKINFOPRODUCTNAME
	//		Pos. 4	->			epfBLOWTANKINFOPRODUCTSIZE
	//		Pos. 5	->		epfBLOWTANKTECHINFO
	//		Pos. 6	->	epfBLOWTANKTECHINFOPS
	// Here, we have added the "epfBLOWTANKINFOPRODUCTPN" variable just after "epfBLOWTANKINFOPRODUCTSIZE" at the position 4.
	// So, pay attention that if you want for example hide this variable, note well the position:
	//		Pos. 1	->	epfBLOWTANKINFO
	//		Pos. 2	->		epfBLOWTANKINFOPRODUCT
	//		Pos. 3	->			epfBLOWTANKINFOPRODUCTNAME
	//		Pos. 4	->			epfBLOWTANKINFOPRODUCTSIZE
	//		Pos. 5 ->			epfBLOWTANKINFOPRODUCTPN
	//		Pos. 6	->		epfBLOWTANKTECHINFO
	//		Pos. 7	->	epfBLOWTANKTECHINFOPS
	//		1, 1, 1, 1, 0, 1, 1

	switch( iStyle )
	{
		case PAGESTYLECOMPLETE:
			{
				bool btemp[PAGEFIELD_SIZE] = { 
												0,1,1,1,										// none, 1st ref, 2nd ref, water info
												1,1,1,1,1,1,1,1,1,1,1,							// Separator & air vent info
												1,1,1,1,1,1,1,1,1,								// Statico info
												1,1,1,1,1,1,									// Tecbox info
												1,1,1,1,1,1,1,									// Water make-up info
												1,1,1,1,1,1,1,1,1,1,1,1,1,						// Safety valve
												1,1,1,1,1,1,									// Blow tank
												1,1,1,1,1,1,1,1,1,1,1,							// BV info
												1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,					// DpC info
												1,1,1,1,1,1,1,1,1,1,1,1,1,						// DpCBCV info
												1,1,1,1,1,1,1,1,1,1,							// Shut-off valve info
												1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		// Radiator set info
												1,1,1,1,1,1,1,									// DirectSel Info
												1,1,1,1,										// Part Def Info
												1,												// Article
												1,1,1,1,1,										// Pipe info
												1,												// quantity
												1,1,1,											// sale info,
												1,												// remark
												1,1,1,											// DpC DpMin, DS tech info, PD tech info
												1,1,											// not used
												1,1,1,1,1,1,1,1,1,1,1,1,						// Cv Info
												1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,			// Smart control valve info.
												1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,				// Smart differential pressure controller info.
												1,1,1,1,1,1,1,1,1,1,1,							// 6-way valve info.
												1,1,1,1,1,1,1,									// Tap water control info.
												1,1,1,1,										// Floor heating control.
												1,1,1,1,1,1,1,1,1								// HYS-1741: Pressure reducing valve.
											};
				memcpy( m_Field, btemp, sizeof( m_Field ) );
			}
			break;

		case PAGESTYLETECHNICAL:
			{
				bool btemp[PAGEFIELD_SIZE] = { 
												0,1,1,1,										// none, 1st ref, 2nd ref, water info
												1,1,1,1,1,1,1,1,1,1,1,							// Separator & air vent info
												1,1,1,1,1,1,1,1,1,								// Statico info
												1,1,1,1,1,1,									// Tecbox info
												1,1,1,1,1,1,1,									// Water make-up info
												1,1,1,1,1,1,1,1,1,1,1,1,1,						// Safety valve
												1,1,1,1,1,1,									// Blow tank
												1,1,1,1,1,1,1,1,1,1,1,							// BV info
												1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,					// DpC info
												1,1,1,1,1,1,1,1,1,1,1,1,1,						// DpCBCV info
												1,1,1,1,1,1,1,1,1,1,							// Sv info
												1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		// Radiator set info
												1,1,1,1,1,1,1,									// DirectSel Info
												1,1,1,1,										// Part Def Info
												1,												// Article
												1,1,1,1,1,										// Pipe info
												1,												// quantity
												1,1,1,											// sale info,
												1,												// remark
												1,1,1,											// DpC DpMin, DS tech info, PD tech info
												1,1,											// not used
												1,1,1,1,1,1,1,1,1,1,1,1,						// Cv Info
												1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,			// Smart control valve info.
												1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,				// Smart differential pressure controller info.
												1,1,1,1,1,1,1,1,1,1,1,							// 6-way valve info.
												1,1,1,1,1,1,1,									// Tap water control info.
												1,1,1,1,										// Floor heating control.
												1,1,1,1,1,1,1,1,1								// Pressure reducing valve.
											};
				memcpy( m_Field, btemp, sizeof( m_Field ) );
			}
			break;

		case PAGESTYLETECHNICALSHORT:
			{
				bool btemp[PAGEFIELD_SIZE] = { 
												0,1,1,0,										// none, 1st ref, 2nd ref, water info
												1,1,1,1,1,1,1,1,1,1,1,							// Separator & air vent info
												1,1,1,1,1,1,1,0,0,								// Statico info
												1,1,1,1,1,1,									// Tecbox info
												1,1,1,1,1,1,1,									// Water make-up info
												1,1,1,1,1,1,1,1,1,1,1,1,1,						// Safety valve
												1,1,1,1,1,1,									// Blow tank
												1,1,1,1,1,1,1,1,1,1,1,							// BV info
												1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,					// DpC info
												1,1,1,1,1,1,1,1,1,1,1,1,1,						// DpCBCV info
												1,1,1,1,1,1,1,1,1,1,							// Sv info
												1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		// Radiator set info
												1,1,1,1,1,1,1,									// DirectSel Info
												1,1,1,1,										// Part Def Info
												1,												// Article
												1,1,1,0,0,										// Pipe info
												1,												// quantity
												1,1,1,											// sale info,
												1,												// remark
												1,1,1,											// DpC DpMin, DS tech info, PD tech info
												1,1,											// not used
												1,1,1,1,1,1,1,1,1,1,1,1,						// Cv Info
												1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,			// Smart control valve info.
												1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,				// Smart differential pressure controller info.
												1,1,1,1,1,1,1,1,1,1,1,							// 6-way valve info.
												1,1,1,1,1,1,1,									// Tap water control info.
												1,1,1,1,										// Floor heating control.
												1,1,1,1,1,1,1,1,1								// Pressure reducing valve.
											};
				memcpy( m_Field, btemp, sizeof( m_Field ) );
			}
			break;

		case PAGESTYLEORDER:
			{
				bool btemp[PAGEFIELD_SIZE] = { 
												1,1,1,0,										// none, 1st ref, 2nd ref, water info
												1,1,1,1,1,1,1,1,1,1,1,							// Separator & air vent info
												1,1,1,1,1,1,1,1,1,								// Statico info
												1,1,1,1,1,1,									// Tecbox info
												1,1,1,1,1,1,1,									// Water make-up info
												1,1,1,1,1,1,1,1,1,1,1,1,1,						// Safety valve
												1,1,1,1,1,1,									// Blow tank
												1,1,1,1,1,1,1,1,1,1,0,							// BV info
												1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,					// DpC info
												1,1,1,1,1,1,1,1,1,1,1,1,1,						// DpCBCV info
												1,1,1,1,1,1,1,1,1,1,							// Sv info
												1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		// Radiator set info
												1,1,1,1,1,1,1,									// DirectSel Info
												1,1,1,1,										// Part Def Info
												1,												// Article
												1,1,1,0,0,										// Pipe info
												1,												// quantity
												1,1,1,											// sale info,
												0,												// remark
												0,0,0,											// DpC DpMin, DS tech info, PD tech info
												1,1,											// not used
												1,1,1,1,1,1,1,1,1,1,1,1,						// Cv Info
												1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,			// Smart control valve info.
												1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,				// Smart differential pressure controller info.
												1,1,1,1,1,1,1,1,1,1,1,							// 6-way valve info.
												1,1,1,1,1,1,1,									// Tap water control info.
												1,1,1,1,										// Floor heating control.
												1,1,1,1,1,1,1,1,1								// Pressure reducing valve.
											};
				memcpy( m_Field, btemp, sizeof( m_Field ) );
			}
			break;

		default:
			memset( m_Field, 0, sizeof( m_Field ) );
			break;
	}	
	Modified();
}

void CDB_PageField::OnDatabaseDestroy()
{
	CData::OnDatabaseDestroy();
}

bool CDB_PageField::CompareFields( CDB_PageField *pf )
{
	for( int i = 0; i < PAGEFIELD_SIZE; i++ )
	{
		if( m_Field[i] != pf->m_Field[i] )
		{
			return false;
		}
	}
	
	return true;
}

void CDB_PageField::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_PageField *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_PageField' object!") );
		}

		// Base class.
		CDB_String::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_PageField" class.
		CDB_PageField *pclDestinationPageField = (CDB_PageField *)pclDestination;

		for( int i = 0; i < eECVersionLast; i++ )
		{
			pclDestinationPageField->SetField( (PageField_enum)i, m_Field[i] );
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_PageField::Copy' method with the object '%s'."), GetIDPtr().ID )
}

// Version 7: add 'epfRD7TECHINFODPMIN' and 'epfRD7TECHINFOFLOWRANGE'.
// Version 8: add air vents & separators.
// Version 9: add pressure maintenance products.
// Version 10: make no difference between separators and air vents because there are displayed on the same page.
// Version 11: insert 'epfSEPARATORAIRVENTINFOPRODUCTDPP' after 'epfSEPARATORAIRVENTINFOPRODUCTNAME'.
// Version 12: 'epfSTATICOINFOPRODUCTSIZE', 'epfSTATICOTECHINFO', 'epfSTATICOTECHINFOOPTINITPRESS' and 
//             'epfSTATICOTECHINFOOPTWATERRES' removed.
//             'epfSTATICOINFOPRODUCTWEIGHT' and 'epfSTATICOINFOPRODUCTMAXWEIGHT' added.
// Version 13: 2015-08-31: Water make-up info added.
// Version 14: 2015-11-18: Combined DpC and B&C valve.
// Version 15: 2016-07-08: Shut-off valve added.
// Version 16: 2018-11-19: Safety valve added.
// Version 17: 2019-05-27: Blow tank added.
// Version 18: 2019-10-28: 6-way valve added.
// Version 19: 2020-02-06: HYS-1258: Tap water control added.
// Version 20: 2020-10-30: HYS-1517: Smart control valve added.
// Version 21: 2021-04-05: HYS-1571: Floor heating control added.
// Version 22: 2021-04-22: HYS-1660: Add power supply, input & output signal for smart control valve.
// Version 23: 2021-06-14: HYS-1677: - Remove 'epfSMARTCONTROLVALVEINFOPRODUCTACTUATORNAME'.
//									 - Add localization, control mode and power max added for smart control valve.
// Version 24: 2021-11-09: HYS-1741: Add Pressure reducing valve information.
// Version 25: 2022-07-19: HYS-1958: Add smart differential pressure controller information.
// Version 26: 2022-07-26: HYS-1958: Add pressure drop information for smart control valve.
// Version 27: 2022-05-22: HYS-2027: Add flow and power max for smart differential pressure controller before 'epfSMARTDPCTECHINFODP'.
#define CDB_PAGEFIELD_VERSION	27
void CDB_PageField::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_PAGEFIELD_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_String::Write( outf );
	
	// Infos
	outf.write( (char *)m_Field, eECVersionLast );
}

// For all operation in this class, don't hesitate to read all the comments in the "DataBObj.h" file and in each method.
bool CDB_PageField::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_PAGEFIELD_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_String::Read( inpf ) )
	{
		return false;
	}
	
	// Infos.
	int iNbrField = 0;

	if( 1 == Version )
	{
		iNbrField = eECVersion1;
		ASSERT( eECVersion1 <= eECVersionBiggest );
	}
	else if( 2 == Version )
	{
		iNbrField = eECVersion2;
		ASSERT( eECVersion2 <= eECVersionBiggest );
	}
	else if( 3 == Version )
	{
		iNbrField = eECVersion3;
		ASSERT( eECVersion3 <= eECVersionBiggest );
	}
	else if( 4 == Version )
	{
		iNbrField = eECVersion4;
		ASSERT( eECVersion4 <= eECVersionBiggest );
	}
	else if( 5 == Version )
	{
		iNbrField = eECVersion5;
		ASSERT( eECVersion5 <= eECVersionBiggest );
	}
	else if( 6 == Version )
	{
		iNbrField = eECVersion6;
		ASSERT( eECVersion6 <= eECVersionBiggest );
	}
	else if( 7 == Version )
	{
		iNbrField = eECVersion7;
		ASSERT( eECVersion7 <= eECVersionBiggest );
	}
	else if( 8 == Version )
	{
		iNbrField = eECVersion8;
		ASSERT( eECVersion8 <= eECVersionBiggest );
	}
	else if( 9 == Version )
	{
		iNbrField = eECVersion9;
		ASSERT( eECVersion9 <= eECVersionBiggest );
	}
	else if( 10 == Version )
	{
		iNbrField = eECVersion10;
		ASSERT( eECVersion10 <= eECVersionBiggest );
	}
	else if( 11 == Version )
	{
		iNbrField = eECVersion11;
		ASSERT( eECVersion11 <= eECVersionBiggest );
	}
	else if( 12 == Version )
	{
		iNbrField = eECVersion12;
		ASSERT( eECVersion12 <= eECVersionBiggest );
	}
	else if( 13 == Version )
	{
		iNbrField = eECVersion13;
		ASSERT( eECVersion13 <= eECVersionBiggest );
	}
	else if( 14 == Version )
	{
		iNbrField = eECVersion14;
		ASSERT( eECVersion14 <= eECVersionBiggest );
	}
	else if( 15 == Version )
	{
		iNbrField = eECVersion15;
		ASSERT( eECVersion15 <= eECVersionBiggest );
	}
	else if( 16 == Version )
	{
		iNbrField = eECVersion16;
		ASSERT( eECVersion16 <= eECVersionBiggest );
	}
	else if( 17 == Version )
	{
		iNbrField = eECVersion17;
		ASSERT( eECVersion17 <= eECVersionBiggest );
	}
	else if( 18 == Version )
	{
		iNbrField = eECVersion18;
		ASSERT( eECVersion18 <= eECVersionBiggest );
	}
	else if( 19 == Version )
	{
		iNbrField = eECVersion19;
		ASSERT( eECVersion19 <= eECVersionBiggest );
	}
	else if( 20 == Version )
	{
		iNbrField = eECVersion20;
		ASSERT( eECVersion20 <= eECVersionBiggest );
	}
	else if( 21 == Version )
	{
		iNbrField = eECVersion21;
		ASSERT( eECVersion21 <= eECVersionBiggest );
	}
	else if( 22 == Version )
	{
		iNbrField = eECVersion22;
		ASSERT( eECVersion22 <= eECVersionBiggest );
	}
	else if( 23 == Version )
	{
		iNbrField = eECVersion23;
		ASSERT( eECVersion23 <= eECVersionBiggest );
	}
	// HYS-1741
	else if( 24 == Version )
	{
		iNbrField = eECVersion24;
		ASSERT( eECVersion24 <= eECVersionBiggest );
	}
	else if( 25 == Version )
	{
		iNbrField = eECVersion25;
		ASSERT( eECVersion25 <= eECVersionBiggest );
	}
	else if( 26 == Version )
	{
		iNbrField = eECVersion26;
		ASSERT( eECVersion26 <= eECVersionBiggest );
	}
	// HYS-2067
	else if( 27 == Version )
	{
		iNbrField = eECVersion27;
		ASSERT( eECVersion27 <= eECVersionBiggest );
	}

	inpf.read( (char *)m_Field, iNbrField );

	if( Version < 2 )
	{
		// Version 2: direct selection and partially defined info before 'epfARTICLE'.
		memmove( (PVOID)&m_Field[epfARTICLE_V2], (const PVOID)&m_Field[epfARTICLE_V1], eECVersion1 - epfARTICLE_V1 );

		m_Field[epfDSINFO_V2] = 1;
		m_Field[epfDSINFOPRODUCT_V2] = 1;
		m_Field[epfDSINFOPRODUCTNAME_V2] = 1;
		m_Field[epfDSINFOPRODUCTSIZE_V2] = 1;
		m_Field[epfDSINFOPRODUCTCONNECTION_V2] = 1;
		m_Field[epfDSINFOPRODUCTVERSION_V2] = 1;
		m_Field[epfDSINFOPRODUCTPN_V2] = 1;
		m_Field[epfPDINFO_V2] = 1;
		m_Field[epfPDINFOPRODUCT_V2] = 1;
		m_Field[epfPDINFOPRODUCTNAME_V2] = 1;
		m_Field[epfPDINFOPRODUCTSIZE_V2] = 1;
	}
		
	if( Version < 3 )
	{
		// Version 3: 'epfDPCTECHINFODPMIN', 'epfDSTECHINFO' and 'epfPDTECHINFO' added at the end.
		m_Field[epfDPCTECHINFODPMIN_V3] = 1;
		m_Field[epfDSTECHINFO_V3] = 1;
		m_Field[epfPDTECHINFO_V3] = 1;
	}

	if( Version < 4 )
	{
		// Version 4: CV added at the end.
		m_Field[epfNU1_V4] = 1;
		m_Field[epfNU2_V4] = 1;
		m_Field[epfCVINFO_V4] = 1;
		m_Field[epfCVINFOPRODUCT_V4] = 1;
		m_Field[epfCVINFOPRODUCTNAME_V4] = 1;
		m_Field[epfCVINFOPRODUCTKV_V4] = 1;
		m_Field[epfCVINFOPRODUCTBDYMATERIAL_V4] = 1;
		m_Field[epfCVINFOPRODUCTCONNECTION_V4] = 1;
		m_Field[epfCVINFOPRODUCTVERSION_V4] = 1;
		m_Field[epfCVINFOPRODUCTPN_V4] = 1;
		m_Field[epfCVTECHINFO_V4] = 1;
		m_Field[epfCVTECHINFOFLOW_V4] = 1;
		m_Field[epfCVTECHINFODP_V4] = 1;
	}

	if( Version < 5 )
	{
		// Version 5: 'epfCVTECHINFOSETTING' enumerator added at the end.
		m_Field[epfCVTECHINFOSETTING_V5] = 1;
	}

	if( Version < 6 )
	{
		// Version 6: 'epfDPCINFOPRODUCTVERSION' enumerator inserted before 'epfDPCINFOPRODUCTDPLRANGE'.
		memmove( (PVOID)&m_Field[epfDPCINFOPRODUCTDPLRANGE_V6], (const PVOID)&m_Field[epfDPCINFOPRODUCTDPLRANGE_V5], eECVersion5 - epfDPCINFOPRODUCTDPLRANGE_V5 );
		m_Field[epfDPCINFOPRODUCTVERSION_V6] = 1;
	}

	if( Version < 7 )
	{
		// Version 7: 'epfRD7TECHINFODPMIN' and 'epfRD7TECHINFOFLOWRANGE' enumerators inserted just before 'epfRD7RADINFO'.
		memmove( (PVOID)&m_Field[epfRD7RADINFO_V7], (const PVOID)&m_Field[epfRD7RADINFO_V6], eECVersion6 - epfRD7RADINFO_V6 );
		m_Field[epfRD7TECHINFODPMIN_V7] = 1;
		m_Field[epfRD7TECHINFOFLOWRANGE_V7] = 1;
	}
		
	if( Version < 8 )
	{
		// Version 8: enumerators for separators & air vents inserted before 'epfBVINFO'.
		memmove( (PVOID)&m_Field[epfBVINFO_V8], (const PVOID)&m_Field[epfBVINFO_V7], eECVersion7 - epfBVINFO_V7 );
		m_Field[epfAIRVENTINFO_V8] = 1;
		m_Field[epfAIRVENTINFOPRODUCT_V8] = 1;
		m_Field[epfAIRVENTINFOPRODUCTNAME_V8] = 1;
		m_Field[epfAIRVENTINFOPRODUCTDPP_V8] = 1;
		m_Field[epfAIRVENTINFOPRODUCTSIZE_V8] = 1;
		m_Field[epfAIRVENTINFOPRODUCTCONNECTION_V8] = 1;
		m_Field[epfAIRVENTINFOPRODUCTVERSION_V8] = 1;
		m_Field[epfAIRVENTINFOPRODUCTPN_V8] = 1;
		m_Field[epfSEPARATORINFO_V8] = 1;
		m_Field[epfSEPARATORINFOPRODUCT_V8] = 1;
		m_Field[epfSEPARATORINFOPRODUCTNAME_V8] = 1;
		m_Field[epfSEPARATORINFOPRODUCTSIZE_V8] = 1;
		m_Field[epfSEPARATORINFOPRODUCTCONNECTION_V8] = 1;
		m_Field[epfSEPARATORINFOPRODUCTVERSION_V8] = 1;
		m_Field[epfSEPARATORINFOPRODUCTPN_V8] = 1;
		m_Field[epfSEPARATORTECHINFO_V8] = 1;
		m_Field[epfSEPARATORTECHINFOFLOW_V8] = 1;
		m_Field[epfSEPARATORTECHINFODP_V8] = 1;
	}

	if( Version < 9 )
	{
		// Version 9: enumerators for pressure maintenance products inserted before 'epfBVINFO'.
		memmove( (PVOID)&m_Field[epfBVINFO_V9], (const PVOID)&m_Field[epfBVINFO_V8], eECVersion8 - epfBVINFO_V8 );

		m_Field[epfSTATICOINFO_V9] = 1;
		m_Field[epfSTATICOINFOPRODUCT_V9] = 1;
		m_Field[epfSTATICOINFOPRODUCTNAME_V9] = 1;
		m_Field[epfSTATICOINFOPRODUCTSIZE_V9] = 1;
		m_Field[epfSTATICOINFOPRODUCTCONNECTION_V9] = 1;
		m_Field[epfSTATICOINFOPRODUCTNOMINALVOLUME_V9] = 1;
		m_Field[epfSTATICOINFOPRODUCTMAXPRESSURE_V9] = 1;
		m_Field[epfSTATICOINFOPRODUCTTEMPRANGE_V9] = 1;
		m_Field[epfSTATICOTECHINFO_V9] = 1;
		m_Field[epfSTATICOTECHINFOOPTINITPRESS_V9] = 1;
		m_Field[epfSTATICOTECHINFOOPTWATERRES_V9] = 1;
		m_Field[epfTECHBOXINFO_V9] = 1;
		m_Field[epfTECHBOXINFOPRODUCT_V9] = 1;
		m_Field[epfTECHBOXINFOPRODUCTNAME_V9] = 1;
		m_Field[epfTECHBOXINFOPRODUCTPS_V9] = 1;
		m_Field[epfTECHBOXINFOPRODUCTPOWER_V9] = 1;
		m_Field[epfTECHBOXINFOPRODUCTSUPPLYVOLTAGE_V9] = 1;
	}

	if( Version < 10 )
	{
		// Version 10: enumerators for air vents alone has been merged with separators.
		//             8 enumerators were removed.
		memmove( (PVOID)&m_Field[epfSEPARATORAIRVENTINFO_V10], (const PVOID)&m_Field[epfSEPARATORINFO_V9], eECVersion9 - epfSEPARATORINFO_V9 );
	}

	if( Version < 11 )
	{
		// Version 11: insert enumerator 'epfSEPARATORAIRVENTINFOPRODUCTDPP' before 'epfSEPARATORAIRVENTINFOPRODUCTSIZE'.
		memmove( (PVOID)&m_Field[epfSEPARATORAIRVENTINFOPRODUCTSIZE_V11], (const PVOID)&m_Field[epfSEPARATORAIRVENTINFOPRODUCTSIZE_V10], eECVersion10 - epfSEPARATORAIRVENTINFOPRODUCTSIZE_V10 );
		m_Field[epfSEPARATORAIRVENTINFOPRODUCTDPP_V11] = 1;
	}

	if( Version < 12 )
	{
		// Version 12: 'epfSTATICOTECHINFO', 'epfSTATICOTECHINFOOPTINITPRESS' and 'epfSTATICOTECHINFOOPTWATERRES' removed.
		memmove( (PVOID)&m_Field[epfSTATICOTECHINFO_V11], (const PVOID)&m_Field[epfTECHBOXINFO_V11], eECVersion11 - epfTECHBOXINFO_V11 );

		int iShiftUp = epfTECHBOXINFO_V11 - epfSTATICOTECHINFO_V11;

		// Version 12: 'epfSTATICOINFOPRODUCTSIZE' removed.
		memmove( (PVOID)&m_Field[epfSTATICOINFOPRODUCTSIZE_V11], (const PVOID)&m_Field[epfSTATICOINFOPRODUCTCONNECTION_V11], eECVersion11 - epfSTATICOINFOPRODUCTCONNECTION_V11 - iShiftUp );

		iShiftUp += ( epfSTATICOINFOPRODUCTCONNECTION_V11 - epfSTATICOINFOPRODUCTSIZE_V11 );
	
		// Version 12: insert 'epfSTATICOINFOPRODUCTWEIGHT' and 'epfSTATICOINFOPRODUCTMAXWEIGHT' before 'epfTECHBOXINFO'.
		// -2 to avoid that the two last octets of 'm_Field' to be moved outside the buffer.
		memmove( (PVOID)&m_Field[epfTECHBOXINFO_V12], (const PVOID)&m_Field[epfTECHBOXINFO_V11 - iShiftUp], eECVersion11 - epfTECHBOXINFO_V11 - iShiftUp );

		// In version 11, vessel and tecbox enumerators already existed but not available in the 'CDlgPageField'. Thus by default these values are all
		// set to 'false'.
		m_Field[epfSTATICOINFO_V12] = 1;
		m_Field[epfSTATICOINFOPRODUCT_V12] = 1;
		m_Field[epfSTATICOINFOPRODUCTNAME_V12] = 1;
		m_Field[epfSTATICOINFOPRODUCTCONNECTION_V12] = 1;
		m_Field[epfSTATICOINFOPRODUCTNOMINALVOLUME_V12] = 1;
		m_Field[epfSTATICOINFOPRODUCTMAXPRESSURE_V12] = 1;
		m_Field[epfSTATICOINFOPRODUCTTEMPRANGE_V12] = 1;
		m_Field[epfTECHBOXINFO_V12] = 1;
		m_Field[epfTECHBOXINFOPRODUCT_V12] = 1;
		m_Field[epfTECHBOXINFOPRODUCTNAME_V12] = 1;
		m_Field[epfTECHBOXINFOPRODUCTPS_V12] = 1;
		m_Field[epfTECHBOXINFOPRODUCTPOWER_V12] = 1;
		m_Field[epfTECHBOXINFOPRODUCTSUPPLYVOLTAGE_V12] = 1;

		// Set the new fields.
		m_Field[epfSTATICOINFOPRODUCTWEIGHT_V12] = 1;
		m_Field[epfSTATICOINFOPRODUCTMAXWEIGHT_V12] = 1;
	}

	if( Version < 13 )
	{
		// Version 13: Water make-up info added before 'epfBVINFO'.
		memmove( (PVOID)&m_Field[epfBVINFO_V13], (const PVOID)&m_Field[epfBVINFO_V12], eECVersion12 - epfBVINFO_V12 );

		m_Field[epfWATERMAKEUPINFO_V13] = 1;
		m_Field[epfWATERMAKEUPINFOPRODUCT_V13] = 1;
		m_Field[epfWATERMAKEUPINFOPRODUCTNAME_V13] = 1;
		m_Field[epfWATERMAKEUPINFOPRODUCTFUNCTIONS_V13] = 1;
		m_Field[epfWATERMAKEUPINFOPRODUCTCAPACITY_V13] = 1;
		m_Field[epfWATERMAKEUPINFOPRODUCTHEIGHT_V13] = 1;
		m_Field[epfWATERMAKEUPINFOPRODUCTWEIGHT_V13] = 1;
	}

	if( Version < 14 )
	{
		// Version 14: Combined Dp controller and Balancing & control valve info added before 'epfRD7INFO'.
		memmove( (PVOID)&m_Field[epfRD7INFO_V14], (const PVOID)&m_Field[epfRD7INFO_V13], eECVersion13 - epfRD7INFO_V13 );

		m_Field[epfDPCBCVINFO_V14] = 1;
		m_Field[epfDPCBCVINFOPRODUCT_V14] = 1;
		m_Field[epfDPCBCVINFOPRODUCTNAME_V14] = 1;
		m_Field[epfDPCBCVINFOPRODUCTSIZE_V14] = 1;
		m_Field[epfDPCBCVINFOPRODUCTCONNECTION_V14] = 1;
		m_Field[epfDPCBCVINFOPRODUCTVERSION_V14] = 1;
		m_Field[epfDPCBCVINFOPRODUCTDPLRANGE_V14] = 1;
		m_Field[epfDPCBCVINFOPRODUCTPN_V14] = 1;
		m_Field[epfDPCBCVTECHINFO_V14] = 1;
		m_Field[epfDPCBCVTECHINFOFLOW_V14] = 1;
		m_Field[epfDPCBCVTECHINFODPMIN_V14] = 1;
		m_Field[epfDPCBCVTECHINFOSETTING_V14] = 1;
		m_Field[epfDPCBCVTECHINFOHMIN_V14] = 1;
	}

	if( Version < 15 )
	{
		// Version 15: Shut-off valve info added before 'epfRD7INFO'.
		memmove( (PVOID)&m_Field[epfRD7INFO_V15], (const PVOID)&m_Field[epfRD7INFO_V14], eECVersion14 - epfRD7INFO_V14 );

		m_Field[epfSVINFO_V15] = 1;
		m_Field[epfSVINFOPRODUCT_V15] = 1;
		m_Field[epfSVINFOPRODUCTNAME_V15] = 1;
		m_Field[epfSVINFOPRODUCTSIZE_V15] = 1;
		m_Field[epfSVINFOPRODUCTCONNECTION_V15] = 1;
		m_Field[epfSVINFOPRODUCTVERSION_V15] = 1;
		m_Field[epfSVINFOPRODUCTPN_V15] = 1;
		m_Field[epfSVTECHINFO_V15] = 1;
		m_Field[epfSVTECHINFOFLOW_V15] = 1;
		m_Field[epfSVTECHINFODP_V15] = 1;
	}

	if( Version < 16 )
	{
		// Version 16: Safety valve info added before 'epfBVINFO'.
		memmove( (PVOID)&m_Field[epfBVINFO_V16], (const PVOID)&m_Field[epfBVINFO_V15], eECVersion15 - epfBVINFO_V15 );

		m_Field[epfSAFETYVALVEINFO_V16] = 1;
		m_Field[epfSAFETYVALVEINFOPRODUCT_V16] = 1;
		m_Field[epfSAFETYVALVEINFOPRODUCTNAME_V16] = 1;
		m_Field[epfSAFETYVALVEINFOPRODUCTSIZE_V16] = 1;
		m_Field[epfSAFETYVALVEINFOPRODUCTCONNECTION_V16] = 1;
		m_Field[epfSAFETYVALVEINFOPRODUCTPROJECTTYPE_V16] = 1;
		m_Field[epfSAFETYVALVETECHINFO_V16] = 1;
		m_Field[epfSAFETYVALVETECHINFOSETPRESSURE_V16] = 1;
		m_Field[epfSAFETYVALVETECHINFOHEATGENERATORTYPE_V16] = 1;
		m_Field[epfSAFETYVALVETECHINFOPOWERMAX_V16] = 1;
		m_Field[epfSAFETYVALVETECHINFOPOWERSYSTEM_V16] = 1;
		m_Field[epfSAFETYVALVETECHINFOCOLLECTORMAX_V16] = 1;
		m_Field[epfSAFETYVALVETECHINFOCOLLECTOR_V16] = 1;
	}

	if( Version < 17 )
	{
		// Version 17: Blow tank info added before 'epfBVINFO'.
		memmove( (PVOID)&m_Field[epfBVINFO_V17], (const PVOID)&m_Field[epfBVINFO_V16], eECVersion16 - epfBVINFO_V16 );

		m_Field[epfBLOWTANKINFO_V17] = 1;
		m_Field[epfBLOWTANKINFOPRODUCT_V17] = 1;
		m_Field[epfBLOWTANKINFOPRODUCTNAME_V17] = 1;
		m_Field[epfBLOWTANKINFOPRODUCTSIZE_V17] = 1;
		m_Field[epfBLOWTANKTECHINFO_V17] = 1;
		m_Field[epfBLOWTANKTECHINFOPS_V17] = 1;
	}

	if( Version < 18 )
	{
		// Version 18: 6-way valve info added after 'epfCVTECHINFOSETTING'.
		m_Field[epf6WAYVALVEINFO_V18] = 1;
		m_Field[epf6WAYVALVEINFOPRODUCT_V18] = 1;
		m_Field[epf6WAYVALVEINFOPRODUCTNAME_V18] = 1;
		m_Field[epf6WAYVALVEINFOPRODUCTKVS_V18] = 1;
		m_Field[epf6WAYVALVEINFOPRODUCTBDYMATERIAL_V18] = 1;
		m_Field[epf6WAYVALVEINFOPRODUCTCONNECTION_V18] = 1;
		m_Field[epf6WAYVALVEINFOPRODUCTVERSION_V18] = 1;
		m_Field[epf6WAYVALVEINFOPRODUCTPN_V18] = 1;
		m_Field[epf6WAYVALVETECHINFO_V18] = 1;
		m_Field[epf6WAYVALVETECHINFOFLOW_V18] = 1;
		m_Field[epf6WAYVALVETECHINFODP_V18] = 1;
	}

	if( Version < 19 )
	{
		// Version 19: tap water control info added after 'epf6WAYVALVETECHINFODP'.
		m_Field[epfTAPWATERCONTROLINFO_V19] = 1;
		m_Field[epfTAPWATERCONTROLINFOPRODUCT_V19] = 1;
		m_Field[epfTAPWATERCONTROLINFOPRODUCTNAME_V19] = 1;
		m_Field[epfTAPWATERCONTROLINFOPRODUCTSETTINGRANGE_V19] = 1;
		m_Field[epfTAPWATERCONTROLINFOPRODUCTBDYMATERIAL_V19] = 1;
		m_Field[epfTAPWATERCONTROLINFOPRODUCTCONNECTION_V19] = 1;
		m_Field[epfTAPWATERCONTROLINFOPRODUCTVERSION_V19] = 1;
	}

	if( Version < 20 )
	{
		// Version 20: Smart control valve info added before 'epf6WAYVALVEINFO'.
		memmove( (PVOID)&m_Field[epf6WAYVALVEINFO_V20], (const PVOID)&m_Field[epf6WAYVALVEINFO_V19], eECVersion19 - epf6WAYVALVEINFO_V19 );

		m_Field[epfSMARTCONTROLVALVEINFO_V20] = 1;
		m_Field[epfSMARTCONTROLVALVEINFOPRODUCT_V20] = 1;
		m_Field[epfSMARTCONTROLVALVEINFOPRODUCTNAME_V20] = 1;
		m_Field[epfSMARTCONTROLVALVEINFOPRODUCTBDYMATERIAL_V20] = 1;
		m_Field[epfSMARTCONTROLVALVEINFOPRODUCTCONNECTION_V20] = 1;
		m_Field[epfSMARTCONTROLVALVEINFOPRODUCTPN_V20] = 1;
		m_Field[epfSMARTCONTROLVALVEINFOPRODUCTKVS_V20] = 1;
		m_Field[epfSMARTCONTROLVALVEINFOPRODUCTQNOM_V20] = 1;
		m_Field[epfSMARTCONTROLVALVEINFOPRODUCTACTUATORNAME_V20] = 1;
		m_Field[epfSMARTCONTROLVALVETECHINFO_V20] = 1;
		m_Field[epfSMARTCONTROLVALVETECHINFOFLOW_V20] = 1;
		m_Field[epfSMARTCONTROLVALVETECHINFODPMIN_V20] = 1;
	}

	if( Version < 21 )
	{
		// Version 21: Floor heating control info added after 'epfTAPWATERCONTROLINFOPRODUCTVERSION_V20'.
		m_Field[epfFLOORHEATINGCONTROLINFO_V21] = 1;
		m_Field[epfFLOORHEATINGCONTROLINFOPRODUCT_V21] = 1;
		m_Field[epfFLOORHEATINGCONTROLINFOPRODUCTNAME_V21] = 1;
		m_Field[epfFLOORHEATINGCONTROLINFOPRODUCTADDINFO_V21] = 1;
	}

	if( Version < 22 )
	{
		// Version 22: Smart control valve power supply, input and output signal added before 'epfSMARTCONTROLVALVEINFOPRODUCTACTUATORNAME_V21'.
		memmove( (PVOID)&m_Field[epfSMARTCONTROLVALVEINFOPRODUCTACTUATORNAME_V22], (const PVOID)&m_Field[epfSMARTCONTROLVALVEINFOPRODUCTACTUATORNAME_V21], eECVersion21 - epfSMARTCONTROLVALVEINFOPRODUCTACTUATORNAME_V21 );

		m_Field[epfSMARTCONTROLVALVEINFOPRODUCTPOWERSUPPLY_V22] = 1;
		m_Field[epfSMARTCONTROLVALVEINFOPRODUCTINPUTSIGNAL_V22] = 1;
		m_Field[epfSMARTCONTROLVALVEINFOPRODUCTOUTPUTSIGNAL_V22] = 1;
	}

	if( Version < 23 )
	{
		// Version 23: remove 'epfSMARTCONTROLVALVEINFOPRODUCTACTUATORNAME_V22'.
		memmove( (PVOID)&m_Field[epfSMARTCONTROLVALVEINFOPRODUCTACTUATORNAME_V22], (const PVOID)&m_Field[epfSMARTCONTROLVALVETECHINFO_V22], eECVersion22 - epfSMARTCONTROLVALVETECHINFO_V22 + 1 );

		// Version 23: Smart control valve localization, control mode and power max added before 'epf6WAYVALVEINFO_V22'.
		memmove( (PVOID)&m_Field[epf6WAYVALVEINFO_V23], (const PVOID)&m_Field[epf6WAYVALVEINFO_V22], eECVersion22 - epf6WAYVALVEINFO_V22 );

		m_Field[epfSMARTCONTROLVALVETECHINFOLOCALIZATION_V23] = 1;
		m_Field[epfSMARTCONTROLVALVETECHINFOCONTROLMODE_V23] = 1;
		m_Field[epfSMARTCONTROLVALVETECHINFOPOWERMAX_V23] = 1;
	}

	// HYS-1741
	if( Version < 24 )
	{
		// Version 24: Add Pressure reducer valve.
		m_Field[epfPRESSUREREDUCVALVEINFOPRODUCTNAME_V24] = 1;
		m_Field[epfPRESSUREREDUCVALVEINFOPRODUCTBDYMATERIAL_V24] = 1;
		m_Field[epfPRESSUREREDUCVALVEINFOPRODUCTCONNECTION_V24] = 1;
		m_Field[epfPRESSUREREDUCVALVEINFOPRODUCTVERSION_V24] = 1;
		m_Field[epfPRESSUREREDUCVALVEINFOPRODUCTPN_V24] = 1;
		m_Field[epfPRESSUREREDUCVALVEINFOPRODUCTINLETPRESS_V24] = 1;
		m_Field[epfPRESSUREREDUCVALVEINFOPRODUCTOUTLETPRESS_V24] = 1;
	}

	// HYS-1958: add smart differential pressure controller.
	if( Version < 25 )
	{
		// Version 25: Smart differential pressure controller added before 'epf6WAYVALVEINFO'.
		memmove( (PVOID)&m_Field[epf6WAYVALVEINFO_V25], (const PVOID)&m_Field[epf6WAYVALVEINFO_V24], eECVersion24 - epf6WAYVALVEINFO_V24 );

		m_Field[epfSMARTDPCINFO_V25] = 1;
		m_Field[epfSMARTDPCINFOPRODUCT_V25] = 1;
		m_Field[epfSMARTDPCINFOPRODUCTNAME_V25] = 1;
		m_Field[epfSMARTDPCINFOPRODUCTBDYMATERIAL_V25] = 1;
		m_Field[epfSMARTDPCINFOPRODUCTCONNECTION_V25] = 1;
		m_Field[epfSMARTDPCINFOPRODUCTPN_V25] = 1;
		m_Field[epfSMARTDPCINFOPRODUCTKVS_V25] = 1;
		m_Field[epfSMARTDPCINFOPRODUCTQNOM_V25] = 1;
		m_Field[epfSMARTDPCINFOPRODUCTDPMAX_V25] = 1;
		m_Field[epfSMARTDPCTECHINFO_V25] = 1;
		m_Field[epfSMARTDPCTECHINFODP_V25] = 1;
		m_Field[epfSMARTDPCTECHINFODPMIN_V25] = 1;
		m_Field[epfSMARTDPCTECHINFODPMAX_V25] = 1;
		m_Field[epfSMARTDPCTECHINFOLOCALIZATION_V25] = 1;
	}

	// HYS-1958: add pressure drop for smart control valve.
	if( Version < 26 )
	{
		// Version 26: 'epfSMARTCONTROLVALVETECHINFODP' added before 'epfSMARTCONTROLVALVETECHINFODPMIN'.
		memmove( (PVOID)&m_Field[epfSMARTCONTROLVALVETECHINFODP_V26], (const PVOID)&m_Field[epfSMARTCONTROLVALVETECHINFODPMIN_V25], eECVersion25 - epfSMARTCONTROLVALVETECHINFODPMIN_V25 );
		m_Field[epfSMARTCONTROLVALVETECHINFODP_V26] = 1;
	}

	// HYS-2067: Add flow and power max for smart differential pressure controller before 'epfSMARTDPCTECHINFODP'.
	if( Version < 27 )
	{
		memmove( (PVOID)&m_Field[epfSMARTDPCTECHINFODP], (const PVOID)&m_Field[epfSMARTDPCTECHINFODP_V26], eECVersion26 - epfSMARTDPCTECHINFODP_V26 );
		m_Field[epfSMARTDPCTECHINFOFLOW] = 1;
		m_Field[epfSMARTDPCTECHINFOPOWERMAX] = 1;
	}

	// Before any change, don't hesitate to read all the comments in the "DataBObj.h" file for the "CDB_PageField" class and what is following.
	// 
	// First step.
	// Ex: if we create here the version 28, before add new lines, we need first to modify the previous ones.
	//		if( Version < 27 )
	//		{
	//			memmove( (PVOID)&m_Field[epfSMARTDPCTECHINFODP], (const PVOID)&m_Field[epfSMARTDPCTECHINFODP_V26], eECVersion26 - epfSMARTDPCTECHINFODP_V26 );
	//			m_Field[epfSMARTDPCTECHINFOFLOW] = 1;
	//			m_Field[epfSMARTDPCTECHINFOPOWERMAX] = 1;
	//		}
	//			-> "memmove( (PVOID)&m_Field[epfSMARTDPCTECHINFODP]" must be replaced by "memmove( (PVOID)&m_Field[epfSMARTDPCTECHINFODP_V27]" by adding "_V27' and the end of "epfSMARTDPCTECHINFODP".
	//			-> For "m_Field" just add also "_V27 at the end of each variables:
	//					m_Field[epfSMARTDPCTECHINFOFLOW_V27] = 1;
	//					m_Field[epfSMARTDPCTECHINFOPOWERMAX_V27] = 1;
	//
	// Second step. 
	//		Case 1: If the new variables for version 28 are added at the end of the 'PageField_enum' enum we just need to add these new variables in this way:
	//				if( Version < 28 )
	//				{
	//					m_Field[epfLastn-1Variable] = 1;
	//					m_Field[epfLastnVaraible] = 1;
	//				}
	//		Why? Simply because in the version 27 these variables was not existing and we thus set them to 1 by default. And because there are added
	//		     at the end, we don't disturb what was in the previous version.
	//
	//		Case 2: If the new group for version 28 is inserted anywhere in the previous 'PageField_enum'.
	//		Let's take a little example to simplify. Imagine we have this at this moment for the V27:
	//		   Pos
	//			enum PageField_enum {
	//			0:	epfPRODUCT1INFO,						// V27
	//			1:		epfPRODUCT1INFOPRODUCT,				// V27
	//			2:			epfPRODUCT1INFOPRODUCTNAME,		// V27
	//			3:	epfPRODUCT2INFO,						// V27
	//			4:		epfPRODUCT2INFOPRODUCT,				// V27
	//			5:			epfPRODUCT2INFOPRODUCTNAME		// V27
	//			6:  epfLASTFIELD
	//				};
	//
	//		We want to insert a new product before epfPRODUCT2INFO.
	//		First of all, we need to copy the actual "epfPRODUCT2INFO" in the "DBPageFieldVersion.h" as commented in this file:
	//		  Pos
	//			enum PageField_enum_V27 {
	//			0:	epfPRODUCT1INFO_V27,
	//			1:		epfPRODUCT1INFOPRODUCT_V27,
	//			2:			epfPRODUCT1INFOPRODUCTNAME_V27,
	//			3:	epfPRODUCT2INFO_V27,
	//			4:		epfPRODUCT2INFOPRODUCT_V27,
	//			5:			epfPRODUCT2INFOPRODUCTNAME_V27,
	//			6:  epfLASTFIELD_V27
	//				};
	//
	//		Now in the "DataBObj.h" we add our new group:
	//		  Pos
	//			enum PageField_enum {
	//			0:	epfPRODUCT1INFO,						// V27
	//			1:		epfPRODUCT1INFOPRODUCT,				// V27
	//			2:			epfPRODUCT1INFOPRODUCTNAME,		// V27
	//			3:  epfNEWPRODUCTINFO,						// V28
	//			4:		epfNEWPRODUCTINFOPRODUCT,			// V28
	//			5:			epfPRODUCT1INFOPRODUCTNAME,		// V28
	//			6:	epfPRODUCT2INFO,						// V27
	//			7:		epfPRODUCT2INFOPRODUCT,				// V27
	//			8:			epfPRODUCT2INFOPRODUCTNAME,		// V27
	//			9:  epfLASTFIELD
	//				};
	//
	// Our new group takes the place of Product2 from the version 27. If we read a database containing version below V28 we will read
	// position 0 to 6. But these data will fill pos 0 to 6 of the new V28 version. And then in the position 3, 4 & 5 of the new product info
	// we will have in reality the old version 27 of product 2. Old version of product 2 must be read to the position 7, 8 & 9 !
	//
	// All the data are read in the "m_Field" variable that is defined in the "DataBObj.h" in this way:
	//		struct PageField_struct
	//		{
	//			bool m_Field[eECVersionBiggest];	
	//		};
	//
	// The variable "eECVersionBiggest" is always updated with the number of fields defined in the "PageField_enum" each time we have
	// a new version. For our example "eECVersionLast = eECVersion27" and "eECVersion27" is 6 to contains all the fields defined above (0-6 thus well 7 elements).
	// Now that we have added a new group, we must to add "eECVersion28 = 9" in the "EnumeratorCount" enum defined in the "DataBObj.h" file (0-9 thus well 10 elements).
	//
	// Before reading the version 28, we read all the fields from the position 0-6. In the "m_Field" we have well all the information for Product1 and Product2.
	// But information for Product2 must be moved to the position 6, 7 & 8 for the new V28. This is why we do this:
	//		if( Version < 28 )
	//		{
	//			memmove( (PVOID)&m_Field[epfPRODUCT2INFO], (const PVOID)&m_Field[epfPRODUCT2INFO_V27], eECVersion27 - epfPRODUCT2INFO_V27 );
	//
	//	 Destination = &m_Field[epfPRODUCT2INFO] -> in the new "PageField_enum" the position (epfPRODUCT2INFO) for the destination is 6.
	//   Source      = &m_Field[epfPRODUCT2INFO_V27] -> in the old "PageField_enum" that is now in the "DBPageFieldVersion.h" the position for the source (epfPRODUCT2INFO_V27) is 3.
	//   Size        = eECVersion27 - epfPRODUCT2INFO_V27 = 6 - 3 = 3
	//
	//   The "memmove" will take the values from the position 3, 4 & 5 and put them at the position 6, 7 & 8.
	//   In this way the old information for product 2 are well placed in the new array.
	//
	// And what about our new product ? In the old version, these data were not existing. This is why we add now these lines:
	//			m_Field[epfNEWPRODUCTINFO] = 1;
	//			m_Field[epfNEWPRODUCTINFOPRODUCT] = 1;
	//			m_Field[epfPRODUCT1INFOPRODUCTNAME] = 1;
	//		}
	// We set by default 1, the user will be free after to hide or not these information in the "DlgPageField" dialog.


	return true;
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_PageSetup
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_PageSetup )

CDB_PageSetup::CDB_PageSetup( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_PageField( pDataBase, ID )
{
	_tcsncpy_s( m_tzName, SIZEOFINTCHAR( m_tzName ), _T(""), SIZEOFINTCHAR( m_tzName ) - 1 );
	int i;

	for( i = 0; i < _KEY_NUMBER; i++ )
	{
		m_areKey[i] = epfNONE;
	}

	m_bLogo = true;
	m_bFirstLogo = true;
	
	// HYS-1090: customer logo
	m_bCustoLogo = false;
	m_bFirstCustoLogo = false;
	m_bFirstPage = false;
	m_bShowDate = true;
	m_bShowUserRef = true;
	m_bShowOtherInfo = true;
	m_bShowPrjName = true;
	m_bShowCustRef = true;
	m_bShowComment = true;
	m_bPrintPrjInfo = true;

	for( i = enCheck::FIRSTFIELD; i < enCheck::LASTFIELD; i++ )
	{
		m_bCheck[i] = true;
	}

	for( i = 0; i < _PAGESETUP_ENUM; i++ )
	{
		m_ardMargin[i] = 0.01;
		_tcsncpy_s( m_artzText[i], SIZEOFINTCHAR( m_artzText[i] ), _T(""), SIZEOFINTCHAR( m_artzText[i] ) - 1 );
		memset( &m_arLogFont[(PageSetup_enum)i], 0, sizeof( LOGFONT ) );
		m_arLogFont[(PageSetup_enum)i].lfHeight = 12;		// request a 12-pixel-height font
		_tcsncpy_s( m_arLogFont[(PageSetup_enum)i].lfFaceName, SIZEOFINTCHAR( m_arLogFont[(PageSetup_enum)i].lfFaceName ), _T("Arial"), SIZEOFINTCHAR( m_arLogFont[(PageSetup_enum)i].lfFaceName ) - 1 );        
		m_peAlignment[i] = epaTextLeft;
		m_arFontColor[i] = 0;
	}

	Modified();
	SetTACBXVer(0);				// Skipped by default
}

void CDB_PageSetup::SetName( TCHAR *tzName )
{ 
	if( _tcscmp( m_tzName, tzName ) ) 
	{ 
		_tcsncpy_s( m_tzName, SIZEOFINTCHAR( m_tzName ), tzName, _STRING_LENGTH ); 
		Modified(); 
		m_tzName[_STRING_LENGTH] = 0;
	}
}

void CDB_PageSetup::SetKey( int iKey, PageField_enum eField )
{ 
	if( m_areKey[iKey] != eField )
	{ 
		m_areKey[iKey] = eField; 
		Modified();
	}
}

void CDB_PageSetup::SetLogo( bool fLogo )
{ 
	if( m_bLogo != fLogo )
	{ 
		m_bLogo = fLogo; 
		Modified();
	}
}

void CDB_PageSetup::SetFirstLogo( bool fFirstLogo )
{
	if( m_bFirstLogo != fFirstLogo )
	{
		m_bFirstLogo = fFirstLogo;
		Modified();
	}
}

void CDB_PageSetup::SetCustoLogo( bool fLogo )
{
	if( m_bCustoLogo != fLogo )
	{
		m_bCustoLogo = fLogo;
		Modified();
	}
}

void CDB_PageSetup::SetFirstCustoLogo( bool fFirstLogo )
{
	if( m_bFirstCustoLogo != fFirstLogo )
	{
		m_bFirstCustoLogo = fFirstLogo;
		Modified();
	}
}

void CDB_PageSetup::SetFirstPageDifferent( bool fFirstPage )
{
	if( m_bFirstPage= fFirstPage )
	{
		m_bFirstPage = fFirstPage;
		Modified();
	}
}

void CDB_PageSetup::SetMargin( PageSetup_enum ePage, double dMargin )
{
	if( m_ardMargin[ePage] != dMargin )
	{
		m_ardMargin[ePage] = dMargin;
		Modified();
	}
}

void CDB_PageSetup::SetText( PageSetup_enum ePage, TCHAR *tzText )
{
	if( _tcsncmp( m_artzText[ePage], tzText, _HEADER_LENGTH ) )
	{
		_tcsncpy_s( m_artzText[ePage], SIZEOFINTCHAR( m_artzText[ePage] ), tzText, _HEADER_LENGTH);
		m_artzText[ePage][_HEADER_LENGTH] = 0;
		Modified();
	}
}

void CDB_PageSetup::SetLogFont( PageSetup_enum ePage, LOGFONT *pLogFont )
{
	if( memcmp( &m_arLogFont[ePage], pLogFont, sizeof( LOGFONT ) ) )
	{
		memcpy( &m_arLogFont[ePage], pLogFont, sizeof( LOGFONT ) );
		Modified();
	}
}

void CDB_PageSetup::SetAlignment( PageSetup_enum ePage, PageSetup_Alignment eAlign )
{
	if( m_peAlignment[ePage] != eAlign )
	{
		m_peAlignment[ePage] = eAlign;
		Modified();
	}
}

void CDB_PageSetup::SetFontColor( PageSetup_enum ePage, COLORREF color )
{
	if( m_arFontColor[ePage] != color )
	{
		m_arFontColor[ePage] = color;
		Modified();
	}
}

void CDB_PageSetup::OnDatabaseDestroy()
{
	CData::OnDatabaseDestroy();
}

LPCTSTR CDB_PageSetup::GetText( PageSetup_enum ePage )
{
	// HYS-1090: Verify number of lines. 2 lines are allowed for Header and 4 lines for footer
	int nField = 0;
	int index = 0;
	CStringArray p_outArray;
	CString strField = (TCHAR*)m_artzText[ePage];
	ParseString( strField, _T("\r\n"), &nField, &p_outArray );
	
	if( ( 3 <= nField )
			&& ( ( epsFIRSTHEADER == ePage ) || ( epsHEADER == ePage ) ) )
	{
		strField = p_outArray[0] + _T("\r\n") + p_outArray[1];
		SetText( ePage, (TCHAR*)(LPCTSTR)strField );
	}
	else if( ( 5 <= nField ) && ( ( epsFIRSTFOOTER == ePage ) || ( epsFOOTER == ePage ) ) )
	{
		strField = p_outArray[0] + _T("\r\n") + p_outArray[1];
		strField += _T("\r\n" ) + p_outArray[2] + _T( "\r\n") + p_outArray[3];
		SetText( ePage, (TCHAR*)(LPCTSTR)strField );
	}

	return m_artzText[ePage];
}

bool CDB_PageSetup::GetCheck( enum enCheck part )
{
	bool bReturn = true;

	switch( part )
	{
		case enCheck::AIRVENTSEPARATOR:
			bReturn = TASApp.IsAirVentSepDisplayed();
			break;

		case enCheck::PRESSMAINT:
			bReturn = TASApp.IsPressureMaintenanceDisplayed();
			break;

		case enCheck::SAFETYVALVE:
			bReturn = TASApp.IsSafetyValveDisplayed();
			break;

		case enCheck::DPC:
			bReturn = TASApp.IsDpCDisplayed();
			break;

		case enCheck::DPCBCV:
			bReturn = TASApp.IsDpCBCVDisplayed();
			break;

		case enCheck::SV:
			bReturn = TASApp.IsShutOffValveDisplayed();
			break;

		case enCheck::TRV:
			bReturn = TASApp.IsTrvDisplayed();
			break;

		case enCheck::HUB:
			bReturn = TASApp.IsHubDisplayed();
			break;

		case enCheck::CV:
			bReturn = ( TASApp.IsCvDisplayed() || TASApp.IsBCvDisplayed() || TASApp.IsPICvDisplayed() );
			break;

		case enCheck::SMARTCONTROLVALVE:
			bReturn = TASApp.IsSmartControlValveDisplayed() ;
			break;

		case enCheck::SMARTDPC:
			bReturn = TASApp.IsSmartDpCDisplayed() ;
			break;

		case enCheck::SIXWAYVALVE:
			bReturn = TASApp.Is6WayCVDisplayed();
			break;

		case enCheck::TAPWATERCONTROL:
			bReturn = TASApp.IsTapWaterControlDisplayed();
			break;

		case enCheck::FLOORHEATINGCONTROL:
			bReturn = TASApp.IsFloorHeatingControlDisplayed();
			break;
	}

	if( true == bReturn )
	{
		bReturn = m_bCheck[part];
	}

	return bReturn;
}

// Copy  CDB_PageSetup to another
void CDB_PageSetup::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_PageSetup *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_PageSetup' object!") );
		}
	
		// Base class.
		CDB_PageField::Copy( pclDestination );

		// Copy now what it is common to the "CDB_PageSetup" class.
		CDB_PageSetup *pclDestinationPageSetup = (CDB_PageSetup *)pclDestination;

		pclDestinationPageSetup->SetFirstPageDifferent( GetFirstPageDifferent() );
		pclDestinationPageSetup->SetLogo( GetLogo() );
		pclDestinationPageSetup->SetFirstLogo( GetFirstLogo() );
	
		// HYS-1090: customer logo.
		pclDestinationPageSetup->SetCustoLogo( GetCustoLogo() );
		pclDestinationPageSetup->SetFirstCustoLogo( GetFirstCustoLogo() );
		pclDestinationPageSetup->SetName( (TCHAR *)GetName() );
		pclDestinationPageSetup->SetStyle( this );
		pclDestinationPageSetup->SetShowDate( m_bShowDate );
		pclDestinationPageSetup->SetShowUserRef( m_bShowUserRef );
		pclDestinationPageSetup->SetShowOtherInfo( m_bShowOtherInfo );
		pclDestinationPageSetup->SetShowPrjName( m_bShowPrjName );
		pclDestinationPageSetup->SetShowCustRef( m_bShowCustRef );
		pclDestinationPageSetup->SetShowComment( m_bShowComment );
		pclDestinationPageSetup->SetPrintPrjInfo( m_bPrintPrjInfo );

		int i;
	
		for( i = 0; i < enCheck::LASTFIELD; i++ )
		{
			pclDestinationPageSetup->SetCheck( (enum CDB_PageSetup::enCheck)i, m_bCheck[i] );
		}

		for( i = 0; i < _KEY_NUMBER; i++ )
		{
			pclDestinationPageSetup->SetKey( i, GetKey( i ) );
		}

		for( i = 0; i < _PAGESETUP_ENUM; i++ )
		{
			pclDestinationPageSetup->SetMargin( (PageSetup_enum)i, GetMargin( (PageSetup_enum)i ) );
			pclDestinationPageSetup->SetText( (PageSetup_enum)i, (TCHAR *)GetText( (PageSetup_enum)i ) );
			pclDestinationPageSetup->SetLogFont( (PageSetup_enum)i, &m_arLogFont[i] );
			pclDestinationPageSetup->SetAlignment( (PageSetup_enum)i, m_peAlignment[i] );
			pclDestinationPageSetup->SetFontColor( (PageSetup_enum)i, m_arFontColor[i] );
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_PageSetup::Copy' method with the object '%s'."), GetIDPtr().ID )
}

// Version 5: enCheck::DIRSEL has been removed.
// Version 6: enCheck -> order modified and add 'AIRVENTSEPARATOR' (see .h).
// Version 7: enCheck -> insert 'PRESSMAINT' before 'BV'.
// Version 8: 2015-11-18 -> enCheck -> insert 'DpCBCV'.
// Version 9: 2016-07-08 -> enCheck -> insert 'SV'.
// Version 10: 2018-11-19 -> enCheck -> insert 'SAFETYVALVE'.
// Version 11: 2019-06-26 -> Insert customer m_bCustoLogo and m_bFirstCustoLogo 
// Version 12: 2019-10-28 -> Insert 6-way valve after CV.
// Version 13: HYS-1258: 2020-02-06 -> Insert tap water control after TRV.
// Version 14: HYS-1517: 2020-10-30 -> Insert smart control valve after CV.
// Version 15: HYS-1571: 2021-04-02 -> Insert floor heating control valve after TRV.
// Version 16: HYS-1958: 2022-07-20 -> Insert 'SMARTDPC' after 'SMARTCONTROLVALVE'.
#define CDB_PAGESETUP_VERSION	16
void CDB_PageSetup::Write( OUTSTREAM outf )
{
	LOGFONT lf;

	// Version.
	BYTE Version = CDB_PAGESETUP_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CDB_PageField::Write( outf );
	
	// Info.
	WriteString( outf, m_tzName );
	int i;
	
	for( i = 0; i < _KEY_NUMBER; i++ )
	{
		outf.write( (char *)&m_areKey[i], sizeof( m_areKey[i] ) );
	}
	
	outf.write( (char *)&m_bLogo, sizeof( m_bLogo ) );
	outf.write( (char *)&m_bFirstLogo, sizeof( m_bFirstLogo ) );
	outf.write( (char *)&m_bFirstPage, sizeof( m_bFirstPage ) );
	outf.write( (char *)&m_bShowDate, sizeof( m_bShowDate ) );
	outf.write( (char *)&m_bShowUserRef, sizeof( m_bShowUserRef ) );
	outf.write( (char *)&m_bShowOtherInfo, sizeof( m_bShowOtherInfo ) );
	outf.write( (char *)&m_bShowPrjName, sizeof( m_bShowPrjName ) );
	outf.write( (char *)&m_bShowCustRef, sizeof( m_bShowCustRef ) );
	outf.write( (char *)&m_bShowComment, sizeof( m_bShowComment ) );
	outf.write(( char*)&m_bPrintPrjInfo, sizeof( m_bPrintPrjInfo ) );

	int iNumOfFields = enCheck::LASTFIELD;
	outf.write( (char *)&iNumOfFields, sizeof( iNumOfFields ) );
	
	for( i = 0; i < iNumOfFields; i++ )
	{
		outf.write( (char *)&m_bCheck[i], sizeof( m_bCheck[i] ) );
	}

	for( i = 0; i < _PAGESETUP_ENUM; i++ )
	{
		outf.write( (char *)&m_ardMargin[(PageSetup_enum)i], sizeof( m_ardMargin[(PageSetup_enum)i] ) );
		WriteString( outf, m_artzText[(PageSetup_enum)i] );
		GetLogFont( (PageSetup_enum)i, &lf );
		outf.write( (char *)&m_arLogFont[(PageSetup_enum)i], sizeof( LOGFONT ) );
		outf.write( (char *)&m_peAlignment[i], sizeof( m_peAlignment[i] ) );
		outf.write( (char *)&m_arFontColor[i], sizeof( m_arFontColor[i] ) );
	}
	
	// HYS-1090: customer logo
	outf.write( (char *)&m_bCustoLogo, sizeof( m_bCustoLogo ) );
	outf.write( (char *)&m_bFirstCustoLogo, sizeof( m_bFirstCustoLogo ) );
}

bool CDB_PageSetup::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );
	
	if( Version < 1 || Version > CDB_PAGESETUP_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_PageField::Read( inpf ) )
	{
		return false;
	}
	
	// Info.
	if( false == ReadString( inpf, m_tzName, sizeof( m_tzName ) ) )
	{
		return false;
	}
	
	int i;

	for( i = 0; i < _KEY_NUMBER; i++ )
	{
		inpf.read( (char *)&m_areKey[i], sizeof( m_areKey[i] ) );
	}
	
	inpf.read( (char *)&m_bLogo, sizeof( m_bLogo ) );
	inpf.read( (char *)&m_bFirstLogo, sizeof( m_bFirstLogo ) );
	inpf.read( (char *)&m_bFirstPage, sizeof( m_bFirstPage ) );
	inpf.read( (char *)&m_bShowDate, sizeof( m_bShowDate ) );
	inpf.read( (char *)&m_bShowUserRef, sizeof( m_bShowUserRef ) );
	inpf.read( (char *)&m_bShowOtherInfo, sizeof( m_bShowOtherInfo ) );
	inpf.read( (char *)&m_bShowPrjName, sizeof( m_bShowPrjName ) );
	inpf.read( (char *)&m_bShowCustRef, sizeof( m_bShowCustRef ) );
	inpf.read( (char *)&m_bShowComment, sizeof( m_bShowComment ) );

	if( Version > 2 )
	{
		inpf.read( (char *)&m_bPrintPrjInfo, sizeof( m_bPrintPrjInfo ) );
	}
	
	// Read 'enCheck' in a temporary table to modify order.
	bool bCheck[enCheck::LASTFIELD];

	for( i = enCheck::FIRSTFIELD; i < enCheck::LASTFIELD; i++ )
	{
		bCheck[i] = true;
	}
	
	if( 1 == Version )
	{
		for( i = 0; i < _CHECKBOXNUMBERv1; i++ )
		{
			inpf.read( (char *)&bCheck[i], sizeof( bCheck[i] ) );
		}

		bCheck[enCheck::ARTLIST] = bCheck[enCheck::PARTDEF];
		bCheck[enCheck::PARTDEF] = false;
	}
	else if( 2 == Version || 3 == Version )
	{
		int j = 0;

		for( i = 0; i < _CHECKBOXNUMBERv2; i++ )
		{
			if( i >= enCheck::HUB )
			{
				j = 1;
			}

			inpf.read( (char *)&bCheck[i + j], sizeof( bCheck[i + j] ) );
		}
		bCheck[enCheck::HUB] = 1;
	}
	else if( 4 == Version )
	{
		int iNumOfFields = 0;
		inpf.read( (char *)&iNumOfFields, sizeof( iNumOfFields ) );
		int j = 0;
		
		for( i = 0; i < iNumOfFields; i++ )
		{
			bool bValue;
			inpf.read( (char *)&bValue, sizeof( bValue ) );

			// Bypass old 'enCheck::DIRSEL' that is no more used in code.
			if( 5 == i )
			{
				j = i;
				continue;
			}
		
			bCheck[j] = bValue;
			j++;
		}
	}
	else if( Version >= 5 )
	{
		int iNumOfFields = 0;
		inpf.read( (char *)&iNumOfFields, sizeof( iNumOfFields ) );
		
		for( i = 0; i < iNumOfFields; i++ )
		{
			inpf.read( (char *)&bCheck[i], sizeof( bCheck[i] ) );
		}
	}

	// Reorder.
	if( Version < 6 )
	{
		m_bCheck[enCheck::AIRVENTSEPARATOR] = true;
		m_bCheck[enCheck::PRESSMAINT] = true;
		m_bCheck[enCheck::BV] = bCheck[enCheckOld::oldBV];
		m_bCheck[enCheck::DPC] = bCheck[enCheckOld::oldDPC];
		m_bCheck[enCheck::CV] = bCheck[enCheckOld::oldCV];
		m_bCheck[enCheck::TRV] = bCheck[enCheckOld::oldTRV];
		m_bCheck[enCheck::HUB] = bCheck[enCheckOld::oldHUB];
		m_bCheck[enCheck::PARTDEF] = bCheck[enCheckOld::oldPARTDEF];
		m_bCheck[enCheck::PIPELIST] = bCheck[enCheckOld::oldPIPELIST];
		m_bCheck[enCheck::DIVERSITYFACTOR] = bCheck[enCheckOld::oldDIVERSITYFACTOR];
		m_bCheck[enCheck::ARTLIST] = bCheck[enCheckOld::oldARTLIST];
		m_bCheck[enCheck::TENDERTEXT] = true;
	}
	else if( Version < 7 )
	{
		m_bCheck[enCheck::ARTLIST] = bCheck[enCheck::DIVERSITYFACTOR];
		m_bCheck[enCheck::DIVERSITYFACTOR] = bCheck[enCheck::PIPELIST];
		m_bCheck[enCheck::PIPELIST] = bCheck[enCheck::PARTDEF];
		m_bCheck[enCheck::PARTDEF] = bCheck[enCheck::HUB];
		m_bCheck[enCheck::HUB] = bCheck[enCheck::TRV];
		m_bCheck[enCheck::TRV] = bCheck[enCheck::CV];
		m_bCheck[enCheck::CV] = bCheck[enCheck::DPC];
		m_bCheck[enCheck::DPC] = bCheck[enCheck::BV];
		m_bCheck[enCheck::BV] = bCheck[enCheck::PRESSMAINT];
		m_bCheck[enCheck::PRESSMAINT] = true;
		m_bCheck[enCheck::AIRVENTSEPARATOR] = true;
		m_bCheck[enCheck::TENDERTEXT] = true;
	}
	else if( Version < 8 )
	{
		m_bCheck[enCheck::TENDERTEXT] = bCheck[enCheck::ARTLIST];
		m_bCheck[enCheck::ARTLIST] = bCheck[enCheck::DIVERSITYFACTOR];
		m_bCheck[enCheck::DIVERSITYFACTOR] = bCheck[enCheck::PIPELIST];
		m_bCheck[enCheck::PIPELIST] = bCheck[enCheck::PARTDEF];
		m_bCheck[enCheck::PARTDEF] = bCheck[enCheck::HUB];
		m_bCheck[enCheck::HUB] = bCheck[enCheck::TRV];
		m_bCheck[enCheck::TRV] = bCheck[enCheck::CV];
		m_bCheck[enCheck::CV] = bCheck[enCheck::DPCBCV];
		m_bCheck[enCheck::DPCBCV] = true;							// Inserted in version 8.
		m_bCheck[enCheck::DPC] = bCheck[enCheck::DPC];
		m_bCheck[enCheck::BV] = bCheck[enCheck::BV];
		m_bCheck[enCheck::PRESSMAINT] = bCheck[enCheck::PRESSMAINT];
		m_bCheck[enCheck::AIRVENTSEPARATOR] = bCheck[enCheck::AIRVENTSEPARATOR];
	}
	else if( Version < 9 )
	{
		m_bCheck[enCheck::TENDERTEXT] = bCheck[enCheck::ARTLIST];
		m_bCheck[enCheck::ARTLIST] = bCheck[enCheck::DIVERSITYFACTOR];
		m_bCheck[enCheck::DIVERSITYFACTOR] = bCheck[enCheck::PIPELIST];
		m_bCheck[enCheck::PIPELIST] = bCheck[enCheck::PARTDEF];
		m_bCheck[enCheck::PARTDEF] = bCheck[enCheck::HUB];
		m_bCheck[enCheck::HUB] = bCheck[enCheck::TRV];
		m_bCheck[enCheck::TRV] = bCheck[enCheck::SV];
		m_bCheck[enCheck::SV] = true;								// Inserted in version 9.
		m_bCheck[enCheck::CV] = bCheck[enCheck::CV];
		m_bCheck[enCheck::DPCBCV] = bCheck[enCheck::DPCBCV];
		m_bCheck[enCheck::DPC] = bCheck[enCheck::DPC];
		m_bCheck[enCheck::BV] = bCheck[enCheck::BV];
		m_bCheck[enCheck::PRESSMAINT] = bCheck[enCheck::PRESSMAINT];
		m_bCheck[enCheck::AIRVENTSEPARATOR] = bCheck[enCheck::AIRVENTSEPARATOR];
	}
	else if( Version < 10 )
	{
		m_bCheck[enCheck::TENDERTEXT] = bCheck[enCheck::ARTLIST];
		m_bCheck[enCheck::ARTLIST] = bCheck[enCheck::DIVERSITYFACTOR];
		m_bCheck[enCheck::DIVERSITYFACTOR] = bCheck[enCheck::PIPELIST];
		m_bCheck[enCheck::PIPELIST] = bCheck[enCheck::PARTDEF];
		m_bCheck[enCheck::PARTDEF] = bCheck[enCheck::HUB];
		m_bCheck[enCheck::HUB] = bCheck[enCheck::TRV];
		m_bCheck[enCheck::TRV] = bCheck[enCheck::SV];
		m_bCheck[enCheck::SV] = bCheck[enCheck::CV];
		m_bCheck[enCheck::CV] = bCheck[enCheck::DPCBCV];
		m_bCheck[enCheck::DPCBCV] = bCheck[enCheck::DPC];
		m_bCheck[enCheck::DPC] = bCheck[enCheck::BV];
		m_bCheck[enCheck::BV] = bCheck[enCheck::SAFETYVALVE];
		m_bCheck[enCheck::SAFETYVALVE] = true;						// Inserted in version 10.
		m_bCheck[enCheck::PRESSMAINT] = bCheck[enCheck::PRESSMAINT];
		m_bCheck[enCheck::AIRVENTSEPARATOR] = bCheck[enCheck::AIRVENTSEPARATOR];
	}
	else if( Version < 12 )
	{
		m_bCheck[enCheck::TENDERTEXT] = bCheck[enCheck::ARTLIST];
		m_bCheck[enCheck::ARTLIST] = bCheck[enCheck::DIVERSITYFACTOR];
		m_bCheck[enCheck::DIVERSITYFACTOR] = bCheck[enCheck::PIPELIST];
		m_bCheck[enCheck::PIPELIST] = bCheck[enCheck::PARTDEF];
		m_bCheck[enCheck::PARTDEF] = bCheck[enCheck::HUB];
		m_bCheck[enCheck::HUB] = bCheck[enCheck::TRV];
		m_bCheck[enCheck::TRV] = bCheck[enCheck::SV];
		m_bCheck[enCheck::SV] = bCheck[enCheck::SIXWAYVALVE];
		m_bCheck[enCheck::SIXWAYVALVE] = true;						// Inserted in version 12.
		m_bCheck[enCheck::CV] = bCheck[enCheck::CV];
		m_bCheck[enCheck::DPCBCV] = bCheck[enCheck::DPCBCV];
		m_bCheck[enCheck::DPC] = bCheck[enCheck::DPC];
		m_bCheck[enCheck::BV] = bCheck[enCheck::BV];
		m_bCheck[enCheck::SAFETYVALVE] = bCheck[enCheck::SAFETYVALVE];
		m_bCheck[enCheck::PRESSMAINT] = bCheck[enCheck::PRESSMAINT];
		m_bCheck[enCheck::AIRVENTSEPARATOR] = bCheck[enCheck::AIRVENTSEPARATOR];
	}
	else if( Version < 13 )
	{
		m_bCheck[enCheck::TENDERTEXT] = bCheck[enCheck::ARTLIST];
		m_bCheck[enCheck::ARTLIST] = bCheck[enCheck::DIVERSITYFACTOR];
		m_bCheck[enCheck::DIVERSITYFACTOR] = bCheck[enCheck::PIPELIST];
		m_bCheck[enCheck::PIPELIST] = bCheck[enCheck::PARTDEF];
		m_bCheck[enCheck::PARTDEF] = bCheck[enCheck::HUB];
		m_bCheck[enCheck::HUB] = bCheck[enCheck::TAPWATERCONTROL];
		m_bCheck[enCheck::TAPWATERCONTROL] = true;			// HYS-1258.
		m_bCheck[enCheck::TRV] = bCheck[enCheck::TRV];
		m_bCheck[enCheck::SV] = bCheck[enCheck::SV];
		m_bCheck[enCheck::SIXWAYVALVE] = bCheck[enCheck::SIXWAYVALVE];
		m_bCheck[enCheck::CV] = bCheck[enCheck::CV];
		m_bCheck[enCheck::DPCBCV] = bCheck[enCheck::DPCBCV];
		m_bCheck[enCheck::DPC] = bCheck[enCheck::DPC];
		m_bCheck[enCheck::BV] = bCheck[enCheck::BV];
		m_bCheck[enCheck::SAFETYVALVE] = bCheck[enCheck::SAFETYVALVE];
		m_bCheck[enCheck::PRESSMAINT] = bCheck[enCheck::PRESSMAINT];
		m_bCheck[enCheck::AIRVENTSEPARATOR] = bCheck[enCheck::AIRVENTSEPARATOR];
	}
	else if( Version < 14 )
	{
		m_bCheck[enCheck::TENDERTEXT] = bCheck[enCheck::ARTLIST];
		m_bCheck[enCheck::ARTLIST] = bCheck[enCheck::DIVERSITYFACTOR];
		m_bCheck[enCheck::DIVERSITYFACTOR] = bCheck[enCheck::PIPELIST];
		m_bCheck[enCheck::PIPELIST] = bCheck[enCheck::PARTDEF];
		m_bCheck[enCheck::PARTDEF] = bCheck[enCheck::HUB];
		m_bCheck[enCheck::HUB] = bCheck[enCheck::TAPWATERCONTROL];
		m_bCheck[enCheck::TAPWATERCONTROL] = bCheck[enCheck::TRV];
		m_bCheck[enCheck::TRV] = bCheck[enCheck::SV];
		m_bCheck[enCheck::SV] = bCheck[enCheck::SIXWAYVALVE];
		m_bCheck[enCheck::SIXWAYVALVE] = bCheck[enCheck::SMARTCONTROLVALVE];
		m_bCheck[enCheck::SMARTCONTROLVALVE] = true;	// HYS-1517.
		m_bCheck[enCheck::CV] = bCheck[enCheck::CV];
		m_bCheck[enCheck::DPCBCV] = bCheck[enCheck::DPCBCV];
		m_bCheck[enCheck::DPC] = bCheck[enCheck::DPC];
		m_bCheck[enCheck::BV] = bCheck[enCheck::BV];
		m_bCheck[enCheck::SAFETYVALVE] = bCheck[enCheck::SAFETYVALVE];
		m_bCheck[enCheck::PRESSMAINT] = bCheck[enCheck::PRESSMAINT];
		m_bCheck[enCheck::AIRVENTSEPARATOR] = bCheck[enCheck::AIRVENTSEPARATOR];
	}
	else if( Version < 15 )
	{
		m_bCheck[enCheck::TENDERTEXT] = bCheck[enCheck::ARTLIST];
		m_bCheck[enCheck::ARTLIST] = bCheck[enCheck::DIVERSITYFACTOR];
		m_bCheck[enCheck::DIVERSITYFACTOR] = bCheck[enCheck::PIPELIST];
		m_bCheck[enCheck::PIPELIST] = bCheck[enCheck::PARTDEF];
		m_bCheck[enCheck::PARTDEF] = bCheck[enCheck::HUB];
		m_bCheck[enCheck::HUB] = bCheck[enCheck::TAPWATERCONTROL];
		m_bCheck[enCheck::TAPWATERCONTROL] = bCheck[enCheck::FLOORHEATINGCONTROL];
		m_bCheck[enCheck::FLOORHEATINGCONTROL] = true;		// HYS-1571.
		m_bCheck[enCheck::TRV] = bCheck[enCheck::TRV];
		m_bCheck[enCheck::SV] = bCheck[enCheck::SV];
		m_bCheck[enCheck::SIXWAYVALVE] = bCheck[enCheck::SIXWAYVALVE];
		m_bCheck[enCheck::SMARTCONTROLVALVE] = bCheck[enCheck::SMARTCONTROLVALVE];
		m_bCheck[enCheck::CV] = bCheck[enCheck::CV];
		m_bCheck[enCheck::DPCBCV] = bCheck[enCheck::DPCBCV];
		m_bCheck[enCheck::DPC] = bCheck[enCheck::DPC];
		m_bCheck[enCheck::BV] = bCheck[enCheck::BV];
		m_bCheck[enCheck::SAFETYVALVE] = bCheck[enCheck::SAFETYVALVE];
		m_bCheck[enCheck::PRESSMAINT] = bCheck[enCheck::PRESSMAINT];
		m_bCheck[enCheck::AIRVENTSEPARATOR] = bCheck[enCheck::AIRVENTSEPARATOR];
	}
	else if( Version < 16 )
	{
		m_bCheck[enCheck::TENDERTEXT] = bCheck[enCheck::ARTLIST];
		m_bCheck[enCheck::ARTLIST] = bCheck[enCheck::DIVERSITYFACTOR];
		m_bCheck[enCheck::DIVERSITYFACTOR] = bCheck[enCheck::PIPELIST];
		m_bCheck[enCheck::PIPELIST] = bCheck[enCheck::PARTDEF];
		m_bCheck[enCheck::PARTDEF] = bCheck[enCheck::HUB];
		m_bCheck[enCheck::HUB] = bCheck[enCheck::TAPWATERCONTROL];
		m_bCheck[enCheck::TAPWATERCONTROL] = bCheck[enCheck::FLOORHEATINGCONTROL];
		m_bCheck[enCheck::FLOORHEATINGCONTROL] = bCheck[enCheck::TRV];
		m_bCheck[enCheck::TRV] = bCheck[enCheck::SV];
		m_bCheck[enCheck::SV] = bCheck[enCheck::SIXWAYVALVE];
		m_bCheck[enCheck::SIXWAYVALVE] = bCheck[enCheck::SMARTDPC];
		m_bCheck[enCheck::SMARTDPC] = true;	// Version 16: HYS-1958: 2022-07-20 -> Insert 'SMARTDPC' after 'SMARTCONTROLVALVE'.
		m_bCheck[enCheck::SMARTCONTROLVALVE] = bCheck[enCheck::SMARTCONTROLVALVE];
		m_bCheck[enCheck::CV] = bCheck[enCheck::CV];
		m_bCheck[enCheck::DPCBCV] = bCheck[enCheck::DPCBCV];
		m_bCheck[enCheck::DPC] = bCheck[enCheck::DPC];
		m_bCheck[enCheck::BV] = bCheck[enCheck::BV];
		m_bCheck[enCheck::SAFETYVALVE] = bCheck[enCheck::SAFETYVALVE];
		m_bCheck[enCheck::PRESSMAINT] = bCheck[enCheck::PRESSMAINT];
		m_bCheck[enCheck::AIRVENTSEPARATOR] = bCheck[enCheck::AIRVENTSEPARATOR];
	}
	else
	{
		for( i = enCheck::FIRSTFIELD; i < enCheck::LASTFIELD; i++ )
		{
			m_bCheck[i] = bCheck[i];
		}
	}

	for( i = 0; i < _PAGESETUP_ENUM; i++ )
	{
		m_ardMargin[(PageSetup_enum)i] = ReadDouble( inpf );
		
		if( false == ReadString( inpf, m_artzText[(PageSetup_enum)i], sizeof( m_artzText[(PageSetup_enum)i] ) ) )
		{
			return false;
		}
		
		if( true == g_bSBCSFile )
		{
			inpf.read( (char *)&m_arLogFont[(PageSetup_enum)i], sizeof( LOGFONT ) - sizeof( m_arLogFont[(PageSetup_enum)i].lfFaceName ) );
			BYTE OneChar;

			for( int j = 0; j < SIZEOFINTCHAR( m_arLogFont[(PageSetup_enum)i].lfFaceName ); j++ )
			{
				inpf.read( (char *)&OneChar, sizeof( OneChar ) );
				m_arLogFont[(PageSetup_enum)i].lfFaceName[j] = (TCHAR)OneChar;
			}
		}
		else
		{
			inpf.read( (char *)&m_arLogFont[(PageSetup_enum)i], sizeof( LOGFONT ) );
		}
		
		inpf.read( (char *)&m_peAlignment[i], sizeof( m_peAlignment[i] ) );
		inpf.read( (char *)&m_arFontColor[i], sizeof( m_arFontColor[i] ) );
	}

	// HYS-1090: customer logo
	if( Version >= 11 )
	{
		inpf.read( (char *)&m_bCustoLogo, sizeof( m_bCustoLogo ) );
		inpf.read( (char *)&m_bFirstCustoLogo, sizeof( m_bFirstCustoLogo ) );
	}
	
	return true;
}
#endif
///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_AlienProduct
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_AlienProduct )

CDB_AlienProduct::CDB_AlienProduct( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_Thing( pDataBase, ID )
{
	m_Name = _T("");
}

IDPTR CDB_AlienProduct::GetFamIDPtr()
{
	m_FamIDPtr.DB = GetDB();
	Extend( &m_FamIDPtr );
	return m_FamIDPtr;
}

IDPTR CDB_AlienProduct::GetSizeIDPtr()
{
	m_SizeIDPtr.DB = GetDB();
	Extend( &m_SizeIDPtr );
	return m_SizeIDPtr;
}

int CDB_AlienProduct::GetSizeKey()
{
	CDB_StringID *pclStringID = (CDB_StringID *)( GetSizeIDPtr().MP );
	ASSERT( NULL != pclStringID );

	int iDN;
	pclStringID->GetIDstrAs<int>( 0, iDN );

	return iDN;
}

LPCTSTR CDB_AlienProduct::GetName() 
{ 
	return (LPCTSTR)m_Name.c_str(); 
}

#define CDB_ALIENPRODUCT_VERSION	1
void CDB_AlienProduct::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_ALIENPRODUCT_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_Thing::Write( outf );
	
	WriteString( outf, m_Name.c_str() );
	WriteString( outf, m_FamIDPtr.ID );
	WriteString( outf, m_SizeIDPtr.ID );
}

bool CDB_AlienProduct::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > 1 )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_Thing::Read( inpf ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_Name ) )
	{
		return false;
	}

	if( false == m_FamIDPtr.Read( inpf, GetpTADB() ) )
	{
		return false;
	}

	if( false == m_SizeIDPtr.Read( inpf, GetpTADB() ) )
	{
		return false;
	}

	return true;
}

#ifndef TACBX
void CDB_AlienProduct::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Read base.
		CDB_Thing::ReadText( inpf, pusLineCount );

		ptcLine = ReadTextLine( inpf, pusLineCount );
		int iLength = _tcslen( ptcLine );

		if( iLength > ( _PRODUCT_NAME_LENGTH + 2 ) )
		{
			HYSELECT_THROW( _T("Name (%s) is too long (%i > %i) (pos: %i)."), ptcLine, iLength, ( _PRODUCT_NAME_LENGTH + 2 ), *pusLineCount );
		}

		if( _T('"') != *ptcLine )
		{
			HYSELECT_THROW( _T("Name must start with \" (pos: %i)."), *pusLineCount );
		}
		
		if( _T('"') != ptcLine[iLength - 1] )
		{
			HYSELECT_THROW( _T("Name must end with \" (pos: %i)."), *pusLineCount );
		}

		ptcLine[iLength - 1] = _T('\0');										// For removing ""
		m_Name = &ptcLine[1];											

		if( m_Name.size() <= 0 )
		{
			HYSELECT_THROW( _T("Name can't be empty (pos: %i)."), *pusLineCount );
		}
	
		// Family ID.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		iLength = _tcslen( ptcLine );

		if( iLength > _ID_LENGTH )
		{
			HYSELECT_THROW( _T("Family ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, iLength, _ID_LENGTH, *pusLineCount );
		}

		m_FamIDPtr = _NULL_IDPTR;
		_tcsncpy_s( m_FamIDPtr.ID, _ID_LENGTH + 1, ptcLine, _ID_LENGTH );
		m_FamIDPtr.DB = GetDB();
	
		// Size ID.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		iLength = _tcslen( ptcLine );

		if( iLength > _ID_LENGTH )
		{
			HYSELECT_THROW( _T("Size ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, iLength, _ID_LENGTH, *pusLineCount );
		}

		m_SizeIDPtr = _NULL_IDPTR;
		_tcsncpy_s( m_SizeIDPtr.ID, _ID_LENGTH + 1, ptcLine, _ID_LENGTH );
		m_SizeIDPtr.DB = GetDB();

		// Close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_AlienProduct::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

CData::CheckFilterReturnValue CDB_AlienProduct::CheckFilter( CFilterTab *pFilter, CString strFilter )
{
	try
	{
		//	Filter string
		//  CDB_ClassName;TABLE;ID;EDIT;FAMILY;Availability
		//	Field 0			1	2	3	4			5
		//	
		if( true == strFilter.IsEmpty() )
		{
			HYSELECT_THROW( _T("Filter line can't be empty.") );
		}

		int iFieldNumber = pFilter->GetNumberOfFields( strFilter );
		
		// EDIT.
		CString str;
		str = pFilter->GetField( 3, strFilter );

		if( str.CompareNoCase( _T("EDIT") ) )
		{
			return CData::CFRV_FilterNotApplied;
		}

		// FAMILY.
		str = pFilter->GetNextField( strFilter );

		if( false == str.IsEmpty() )
		{
			if( _tcscmp( (LPCTSTR)str, GetFamIDPtr().ID ) )
			{
				return CData::CFRV_FilterNotApplied;
			}
		}

		// Availability.
		str = pFilter->GetNextField( strFilter );

		if( false == str.IsEmpty() )
		{
			if( _T('0') == str[0] )
			{
				SetAvailable( 0 );
			}

			if( _T('1') == str[0] )
			{
				SetAvailable( 1 );
			}

			if( _T('0') == str[2] )
			{
				SetHidden( 0 );
			}

			if( _T('1') == str[2] )
			{
				SetHidden( 1 );
			}
		}

		return CData::CFRV_FilterApplied;
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_AlienProduct::CheckFilter'."), __LINE__, __FILE__ );
		throw;
	}
}

#endif
///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_UPRegValve
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_AlienRegValve )

CDB_AlienRegValve::CDB_AlienRegValve( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_AlienProduct( pDataBase, ID )
{
	m_Name = _T("");
	m_ValveCharIDPtr = _NULL_IDPTR;
	m_dKvsSignal = 0.0;
}

#define CDB_ALIENREGVALVE_VERSION	1
void CDB_AlienRegValve::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_ALIENREGVALVE_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CDB_AlienProduct::Write( outf );
	WriteString( outf, m_ValveCharIDPtr.ID );
	WriteDouble( outf, m_dKvsSignal );
}

bool CDB_AlienRegValve::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > 1 )
	{
		return false;
	}
	
	// Base class.
	if( false == CDB_AlienProduct::Read( inpf ) )
	{
		return false;
	}
	
	TCHAR buf[CSTRING_LINE_SIZE_MAX];

	if( false == ReadString( inpf, buf, sizeof( buf ) ) )
	{
		return false;
	}

	ASSERT( _tcslen( buf ) <= _ID_LENGTH );
	_tcsncpy_s( m_ValveCharIDPtr.ID, SIZEOFINTCHAR( m_ValveCharIDPtr.ID), buf, SIZEOFINTCHAR( m_ValveCharIDPtr.ID) - 1 );

	m_dKvsSignal = ReadDouble( inpf );
	return true;
}

void CDB_AlienRegValve::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_Thing::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( _T('\0') !=  *m_ValveCharIDPtr.ID && 0 != _tcscmp( _NO_ID, m_ValveCharIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_ValveCharIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Valve characteristic ID (%s) is defined but not found in the database."), m_ValveCharIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_ValveCharacteristic ) ) )
			{
				HYSELECT_THROW( _T("Valve characteristic ID (%s) is found in the database but it's not a 'CDB_ValveCharacteristic' object."), m_ValveCharIDPtr.ID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_AlienRegValve::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

#ifndef TACBX
void CDB_AlienRegValve::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Read base.
		CDB_AlienProduct::ReadText( inpf, pusLineCount );

		// Valve characteristic ID.
		m_ValveCharIDPtr = _NULL_IDPTR;
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _tcslen( ptcLine ) > _ID_LENGTH )
		{
			HYSELECT_THROW( _T("Valve characteristic ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
		}

		_tcsncpy_s( m_ValveCharIDPtr.ID, SIZEOFINTCHAR( m_ValveCharIDPtr.ID ), ptcLine, SIZEOFINTCHAR( m_ValveCharIDPtr.ID ) - 1 );

		// Kvs signal.
		TCHAR *ptcEndPtr;
		ptcLine = ReadTextLine( inpf, pusLineCount );

		m_dKvsSignal = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert Kvs signal value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		if( m_dKvsSignal < 0.0 && m_dKvsSignal != -1.0 )
		{
			HYSELECT_THROW( _T("Kv signal (%f) must be either equal to -1 or higher or equal to 0 (pos: %i)."), m_dKvsSignal, *pusLineCount );
		}

		// Close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_AlienRegValve::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif

CDB_ValveCharacteristic *CDB_AlienRegValve::GetValveCharacteristic()
{
	GetValveCharIDPtr();
	return dynamic_cast<CDB_ValveCharacteristic *>( m_ValveCharIDPtr.MP );
}

IDPTR CDB_AlienRegValve::GetValveCharIDPtr()
{
	if( NULL == m_ValveCharIDPtr.MP )
	{
		if( _T('\0') !=  *m_ValveCharIDPtr.ID && 0 != IDcmp( m_ValveCharIDPtr.ID, _NO_ID ) )
		{
			m_ValveCharIDPtr.DB = GetDB();
			Extend(&m_ValveCharIDPtr);
		}
	}
	
	return m_ValveCharIDPtr;
}

////////////////////////////////////////////////////////////////
//
//		CRegValvAlienTab :
//
////////////////////////////////////////////////////////////////
//	Inherit from CTable
////////////////////////////////////////////////////////////////
IMPLEMENT_DATA( CRegValvAlienTab )

CRegValvAlienTab::CRegValvAlienTab( CDataBase *pDataBase, LPCTSTR ID ):CTable( pDataBase, ID )
{
}

////////////////////////////////////////////////////////////////
//
//		CFamAlienTab :
//
////////////////////////////////////////////////////////////////
//	Inherit from CTable
////////////////////////////////////////////////////////////////
IMPLEMENT_DATA( CCharAlienTab )

CCharAlienTab::CCharAlienTab( CDataBase *pDataBase, LPCTSTR ID ):CTable( pDataBase, ID )
{
}


////////////////////////////////////////////////////////////////
//
//		CCharAlienTab :
//
////////////////////////////////////////////////////////////////
//	Inherit from CTable
////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CFamAlienTab )

CFamAlienTab::CFamAlienTab( CDataBase *pDataBase, LPCTSTR ID ):CTable( pDataBase, ID )
{
}



#ifndef TACBX
///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_RadNomCond
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_RadNomCond )

CDB_RadNomCond::CDB_RadNomCond( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
	m_RadNomCond_struct.m_dTs = 0.0;
	m_RadNomCond_struct.m_dTr = 0.0;
	m_RadNomCond_struct.m_dTi = 0.0;
	m_RadNomCond_struct.m_bFix = true;
	SetTACBXVer( 0 );				// Skipped by default
}

LPCTSTR CDB_RadNomCond::GetName()
{
	static CString name;
	
	CUnitDatabase *pUnitDB = CDimValue::AccessUDB();
	UnitDesign_struct ud = pUnitDB->GetUnit( _U_TEMPERATURE, pUnitDB->GetDefaultUnitIndex( _U_TEMPERATURE ) );
	
	double dVal = m_RadNomCond_struct.m_dTs / GetConvOf( ud ) - GetOffsetOf( ud );
	CString str = WriteDouble( dVal, 1, 0, 0 );
	name = str + _T("/");

	dVal = m_RadNomCond_struct.m_dTr / GetConvOf( ud ) - GetOffsetOf( ud );
	str = WriteDouble( dVal, 1, 0, 0 );
	name += str + _T("/");

	dVal = m_RadNomCond_struct.m_dTi / GetConvOf( ud ) - GetOffsetOf( ud );
	str = WriteDouble( dVal, 1, 0, 0 );
	name += str;
	
	return (LPCTSTR)name;
}

void CDB_RadNomCond::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_RadNomCond *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_RadNomCond' object!") );
		}

		// Base class.
		CData::Copy( pclDestination );

		// Copy now what it is common to the "CDB_RadNomCond" class.
		CDB_RadNomCond *pclDestinationRadNomCond = (CDB_RadNomCond *)pclDestination;

		pclDestinationRadNomCond->SetTs( m_RadNomCond_struct.m_dTs );
		pclDestinationRadNomCond->SetTi( m_RadNomCond_struct.m_dTi );
		pclDestinationRadNomCond->SetTr( m_RadNomCond_struct.m_dTr );
		pclDestinationRadNomCond->SetFix( m_RadNomCond_struct.m_bFix );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_RadNomCond::Copy' method with the object '%s'."), GetIDPtr().ID )
}

void CDB_RadNomCond::Write( OUTSTREAM outf )
{
	// Version
	BYTE Version = 1;

	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CData::Write( outf );
	outf.write( (char *)&m_RadNomCond_struct.m_dTs, sizeof( m_RadNomCond_struct.m_dTs ) );
	outf.write( (char *)&m_RadNomCond_struct.m_dTr, sizeof( m_RadNomCond_struct.m_dTr ) );
	outf.write( (char *)&m_RadNomCond_struct.m_dTi, sizeof( m_RadNomCond_struct.m_dTi ) );
	outf.write( (char *)&m_RadNomCond_struct.m_bFix, sizeof( m_RadNomCond_struct.m_bFix ) );
}

bool CDB_RadNomCond::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > 1 )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	m_RadNomCond_struct.m_dTs = ReadDouble( inpf );
	m_RadNomCond_struct.m_dTr = ReadDouble( inpf );
	m_RadNomCond_struct.m_dTi = ReadDouble( inpf );
	inpf.read( (char *)&m_RadNomCond_struct.m_bFix, sizeof( m_RadNomCond_struct.m_bFix ) );
	
	return true;
}

void CDB_RadNomCond::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Read base.
		CData::ReadText( inpf, pusLineCount );

		TCHAR *ptcEndPtr;
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_RadNomCond_struct.m_dTs = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert the supply temperature value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_RadNomCond_struct.m_dTr = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert the return temperature value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_RadNomCond_struct.m_dTi = _tcstod( ptcLine, &ptcEndPtr );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert the room temperature value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		m_RadNomCond_struct.m_bFix = true;
	
		// Close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_RadNomCond::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

#endif 

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_CircSchemeCateg
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_CircSchemeCateg)

CDB_CircSchemeCateg::CDB_CircSchemeCateg( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
	m_iOrderNr = 0;
	m_iVarPrimFlow=CDB_CircSchemeCateg::Undef;
	m_iVarSecondFlow=CDB_CircSchemeCateg::Undef;
	m_e2W3W = CDB_ControlProperties::CVUnknown;
	m_SchCategName = L"";
	m_AbbrSchCategName = L"";
	m_bInjection = false;
	m_e3WType = e3wTypeUndef;
	m_pStr = NULL;
}

_string CDB_CircSchemeCateg::GetSchName()
{ 
	m_pStr = GetpXmlStrTab()->GetIDSStr( (LPCTSTR)m_SchCategName.c_str() );

	if( NULL != m_pStr )
	{
		return m_pStr->c_str();
	}
	else
	{
		return m_SchCategName;
	}
}

_string CDB_CircSchemeCateg::GetAbbrSchName()
{ 
	m_pStr = GetpXmlStrTab()->GetIDSStr( (LPCTSTR)m_AbbrSchCategName.c_str() );

	if( NULL != m_pStr )
	{
		return m_pStr->c_str();
	}
	else
	{
		return m_AbbrSchCategName;
	}
}

#define CDB_CIRCSCHEMECATEG_VERSION  3
void CDB_CircSchemeCateg::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_CIRCSCHEMECATEG_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CData::Write( outf );
	outf.write( (char *)&m_iOrderNr, sizeof( m_iOrderNr ) );
	outf.write( (char *)&m_iVarPrimFlow, sizeof( m_iVarPrimFlow ) );
	outf.write( (char *)&m_iVarSecondFlow, sizeof( m_iVarSecondFlow ) );
	outf.write( (char *)&m_e2W3W, sizeof( m_e2W3W ) );
	outf.write( (char *)&m_e3WType, sizeof( m_e3WType ) );
	WriteString( outf, m_SchCategName.c_str() );
	WriteString( outf, m_AbbrSchCategName.c_str() );
	outf.write( (char *)&m_bInjection, sizeof( m_bInjection ) );
}

bool CDB_CircSchemeCateg::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version != CDB_CIRCSCHEMECATEG_VERSION )
	{
		return false;
	}
	
	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	inpf.read( (char *)&m_iOrderNr, sizeof( m_iOrderNr ) );
	inpf.read( (char *)&m_iVarPrimFlow, sizeof( m_iVarPrimFlow ) );
	inpf.read( (char *)&m_iVarSecondFlow, sizeof( m_iVarSecondFlow ) );
	inpf.read( (char *)&m_e2W3W, sizeof( m_e2W3W ) );
	inpf.read( (char *)&m_e3WType, sizeof( m_e3WType ) );

	TCHAR tcBuffer[CSTRING_LINE_SIZE_MAX];

	if( false == ReadString( inpf, tcBuffer, sizeof( tcBuffer ) ) )
	{
		return false;
	}

	m_SchCategName = tcBuffer;

	if( false == ReadString( inpf, tcBuffer, sizeof( tcBuffer ) ) )
	{
		return false;
	}

	m_AbbrSchCategName = tcBuffer;

	inpf.read( (char *)&m_bInjection, sizeof( m_bInjection ) );

	return true;
}

#ifndef TACBX 
void CDB_CircSchemeCateg::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		//	new:CDB_CircSchemeCateg(ID)->tableID	Common CData syntax
		//	{
		//		m_OrderNr;					Ordinal number of the circuit scheme category
		//		"Scheme Name"				Displayed scheme name
		//		"Abbrev. Scheme Name"		Abbreviated scheme name
		//		m_VarPrimFlow;				Primary side is -1: Undefined \ 0: Constant flow \ 1: Variable flow 
		//		m_VarSecondFlow;			Secondary side is -1: Undefined \ 0: Constant flow \ 1: Variable flow 
		//		m_i2W3W					    -1: Not applicable \ 0: control circuit with 2-way valve \ 1: control circuit with 3-way valve
		//		m_3WType					enum: type of 3W circuit
		//		m_fInjection				true/false
		//	}

		// Skip the open curve bracket
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Read base.
		CData::ReadText( inpf, pusLineCount );

		TCHAR *ptcEndPtr;
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_iOrderNr = _ttoi(ptcLine );

		if( m_iOrderNr < 0 )
		{
			HYSELECT_THROW( _T("Order number can't be lower than 0 (pos: %i)."), m_iOrderNr );
		}
		else if( m_iOrderNr >= 99 )
		{
			HYSELECT_THROW( _T("Order number can't be higher or equal to 99 (pos: %i)."), m_iOrderNr );
		}

		// Displayed scheme name.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		int iLength = _tcslen( ptcLine );

		if( _T('"') != *ptcLine )
		{
			HYSELECT_THROW( _T("Scheme name must start with \" (pos: %i)."), *pusLineCount );
		}
		else if( _T('"') != ptcLine[iLength - 1] )
		{
			HYSELECT_THROW( _T("Scheme name must end with \" (pos: %i)."), *pusLineCount );
		}

		ptcLine[iLength - 1] = _T('\0');
		m_SchCategName = ptcLine + 1;
	
		// Abbreviated scheme name.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		iLength = _tcslen( ptcLine );

		if( _T('"') != *ptcLine )
		{
			HYSELECT_THROW( _T("Abbreviated scheme name must start with \" (pos: %i)."), *pusLineCount );
		}
		else if( _T('"') != ptcLine[iLength - 1] )
		{
			HYSELECT_THROW( _T("Abbreviated scheme name must end with \" (pos: %i)."), *pusLineCount );
		}

		ptcLine[iLength - 1] = _T('\0');
		m_AbbrSchCategName = ptcLine + 1;

		// Primary flow definition.
		m_iVarPrimFlow = ReadEnumLine( inpf, pusLineCount );

		if( m_iVarPrimFlow != eFLOWVAR::Undef && m_iVarPrimFlow != CDB_CircSchemeCateg::eFLOWVAR::Constant && m_iVarPrimFlow != CDB_CircSchemeCateg::eFLOWVAR::Variable )
		{
			HYSELECT_THROW( _T("Primary flow value must be one of these values: '#eFLOWVAR_Undef', '#eFLOWVAR_Constant' or '#eFLOWVAR_Variable' (pos: %i)."), *pusLineCount );
		}
	
		// Secondary flow definition.
		m_iVarSecondFlow = ReadEnumLine( inpf, pusLineCount );

		if( m_iVarSecondFlow != eFLOWVAR::Undef && m_iVarSecondFlow != CDB_CircSchemeCateg::eFLOWVAR::Constant && m_iVarSecondFlow != CDB_CircSchemeCateg::eFLOWVAR::Variable )
		{
			HYSELECT_THROW( _T("Secondary flow value must be one of these values: '#eFLOWVAR_Undef', '#eFLOWVAR_Constant' or '#eFLOWVAR_Variable' (pos: %i)."), *pusLineCount );
		}

		// m_b2W3W.
		int iValue = ReadEnumLine( inpf, pusLineCount );

		if( iValue != CDB_ControlProperties::CVUnknown && iValue != CDB_ControlProperties::CV2W && iValue != CDB_ControlProperties::CV3W && iValue != CDB_ControlProperties::CV4W && iValue != CDB_ControlProperties::CV6W )
		{
			HYSELECT_THROW( _T("2W3W value must be one of these values: '#eCV2W3W_CVNU', '#eCV2W3W_CV2W', '#eCV2W3W_CV3W', '#eCV2W3W_CV4W' or '#eCV2W3W_CV6W' (pos: %i)."), *pusLineCount );
		}

		m_e2W3W = (CDB_ControlProperties::CV2W3W)iValue;

		// m_e3WType.
		iValue = ReadEnumLine( inpf, pusLineCount );
	
		if( iValue != CDB_CircSchemeCateg::e3wTypeUndef && iValue != CDB_CircSchemeCateg::e3wTypeDividing && iValue != CDB_CircSchemeCateg::e3wTypeMixing && iValue != CDB_CircSchemeCateg::e3wTypeMixDecByp 
				&& iValue != CDB_CircSchemeCateg::e3wTypeDoubleMix )
		{
			HYSELECT_THROW( _T("3-way type value must be one of these values: '#eCV3W_UNDEF', '#eCV3W_DIVIDING', '#eCV2W3W_CV3W', '#eCV3W_MIXING', '#eCV3W_MIXWITHDECBYP' or '#eCV3W_DOUBLEMIXING' (pos: %i)."), *pusLineCount );
		}

		m_e3WType = (e3WType)iValue;

		// m_bInjection.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_bInjection = ( _tcstod( ptcLine, &ptcEndPtr ) ) ? true : false;

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert innjection value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		// Close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_CircSchemeCateg::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

#endif
#ifndef TACBX 
///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_MultiPair
//
///////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DATA( CDB_MultiPair)

CDB_MultiPair::CDB_MultiPair( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
}

bool CDB_MultiPair::GetPoint( unsigned int index, CPoint &pt )
{
	if( index < m_List.size() )
	{
		pt.x = m_List.at( index ).first;
		pt.y = m_List.at( index ).second;
		return true;
	}	
	
	return false;
}

bool CDB_MultiPair::GetPair( unsigned int index, std::pair<int, int> &pt )
{
	if( index < m_List.size() )
	{
		pt = m_List.at( index );
		return true;
	}	
	
	return false;
}

void CDB_MultiPair::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = 1;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CData::Write( outf );

	// Write list size.
	int iSize = m_List.size();
	outf.write( (char *)&iSize, sizeof( iSize ) );

	// Write elements.
	for( int i = 0; i < iSize; i++ )
	{
		outf.write( (char *)&m_List.at( i ).first, sizeof( int ) );
		outf.write( (char *)&m_List.at( i ).second, sizeof( int ) );
	}
}

bool CDB_MultiPair::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > 1 )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Read elements...
	m_List.clear();
	int iSize = 0;
	inpf.read( (char *)&iSize, sizeof( iSize ) );

	for( int i = 0; i < iSize; i++ )
	{
		int x,y;
		inpf.read( (char *)&x, sizeof( x ) );
		inpf.read( (char *)&y, sizeof( y ) );
		m_List.push_back( std::pair<int, int>( x, y ) );	
	}
	
	return true;
}

void CDB_MultiPair::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Read base.
		CData::ReadText( inpf, pusLineCount );

		TCHAR *ptcEndPtr;
	
		// Read array size.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		int iLength = (int)( _tcstod( ptcLine, &ptcEndPtr ) );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert array size value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		m_List.clear();

		// Read each pair.
		int nCheck = 2;
		TCHAR **pptcField;

		for( int i = 0; i < iLength; i++ )
		{
			ptcLine = ReadTextLine( inpf, pusLineCount );
			pptcField = ParseTextLine( ptcLine,&nCheck );

			// Column
			int x = (int)_tcstod( pptcField[0], &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't convert column value (%s) in double (pos: %i)."), pptcField[0], *pusLineCount );
			}

			// Row
			int y = (int)_tcstod( pptcField[1], &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't convert row value (%s) in double (pos: %i)."), pptcField[1], *pusLineCount );
			}

			m_List.push_back( std::pair<int,int>( x, y ) );	
		}
	
		// Close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_MultiPair::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif


///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_CircuitScheme
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_CircuitScheme)

CDB_CircuitScheme::CDB_CircuitScheme( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
	m_SchemeCategIDPtr = _NULL_IDPTR;
	m_SchemeName = L"";									// Displayed scheme name
	m_DynCirScheme = L"";								// Circuit scheme Name into the Circuit scheme DLL 
	m_iBalType = 1;										// 0: No balancing / 1: BV / 2: DpC
	m_iDpCType = 0;										// 0: DpC / 1: PICV
	m_iTermUnit = 0;									// 0: Terminal Unit not allowed / 1: Terminal Unit allowed / 2: Terminal unit compulsory  
	m_iCVFunc = 0;										// 0: Control only / 1: Presettable / 2: Presettable with meas. points
	m_bBVin3WBypAllowed = false;
	m_BoxesIDPtr = _NULL_IDPTR;
	m_eDpStab = DpStabOnBranch;							// 0 Branch, 1 Control valve
	m_eMvLoc = MvLocPrimary;							// 0 Primary, 1 Secondary
	m_eDpCLoc = DpCLocDownStream;						// 0 DownStream, 1 UpStream
	m_bSet = false;
	m_eCvLoc = CvLocLast;
	m_eShutoffValveLoc = ShutoffValveLocLast;
	m_eSmartControlValveLoc = SmartValveLocLast;
	m_eSmartDpCLoc = SmartValveLocLast;
	m_mapAnchorPt.clear();

#ifndef TACBX
	m_mapAnchorPtBckColor.clear();
#endif
}

IDPTR CDB_CircuitScheme::GetSchemeCategIDPtr()
{
	if( _T('\0') != *m_SchemeCategIDPtr.ID && NULL != m_SchemeCategIDPtr.DB )
	{
		Extend( &m_SchemeCategIDPtr );
		return m_SchemeCategIDPtr;
	}
	else
	{
		return _NULL_IDPTR;
	}
}

CDB_CircSchemeCateg *CDB_CircuitScheme::GetpSchCateg()
{
	IDPTR idptr = GetSchemeCategIDPtr();
	return dynamic_cast<CDB_CircSchemeCateg *>( idptr.MP );
}

IDPTR CDB_CircuitScheme::GetBoxesIDPtr()
{
	if( _T('\0') != *m_BoxesIDPtr.ID && NULL != m_BoxesIDPtr.DB )
	{
		Extend( &m_BoxesIDPtr );
		return m_BoxesIDPtr;
	}

	ASSERTA_RETURN( _NULL_IDPTR );
}

_string	CDB_CircuitScheme::GetSchemeName()
{
	if( true == m_SchemeName.empty() )
	{
		return m_SchemeName;
	}

	_string *pStr = GetpXmlStrTab()->GetIDSStr( m_SchemeName );
	
	if( NULL != pStr)
	{
		_string Str = *pStr;
		return Str;
	}
	else
	{
		return m_SchemeName;
	}
}

_string	CDB_CircuitScheme::GetSchemeCategName()
{
	_string strIDS = GetpSchCateg()->GetSchName();	
	_string *pStr = GetpXmlStrTab()->GetIDSStr( strIDS );

	if( NULL != pStr )
	{
		_string Str = *pStr;
		return Str;
	}
	else
	{
		return strIDS;
	}
}

_string	CDB_CircuitScheme::GetAbbrevSchCategName()
{
	_string strIDS = GetpSchCateg()->GetAbbrSchName();	
	_string *pStr = GetpXmlStrTab()->GetIDSStr( strIDS );
	
	if( NULL != pStr )
	{
		_string Str = *pStr;
		return Str;
	}
	else
	{
		return strIDS;
	}
}

_string CDB_CircuitScheme::GetBalTypeStr()
{
	return GetBalTypeStr( GetBalType() );
}

_string CDB_CircuitScheme::GetBalTypeStr( eBALTYPE BalType )
{
	_string strBalTypeName = _T("");
	
	if( CDB_CircuitScheme::SP == BalType )
	{
		strBalTypeName = *( GetpXmlStrTab()->GetIDSStr( _T("IDS_CIRCSCH_BALTYPE_NONE") ) );
	}
	else if( CDB_CircuitScheme::BV == BalType )
	{
		strBalTypeName = *( GetpXmlStrTab()->GetIDSStr( _T("IDS_CIRCSCH_BALTYPE_MANBAL") ) );
	}
	else if( CDB_CircuitScheme::DPC == BalType )
	{
		strBalTypeName = *( GetpXmlStrTab()->GetIDSStr( _T("IDS_BALANCINGTYPE_DPCBAL") ) );
	}
	else if( CDB_CircuitScheme::ELECTRONIC == BalType )
	{
		strBalTypeName = *( GetpXmlStrTab()->GetIDSStr( _T("IDS_BALANCINGTYPE_ELECBAL") ) );
	}
	else if( CDB_CircuitScheme::ELECTRONICDPC == BalType )
	{
		strBalTypeName = *( GetpXmlStrTab()->GetIDSStr( _T("IDS_BALANCINGTYPE_ELECDPC") ) );
	}

	return strBalTypeName;
}

CvLocation CDB_CircuitScheme::GetCvLoc()
{
	if( CvLocLast != m_eCvLoc )
	{
		return m_eCvLoc;
	}
	
	m_eCvLoc = CvLocNone;
	CAnchorPt::AnchorPtFunc *pAnchorPtFunc = NULL;

	if( true == IsAnchorPtExist( CAnchorPt::ControlValve ) )
	{
		pAnchorPtFunc = GetAnchorPtDetails( CAnchorPt::ControlValve );
	}
	else if( true == IsAnchorPtExist( CAnchorPt::PICV ) )
	{
		pAnchorPtFunc = GetAnchorPtDetails( CAnchorPt::PICV );
	}
	else if( true == IsAnchorPtExist( CAnchorPt::DPCBCV ) )
	{
		pAnchorPtFunc = GetAnchorPtDetails( CAnchorPt::DPCBCV );
	}
	else
	{
		return m_eCvLoc;
	}

	ASSERT( NULL != pAnchorPtFunc );

	if( CAnchorPt::CircuitSide_Primary == pAnchorPtFunc->m_eCircuitSide )
	{
		m_eCvLoc = CvLocPrimSide;
	}
	else if( CAnchorPt::CircuitSide_Secondary == pAnchorPtFunc->m_eCircuitSide )
	{
		m_eCvLoc = CvLocSecSide;
	}
	else
	{
		// Location not recognized !!
		ASSERT( 0 );
	}

	return m_eCvLoc;
}

ShutoffValveLoc CDB_CircuitScheme::GetShutoffValveLoc()
{
	if( ShutoffValveLocLast != m_eShutoffValveLoc )
	{
		return m_eShutoffValveLoc;
	}

	m_eShutoffValveLoc = ShutoffValveLocNone;
	
	if( true == IsAnchorPtExist( CAnchorPt::ShutoffValve ) )
	{
		CAnchorPt::AnchorPtFunc *pAnchorPtFunc = GetAnchorPtDetails( CAnchorPt::ShutoffValve );
		ASSERT( NULL != pAnchorPtFunc );

		if( CAnchorPt::PipeLocation_Supply == pAnchorPtFunc->m_ePipeLocation )
		{
			m_eShutoffValveLoc = ShutoffValveLocSupply;
		}
		else if( CAnchorPt::PipeLocation_Return == pAnchorPtFunc->m_ePipeLocation )
		{
			m_eShutoffValveLoc = ShutoffValveLocReturn;
		}
		else
		{
			// Location not recognized !!
			ASSERT( 0 );
		}
	}

	return m_eShutoffValveLoc;
}

SmartValveLocalization CDB_CircuitScheme::GetSmartControlValveLoc()
{ 
	if( SmartValveLocLast != m_eSmartControlValveLoc )
	{
		return m_eSmartControlValveLoc;
	}

	m_eSmartControlValveLoc = SmartValveLocNone;
	
	if( true == IsAnchorPtExist( CAnchorPt::SmartControlValve ) )
	{
		CAnchorPt::AnchorPtFunc *pAnchorPtFunc = GetAnchorPtDetails( CAnchorPt::SmartControlValve );
		ASSERT( NULL != pAnchorPtFunc );

		if( CAnchorPt::PipeLocation_Supply == pAnchorPtFunc->m_ePipeLocation )
		{
			m_eSmartControlValveLoc = SmartValveLocSupply;
		}
		else if( CAnchorPt::PipeLocation_Return == pAnchorPtFunc->m_ePipeLocation )
		{
			m_eSmartControlValveLoc = SmartValveLocReturn;
		}
		else
		{
			// Location not recognized !!
			ASSERT( 0 );
		}
	}

	return m_eSmartControlValveLoc;
}

SmartValveLocalization CDB_CircuitScheme::GetSmartDpCLoc()
{ 
	if( SmartValveLocLast != m_eSmartDpCLoc )
	{
		return m_eSmartDpCLoc;
	}

	m_eSmartDpCLoc = SmartValveLocNone;
	
	if( true == IsAnchorPtExist( CAnchorPt::SmartDpC ) )
	{
		CAnchorPt::AnchorPtFunc *pAnchorPtFunc = GetAnchorPtDetails( CAnchorPt::SmartDpC );
		ASSERT( NULL != pAnchorPtFunc );

		if( CAnchorPt::PipeLocation_Supply == pAnchorPtFunc->m_ePipeLocation )
		{
			m_eSmartDpCLoc = SmartValveLocSupply;
		}
		else if( CAnchorPt::PipeLocation_Return == pAnchorPtFunc->m_ePipeLocation )
		{
			m_eSmartDpCLoc = SmartValveLocReturn;
		}
		else
		{
			// Location not recognized !!
			ASSERT( 0 );
		}
	}

	return m_eSmartDpCLoc;
}

#ifndef TACBX 
CPoint CDB_CircuitScheme::GetBox( eBoxes box )
{
	CPoint pt( 0, 0 );
	CDB_MultiPair *pMP = dynamic_cast<CDB_MultiPair *>( GetBoxesIDPtr().MP );
	
	if( NULL != pMP )
	{
		pMP->GetPoint( box, pt );
	}

	return pt;
}

COLORREF CDB_CircuitScheme::GetAnchorPtColor( CAnchorPt::eFunc func )
{
	std::map<unsigned short, COLORREF>::iterator It;
	It = m_mapAnchorPtBckColor.find( ( CAnchorPt::eFunc )( func & 0x7FFF ) );
	
	if( m_mapAnchorPtBckColor.end() != It )
	{
		return It->second;
	}

	return _TAH_ORANGE;
}

void CDB_CircuitScheme::SetAnchorPtColor( CAnchorPt::eFunc func, COLORREF col )
{
	m_mapAnchorPtBckColor[func] = col;
}
#endif

CAnchorPt::eFunc CDB_CircuitScheme::GetAnchorPtFunc( int index )
{
	CAnchorPt::eFunc ePtFunc = CAnchorPt::eFuncNU;

	if( index < (int)m_mapAnchorPt.size() )
	{
		std::map<CAnchorPt::eFunc, CAnchorPt::AnchorPtFunc>::iterator iter = m_mapAnchorPt.begin();
		std::advance( iter, index );
		ePtFunc = iter->first;
	}
	
	return ePtFunc;
}

bool CDB_CircuitScheme::IsAnchorPtOptional( CAnchorPt::eFunc func )
{
	bool bOptional = false;

	if( 0 != m_mapAnchorPt.count( func ) )
	{
		bOptional = m_mapAnchorPt[func].m_bOptional;
	}

	return bOptional;
}

bool CDB_CircuitScheme::IsAnchorPtExist( CAnchorPt::eFunc func )
{
	for( int j = 0; j < GetAnchorPtListSize(); j++ )
	{
		if( func == GetAnchorPtFunc( j ) )
		{
			return true;
		}
	}

	return false;
}

CAnchorPt::AnchorPtFunc *CDB_CircuitScheme::GetAnchorPtDetails( CAnchorPt::eFunc func )
{
	CAnchorPt::AnchorPtFunc *prAnchorPtFunc = NULL;

	if( 0 != m_mapAnchorPt.count( func ) )
	{
		prAnchorPtFunc = &m_mapAnchorPt[func];
	}

	return prAnchorPtFunc;
}

CAnchorPt::PipeType CDB_CircuitScheme::GetAnchorPtPipeType( CAnchorPt::eFunc func )
{
	CAnchorPt::PipeType ePipeType = CAnchorPt::PipeType_Undefined;

	if( 0 != m_mapAnchorPt.count( func ) )
	{
		ePipeType = m_mapAnchorPt[func].m_ePipeType;
	}

	return ePipeType;
}

CAnchorPt::PipeLocation CDB_CircuitScheme::GetAnchorPtPipeLocation( CAnchorPt::eFunc func )
{
	CAnchorPt::PipeLocation ePipeLocation = CAnchorPt::PipeLocation_Undefined;

	if( 0 != m_mapAnchorPt.count( func ) )
	{
		ePipeLocation = m_mapAnchorPt[func].m_ePipeLocation;
	}

	return ePipeLocation;
}

CAnchorPt::CircuitSide CDB_CircuitScheme::GetAnchorPtCircuitSide( CAnchorPt::eFunc func )
{
	CAnchorPt::CircuitSide eCircuitSide = CAnchorPt::CircuitSide_Undefined;

	if( 0 != m_mapAnchorPt.count( func ) )
	{
		eCircuitSide = m_mapAnchorPt[func].m_eCircuitSide;
	}

	return eCircuitSide;
}

#define CDB_CIRCUITSCHEMEVERSION	11
// Version 11: 2022-07-13 - HYS-1956: Add smart differential pressure controller location.
// Version 10: 2021-12-13  - HYS-1828: add 'm_bSet' to set if a circuit scheme is specific to a set selection or not.
// Version 9: 2021-07-08 - HYS-1716: now anchoring point contains also pipe type, pipe location and circuit side definitions.
// Version 8: 2021-04-28 - HYS-1671: Add Smart control valve location.
// Version 7: 2017-01-16 - Anchoring points are now available in TA-Scope.
// Version 6: 2016-07-11 - Add Shutoff valve location.
bool CDB_CircuitScheme::Read( INPSTREAM  inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_CIRCUITSCHEMEVERSION )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_SchemeCategIDPtr.ID, sizeof( m_SchemeCategIDPtr.ID ) ) )
	{
		return false;
	}

	m_SchemeCategIDPtr.DB = GetDB();

	TCHAR tcBuffer[CSTRING_LINE_SIZE_MAX];

	if( false == ReadString( inpf, tcBuffer, sizeof( tcBuffer ) ) )
	{
		return false;
	}

	m_SchemeName = tcBuffer;

	if( false == ReadString( inpf, tcBuffer, sizeof( tcBuffer ) ) )
	{
		return false;
	}

	m_DynCirScheme = tcBuffer;

	inpf.read( (char *)&m_iBalType, sizeof( m_iBalType ) );
	inpf.read( (char *)&m_iDpCType, sizeof( m_iDpCType ) );
	inpf.read( (char *)&m_iTermUnit, sizeof( m_iTermUnit ) );
	inpf.read( (char *)&m_iCVFunc, sizeof( m_iCVFunc ) );

	// Box description ID.
	if( false == ReadString( inpf, m_BoxesIDPtr.ID, sizeof( m_BoxesIDPtr.ID ) ) )
	{
		return false;
	}

	m_BoxesIDPtr.DB = GetDB();

	inpf.read( (char *)&m_eDpStab, sizeof( m_eDpStab ) );
	inpf.read( (char *)&m_eMvLoc, sizeof( m_eMvLoc ) );
	inpf.read( (char *)&m_eDpCLoc, sizeof( m_eDpCLoc ) );
	inpf.read( (char *)&m_eCvLoc, sizeof( m_eCvLoc ) );
	inpf.read( (char *)&m_eShutoffValveLoc, sizeof( m_eShutoffValveLoc ) );				// Version 6.

	// HYS-1671
	if( Version > 7 )
	{
		inpf.read( (char*)&m_eSmartControlValveLoc, sizeof( m_eSmartControlValveLoc ) );
	}

	int iVectorSize = 0;
	inpf.read( (char *)&iVectorSize, sizeof( iVectorSize ) );

	for( int i = 0; i < iVectorSize; i++ )
	{
		CAnchorPt::AnchorPtFunc rAnchorPtFunc;
		inpf.read( (char *)&rAnchorPtFunc.m_eFunction, sizeof( rAnchorPtFunc.m_eFunction ) );

		// Version 9: 2021-07-08 - HYS-1716: now anchoring point contains also pipe type, pipe location and circuit side definitions.
		if( Version > 8 )
		{
			if( false == ReadString( inpf, rAnchorPtFunc.m_tcName, sizeof( rAnchorPtFunc.m_tcName ) ) )
			{
				return false;
			}

			inpf.read( (char *)&rAnchorPtFunc.m_bOptional, sizeof( rAnchorPtFunc.m_bOptional ) );
			inpf.read( (char *)&rAnchorPtFunc.m_ePipeType, sizeof( rAnchorPtFunc.m_ePipeType ) );
			inpf.read( (char *)&rAnchorPtFunc.m_ePipeLocation, sizeof( rAnchorPtFunc.m_ePipeLocation ) );
			inpf.read( (char *)&rAnchorPtFunc.m_eCircuitSide, sizeof( rAnchorPtFunc.m_eCircuitSide ) );
		}

		m_mapAnchorPt[rAnchorPtFunc.m_eFunction] = rAnchorPtFunc;
	}

	if( Version < 10 )
	{
		return true;
	}

	// Version 10.
	inpf.read( (char *)&m_bSet, sizeof( m_bSet ) );

	if( Version < 11 )
	{
		return true;
	}

	inpf.read( (char*)&m_eSmartDpCLoc, sizeof( m_eSmartDpCLoc ) );

	return true;
}

void CDB_CircuitScheme::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_CIRCUITSCHEMEVERSION;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CData::Write( outf );
	WriteString( outf, (LPCTSTR)m_SchemeCategIDPtr.ID );
	WriteString( outf, m_SchemeName.c_str() );
	WriteString( outf, m_DynCirScheme.c_str() );
	outf.write( (char *)&m_iBalType, sizeof( m_iBalType ) );
	outf.write( (char *)&m_iDpCType, sizeof( m_iDpCType ) );
	outf.write( (char *)&m_iTermUnit, sizeof( m_iTermUnit ) );
	outf.write( (char *)&m_iCVFunc, sizeof( m_iCVFunc ) );
	WriteString( outf, (LPCTSTR)m_BoxesIDPtr.ID );
	outf.write( (char *)&m_eDpStab, sizeof( m_eDpStab ) );
	outf.write( (char *)&m_eMvLoc, sizeof( m_eMvLoc ) );
	outf.write( (char *)&m_eDpCLoc, sizeof( m_eDpCLoc ) );
	outf.write( (char *)&m_eCvLoc, sizeof( m_eCvLoc ) );
	outf.write( (char *)&m_eShutoffValveLoc, sizeof( m_eShutoffValveLoc ) );				// Version 6.
	
	// HYS-1671.
	outf.write( (char *)&m_eSmartControlValveLoc, sizeof( m_eSmartControlValveLoc ) );				// Version 8.
	
	int iMapSize = (int)m_mapAnchorPt.size();
	outf.write( (char *)&iMapSize, sizeof( iMapSize ) );

	std::map<CAnchorPt::eFunc, CAnchorPt::AnchorPtFunc>::iterator iter;
	for( iter = m_mapAnchorPt.begin(); iter != m_mapAnchorPt.end(); iter++ )
	{
		outf.write( (char *)&iter->second.m_eFunction, sizeof( CAnchorPt::eFunc ) );

		// Version 9: 2021-07-08 - HYS-1716: now anchoring point contains also pipe type, pipe location and circuit side definitions.
		WriteString( outf, iter->second.m_tcName );
		outf.write( (char *)&iter->second.m_bOptional, sizeof( iter->second.m_bOptional ) );
		outf.write( (char *)&iter->second.m_ePipeType, sizeof( iter->second.m_ePipeType ) );
		outf.write( (char *)&iter->second.m_ePipeLocation, sizeof( iter->second.m_ePipeLocation ) );
		outf.write( (char *)&iter->second.m_eCircuitSide, sizeof( iter->second.m_eCircuitSide ) );
	}

	outf.write( (char *)&m_bSet, sizeof( m_bSet ) );

	// Version 11.
	outf.write( (char *)&m_eSmartDpCLoc, sizeof( m_eSmartDpCLoc ) );
}

#ifndef TACBX 
void CDB_CircuitScheme::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CData::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( _T('\0') != *m_SchemeCategIDPtr.ID && 0 != _tcscmp( _NO_ID, m_SchemeCategIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_SchemeCategIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Scheme category ID (%s) is defined but not found in the database."), m_SchemeCategIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_CircSchemeCateg ) ) )
			{
				HYSELECT_THROW( _T("Scheme category ID (%s) is found in the database but it's not a 'CDB_CircSchemeCateg' object."), m_SchemeCategIDPtr.ID );
			}
		}

		if( _T('\0') != *m_BoxesIDPtr.ID && 0 != _tcscmp( _NO_ID, m_BoxesIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_BoxesIDPtr.ID );
		
			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Boxes ID (%s) is defined but not found in the database."), m_BoxesIDPtr.ID );
			}
		
			if( false == IDPtr.MP->IsClass( CLASS( CDB_MultiPair ) ) )
			{
				HYSELECT_THROW( _T("Boxes ID (%s) is found in the database but it's not a 'CDB_MultiPair' object."), m_BoxesIDPtr.ID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_CircuitScheme::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

void CDB_CircuitScheme::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Read base.
		CData::ReadText( inpf, pusLineCount );

		// Scheme category.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _tcslen( ptcLine ) > _ID_LENGTH )
		{
			HYSELECT_THROW( _T("Scheme category (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
		}

		_tcsncpy_s( m_SchemeCategIDPtr.ID, SIZEOFINTCHAR( m_SchemeCategIDPtr.ID ), ptcLine, SIZEOFINTCHAR( m_SchemeCategIDPtr.ID ) - 1 );
		m_SchemeCategIDPtr.DB = GetDB();

		// Scheme name.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		int iLength = _tcslen( ptcLine );

		if( _T('"') != *ptcLine )
		{
			HYSELECT_THROW( _T("Scheme name variable must start with \" (pos: %i)."), *pusLineCount );
		}
		else if( _T('"') != ptcLine[iLength - 1] )
		{
			HYSELECT_THROW( _T("Scheme name variable must end with \" (pos: %i)."), *pusLineCount );
		}
	
		ptcLine[iLength - 1] = _T('\0');
		m_SchemeName = ptcLine + 1;

		// Dynamic circuit scheme.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		iLength = _tcslen( ptcLine );

		if( _T('"') != *ptcLine )
		{
			HYSELECT_THROW( _T("Dynamic scheme name variable must start with \" (pos: %i)."), *pusLineCount );
		}
		else if( _T('"') != ptcLine[iLength - 1] )
		{
			HYSELECT_THROW( _T("Dynamic scheme name variable must end with \" (pos: %i)."), *pusLineCount );
		}
	
		ptcLine[iLength - 1] = _T('\0');
		m_DynCirScheme = ptcLine + 1;
	
		// Balancing type.
		m_iBalType = ReadEnumLine( inpf, pusLineCount );

		if( m_iBalType != CDB_CircuitScheme::eBALTYPE::SP && m_iBalType != CDB_CircuitScheme::eBALTYPE::BV 
				&& m_iBalType != CDB_CircuitScheme::eBALTYPE::DPC && m_iBalType != CDB_CircuitScheme::eBALTYPE::ELECTRONIC 
				&& m_iBalType != CDB_CircuitScheme::eBALTYPE::ELECTRONICDPC )
		{
			HYSELECT_THROW( _T("Balancing type value must be one of these values: '#eBALTYPE_SP', '#eBALTYPE_BV', '#eBALTYPE_DPC' or '#eBALTYPE_ELECTRONIC' (pos: %i)."), *pusLineCount );
		}
	
		// Dp controler type.
		m_iDpCType = ReadEnumLine( inpf, pusLineCount );

		if( m_iDpCType != CDB_CircuitScheme::eDpCTypeNU && m_iDpCType != CDB_CircuitScheme::eDpCTypeDPC && m_iDpCType != CDB_CircuitScheme::eDpCTypePICV 
				&& m_iDpCType != CDB_CircuitScheme::eDpCTypeDPCBCV && m_iDpCType != CDB_CircuitScheme::eDpCTypeSMARTDP )
		{
			HYSELECT_THROW( _T("Dp controler type value must be one of these values: '#eDPCTYPE_NU', '#eDPCTYPE_DPC', '#eDPCTYPE_PICV', '#eDPCTYPE_DPCBCV' or '#eDPCTYPE_SMARTDP' (pos: %i)."), *pusLineCount );
		}
	
		// Terminal unit.
		m_iTermUnit = ReadEnumLine( inpf, pusLineCount );

		if( m_iTermUnit != CDB_CircuitScheme::eTERMUNIT::NotAllowed && m_iTermUnit != CDB_CircuitScheme::eTERMUNIT::Allowed && m_iTermUnit != CDB_CircuitScheme::eTERMUNIT::Compulsory )
		{
			HYSELECT_THROW( _T("Terminal unit value must be one of these values: '#eTERMUNIT_NotAllowed', '#eTERMUNIT_Allowed' or '#eTERMUNIT_Compulsory' (pos: %i)."), *pusLineCount );
		}
	
		// Control valve function.
		m_iCVFunc = ReadEnumLine( inpf, pusLineCount );

		if( m_iCVFunc != CDB_ControlProperties::eCVFUNC::NoControl && m_iCVFunc != CDB_ControlProperties::eCVFUNC::ControlOnly && m_iCVFunc != CDB_ControlProperties::eCVFUNC::Presettable 
				&& m_iCVFunc != CDB_ControlProperties::eCVFUNC::PresetPT && m_iCVFunc != CDB_ControlProperties::eCVFUNC::Electronic )
		{
			HYSELECT_THROW( _T("Control valve function value must be one of these values: '#eCVFUNC_NoControl', '#eCVFUNC_ControlOnly', '#eCVFUNC_Presettable', '#eCVFUNC_PresetPT' or '#eCVFUNC_Electronic' (pos: %i)."), *pusLineCount );
		}

		// Box description ID.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _tcslen( ptcLine ) > _ID_LENGTH )
		{
			HYSELECT_THROW( _T("Box description ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
		}
	
		_tcsncpy_s( m_BoxesIDPtr.ID, SIZEOFINTCHAR( m_BoxesIDPtr.ID ), ptcLine, SIZEOFINTCHAR( m_BoxesIDPtr.ID ) - 1 );
		m_BoxesIDPtr.DB = GetDB();

		// Dp stabilisation location.
		int iValue = ReadEnumLine( inpf, pusLineCount );

		if( iValue != eDpStab::DpStabOnBranch && iValue != eDpStab::DpStabOnCV && iValue != eDpStab::DpStabOnBVBypass && iValue != eDpStab::DpStabNone )
		{
			HYSELECT_THROW( _T("Dp stabilisation location value must be one of these values: '#eDpStab_Branch', '#eDpStab_Cv', '#eDpStabOnBVBypass' or '#eDpStab_None' (pos: %i)."), *pusLineCount );
		}

		m_eDpStab = (eDpStab)iValue;

		// Balancing valve location.
		iValue = ReadEnumLine( inpf, pusLineCount );

		if( iValue != eMvLoc::MvLocPrimary && iValue != eMvLoc::MvLocSecondary && iValue != eMvLoc::MvLocNone )
		{
			HYSELECT_THROW( _T("Balancing valve location value must be one of these values: '#eMvLoc_Prim', '#eMvLoc_Sec' or '#eMvLoc_None' (pos: %i)."), *pusLineCount );
		}

		m_eMvLoc = (eMvLoc)iValue;

		// Dp controller location.
		iValue = ReadEnumLine( inpf, pusLineCount );

		if( iValue != eDpCLoc::DpCLocDownStream && iValue != eDpCLoc::DpCLocUpStream && iValue != eDpCLoc::DpCLocNone )
		{
			HYSELECT_THROW( _T("Dp controller location value must be one of these values: '#eDpCLoc_DownStream', '#eDpCLoc_UpStream' or '#eDpCLoc_None' (pos: %i)."), *pusLineCount );
		}
	
		m_eDpCLoc = (eDpCLoc)iValue;

		// Is the circuit scheme for a set ?
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_bSet = ( 0 == _ttoi( ptcLine ) ) ? false : true;

		// Anchoring points.
		TCHAR *ptcString = ReadTextLine( inpf, pusLineCount );

		CString str = ptcString;
		CString strToken;
		int iCurPos = 0;
		strToken = str.Tokenize( _T(";,"), iCurPos );

		while( _T("") != strToken )
		{
			CAnchorPt::AnchorPtFunc rAnchorPtFunc;
			CAnchorPt::TranslateError eErrror = CAnchorPt::TranslateTADBAnchorTxt( (LPCTSTR)strToken, rAnchorPtFunc ); 
		
			switch( eErrror )
			{
				case CAnchorPt::TranslateError::BadSyntax:
				case CAnchorPt::TranslateError::BadAnchorPt:
					HYSELECT_THROW( _T("Anchor point value can be a conbination of one of these values: NU, BV_P, BV_Byp, BV_S, ControlValve, DpC, PICV, Pump, ShutoffValve, DPCBCV, SmartControlValve, TempSensor, SmartDpC or DpSensor (pos: %i)."), *pusLineCount );	
					break;

				case CAnchorPt::TranslateError::BadPipeType:
					HYSELECT_THROW( _T("Pipe type can be one of these values: 'd' (For 'Distribution'), 'c' (For 'Circuit') or 'n' (For 'Not applicable') (pos: %i)."), *pusLineCount );
					break;

				case CAnchorPt::TranslateError::BadPipeLocation:
					HYSELECT_THROW( _T("Pipe location can be one of these values: 's' (For 'Supply'), 'r' (For 'Return'), 'b' (For 'Bypass') or 'n' (For 'Not applicable') (pos: %i)."), *pusLineCount );
					break;

				case CAnchorPt::TranslateError::BadCircuitSide:
					HYSELECT_THROW( _T("Circuit side can be one of these values: 'p' (For 'Primary'), 's' (For 'Secondary) or 'n' (For 'Not applicable') (pos: %i)."), *pusLineCount );
					break;
			}

			if( 0 != m_mapAnchorPt.count( rAnchorPtFunc.m_eFunction ) )
			{
				HYSELECT_THROW( _T("Anchoring point (%s) can be defined more than one time (pos: %i)."), rAnchorPtFunc.m_tcName, *pusLineCount );
			}

			m_mapAnchorPt[rAnchorPtFunc.m_eFunction] = rAnchorPtFunc;
			strToken = str.Tokenize( _T(";,"), iCurPos );
		}

		// To force update internal variables.
		GetCvLoc();
		GetShutoffValveLoc();
		GetSmartControlValveLoc();
		GetSmartDpCLoc();
	
		// Close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_CircuitScheme::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif 

#ifndef TACBX 
///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_Singularity
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_Singularity)

CDB_Singularity::CDB_Singularity( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
	m_nData = 0;
	m_XType = eXType::Constant;
	m_pDzetaChar = NULL;
	SetTACBXVer(0);				// Skipped by default
}

CString CDB_Singularity::GetDescription()
{
	_string *pStr = GetpXmlStrTab()->GetIDSStr(m_Description);

	if( NULL != pStr )
	{
		return pStr->c_str();
	}
	else
	{
		return m_Description.c_str();
	}
}

double CDB_Singularity::GetDzeta( double x )
{
	if( x < m_pDzetaChar->GetMinX() )
	{
		x = m_pDzetaChar->GetMinX();
	}

	if( x > m_pDzetaChar->GetMaxX() )
	{
		x = m_pDzetaChar->GetMaxX();
	}

	return m_pDzetaChar->GetValue( x );
}

void CDB_Singularity::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = 1;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CData::Write( outf );

	// Number of data.
	outf.write( (char *)&m_nData, sizeof( m_nData ) );
	
	// Description.
	WriteString( outf, (LPCTSTR)m_Description.c_str() );
	
	// Characteristic type.
	outf.write( (char *)&m_XType, sizeof( m_XType ) );
	
	// The curve.
	int i = m_pDzetaChar->GetSize();
	outf.write( (char *)&i, sizeof( i ) );

	for( i--; i >= 0; i-- )
	{
		// Position.
		double dX = m_pDzetaChar->GetPointX( i );
		outf.write( (char *)&dX, sizeof( double ) );
		
		// Kv from catalogue, Lambda, Re* and Kv from test.
		for( int j = 0; j < m_nData; j++ )
		{
			double dF = m_pDzetaChar->GetPointF( i, j );
			outf.write( (char *)&dF, sizeof( double ) );
		}
	}
}

bool CDB_Singularity::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > 1 )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Number of data.
	inpf.read( (char *)&m_nData, sizeof( int ) );
	ASSERT( 1 == m_nData || 4 == m_nData );

	m_pDzetaChar = new CCurveFitter( m_nData );

	// Description.
	if( false == ReadString( inpf, m_Description ) )
	{
		return false;
	}

	// Characteristic type.
	inpf.read( (char *)&m_XType, sizeof( m_XType ) );

	// The curve.
	int i;
	double x;
	double *f = new double [m_nData];

	for( inpf.read( (char *)&i, sizeof( i ) ); i; i-- )
	{
		x = ReadDouble( inpf );

		for( int j = 0; j < m_nData; j++ )
		{
			f[j] = ReadDouble( inpf );
		}

		m_pDzetaChar->AddPoint( x, f );
	}

	delete[] f;
	return true;
}

void CDB_Singularity::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_Singularity format

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Read base.
		CData::ReadText( inpf, pusLineCount );

		// Description.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		int iLength = _tcslen( ptcLine );

		if( _T('"') != *ptcLine )
		{
			HYSELECT_THROW( _T("Description must start with \" (pos: %i)."), *pusLineCount );
		}
		else if( _T('"') != ptcLine[iLength - 1] )
		{
			HYSELECT_THROW( _T("Description must end with \" (pos: %i)."), *pusLineCount );
		}

		ptcLine[iLength - 1] = _T('\0');
		m_Description = ptcLine + 1;

		// Type.
		int iValue = ReadEnumLine( inpf, pusLineCount );

		if( iValue != eXType::Constant && iValue != eXType::Va_Vb && iValue != eXType::Vb_Vbp && iValue != eXType::Vbp_Vb && iValue != eXType::Sa_Sb )
		{
			HYSELECT_THROW( _T("Singularity type value must be one of these values: '#eSingularityType_Constant', '#eSingularityType_Va_Vb', '#eSingularityType_Vb_Vbp', '#eSingularityType_Vbp_Vb' or '#eSingularityType_Sa_Sb' (pos: %i)."), *pusLineCount );
		}

		m_XType = (CDB_Singularity::eXType)iValue;
		
		// Read the curve characteristics.
		//
		// Analyze first line to determine the number of columns.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		for( TCHAR *Itr = ptcLine; _T('\0') != *Itr; Itr++ )
		{
			if( _T('\\') == *Itr )
			{
				m_nData++;
			}
		}

		m_pDzetaChar = new CCurveFitter( m_nData );

		if( NULL == m_pDzetaChar )
		{
			HYSELECT_THROW( _T("Internal error: 'm_pDzetaChar' instantiation error (pos: %i)."), *pusLineCount );
		}
	
		// Variables for temporary storage of data.
		int nCheck;
		double h;
		double *parDouble = new double[m_nData];

		if( NULL == parDouble )
		{
			HYSELECT_THROW( _T("Internal error: 'parDouble' instantiation error (pos: %i)."), *pusLineCount );
		}

		TCHAR *ptcEndPtr;
		TCHAR **pptcField;

		// Start the loop on lines
		do 
		{
			if( _T('}') == *ptcLine )
			{
				break;
			}

			nCheck = 0;
			pptcField = ParseTextLine( ptcLine, &nCheck );

			if( nCheck != m_nData + 1 )
			{
				HYSELECT_THROW( _T("The current line has not the correct number of tokens (%i != %i) (pos: %i)."), nCheck, ( m_nData + 1 ), *pusLineCount );
			}

			// Look for position.
			h = _tcstod( pptcField[0], &ptcEndPtr );

			if( _T('\0') != *ptcEndPtr )
			{
				HYSELECT_THROW( _T("Can't convert internal diameter value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
			}

			for( int i = 1; i <= m_nData; i++ )
			{
				parDouble[i - 1] = _tcstod( pptcField[i], &ptcEndPtr );

				if( _T('\0') != *ptcEndPtr )
				{
					HYSELECT_THROW( _T("Can't convert value (%s) at position %i in double (pos: %i)."), pptcField[i], i, *pusLineCount );
				}
			}

			// Add data to the "curve".
			m_pDzetaChar->AddPoint( h, parDouble );

			ptcLine = ReadTextLine( inpf, pusLineCount );

		}while( 1 );

		delete[] parDouble;
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Singularity::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif

#ifndef TACBX 
///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_HubValv
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_HubValv )

CDB_HubValv::CDB_HubValv( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
	m_eSupRetValv = CDB_HubValv::eSupplyReturnValv::Supply;
	m_IDPtrValve = _NULL_IDPTR;
	m_ImageID = 0;
	SetTACBXVer( 0 );				// Skipped by default
}

CString CDB_HubValv::GetName()
{
	_string *pStr = GetpXmlStrTab()->GetIDSStr( m_Name );

	if( NULL != pStr )
	{
		return pStr->c_str();
	}
	else
	{
		return m_Name.c_str();
	}
}

IDPTR CDB_HubValv::GetValveIDPtr()
{ 
	if( _T('\0') != *m_IDPtrValve.ID && 0 != _tcscmp( _NO_ID, m_IDPtrValve.ID ) )
	{
		if( NULL == m_IDPtrValve.MP )
		{
			m_IDPtrValve.DB = GetDB();
			Extend( &m_IDPtrValve );
		}
		
		return m_IDPtrValve;
	}	
	
	return _NULL_IDPTR;
}

void CDB_HubValv::OnDatabaseDestroy()
{
	CData::OnDatabaseDestroy();
}

void CDB_HubValv::Write( OUTSTREAM outf )
{
	// Version
	BYTE Version = 1;
	outf.write( (char *)&Version, sizeof( Version ) );
	
	// Base class.
	CData::Write( outf );
	
	// Infos.
	outf.write( (char *)&m_eSupRetValv, sizeof( m_eSupRetValv));
	WriteString( outf,(LPCTSTR)m_Name.c_str());
	WriteString( outf, m_IDPtrValve.ID );
	WriteString( outf,(LPCTSTR)m_TAISHubPartner);
	WriteString( outf,(LPCTSTR)m_TAISHubPartnerSize);
	WriteString( outf,(LPCTSTR)m_TAISPartnerDP);
	outf.write( (char *)&m_ImageID, sizeof( m_ImageID));
}

bool CDB_HubValv::Read( INPSTREAM inpf )
{
	// Version
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > 1 )
	{
		return false;
	}
	
	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Infos.
	inpf.read( (char *)&m_eSupRetValv, sizeof( m_eSupRetValv ) );

	if( false == ReadString( inpf, m_Name ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_IDPtrValve.ID, sizeof( m_IDPtrValve.ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_TAISHubPartner ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_TAISHubPartnerSize ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_TAISPartnerDP ) )
	{
		return false;
	}

	inpf.read( (char *)&m_ImageID, sizeof( m_ImageID ) );

	return true;
}

void CDB_HubValv::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CData::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( _T('\0') !=  *m_IDPtrValve.ID && 0 != _tcscmp( _NO_ID, m_IDPtrValve.ID ) )
		{
			IDPtr = GetDB()->Get( m_IDPtrValve.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Valve ID (%s) is defined but not found in the database."), m_IDPtrValve.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_RegulatingValve ) )
					&& false == IDPtr.MP->IsClass( CLASS( CDB_VenturiValve ) )
					&& false == IDPtr.MP->IsClass( CLASS( CDB_ShutoffValve ) )
					&& false == IDPtr.MP->IsClass( CLASS( CDB_ControlValve ) )
					&& false == IDPtr.MP->IsClass( CLASS( CDB_DpController ) ) )
			{
				HYSELECT_THROW( _T("Valve ID (%s) is found in the database but it's not a 'CDB_RegulatingValve', 'CDB_VenturiValve', 'CDB_ShutoffValve', 'CDB_ControlValve' or 'CDB_DpController' object."), m_IDPtrValve.ID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_HubValv::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

void CDB_HubValv::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Read base.
		CData::ReadText( inpf, pusLineCount );

		// Supply/Return.
		int iValue = ReadEnumLine( inpf, pusLineCount );

		if( iValue != eSupplyReturnValv::Supply && iValue != eSupplyReturnValv::Return )
		{
			HYSELECT_THROW( _T("Hub valve type value must be one of these values: '#eHubSupply' or '#eHubReturn' (pos: %i)."), *pusLineCount );
		}

		m_eSupRetValv = (CDB_HubValv::eSupplyReturnValv)iValue;
	
		// Name.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		int iLength = _tcslen( ptcLine );

		if( _T('"') != *ptcLine )
		{
			HYSELECT_THROW( _T("Hub name must start with \" (pos: %i)."), *pusLineCount );
		}
		else if( _T('"') != ptcLine[iLength - 1] )
		{
			HYSELECT_THROW( _T("Hub name must end with \" (pos: %i)."), *pusLineCount );
		}
	
		ptcLine[iLength - 1] = _T('\0');
		m_Name = ptcLine + 1;

		// The regulating valve characteristic ID.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _tcslen( ptcLine ) > _ID_LENGTH )
		{
			HYSELECT_THROW( _T("Regulating valve characteristic ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
		}

		_tcsncpy_s( m_IDPtrValve.ID, SIZEOFINTCHAR( m_IDPtrValve.ID ), ptcLine, SIZEOFINTCHAR( m_IDPtrValve.ID ) - 1 );

		if( 0 != _tcscmp( _NO_ID, m_IDPtrValve.ID ) )
		{
			m_IDPtrValve = GetDB()->Get( m_IDPtrValve.ID );

			if( _T('\0') == *m_IDPtrValve.ID )
			{
				HYSELECT_THROW( _T("ID (%s) is defined but can't be found in the database (pos: %i)."), m_IDPtrValve.ID, *pusLineCount );
			}
		}

		// TAISHubPartnerSupply.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		iLength = _tcslen( ptcLine );

		if( _T('"') != *ptcLine )
		{
			HYSELECT_THROW( _T("Hub partner valve name must start with \" (pos: %i)."), *pusLineCount );
		}
		else if( _T('"') != ptcLine[iLength - 1] )
		{
			HYSELECT_THROW( _T("Hub partner valve name must end with \" (pos: %i)."), *pusLineCount );
		}
	
		ptcLine[iLength - 1] = _T('\0');
		m_TAISHubPartner = ptcLine + 1;

		// TAISHubPartnerSize.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		iLength = _tcslen( ptcLine );

		if( _T('"') != *ptcLine )
		{
			HYSELECT_THROW( _T("Hub partner valve name must start with \" (pos: %i)."), *pusLineCount );
		}
		else if( _T('"') != ptcLine[iLength - 1] )
		{
			HYSELECT_THROW( _T("Hub partner valve name must end with \" (pos: %i)."), *pusLineCount );
		}

		ptcLine[iLength - 1] = _T('\0');
		m_TAISHubPartnerSize = ptcLine + 1;

		// TAISPartnerDP.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		iLength = _tcslen( ptcLine );

		if( _T('"') != *ptcLine )
		{
			HYSELECT_THROW( _T("Hub partner valve size must start with \" (pos: %i)."), *pusLineCount );
		}
		else if( _T('"') != ptcLine[iLength - 1] )
		{
			HYSELECT_THROW( _T("Hub partner valve size must end with \" (pos: %i)."), *pusLineCount );
		}
	
		ptcLine[iLength - 1] = _T('\0');
		m_TAISPartnerDP = ptcLine + 1;
	
		// ImageID.
		m_ImageID = ReadEnumLine( inpf, pusLineCount );

		if( INT_MAX == m_ImageID )
		{
			HYSELECT_THROW( _T("Image ID is invalid (pos: %i)."), *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_HubValv::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_HubSupRetLnk
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_HubSupRetLnk)

CDB_HubSupRetLnk::CDB_HubSupRetLnk( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
	m_IDPtrValvType = _NULL_IDPTR;
	SetTACBXVer( 0 );				// Skipped by default
}

IDPTR CDB_HubSupRetLnk::GetValveTypeIDPtr()
{ 
	if( _T('\0') != *m_IDPtrValvType.ID && 0 != _tcscmp( _NO_ID, m_IDPtrValvType.ID ) )
	{
		if( NULL == m_IDPtrValvType.MP )
		{
			m_IDPtrValvType.DB = GetDB();
			Extend( &m_IDPtrValvType );
		}
		
		return m_IDPtrValvType;
	}	
	
	return _NULL_IDPTR;
}

void CDB_HubSupRetLnk::OnDatabaseDestroy()
{
	CData::OnDatabaseDestroy();
}

void CDB_HubSupRetLnk::Write( OUTSTREAM outf )
{
	// Version
	BYTE Version = 1;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CData::Write( outf );

	// Infos.
	WriteString( outf, (LPCTSTR)m_IDPtrValvType.ID );
	WriteString( outf, (LPCTSTR)m_TAISHubPartnerSupply );
	WriteString( outf, (LPCTSTR)m_TAISHubPartnerReturn );
}

bool CDB_HubSupRetLnk::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > 1 )
	{
		return false;
	}
	
	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Infos.
	if( false == ReadString( inpf, m_IDPtrValvType.ID, sizeof( m_IDPtrValvType.ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_TAISHubPartnerSupply ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_TAISHubPartnerReturn ) )
	{
		return false;
	}

	return true;
}

void CDB_HubSupRetLnk::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CData::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( _T('\0') !=  *m_IDPtrValvType.ID && 0 != _tcscmp( _NO_ID, m_IDPtrValvType.ID ) )
		{
			IDPtr = GetDB()->Get( m_IDPtrValvType.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Valve type ID (%s) is defined but not found in the database."), m_IDPtrValvType.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("Valve type ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_IDPtrValvType.ID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_HubSupRetLnk::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

void CDB_HubSupRetLnk::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Read base.
		CData::ReadText( inpf, pusLineCount );
	
		// m_IDPtrPartnerValvType.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		int iLength = _tcslen( ptcLine );
		
		if( _tcslen( ptcLine ) > _ID_LENGTH )
		{
			HYSELECT_THROW( _T("Hub partner supply valve ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
		}
		
		_tcsncpy_s( m_IDPtrValvType.ID, SIZEOFINTCHAR( m_IDPtrValvType.ID ), ptcLine, SIZEOFINTCHAR( m_IDPtrValvType.ID ) - 1 );
		m_IDPtrValvType = GetDB()->Get( m_IDPtrValvType.ID );

		if( _T('\0') == *m_IDPtrValvType.ID )
		{
			HYSELECT_THROW( _T("Hub partner supply valve ID defined (%s) but not found in the database (pos: %i)."), m_IDPtrValvType.ID, *pusLineCount );
		}

		// TAISHubPartnerSupply.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		iLength = _tcslen( ptcLine );

		if( _T('"') != *ptcLine )
		{
			HYSELECT_THROW( _T("Hub partner valve supply name must start with \" (pos: %i)."), *pusLineCount );
		}
		else if( _T('"') != ptcLine[iLength - 1] )
		{
			HYSELECT_THROW( _T("Hub partner valve supply name must end with \" (pos: %i)."), *pusLineCount );
		}

		ptcLine[iLength - 1] = _T('\0');
		m_TAISHubPartnerSupply = ptcLine + 1;

		// TAISHubPartnerReturn.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		iLength = _tcslen( ptcLine );

		if( _T('"') != *ptcLine )
		{
			HYSELECT_THROW( _T("Hub partner valve return name must start with \" (pos: %i)."), *pusLineCount );
		}
		else if( _T('"') != ptcLine[iLength - 1] )
		{
			HYSELECT_THROW( _T("Hub partner valve return name must end with \" (pos: %i)."), *pusLineCount );
		}

		ptcLine[iLength - 1] = _T('\0');
		m_TAISHubPartnerReturn = ptcLine + 1;
	
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_HubSupRetLnk::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_HubStaValv
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_HubStaValv)

CDB_HubStaValv::CDB_HubStaValv( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
	m_eSupRetValv = CDB_HubStaValv::eSupplyReturnValv::Supply;
	m_IDPtrValve = _NULL_IDPTR;
	m_IDPtrActuator = _NULL_IDPTR;
	m_ImageID = 0;
	SetTACBXVer( 0 );				// Skipped by default
}

CString	CDB_HubStaValv::GetName()
{
	_string *pStr = GetpXmlStrTab()->GetIDSStr( m_Name );

	if( NULL != pStr )
	{
		return pStr->c_str();
	}
	else
	{
		return m_Name.c_str();
	}
}

IDPTR CDB_HubStaValv::GetValveIDPtr()
{ 
	if( _T('\0') != *m_IDPtrValve.ID && 0 != _tcscmp( _NO_ID, m_IDPtrValve.ID ) )
	{
		if( NULL == m_IDPtrValve.MP )
		{
			m_IDPtrValve.DB = GetDB();
			Extend( &m_IDPtrValve );
		}
		
		return m_IDPtrValve;
	}	
	
	return _NULL_IDPTR;
}

void CDB_HubStaValv::Write( OUTSTREAM outf )
{
	// Version
	BYTE Version = 1;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CData::Write( outf );
	
	// Infos.
	outf.write( (char *)&m_eSupRetValv, sizeof( m_eSupRetValv ) );
	WriteString( outf, (LPCTSTR)m_Name.c_str() );
	WriteString( outf, m_IDPtrValve.ID );
	WriteString( outf, (LPCTSTR)m_TAISValve );
	WriteString( outf, (LPCTSTR)m_TAISSize );
	WriteString( outf, m_IDPtrActuator.ID );
	outf.write( (char *)&m_ImageID, sizeof( m_ImageID ) );
}

bool CDB_HubStaValv::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > 1 )
	{
		return false;
	}
	
	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Infos.
	inpf.read( (char *)&m_eSupRetValv, sizeof( m_eSupRetValv ) );

	if( false == ReadString( inpf, m_Name ) )
	{
		return false;
	}
	
	if( false == ReadString( inpf, m_IDPtrValve.ID, sizeof( m_IDPtrValve.ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf,m_TAISValve ) )
	{
		return false;
	}

	if( false == ReadString( inpf,m_TAISSize ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_IDPtrActuator.ID, sizeof( m_IDPtrActuator.ID ) ) )
	{
		return false;
	}

	inpf.read( (char *)&m_ImageID, sizeof( m_ImageID ) );
	return true;
}

void CDB_HubStaValv::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CData::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;
	
		if( _T('\0') !=  *m_IDPtrValve.ID && 0 != _tcscmp( _NO_ID, m_IDPtrValve.ID ) )
		{
			IDPtr = GetDB()->Get( m_IDPtrValve.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Valve ID (%s) is defined but not found in the database."), m_IDPtrValve.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_RegulatingValve ) )
					&& false == IDPtr.MP->IsClass( CLASS( CDB_VenturiValve ) )
					&& false == IDPtr.MP->IsClass( CLASS( CDB_ShutoffValve ) )
					&& false == IDPtr.MP->IsClass( CLASS( CDB_ControlValve ) )
					&& false == IDPtr.MP->IsClass( CLASS( CDB_DpController ) ) )
			{
				HYSELECT_THROW( _T("Valve ID (%s) is found in the database but it's not a 'CDB_RegulatingValve', 'CDB_VenturiValve', 'CDB_ShutoffValve', 'CDB_ControlValve' or 'CDB_DpController' object."), m_IDPtrValve.ID );
			}
		}

		if( _T('\0') !=  *m_IDPtrActuator.ID && 0 != _tcscmp( _NO_ID, m_IDPtrActuator.ID ) )
		{
			IDPtr = GetDB()->Get( m_IDPtrActuator.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Actuator ID (%s) is defined but not found in the database."), m_IDPtrActuator.ID );
			}
		
			if( false == IDPtr.MP->IsClass( CLASS( CDB_Actuator ) ) )
			{
				HYSELECT_THROW( _T("Actuator ID (%s) is found in the database but it's not a 'CDB_Actuator' object."), m_IDPtrActuator.ID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_HubStaValv::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

void CDB_HubStaValv::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Read base.
		CData::ReadText( inpf, pusLineCount );
	
		// Supply/Return.
		int iValue = ReadEnumLine( inpf, pusLineCount );

		if( iValue != eSupplyReturnValv::Supply && iValue != eSupplyReturnValv::Return )
		{
			HYSELECT_THROW( _T("Hub valve type value must be one of these values: '#eHubSupply' or '#eHubReturn' (pos: %i)."), *pusLineCount );
		}

		m_eSupRetValv = (CDB_HubStaValv::eSupplyReturnValv)iValue;
	
		// Name.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		int iLength =_tcslen( ptcLine );

		if( _T('"') != *ptcLine )
		{
			HYSELECT_THROW( _T("Hub name must start with \" (pos: %i)."), *pusLineCount );
		}
		else if( _T('"') != ptcLine[iLength - 1] )
		{
			HYSELECT_THROW( _T("Hub name must end with \" (pos: %i)."), *pusLineCount );
		}

		ptcLine[iLength - 1] = _T('\0');
		m_Name = ptcLine + 1;
	
		// The regulating valve ID.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _tcslen( ptcLine ) > _ID_LENGTH )
		{
			HYSELECT_THROW( _T("Regulating valve ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
		}

		_tcsncpy_s( m_IDPtrValve.ID, SIZEOFINTCHAR( m_IDPtrValve.ID), ptcLine, SIZEOFINTCHAR( m_IDPtrValve.ID) - 1 );

		if( 0 != _tcscmp( _NO_ID, m_IDPtrValve.ID ) )
		{
			m_IDPtrValve = GetDB()->Get( m_IDPtrValve.ID );

			if( _T('\0') == *m_IDPtrValve.ID )
			{
				HYSELECT_THROW( _T("Regulating valve ID defined (%s) but not found in the database (pos: %i)."), m_IDPtrValve.ID, *pusLineCount );
			}
		}

		// TAISValve.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		iLength = _tcslen( ptcLine );

		if( _T('"') != *ptcLine )
		{
			HYSELECT_THROW( _T("Hub valve name must start with \" (pos: %i)."), *pusLineCount );
		}
		else if( _T('"') != ptcLine[iLength - 1] )
		{
			HYSELECT_THROW( _T("Hub valve name must end with \" (pos: %i)."), *pusLineCount );
		}

		ptcLine[iLength - 1] = _T('\0');
		m_TAISValve = ptcLine + 1;
	
		// TAISSize.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		iLength = _tcslen( ptcLine );

		if( _T('"') != *ptcLine )
		{
			HYSELECT_THROW( _T("Hub valve size must start with \" (pos: %i)."), *pusLineCount );
		}
		else if( _T('"') != ptcLine[iLength - 1] )
		{
			HYSELECT_THROW( _T("Hub valve size must end with \" (pos: %i)."), *pusLineCount );
		}

		ptcLine[iLength - 1] = _T('\0');
		m_TAISSize = ptcLine + 1;

		// The Actuator Tab ID.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _tcslen( ptcLine ) > _ID_LENGTH )
		{
			HYSELECT_THROW( _T("Hub actuator ID (%s) is too long (%i > %i) (pos: %i)."), ptcLine, _tcslen( ptcLine ), _ID_LENGTH, *pusLineCount );
		}

		_tcsncpy_s( m_IDPtrActuator.ID, SIZEOFINTCHAR( m_IDPtrActuator.ID ), ptcLine, SIZEOFINTCHAR( m_IDPtrActuator.ID ) - 1 );
	
		if( 0 != _tcscmp( _NO_ID, m_IDPtrActuator.ID ) )
		{
			if( _T('\0') == *GetDB()->Get( m_IDPtrActuator.ID).ID )
			{
				HYSELECT_THROW( _T("Hub actuator ID defined (%s) but not found in the database (pos: %i)."), m_IDPtrActuator.ID, *pusLineCount );
			}
		}

		// ImageID.
		m_ImageID = ReadEnumLine( inpf, pusLineCount );

		if( INT_MAX == m_ImageID )
		{
			HYSELECT_THROW( _T("Image ID is invalid (pos: %i)."), *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_HubStaValv::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_Currency
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_Currency)
CDB_Currency::CDB_Currency( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
	m_Index = 0;
	SetTACBXVer( 0 );				// Skipped by default
}

_string CDB_Currency::GetName()
{
	_string *pStr = GetpXmlStrTab()->GetIDSStr(m_Name);

	if( NULL != pStr )
	{
		return pStr->c_str();
	}
	else
	{
		return m_Name.c_str();
	}
}

void CDB_Currency::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = 1;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CData::Write( outf );

	// Infos.
	WriteString( outf, m_ISO.c_str() );
	WriteString( outf, (LPCTSTR)m_TAIS );
	WriteString( outf, m_Name.c_str() );
	outf.write( (char *)&m_Index, sizeof( m_Index ) );
}

bool CDB_Currency::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > 1 )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}
	
	// Infos.
	if( false == ReadString( inpf,m_ISO ) )
	{
		return false;
	}

	if( false == ReadString( inpf,m_TAIS ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_Name ) )
	{
		return false;
	}

	inpf.read( (char *)&m_Index, sizeof( m_Index ) );
	return true;
}

void CDB_Currency::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Read base.
		CData::ReadText( inpf, pusLineCount );

		// ISO.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		int iLength = _tcslen( ptcLine );

		if( _T('"') != *ptcLine )
		{
			HYSELECT_THROW( _T("Currency ISO code must start with \" (pos: %i)."), *pusLineCount );
		}
		else if( _T('"') != ptcLine[iLength - 1] )
		{
			HYSELECT_THROW( _T("Currency ISO code must end with \" (pos: %i)."), *pusLineCount );
		}

		ptcLine[iLength - 1] = _T('\0');
		m_ISO = ptcLine + 1;
	
		// TAIS.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		iLength = _tcslen( ptcLine );

		if( _T('"') != *ptcLine )
		{
			HYSELECT_THROW( _T("Currency internal code must start with \" (pos: %i)."), *pusLineCount );
		}
		else if( _T('"') != ptcLine[iLength - 1] )
		{
			HYSELECT_THROW( _T("Currency internal code must end with \" (pos: %i)."), *pusLineCount );
		}

		ptcLine[iLength - 1] = _T('\0');
		m_TAIS = ptcLine + 1;
	
		// Name.
		ptcLine = ReadTextLine( inpf, pusLineCount );
		iLength = _tcslen( ptcLine );

		if( _T('"') != *ptcLine )
		{
			HYSELECT_THROW( _T("Currency name must start with \" (pos: %i)."), *pusLineCount );
		}
		else if( _T('"') != ptcLine[iLength - 1] )
		{
			HYSELECT_THROW( _T("Currency name must end with \" (pos: %i)."), *pusLineCount );
		}

		ptcLine[iLength - 1] = _T('\0');
		m_Name = ptcLine + 1;

		// Pos.
		TCHAR *ptcEndPtr;
		ptcLine = ReadTextLine( inpf, pusLineCount );
		m_Index = (int)( _tcstod( ptcLine, &ptcEndPtr ) );

		if( _T('\0') != *ptcEndPtr )
		{
			HYSELECT_THROW( _T("Can't convert psoition value (%s) in double (pos: %i)."), ptcLine, *pusLineCount );
		}

		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Currency::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_MapStrStr
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_MapStrStr )
CDB_MapStrStr::CDB_MapStrStr( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
}

void CDB_MapStrStr::Add( CString strFirst, CString strSecond )
{
	m_mapStrStr.Add( strFirst, strSecond );
}

CString CDB_MapStrStr::Get( CString strFirst )
{
	CString strSecond;
	m_mapStrStr.Get( strFirst, strSecond );
	return strSecond;
}

void CDB_MapStrStr::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = 1;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CData::Write( outf );
	
	// Infos.

	// Write number of items.
	UINT32 uiItemCount = m_mapStrStr.size();
	outf.write( (char *)&uiItemCount, sizeof( uiItemCount ) );

	// Write String/String.
	CString strFirst, strSecond;
	bool bResult = m_mapStrStr.GetFirst( strFirst, strSecond );

	while( true == bResult )
	{
		WriteString( outf, strFirst );
		WriteString( outf, strSecond );
		bResult = m_mapStrStr.GetNext( strFirst, strSecond );
	}
}

bool CDB_MapStrStr::Read( INPSTREAM  inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > 1 )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}
	
	// Infos.

	// Read number of items.
	UINT32 uiItemCount;
	inpf.read( (char *)&uiItemCount, sizeof( uiItemCount ) );
	
	// Read String/String.
	CString strFirst, strSecond;

	while( uiItemCount > 0 )
	{
		if( false == ReadString( inpf, strFirst ) )
		{
			return false;
		}

		if( false == ReadString( inpf, strSecond ) )
		{
			return false;
		}

		m_mapStrStr.Add( strFirst, strSecond );
		uiItemCount--;
	}
	
	return true;
}

#endif

#ifndef TACBX
///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_Vessel
//
///////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DATA(CDB_Vessel)
CDB_Vessel::CDB_Vessel(CDataBase *pDataBase, LPCTSTR ID)
	: CDB_Product( pDataBase, ID )
{
	m_dNominalVolume	= 0.0;			//NominalVolume		double (m3) 
	m_dFactoryP0		= 0.0;			//FactoryP0			double (Pa) 
	m_ConnectIDPtr.Clear();				//ConnectID			string ID   
	m_SizeIDPtr.Clear();				//SizeID			string ID   
	m_SecVsslIDPtr.Clear();				//secondary vessel
	m_dHeight			= 0.0;			//Height			double (m)  
	m_dDiameter			= 0.0;			//Diameter			double (m)	
	m_dWeight			= 0.0;			//Weight			double (kg) 
	m_iInstallationLayout	= eilWallHanged;			//true / false
	m_Compatibilityflags= ePMComp_None;	//can be combined #Statico | #Compresso | #Transfero | #Transfero-TI
	m_PlenoIDPtr = _NULL_IDPTR;
	m_dPSch = 0.0;
	m_bAcceptTecboxOnTop = false;		// HYS-1374.
}

LPCTSTR CDB_Vessel::GetConnect()
{
	CDB_StringID *pStr = (CDB_StringID *)( GetConnectIDPtr().MP );
	ASSERT( NULL != pStr );

	return pStr->GetString();
}

const IDPTR &CDB_Vessel::GetConnectIDPtr()
{
	m_ConnectIDPtr.DB = GetDB();
	Extend( &m_ConnectIDPtr );
	return m_ConnectIDPtr;
}

LPCTSTR CDB_Vessel::GetSize()
{
	CDB_StringID *pStr = (CDB_StringID *)( GetSizeIDPtr().MP );
	ASSERT( NULL != pStr );

	return pStr->GetString();
}

const IDPTR &CDB_Vessel::GetSizeIDPtr()
{
	m_SizeIDPtr.DB = GetDB();
	Extend( &m_SizeIDPtr );
	return m_SizeIDPtr;
}

const IDPTR &CDB_Vessel::GetSecVsslIDPtr()
{
	m_SecVsslIDPtr.DB = GetDB();
	Extend( &m_SecVsslIDPtr );
	return m_SecVsslIDPtr;
}

IDPTR CDB_Vessel::GetPlenoIDPtr()
{
	m_PlenoIDPtr.DB = GetDB();
	Extend( &m_PlenoIDPtr );
	return m_PlenoIDPtr;
}

bool CDB_Vessel::IsPrimaryVesselIntegrated()
{
	return ( eilIntegrated == GetInstallationLayout() ) ? true : false;
}

bool CDB_Vessel::IsCompatible( ePMCompFlags CmpFlg )
{
	return ( ( m_Compatibilityflags & CmpFlg ) == CmpFlg );
}

bool CDB_Vessel::IsCompatibleAND( int CmpFlg )
{
	return ( ( m_Compatibilityflags & CmpFlg ) == CmpFlg );
}

bool CDB_Vessel::IsCompatibleOR( int CmpFlg )
{
	int i = 0x01;
	
	while( i < ePMComp_Latest )
	{
		if( ( ( CmpFlg & i ) == i ) && ( ( m_Compatibilityflags & i ) == i ) )
		{
			return true;
		}

		i <<= 1;
	}
	
	return false;
}

void CDB_Vessel::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_Vessel *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_Vessel' object!") );
		}

		// Base class.
		CDB_Product::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_Vessel" class.
		CDB_Vessel *pclDestinationVessel = (CDB_Vessel *)pclDestination;

		pclDestinationVessel->SetNominalVolume( m_dNominalVolume );
		pclDestinationVessel->SetFactoryP0( m_dFactoryP0 );
		pclDestinationVessel->SetConnectID( m_ConnectIDPtr.ID );
		pclDestinationVessel->SetSizeID( m_SizeIDPtr.ID );
		pclDestinationVessel->SetSecVsslID( m_SecVsslIDPtr.ID );
		pclDestinationVessel->SetHeight( m_dHeight );
		pclDestinationVessel->SetDiameter( m_dDiameter );
		pclDestinationVessel->SetWeight( m_dWeight );
		pclDestinationVessel->SetInstallationLayout( m_iInstallationLayout );
		pclDestinationVessel->SetCompatibilityflags( m_Compatibilityflags );
		pclDestinationVessel->SetPlenoID( m_PlenoIDPtr.ID );
		pclDestinationVessel->SetPSch( m_dPSch );
		pclDestinationVessel->SetAcceptTecBoxOnTop( m_bAcceptTecboxOnTop );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_Vessel::Copy' method with the object '%s'."), GetIDPtr().ID )
}

int CDB_Vessel::GetInstallationLayoutPictureID()
{
	int iPictureID;

	if( eilWallHanged == ( m_iInstallationLayout & eilWallHanged ) )
	{
		iPictureID = IDI_PMVSSLWALLHANGED;
	}
	else
	{
		iPictureID = IDI_PMVSSLFLOORSTANDING;
	}

	return iPictureID;
}

CDB_Vessel::VsslType CDB_Vessel::GetVesselType()
{
	CDB_Vessel::VsslType eVesselType = CDB_Vessel::VsslType::eVsslType_Last;
	CString strTypeID = GetTypeIDPtr().ID;

	if( strTypeID == _T("VSSLTYPE_STAT") )
	{
		eVesselType = eVsslType_Statico;
	}
	else if( strTypeID == _T("VSSLTYPE_STATMEMBR") )
	{
		eVesselType = eVsslType_StatMbr;
	}
	else if( strTypeID == _T("VSSLTYPE_PRIM") )
	{
		eVesselType = eVsslType_Prim;
	}
	else if( strTypeID == _T("VSSLTYPE_SEC") )
	{
		eVesselType = eVsslType_Sec;
	}
	else if( strTypeID == _T("VSSLTYPE_INTERM") )
	{
		eVesselType = eVsslType_Interm;
	}
	else if( strTypeID == _T("VSSLTYPE_AQUA") )
	{
		eVesselType = eVsslType_Aqua;
	}

	return eVesselType;
}

CString CDB_Vessel::GetVesselTypeStr( bool bIsIntegratedIsBuffer )
{
	CString str = CteEMPTY_STRING;

	if( true == bIsIntegratedIsBuffer )
	{
		str = TASApp.LoadLocalizedString( IDS_SSHEETSELPROD_CPM_BUFFERVESSEL );
	}
	else if( false == IsInstallationLayoutIntegrated() )
	{
		switch( GetVesselType() )
		{
			case CDB_Vessel::eVsslType_Statico:
				str = TASApp.LoadLocalizedString( IDS_SSHEETSSELPROD_CPM_PRODUCTSTATICO );
				break;

			case CDB_Vessel::eVsslType_StatMbr:
				str = TASApp.LoadLocalizedString( IDS_SSHEETSSELPROD_CPM_MEMBRANEVESSEL );
				break;

			case CDB_Vessel::eVsslType_Prim:
				str = TASApp.LoadLocalizedString( IDS_SSHEETSSELPROD_CPM_PRODUCTPVESSEL );
				break;

			case CDB_Vessel::eVsslType_Sec:
				str = TASApp.LoadLocalizedString( IDS_SSHEETSSELPROD_CPM_PRODUCTSVESSEL );
				break;

			case CDB_Vessel::eVsslType_Interm:
				str = TASApp.LoadLocalizedString( IDS_SSHEETSSELPROD_CPM_PRODUCTIVESSEL );
				break;

			case CDB_Vessel::eVsslType_Aqua:
				str = TASApp.LoadLocalizedString( IDS_CONFSEL_PRESSMAINT_PRODUCTAVESSEL );
				break;
		}
	}
	else
	{
		str = TASApp.LoadLocalizedString( IDS_SSHEETSELPROD_CPM_INTEGRATEDBUFFERVESSEL );
	}
	return str;
}

CDB_Vessel *CDB_Vessel::GetAssociatedSecondaryVessel()
{
	IDPTR idptrSecVssl = _NULL_IDPTR;

	if( CDB_Vessel::eVsslType_Prim == GetVesselType() )
	{
		idptrSecVssl = GetSecVsslIDPtr();
	}
	
	return (CDB_Vessel *) idptrSecVssl.MP;
}

void CDB_Vessel::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_Product::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( _T('\0') != *m_ConnectIDPtr.ID && 0 != _tcscmp( _NO_ID, m_ConnectIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_ConnectIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Connection ID (%s) is defined but not found in the database."), m_ConnectIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_Connect ) ) )
			{
				HYSELECT_THROW( _T("Connection ID (%s) is found in the database but it's not a 'CDB_Connect' object."), m_ConnectIDPtr.ID );
			}
		}

		if( _T('\0') != *m_SizeIDPtr.ID && 0 != _tcscmp( _NO_ID, m_SizeIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_SizeIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Size ID (%s) is defined but not found in the database."), m_SizeIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("Size ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_SizeIDPtr.ID );
			}
		}

		if( _T('\0') != *m_SecVsslIDPtr.ID && 0 != _tcscmp( _NO_ID, m_SecVsslIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_SecVsslIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Secondary vessel ID (%s) is defined but not found in the database."), m_SecVsslIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_Vessel ) ) )
			{
				HYSELECT_THROW( _T("Secondary vessel ID (%s) is found in the database but it's not a 'CDB_Vessel' object."), m_SecVsslIDPtr.ID );
			}
		}

		if( _T('\0') != *m_PlenoIDPtr.ID && 0 != _tcscmp( _NO_ID, m_PlenoIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_PlenoIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Pleno ID (%s) is defined but not found in the database."), *m_PlenoIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CTable ) ) )
			{
				HYSELECT_THROW( _T("Pleno ID (%s) is found in the database but it's not a 'CTable' object."), *m_PlenoIDPtr.ID );
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDataBase::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

#define CDB_VESSEL_VERSION	4
// Version 4: 2020-04-29: HYS-1374: 'm_bAcceptTecboxOnTop' added.
// Version 3: 2018-09-12: 'm_dPSch' added.
// Version 2: 2015-09-07: 'm_PlenoIDPtr' added.
void CDB_Vessel::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_VESSEL_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CDB_Product::Write( outf );

	// Info.
	WriteDouble( outf, GetNominalVolume() );
	WriteDouble( outf, GetFactoryP0() );
	WriteString( outf, GetConnectIDPtr().ID );
	WriteString( outf, GetSizeIDPtr().ID );
	WriteDouble( outf, GetHeight() );
	WriteDouble( outf, GetDiameter() );
	WriteDouble( outf, GetWeight() );
	outf.write( (char *)&m_iInstallationLayout, sizeof( m_iInstallationLayout ) );
	outf.write( (char *)&m_Compatibilityflags, sizeof( m_Compatibilityflags ) );
	WriteString( outf, m_SecVsslIDPtr.ID );

	// Version 2.
	WriteString( outf, GetPlenoIDPtr().ID );

	// Version 3.
	WriteDouble( outf, m_dPSch );

	// Version 4: HYS-1374: 'm_bAcceptTecboxOnTop' added.
	outf.write( (char *)&m_bAcceptTecboxOnTop, sizeof( m_bAcceptTecboxOnTop ) );
}

bool CDB_Vessel::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_VESSEL_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDB_Product::Read( inpf ) )
	{
		return false;
	}

	SetNominalVolume( ReadDouble( inpf ) );
	SetFactoryP0( ReadDouble( inpf) );
	
	if( false == ReadString( inpf, m_ConnectIDPtr.ID, sizeof( m_ConnectIDPtr.ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_SizeIDPtr.ID, sizeof( m_SizeIDPtr.ID ) ) )
	{
		return false;
	}

	SetHeight( ReadDouble( inpf ) );
	SetDiameter( ReadDouble( inpf ) );
	SetWeight( ReadDouble( inpf ) );

	inpf.read( (char *)&m_iInstallationLayout, sizeof( m_iInstallationLayout));
	inpf.read( (char *)&m_Compatibilityflags, sizeof( m_Compatibilityflags));

	if( false == ReadString( inpf, m_SecVsslIDPtr.ID, sizeof( m_SecVsslIDPtr.ID ) ) )
	{
		return false;
	}

	if( Version < 2 )
	{
		return true;
	}

	if( false == ReadString( inpf, m_PlenoIDPtr.ID, sizeof( m_PlenoIDPtr.ID ) ) )
	{
		return false;
	}

	if( Version < 3 )
	{
		return true;
	}

	m_dPSch = ReadDouble( inpf );

	if( Version < 4 )
	{
		return true;
	}

	// Version 4: HYS-1374: 'm_bAcceptTecboxOnTop' added.
	inpf.read( (char *)&m_bAcceptTecboxOnTop, sizeof( m_bAcceptTecboxOnTop ) );

	return true;
}

#define VESSEL_NominalVolume		_T("::NominalVolume=")
#define VESSEL_FactoryP0    		_T("::FactoryP0=")
#define VESSEL_ConnectID    		_T("::ConnectID=")
#define VESSEL_SizeID       		_T("::SizeID=")
#define VESSEL_Height       		_T("::Height=")
#define VESSEL_Diameter     		_T("::Diameter=")
#define VESSEL_Weight       		_T("::Weight=")
#define VESSEL_InstallationLayout	_T("::InstallationLayout=")
#define VESSEL_CompatibilityFlags	_T("::CompatibilityFlags=")
#define VESSEL_SecVsslID       		_T("::SecVsslID=")
#define VESSEL_PlenoID       		_T("::PlenoID=")
#define VESSEL_PSch       			_T("::PSch=")
#define VESSEL_AcceptTecboxOnTop	_T("::AcceptTecboxOnTop=")

void CDB_Vessel::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( CLASS( CDB_Vessel ) );

		if( pStr->Left(2) != _T("::") && iPos < 0 )
		{
			CDB_Product::InterpretInheritedData( pStr );
		}
		else
		{
			if( iPos >= 0 )
			{
				pStr->Delete( iPos, _tcsclen( CLASS( CDB_Vessel ) ) );
			}

			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( VESSEL_NominalVolume ) > -1 )
			{
				m_dNominalVolume = _ttof( (LPCTSTR)strField );
			
				if( m_dNominalVolume <= 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_Vessel::NominalVolume' (%f) can't be lower or equal than 0."), m_dNominalVolume );
				}
			}
			else if( pStr->Find( VESSEL_FactoryP0 ) > -1 )
			{
				m_dFactoryP0 = _ttof( (LPCTSTR)strField );
			
				if( m_dFactoryP0 < 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_Vessel::FactoryP0' (%f) can't be lower than 0."), m_dFactoryP0 );
				}
			}
			else if( pStr->Find( VESSEL_ConnectID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_Vessel::ConnectID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetConnectID( (LPCTSTR)strField );
			}
			else if( pStr->Find( VESSEL_SizeID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_Vessel::SizeID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetSizeID( (LPCTSTR)strField );
			}
			else if( pStr->Find( VESSEL_Height ) > -1 )
			{
				m_dHeight = _ttof( (LPCTSTR)strField );
			
				if( m_dHeight <= 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_Vessel::Height' (%f) can't be lower or equal than 0."), m_dHeight );
				}
			}
			else if( pStr->Find( VESSEL_Diameter ) > -1 )
			{
				m_dDiameter = _ttof( (LPCTSTR)strField );

				if( m_dDiameter <= 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_Vessel::Diameter' (%f) can't be lower or equal than 0."), m_dDiameter );
				}
			}
			else if( pStr->Find( VESSEL_Weight ) > -1 )
			{
				m_dWeight = _ttof( (LPCTSTR)strField );
			
				if( m_dWeight <= 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_Vessel::Weight' (%f) can't be lower or equal than 0."), m_dWeight );
				}
			}
			else if( pStr->Find( VESSEL_InstallationLayout ) > -1 )
			{
				m_iInstallationLayout = ReadEnum( strField );

				if( m_iInstallationLayout != eilWallHanged && m_iInstallationLayout != eilWallHanged && m_iInstallationLayout != eilVesselTop && m_iInstallationLayout != eilFloorStanding
							&& m_iInstallationLayout != eilFloorStandingNextTo && m_iInstallationLayout != eilFloorStandingInFront && m_iInstallationLayout != eilIntegrated )
				{
					HYSELECT_THROW( _T("'CDB_Vessel::InstallationLayout' value must be one of these values: '#eWallHanged', '#eVesselTop', '#eFloorStanding', '#eFloorStandingNextTo', '#eFloorStandingInFront' or '#eIntegrated'.") );
				}
			}
			else if( pStr->Find( VESSEL_CompatibilityFlags ) > -1 )
			{
				m_Compatibilityflags = ReadEnum( strField );

				if( m_Compatibilityflags < ePMComp_None || m_Compatibilityflags >= ePMComp_Latest )
				{
					HYSELECT_THROW( _T("'CDB_Vessel::CompatibilityFlags' value can be a combination of one of these values: '#ePMComp_Statico', '#ePMComp_Compresso', '#ePMComp_Transfero', '#ePMComp_TransferoTI' or '#ePMComp_VsslIntCoating'.") );
				}

			}
			else if( pStr->Find( VESSEL_SecVsslID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_Vessel::SecVsslID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				SetSecVsslID( (LPCTSTR)strField );
			}
			else if( pStr->Find( VESSEL_PlenoID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_Vessel::PlenoID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				m_PlenoIDPtr = _NULL_IDPTR;
				_tcsncpy_s( m_PlenoIDPtr.ID, _ID_LENGTH + 1, (LPCTSTR)strField, _ID_LENGTH );
				m_PlenoIDPtr.DB = GetDB();
			}
			else if( pStr->Find( VESSEL_PSch ) > -1 )
			{
				m_dPSch = _ttof( (LPCTSTR)strField );
			
				if( m_dPSch < 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_Vessel::PSch' (%f) can't be lower to 0."), m_dPSch );
				}
				else if( m_dPSch > GetPmaxmax() )
				{
					HYSELECT_THROW( _T("'CDB_Vessel::PSch' (%f) can't be higher than Pmaxmax (%f)."), m_dPSch, GetPmaxmax() );
				}
			}
			else if( pStr->Find( VESSEL_AcceptTecboxOnTop ) > -1 )
			{
				m_bAcceptTecboxOnTop = ( 0 == _ttoi( (LPCTSTR)strField ) ) ? false : true;
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Vessel::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_Vessel::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		//		NominalVolume		double (m3)	
		//		FactoryP0			double (Pa)
		//		ConnectID			string ID
		//		SizeID				string ID
		//		Height				double (m)
		//		Diameter			double (m)	
		//		Weight				double (kg)
		//		FloorStanding		true/false
		//		Compatibilityflags	can be combined #Statico | #Compresso | #Transfero | #Transfero-TI
		//		PlenoID				string ID
		//      PSch                double (Pa)
		//		AcceptTecBoxOnTop   int
	
		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Inherited ?
		CString ihID;
	
		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_Vessel *)idptr.MP )->Copy( this );
			
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );

				CDB_Vessel::InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_Product::ReadText( inpf, pusLineCount );

			CStringArray TxtHdr;
			TxtHdr.Add( VESSEL_NominalVolume );
			TxtHdr.Add( VESSEL_FactoryP0 );
			TxtHdr.Add( VESSEL_ConnectID );
			TxtHdr.Add( VESSEL_SizeID );
			TxtHdr.Add( VESSEL_Height );
			TxtHdr.Add( VESSEL_Diameter );
			TxtHdr.Add( VESSEL_Weight );
			TxtHdr.Add( VESSEL_InstallationLayout );
			TxtHdr.Add( VESSEL_CompatibilityFlags );
			TxtHdr.Add( VESSEL_SecVsslID );
			TxtHdr.Add( VESSEL_PlenoID );
			TxtHdr.Add( VESSEL_PSch );
			TxtHdr.Add( VESSEL_AcceptTecboxOnTop );
		
			for( int i = 0; i < TxtHdr.GetSize(); i++ )
			{
				ptcLine = ReadTextLine( inpf, pusLineCount );

				CString str = TxtHdr[i] + CString( ptcLine );
				CDB_Vessel::InterpretInheritedData( &str );
			}
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_Vessel::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_Vessel::WriteText( OUTSTREAM outf, CString &strTab )
{
	CString str, str1, str2;

	// Write object header.
	if( true == IsClass( CLASS( CDB_Vessel ) ) )
	{
		CData::WriteText( outf, strTab );
	}

	// Opening bracket..
	str.Format( _T("\r\n%s{"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	strTab += _T("\t");
	CDB_Product::WriteText( outf, strTab );

	str1 = WriteDouble( m_dNominalVolume, 2, 1 );
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	str1 = WriteDouble( m_dFactoryP0, 2, 1 );
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	WriteFormatedStringW( outf, m_ConnectIDPtr.ID, strTab );

	WriteFormatedStringW( outf, m_SizeIDPtr.ID, strTab );

	str1 = WriteDouble( m_dHeight, 2, 1 );
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	str1 = WriteDouble( m_dDiameter, 2, 1 );
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	str1 = WriteDouble( m_dWeight, 2, 1 );
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	str1 = WriteDouble( m_iInstallationLayout, 2, 1 );
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	str1 = WriteDouble( m_Compatibilityflags, 2, 1 );
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	WriteFormatedStringW( outf, m_SecVsslIDPtr.ID, strTab );

	// Version 2.
	WriteFormatedStringW( outf, m_PlenoIDPtr.ID, strTab );

	// Version 3.
	str1 = WriteDouble( m_dPSch, 2, 1 );
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	// Version 4.
	str1 = ( false == m_bAcceptTecboxOnTop ) ? _T("false") : _T("true");
	str.Format( _T("\r\n%s"), strTab + str1 );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );

	// Closing bracket..
	strTab.Delete( 0 ); // Delete one \t
	str.Format( _T("\r\n%s}"), strTab );
	outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_TecBox
//
///////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DATA( CDB_TecBox )
CDB_TecBox::CDB_TecBox( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_Product( pDataBase, ID )
{
	m_iNbrPumpCompressor = -1;
	m_dPower = -1.0;
	m_dSoundPressureLevel = -1.0;
	m_dAccuracy = -1.0;
	m_dHeight = -1.0;
	m_dWidth = -1.0;
	m_dDepth = -1.0;
	m_dWeight = -1.0;
	m_IPxx[0] = _T('\0');
	m_FrequencyIDPtr = _NULL_IDPTR;
	m_PumpCompressCurveIDPtr = _NULL_IDPTR;
	m_iInstallationLayout = CDB_Product::eiUndefined;
	m_iFunctions = ePMFunc_None;
	m_iFunctionsExcluded = ePMFunc_None;
	m_iTecBoxVariant = ePMVariant_None;
	m_dTmaxWaterMakeUp = -1.0;
	m_PlenoIDPtr = _NULL_IDPTR;
	m_IntegratedVesselIDPtr = _NULL_IDPTR;
	m_iMaxSecondaryVessels = 0;
	m_WaterTreatmentCombIDPtr = _NULL_IDPTR;
}

int CDB_TecBox::GetInstallationLayoutPictureID()
{
	int iPictureID;

	if( eilVesselTop == ( m_iInstallationLayout & eilVesselTop ) )
	{
		iPictureID = IDI_PMTECBOXVSSLTOP;
	}
	else if( eilWallHanged == ( m_iInstallationLayout & eilWallHanged ) )
	{
		iPictureID = IDI_PMTECBOXWALLHANGED;
	}
	else if( eilIntegrated == ( m_iInstallationLayout & eilIntegrated ) )
	{
		iPictureID = IDI_PMTECBOXINTEGRATED;
	}
	else
	{
		iPictureID = IDI_PMTECBOXNEXTTO;
	}

	return iPictureID;
}

IDPTR CDB_TecBox::GetPowerSupplyIDPtr( unsigned int index )
{
	if( index >= GetNumOfPowerSupplyIDptr() )
	{
		ASSERTA_RETURN( _NULL_IDPTR );
	}

	IDPTR idptr = m_arPowerSupplyIDPtr.GetAt( index );
	idptr.DB = GetDB();
	Extend( &idptr );
	m_arPowerSupplyIDPtr.SetAt( index, idptr );
	return idptr;
}

CString CDB_TecBox::GetPowerSupplyStr( CString strSeparator )
{
	CString str( _T("") );
	CString strOut( _T("") );

	for( unsigned int i = 0; i < GetNumOfPowerSupplyIDptr(); i++ )
	{
		str = ( (CDB_StringID *)GetPowerSupplyIDPtr( i ).MP )->GetString();

		if( false == strOut.IsEmpty() )
		{
			strOut += strSeparator;
		}

		strOut += str;
	}

	if( true == strOut.IsEmpty() )
	{
		strOut = _T("-");
	}
	
	return strOut;
}

IDPTR CDB_TecBox::GetFrequencyIDPtr()
{
	m_FrequencyIDPtr.DB = GetDB();
	Extend( &m_FrequencyIDPtr );
	return m_FrequencyIDPtr;
}

IDPTR CDB_TecBox::GetPumpComprCurveIDPtr()
{
	m_PumpCompressCurveIDPtr.DB = GetDB();
	Extend( &m_PumpCompressCurveIDPtr );
	return m_PumpCompressCurveIDPtr;
}

IDPTR CDB_TecBox::GetPlenoIDPtr()
{
	m_PlenoIDPtr.DB = GetDB();
	Extend( &m_PlenoIDPtr );
	return m_PlenoIDPtr;
}

IDPTR CDB_TecBox::GetIntegratedVesselIDPtr()
{
	m_IntegratedVesselIDPtr.DB = GetDB();
	Extend( &m_IntegratedVesselIDPtr );
	return m_IntegratedVesselIDPtr;
}

int CDB_TecBox::GetMaximumSecondaryVessels()
{ 
	return m_iMaxSecondaryVessels;
}

IDPTR CDB_TecBox::GetWaterTreatmentCombIDPtr()
{
	m_WaterTreatmentCombIDPtr.DB = GetDB();
	Extend( &m_WaterTreatmentCombIDPtr );
	return m_WaterTreatmentCombIDPtr;
}

int CDB_TecBox::GetNumberOfFunctions( void )
{
	int iNumbers = 0;
	int iFunctions = (int)m_iFunctions;

	for( int i = ePMFunc_First; i <= ePMFunc_Last; i++ )
	{
		iNumbers += ( iFunctions & 0x01 );
		iFunctions >>= 1;
	}

	return iNumbers;
}

CString CDB_TecBox::GetFunctionsStr( CString strTecboxType )
{
	CString str( strTecboxType );

	//	ePMFunc_None = 0,
	//	ePMFunc_First = 1,
	//	ePMFunc_Degasing = ePMFunc_First,
	//	ePMFunc_WaterMakeUp = 2,
	//	ePMFunc_Compressor = 4,
	//	ePMFunc_Pump = 8,
	//	ePMFunc_Last = ePMFunc_Pump
	CString strSeparator = ( true == strTecboxType.IsEmpty() ) ? _T("") : _T("/");

	for( int i = CDB_TecBox::TBFunctions::ePMFunc_First; i <= CDB_TecBox::TBFunctions::ePMFunc_Last; i++ )
	{
		if( i == ( i & GetFunctions() ) )
		{
			switch( i )
			{
				case CDB_TecBox::TBFunctions::ePMFunc_Degasing:
					str += strSeparator + TASApp.LoadLocalizedString( IDS_DLGWIZPM_RVIEWINPUTPMTYPE_DEGASSING );
					strSeparator = _T("/");
					break;

				case CDB_TecBox::TBFunctions::ePMFunc_WaterMakeUp:
					str += strSeparator + TASApp.LoadLocalizedString( IDS_SSHEET_EXPORT_MWATER );
					strSeparator = _T("/");
					break;

				case CDB_TecBox::TBFunctions::ePMFunc_Compressor:
					str += strSeparator + TASApp.LoadLocalizedString( IDS_SSHEET_EXPORT_COMPRESSOR );
					strSeparator = _T("/");
					break;

				case CDB_TecBox::TBFunctions::ePMFunc_Pump:
					str += strSeparator + TASApp.LoadLocalizedString( IDS_HMCALC_PUMP );
					strSeparator = _T("/");
					break;
			}
		}
	}

	return str;
}

CDB_TecBox::TecBoxType CDB_TecBox::GetTecBoxType()
{
	IDPTR idptr = GetTypeIDPtr();

	if( true == idptr.IDMatch( _T("TBXTYPE_COMPRESSO") ) )
	{
		return etbtCompresso;
	}

	if( true == idptr.IDMatch( _T("TBXTYPE_TRANSFERO_T") ) )
	{
		return etbtTransfero;
	}

	if( true == idptr.IDMatch( _T("TBXTYPE_TRANSFERO_TI") ) )
	{
		return etbtTransferoTI;
	}

	if( true == idptr.IDMatch( _T("TBXTYPE_VENTO") ) )
	{
		return etbtVento;
	}

	if( true == idptr.IDMatch( _T("TBXTYPE_PLENO") ) )
	{
		return etbtPleno;
	}

	return etbtNone;
}

bool CDB_TecBox::IsFctDegassing()
{
	return ( ePMFunc_Degasing == ( m_iFunctions & ePMFunc_Degasing ) ) ? true : false;
}

bool CDB_TecBox::IsFctWaterMakeUp()
{
	return ( ePMFunc_WaterMakeUp == ( m_iFunctions & ePMFunc_WaterMakeUp ) ) ? true : false;
}

bool CDB_TecBox::IsFctCompressor()
{
	return ( ePMFunc_Compressor == ( m_iFunctions & ePMFunc_Compressor ) ) ? true : false;
}

bool CDB_TecBox::IsFctPump()
{
	return ( ePMFunc_Pump == ( m_iFunctions & ePMFunc_Pump ) ) ? true : false;
}

bool CDB_TecBox::IsFctExcludedDegassing()
{
	return ( ePMFunc_Degasing == ( m_iFunctionsExcluded & ePMFunc_Degasing ) ) ? true : false;
}

bool CDB_TecBox::IsFctExcludedWaterMakeUp()
{
	return ( ePMFunc_WaterMakeUp == ( m_iFunctionsExcluded & ePMFunc_WaterMakeUp ) ) ? true : false;
}

bool CDB_TecBox::IsFctExcludedCompressor()
{
	return ( ePMFunc_Compressor == ( m_iFunctionsExcluded & ePMFunc_Compressor ) ) ? true : false;
}

bool CDB_TecBox::IsFctExcludedPump()
{
	return ( ePMFunc_Pump == ( m_iFunctionsExcluded & ePMFunc_Pump ) ) ? true : false;
}

bool CDB_TecBox::IsVariantCooling()
{
	return ( ePMVariant_Cooling == ( m_iTecBoxVariant & ePMVariant_Cooling ) ) ? true : false;
}

bool CDB_TecBox::IsVariantEcoAuto()
{
	return ( ePMVariant_EcoAuto == ( m_iTecBoxVariant & ePMVariant_EcoAuto ) ) ? true : false;
}

bool CDB_TecBox::IsVariantBreakTank()
{
	return ( ePMVariant_BreakTank == ( m_iTecBoxVariant & ePMVariant_BreakTank ) ) ? true : false;
}

bool CDB_TecBox::IsVariantVacuumDegassing()
{
	return ( ePMVariant_VacuumDegassing == ( m_iTecBoxVariant & ePMVariant_VacuumDegassing ) ) ? true : false;
}

bool CDB_TecBox::IsVariantExternalAir()
{
	return ( ePMVariant_ExternalAir == ( m_iTecBoxVariant & ePMVariant_ExternalAir ) ) ? true : false;
}

bool CDB_TecBox::IsVariantIntegratedBufferVessel()
{
	return ( ePMVariant_IntBufferVssl == ( m_iTecBoxVariant & ePMVariant_IntBufferVssl ) ) ? true : false;
}

bool CDB_TecBox::IsVariantHighFlowTemperature()
{
	return ( ePMVariant_HighFlowTemp == ( m_iTecBoxVariant & ePMVariant_HighFlowTemp ) ) ? true : false;
}

bool CDB_TecBox::IsVariantIntegratedPrimaryVessel()
{
	return ( ePMVariant_IntegratedPrimaryVessel == ( m_iTecBoxVariant & ePMVariant_IntegratedPrimaryVessel ) ) ? true : false;
}

bool CDB_TecBox::IsVariantWMProtectionConnection()
{
	return ( ePMVariant_WMProtectionConnection == ( m_iTecBoxVariant & ePMVariant_WMProtectionConnection ) ) ? true : false;
}

CDB_TecBox::TBIntegratedVesselType CDB_TecBox::GetIntegratedVesselType()
{
	TBIntegratedVesselType eIntegratedVesselType = ePMIntVesselType_None;

	if( true == IsVariantIntegratedBufferVessel() )
	{
		eIntegratedVesselType = ePMIntVesselType_Buffer;
	}
	else if( true == IsVariantIntegratedPrimaryVessel() )
	{
		eIntegratedVesselType = ePMIntVesselType_Primary;
	}

	return eIntegratedVesselType;
}

void CDB_TecBox::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_TecBox *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_TecBox' object!") );
		}

		// Base class.
		CDB_Product::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_TecBox" class.
		CDB_TecBox *pclDestinationTecBox = (CDB_TecBox *)pclDestination;

		pclDestinationTecBox->SetNbrPumpCompressor( m_iNbrPumpCompressor );
		pclDestinationTecBox->SetPower( m_dPower );
		pclDestinationTecBox->SetSoundPressureLevel( m_dSoundPressureLevel );
		pclDestinationTecBox->SetAccuracy( m_dAccuracy );
		pclDestinationTecBox->SetHeight( m_dHeight );
		pclDestinationTecBox->SetWeight( m_dWeight );
		pclDestinationTecBox->SetWidth( m_dWidth );
		pclDestinationTecBox->SetDepth( m_dDepth );
		pclDestinationTecBox->SetIPxx( m_IPxx );
		pclDestinationTecBox->SetFrequencyID( m_FrequencyIDPtr.ID );
		pclDestinationTecBox->SetPumpCompressCurveID( m_PumpCompressCurveIDPtr.ID );
		pclDestinationTecBox->SetPowerSupplyIDPtr( m_arPowerSupplyIDPtr );
		pclDestinationTecBox->SetInstallationLayout( m_iInstallationLayout );
		pclDestinationTecBox->SetFunctions( m_iFunctions );
		pclDestinationTecBox->SetFunctionsExcluded( m_iFunctionsExcluded );
		pclDestinationTecBox->SetTecBoxVariant(	m_iTecBoxVariant );
		pclDestinationTecBox->SetTmaxWaterMakeUp( m_dTmaxWaterMakeUp );
		pclDestinationTecBox->SetPlenoID( m_PlenoIDPtr.ID );
		pclDestinationTecBox->SetIntegratedVesselID( m_IntegratedVesselIDPtr.ID );
		pclDestinationTecBox->SetMaxSecondaryVessels( m_iMaxSecondaryVessels );
		pclDestinationTecBox->SetWaterTreatmentCombID( m_WaterTreatmentCombIDPtr.ID );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_TecBox::Copy' method with the object '%s'."), GetIDPtr().ID )
}

void CDB_TecBox::SetPowerSupplyIDPtr( CArray<IDPTR> &arPowerSupplyIDPtr )
{
	m_arPowerSupplyIDPtr.RemoveAll();

	for( int i = 0; i < arPowerSupplyIDPtr.GetCount(); i++ )
	{
		IDPTR IDPtr;
		IDPtr.SetID( arPowerSupplyIDPtr.GetAt( i ).ID );
		m_arPowerSupplyIDPtr.Add( IDPtr );
	}
}

void CDB_TecBox::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_Product::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( _T('\0') != *m_FrequencyIDPtr.ID && 0 != _tcscmp( _NO_ID, m_FrequencyIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_FrequencyIDPtr.ID );
		
			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Frequency ID (%s) is defined but not found in the database."), m_FrequencyIDPtr.ID );
			}
		
			if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
			{
				HYSELECT_THROW( _T("Frequency ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_FrequencyIDPtr.ID );
			}
		}

		if( _T('\0') != *m_PumpCompressCurveIDPtr.ID && 0 != _tcscmp( _NO_ID, m_PumpCompressCurveIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_PumpCompressCurveIDPtr.ID );
		
			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Pump/Compressor curve ID (%s) is defined but not found in the database."), m_PumpCompressCurveIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_TBCurve ) ) )
			{
				HYSELECT_THROW( _T("Pump/Compressor curve ID (%s) is found in the database but it's not a 'CDB_TBCurve' object."), m_PumpCompressCurveIDPtr.ID );
			}
		}

		if( m_arPowerSupplyIDPtr.GetCount() > 0 )
		{
			for( int i = 0; i < m_arPowerSupplyIDPtr.GetCount(); i++ )
			{
				if( _T('\0') != *m_arPowerSupplyIDPtr[i].ID && 0 != _tcscmp( _NO_ID, m_arPowerSupplyIDPtr[i].ID ) )
				{
					IDPtr = GetDB()->Get( m_arPowerSupplyIDPtr[i].ID );
				
					if( NULL == IDPtr.MP )
					{
						HYSELECT_THROW( _T("Power supply ID (%s) is defined but not found in the database."), m_arPowerSupplyIDPtr[i].ID );
					}

					if( false == IDPtr.MP->IsClass( CLASS( CDB_StringID ) ) )
					{
						HYSELECT_THROW( _T("Power supply ID (%s) is found in the database but it's not a 'CDB_StringID' object."), m_arPowerSupplyIDPtr[i].ID );
					}
				}
			}
		}

		if( _T('\0') != *m_PlenoIDPtr.ID && 0 != _tcscmp( _NO_ID, m_PlenoIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_PlenoIDPtr.ID );
		
			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Pleno ID (%s) is defined but not found in the database."), m_PlenoIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CTable ) ) )
			{
				HYSELECT_THROW( _T("Pleno ID (%s) is found in the database but it's not a 'CTable' object."), m_PlenoIDPtr.ID );
			}
		}

		if( _T('\0') != *m_IntegratedVesselIDPtr.ID && 0 != _tcscmp( _NO_ID, m_IntegratedVesselIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_IntegratedVesselIDPtr.ID );
		
			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Integrated vessel ID (%s) is defined but not found in the database."), m_IntegratedVesselIDPtr.ID );
			}

			if( true == IsVariantIntegratedPrimaryVessel() )
			{
				if( false == IDPtr.MP->IsClass( CLASS( CDB_Vessel ) ) )
				{
					HYSELECT_THROW( _T("Integrated vessel ID (%s) is found in the database but it's not a 'CDB_Vessel' object."), m_IntegratedVesselIDPtr.ID );
				}
			}
			else
			{
				if( false == IDPtr.MP->IsClass( CLASS( CTable ) ) )
				{
					HYSELECT_THROW( _T("Integrated vessel ID (%s) is found in the database but it's not a 'CTable' object."), m_IntegratedVesselIDPtr.ID );
				}
			}
		}

		if( _T('\0') != *m_WaterTreatmentCombIDPtr.ID && 0 != _tcscmp( _NO_ID, m_WaterTreatmentCombIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_WaterTreatmentCombIDPtr.ID );
		
			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Water treatment combination ID (%s) is defined but not found in the database."), m_WaterTreatmentCombIDPtr.ID );
			}
		
			if( false == IDPtr.MP->IsClass( CLASS( CTable ) ) )
			{
				HYSELECT_THROW( _T("Water treatment combination ID (%s) is found in the database but it's not a 'CTable' object."), m_WaterTreatmentCombIDPtr.ID );
			}
		}

		// Verify also here if there is no contradiction between 'm_eFunctions' and 'm_eFunctionsExclusion'.
		for( int iLoop = ePMFunc_First; iLoop <= ePMFunc_Last; )
		{
			if( iLoop == ( m_iFunctions & iLoop ) && iLoop == ( m_iFunctionsExcluded & iLoop ) )
			{
				HYSELECT_THROW( _T("Function %i can't be in both function (CDB_TecBox::Functions) and function exclusion (CDB_TecBox::FunctionsExclusion) list"), iLoop );
			}

			iLoop <<= 1;
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_TecBox::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

#define CDB_TecBox_VERSION	3
// Version 3: 2017-09-29 - 'm_eFunctionsExclusion' and 'm_iMaxSecondaryVessels' added.
// Version 2: 2015-08-10 - 'm_PlenoIDPtr', 'm_IntegratedVesselIDPtr' and 'm_WaterTreatmentCombIDPtr' added.
void CDB_TecBox::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_TecBox_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CDB_Product::Write( outf );

	// Info.
	outf.write( (char *)&m_iNbrPumpCompressor, sizeof( m_iNbrPumpCompressor ) );
	outf.write( (char *)&m_dPower, sizeof( m_dPower ) );
	outf.write( (char *)&m_dSoundPressureLevel, sizeof( m_dSoundPressureLevel ) );
	outf.write( (char *)&m_dAccuracy, sizeof( m_dAccuracy ) );
	outf.write( (char *)&m_dHeight, sizeof( m_dHeight));
	outf.write( (char *)&m_dWidth, sizeof( m_dWidth ) );
	outf.write( (char *)&m_dDepth, sizeof( m_dDepth ) );
	outf.write( (char *)&m_dWeight, sizeof( m_dWeight));
	
	// IP.
	WriteString( outf, m_IPxx );

	WriteString( outf, m_FrequencyIDPtr.ID );

	WriteString( outf, m_PumpCompressCurveIDPtr.ID );

	// Power Supply.
	int iCount = m_arPowerSupplyIDPtr.GetCount();
	outf.write( (char *)&iCount, sizeof( iCount ) );

	for( int i = 0; i < iCount; i++ )
	{
		IDPTR idptr = m_arPowerSupplyIDPtr.GetAt( i );
		WriteString( outf, idptr.ID );
	}

	outf.write( (char *)&m_iInstallationLayout, sizeof( m_iInstallationLayout ) );
	outf.write( (char *)&m_iFunctions, sizeof( m_iFunctions ) );
	outf.write( (char *)&m_iTecBoxVariant, sizeof( m_iTecBoxVariant ) );
	WriteDouble( outf, GetTmaxWaterMakeUp() );

	// Version 2: 'm_PlenoIDPtr' and 'm_IntegratedVesselIDPtr' added.
	WriteString( outf, m_PlenoIDPtr.ID );
	WriteString( outf, m_IntegratedVesselIDPtr.ID );
	WriteString( outf, m_WaterTreatmentCombIDPtr.ID );

	// Version 3: 'm_eFunctionsExclusion' added.
	outf.write( (char *)&m_iFunctionsExcluded, sizeof( m_iFunctionsExcluded ) );
	outf.write( (char *)&m_iMaxSecondaryVessels, sizeof( m_iMaxSecondaryVessels ) );
}

bool CDB_TecBox::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_TecBox_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDB_Product::Read( inpf ) )
	{
		return false;
	}

	// Info.
	inpf.read( (char *)&m_iNbrPumpCompressor, sizeof( m_iNbrPumpCompressor ) );
	inpf.read( (char *)&m_dPower, sizeof( m_dPower ) );
	inpf.read( (char *)&m_dSoundPressureLevel, sizeof( m_dSoundPressureLevel ) );
	inpf.read( (char *)&m_dAccuracy, sizeof( m_dAccuracy ) );
	inpf.read( (char *)&m_dHeight, sizeof( m_dHeight ) );
	inpf.read( (char *)&m_dWidth, sizeof( m_dWidth ) );
	inpf.read( (char *)&m_dDepth, sizeof( m_dDepth ) );
	inpf.read( (char *)&m_dWeight, sizeof( m_dWeight ) );
	
	// IP.
	if( false == ReadString( inpf, m_IPxx, sizeof( m_IPxx ) ) )
	{
		return false;
	}

	// Frequency.
	if( false == ReadString( inpf, m_FrequencyIDPtr.ID, sizeof( m_FrequencyIDPtr.ID ) ) )
	{
		return false;
	}

	// Pump compressor curve
	if( false == ReadString( inpf, m_PumpCompressCurveIDPtr.ID, sizeof( m_PumpCompressCurveIDPtr.ID ) ) )
	{
		return false;
	}

	// Power Supply.
	int iCount = 0;
	inpf.read( (char *)&iCount, sizeof( iCount ) );
	m_arPowerSupplyIDPtr.SetSize( iCount );
	
	for( int i = 0; i < iCount; i++ )
	{
		IDPTR idptr = _NULL_IDPTR;

		if( false == ReadString( inpf, idptr.ID, sizeof( idptr.ID ) ) )
		{
			return false;
		}

		idptr.DB = GetDB();
		m_arPowerSupplyIDPtr.SetAt( i, idptr );
	}

	inpf.read( (char *)&m_iInstallationLayout, sizeof( m_iInstallationLayout ) );
	inpf.read( (char *)&m_iFunctions, sizeof( m_iFunctions ) );
	inpf.read( (char *)&m_iTecBoxVariant, sizeof( m_iTecBoxVariant ) );
	m_dTmaxWaterMakeUp = ReadDouble( inpf );
	
	if( Version < 2 )
	{
		return true;
	}

	if( false == ReadString( inpf, m_PlenoIDPtr.ID, sizeof( m_PlenoIDPtr.ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_IntegratedVesselIDPtr.ID, sizeof( m_IntegratedVesselIDPtr.ID ) ) )
	{
		return false;
	}

	if( false == ReadString( inpf, m_WaterTreatmentCombIDPtr.ID, sizeof( m_WaterTreatmentCombIDPtr.ID ) ) )
	{
		return false;
	}

	if( Version < 3 )
	{
		return true;
	}

	inpf.read( (char *)&m_iFunctionsExcluded, sizeof( m_iFunctionsExcluded ) );
	inpf.read( (char *)&m_iMaxSecondaryVessels, sizeof( m_iMaxSecondaryVessels ) );

	return true;
}

#define TecBox_IPxx					_T("::IPxx=")
#define TecBox_PowerSupplyIDs		_T("::PowerSupplyIDs=")
#define TecBox_FrequencyID			_T("::FrequencyID=")
#define TecBox_Power				_T("::Power=")
#define TecBox_SoundPressureLevel	_T("::SoundPressureLevel=")
#define TecBox_NbrPumpCompressor	_T("::NbrPumpCompressor=")
#define TecBox_PumpCompressCurveID	_T("::PumpCompressCurveID=")
#define TecBox_Accuracy				_T("::Accuracy=")
#define TecBox_InstallationLayout	_T("::InstallationLayout=")
#define TecBox_Height				_T("::Height=")
#define TecBox_Width				_T("::Width=")
#define TecBox_Depth				_T("::Depth=")
#define TecBox_Weight				_T("::Weight=")
#define TecBox_Functions			_T("::Functions=")
#define TecBox_FunctionsExclusion	_T("::FunctionsExclusion=")
#define TecBox_TecBoxVariant		_T("::TecBoxVariant=")
#define TecBox_TmaxWaterMakeUp		_T("::TmaxWaterMakeUp=")
#define TecBox_PlenoID				_T("::PlenoID=")
#define TecBox_IntegratedVesselID	_T("::IntegratedVesselID=")
#define TecBox_WaterTreatmentComID	_T("::WaterTreatmentCombID=")
#define TecBox_MaxSecondaryVessels	_T("::MaxSecondaryVessels=")

void CDB_TecBox::InterpretInheritedData( CString* pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( CLASS( CDB_TecBox ) );
	
		if( _T("::") != pStr->Left( 2 ) && iPos < 0 )
		{
			CDB_Product::InterpretInheritedData( pStr );
		}
		else
		{
			if( iPos >= 0 )
			{
				pStr->Delete( iPos, _tcsclen( CLASS( CDB_TecBox ) ) );
			}

			int iEq = pStr->Find( _T("=") );
		
			if( iEq <= 0 ) 
			{
				HYSELECT_THROW( _T("Inherited variable value must be preceeded by '='") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );
		
			if( pStr->Find( TecBox_IPxx ) > -1 )
			{
				strField.Remove( '\"' );
				_tcsncpy_s( m_IPxx, SIZEOFINTCHAR( m_IPxx ), strField, SIZEOFINTCHAR( m_IPxx ) - 1 );
			}
			else if( pStr->Find( TecBox_PowerSupplyIDs ) > -1 )
			{
				ParseIDList( &m_arPowerSupplyIDPtr, strField );
			}
			else if( pStr->Find( TecBox_FrequencyID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_TecBox::FrequencyID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				m_FrequencyIDPtr = _NULL_IDPTR;
				_tcsncpy_s( m_FrequencyIDPtr.ID, _ID_LENGTH + 1, (LPCTSTR)strField, _ID_LENGTH );
				m_FrequencyIDPtr.DB = GetDB();
			}
			else if( pStr->Find( TecBox_Power ) > -1 )
			{
				// Can be '0' (the case of Pleno for Transfero TV Connect).
				m_dPower = _ttof( (LPCTSTR)strField );

				if( m_dPower < 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_TecBox::Power' (%f) can't be lower than 0."), m_dPower );
				}
			}
			else if( pStr->Find( TecBox_SoundPressureLevel ) > -1 )
			{
				m_dSoundPressureLevel = _ttof( (LPCTSTR)strField );
			
				if( m_dSoundPressureLevel < 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_TecBox::SoundPressureLevel' (%f) can't be lower than 0."), m_dSoundPressureLevel );
				}
			}
			else if( pStr->Find( TecBox_NbrPumpCompressor ) > -1 )
			{
				m_iNbrPumpCompressor = _ttoi( (LPCTSTR)strField );
			
				if( m_iNbrPumpCompressor < 0.0 || m_iNbrPumpCompressor > 2 )
				{
					HYSELECT_THROW( _T("'CDB_TecBox::NbrPumpCompressor' (%i) must be one of these values: 0, 1 or 2."), m_iNbrPumpCompressor );
				}
			}
			else if( pStr->Find( TecBox_PumpCompressCurveID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_TecBox::PumpCompressCurveID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				m_PumpCompressCurveIDPtr = _NULL_IDPTR;
				_tcsncpy_s( m_PumpCompressCurveIDPtr.ID, _ID_LENGTH + 1, (LPCTSTR)strField, _ID_LENGTH );
				m_PumpCompressCurveIDPtr.DB = GetDB();
			}
			else if( pStr->Find( TecBox_Accuracy ) > -1 )
			{
				m_dAccuracy = _ttof( (LPCTSTR)strField );

				if( m_dAccuracy < 0.0 && -1.0 != m_dAccuracy )
				{
					HYSELECT_THROW( _T("'CDB_TecBox::Accuracy' (%f) must be equal to -1.0 or greather or equal to 0.0."), m_dAccuracy );
				}
			}
			else if( pStr->Find( TecBox_InstallationLayout ) > -1 )
			{
				m_iInstallationLayout = ReadEnum( strField );

				if( m_iInstallationLayout != eilWallHanged && m_iInstallationLayout != eilWallHanged && m_iInstallationLayout != eilVesselTop && m_iInstallationLayout != eilFloorStanding
							&& m_iInstallationLayout != eilFloorStandingNextTo && m_iInstallationLayout != eilFloorStandingInFront && m_iInstallationLayout != eilIntegrated )
				{
					HYSELECT_THROW( _T("'CDB_TecBox::InstallationLayout' value must be one of these values: '#eWallHanged', '#eVesselTop', '#eFloorStanding', '#eFloorStandingNextTo', '#eFloorStandingInFront' or '#eIntegrated'.") );
				}
			}
			else if( pStr->Find( TecBox_Height ) > -1 )
			{
				m_dHeight = _ttof( (LPCTSTR)strField );

				if( m_dHeight <= 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_TecBox::Height' (%f) can't be lower or equal to 0."), m_dHeight );
				}
			}
			else if( pStr->Find( TecBox_Width ) > -1 )
			{
				m_dWidth = _ttof( (LPCTSTR)strField );
			
				if( m_dWidth <= 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_TecBox::Width' (%f) can't be lower or equal to 0."), m_dWidth );
				}
			}
			else if( pStr->Find( TecBox_Depth ) > -1 )
			{
				m_dDepth = _ttof( (LPCTSTR)strField );

				if( m_dDepth <= 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_TecBox::Depth' (%f) can't be lower or equal to 0."), m_dDepth );
				}
			}
			else if( pStr->Find( TecBox_Weight ) > -1 )
			{
				m_dWeight = _ttof( (LPCTSTR)strField );

				if( m_dWeight <= 0.0 )
				{
					HYSELECT_THROW( _T("'CDB_TecBox::Weight' (%f) can't be lower or equal to 0."), m_dWeight );
				}
			}
			else if( pStr->Find( TecBox_Functions ) > -1 )
			{
				m_iFunctions = ReadEnum( strField );

				if( m_iFunctions < ePMFunc_None || m_iFunctions >= ( ePMFunc_Last << 1 ) )
				{
					HYSELECT_THROW( _T("'CDB_TecBox::Functions' value can be a combination of one of these values: '#ePMFunc_None', '#ePMFunc_Degasing', '#ePMFunc_WaterMakeUp', '#ePMFunc_Compressor' or '#ePMFunc_Pump'.") );
				}
			}
			else if( pStr->Find( TecBox_FunctionsExclusion ) > -1 )
			{
				m_iFunctionsExcluded = ReadEnum( strField );

				if( m_iFunctionsExcluded < ePMFunc_None || m_iFunctionsExcluded >= ( ePMFunc_Last << 1 ) )
				{
					HYSELECT_THROW( _T("'CDB_TecBox::FunctionsExclusion' value can be a combination of one of these values: '#ePMFunc_None', '#ePMFunc_Degasing', '#ePMFunc_WaterMakeUp', '#ePMFunc_Compressor' or '#ePMFunc_Pump'.") );
				}
			}
			else if( pStr->Find( TecBox_TecBoxVariant ) > -1 )
			{
				m_iTecBoxVariant = ReadEnum( (LPCTSTR)strField );

				if( m_iTecBoxVariant < ePMVariant_None || m_iTecBoxVariant >= ( ePMVariant_Last << 1 ) )
				{
					throw CHySelectException( _T("'CDB_TecBox::TecBoxVariant' value can be a combination of one of these values: '#ePMVariant_None', '#ePMVariant_Cooling', '#ePMVariant_EcoAuto', '#ePMVariant_BreakTank', \
							'#ePMVariant_VacuumDegassing', '#ePMVariant_ExternalAir', '#ePMVariant_IntBufferVssl', '#ePMVariant_HighFlowTemp', '#ePMVariant_IntegratedPrimaryVessel' or '#ePMVariant_WMProtectionConnection'."), __LINE__, __FILE__ );
				}
			}
			else if( pStr->Find( TecBox_TmaxWaterMakeUp ) > -1 )
			{
				m_dTmaxWaterMakeUp = _ttof( (LPCTSTR)strField );
			}
			else if( pStr->Find( TecBox_PlenoID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_TecBox::PlenoID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				m_PlenoIDPtr = _NULL_IDPTR;
				_tcsncpy_s( m_PlenoIDPtr.ID, _ID_LENGTH + 1, (LPCTSTR)strField, _ID_LENGTH );
				m_PlenoIDPtr.DB = GetDB();
			}
			else if( pStr->Find( TecBox_IntegratedVesselID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_TecBox::IntegratedVesselID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				m_IntegratedVesselIDPtr = _NULL_IDPTR;
				_tcsncpy_s( m_IntegratedVesselIDPtr.ID, _ID_LENGTH + 1, (LPCTSTR)strField, _ID_LENGTH );
				m_IntegratedVesselIDPtr.DB = GetDB();
			}
			else if( pStr->Find( TecBox_WaterTreatmentComID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_TecBox::WaterTreatmentCombID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				m_WaterTreatmentCombIDPtr = _NULL_IDPTR;
				_tcsncpy_s( m_WaterTreatmentCombIDPtr.ID, _ID_LENGTH + 1, (LPCTSTR)strField, _ID_LENGTH );
				m_WaterTreatmentCombIDPtr.DB = GetDB();
			}
			else if( pStr->Find( TecBox_MaxSecondaryVessels ) > -1 )
			{
				m_iMaxSecondaryVessels = _ttoi( (LPCTSTR)strField );
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_TecBox::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_TecBox::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_TecBox *)idptr.MP)->Copy( this );

			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );
			
				CDB_TecBox::InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_Product::ReadText( inpf, pusLineCount );

			CStringArray TxtHdr;
			TxtHdr.Add( TecBox_IPxx );
			TxtHdr.Add( TecBox_PowerSupplyIDs );
			TxtHdr.Add( TecBox_FrequencyID );
			TxtHdr.Add( TecBox_Power );
			TxtHdr.Add( TecBox_SoundPressureLevel );
			TxtHdr.Add( TecBox_NbrPumpCompressor );
			TxtHdr.Add( TecBox_PumpCompressCurveID );
			TxtHdr.Add( TecBox_Accuracy );
			TxtHdr.Add( TecBox_InstallationLayout );
			TxtHdr.Add( TecBox_Height );
			TxtHdr.Add( TecBox_Width );
			TxtHdr.Add( TecBox_Depth );
			TxtHdr.Add( TecBox_Weight );
			TxtHdr.Add( TecBox_Functions );
			TxtHdr.Add( TecBox_FunctionsExclusion );
			TxtHdr.Add( TecBox_TecBoxVariant );
			TxtHdr.Add( TecBox_TmaxWaterMakeUp );
			TxtHdr.Add( TecBox_PlenoID );
			TxtHdr.Add( TecBox_IntegratedVesselID );
			TxtHdr.Add( TecBox_WaterTreatmentComID );
			TxtHdr.Add( TecBox_MaxSecondaryVessels );
	
			for( int i = 0; i < TxtHdr.GetSize(); i++ )
			{
				ptcLine = ReadTextLine( inpf, pusLineCount );
				
				CString str = TxtHdr[i] + CString( ptcLine );
				CDB_TecBox::InterpretInheritedData( &str );
			}
		}
	
		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_TecBox::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_TecBox::WriteText( OUTSTREAM outf, CString& strTab )
{
	// Info.
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_TBPlenoVento
//
///////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DATA( CDB_TBPlenoVento )
CDB_TBPlenoVento::CDB_TBPlenoVento( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_TecBox( pDataBase, ID )
{
	m_dSystemVolume = -1.0;
	m_dWorkingPressRangeMin = 0.0;
	m_dWorkingPressRangeMax = 0.0;
	m_dFlowWaterMakeUp = -1.0;
	m_dKvs = -1.0;
	m_eRefillable = ePMPR_RefillNone;
	m_RefillGroupIDPtr.Clear();
	m_arVesselVolumeLimits.RemoveAll();
}

_string CDB_TBPlenoVento::GetWorkingPressureRange( void )
{
	_string str = _T("-"); 

	if( -1.0 == m_dWorkingPressRangeMin || -1.0 == m_dWorkingPressRangeMax )
	{
		return str;
	}

	str = WriteCUDouble( _U_PRESSURE, m_dWorkingPressRangeMin );
	str += _T("-");
	str += WriteCUDouble( _U_PRESSURE, m_dWorkingPressRangeMax );
	return str;
}

const IDPTR &CDB_TBPlenoVento::GetRefillGroupIDPtr()
{
	m_RefillGroupIDPtr.DB = GetDB();
	Extend( &m_RefillGroupIDPtr );
	return m_RefillGroupIDPtr;
}

double CDB_TBPlenoVento::GetMinimumVesselVolume( double dP )
{
	double dVolume = -1.0;
	bool bFound = false;

	for( int i = 0; i < m_arVesselVolumeLimits.GetCount() && false == bFound; i++ )
	{
		if( ( -1.0 == m_arVesselVolumeLimits.GetAt( i ).m_dPmin || dP > m_arVesselVolumeLimits.GetAt( i ).m_dPmin ) &&
			( -1.0 == m_arVesselVolumeLimits.GetAt( i ).m_dPmax || dP <= m_arVesselVolumeLimits.GetAt( i ).m_dPmax ) )
		{
			dVolume = m_arVesselVolumeLimits.GetAt( i ).m_dMinimumVolume;
			bFound = true;
		}
	}

	return dVolume;
}

int CDB_TBPlenoVento::GetInstallationLayoutPictureID()
{
	int iPictureID;

	if( eilWallHanged == GetInstallationLayout() )
	{
		iPictureID = IDI_PMTECBOXWALLHANGED;
	}
	else
	{
		iPictureID = IDI_PMVENTOFLOORSTANDING;
	}

	return iPictureID;
}

void CDB_TBPlenoVento::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_TBPlenoVento *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_TBPlenoVento' object!") );
		}
	
		// Base class.
		CDB_TecBox::Copy( pclDestination );

		// Copy now what it is common to the "CDB_TBPlenoVento" class.
		CDB_TBPlenoVento *pclDestinationTBPlenoVento = (CDB_TBPlenoVento *)pclDestination;

		pclDestinationTBPlenoVento->SetSystemVolume( m_dSystemVolume );
		pclDestinationTBPlenoVento->SetWorkingPressRangeMin( m_dWorkingPressRangeMin );
		pclDestinationTBPlenoVento->SetWorkingPressRangeMax( m_dWorkingPressRangeMax );
		pclDestinationTBPlenoVento->SetFlowWaterMakeUp(	m_dFlowWaterMakeUp );
		pclDestinationTBPlenoVento->SetKvs( m_dKvs );
		pclDestinationTBPlenoVento->SetRefillable( m_eRefillable );
		pclDestinationTBPlenoVento->SetRefillGroupID( m_RefillGroupIDPtr.ID );
		pclDestinationTBPlenoVento->SetVesselVolumeLimits( m_arVesselVolumeLimits );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_TBPlenoVento::Copy' method with the object '%s'."), GetIDPtr().ID )
}

void CDB_TBPlenoVento::SetVesselVolumeLimits( CArray<VesselVolumeLimit> &arVesselVolumeLimits )
{
	m_arVesselVolumeLimits.RemoveAll();

	for( int i = 0; i < arVesselVolumeLimits.GetCount(); i++ )
	{
		VesselVolumeLimit rVesselVolumLimit;
		rVesselVolumLimit = arVesselVolumeLimits.GetAt( i );
		m_arVesselVolumeLimits.Add( rVesselVolumLimit );
	}
}

void CDB_TBPlenoVento::CrossVerifyID()
{
	HYSELECT_TRY
	{
		CDB_TecBox::CrossVerifyID();

		IDPTR IDPtr = _NULL_IDPTR;

		if( _T('\0') != *m_RefillGroupIDPtr.ID && 0 != _tcscmp( _NO_ID, m_RefillGroupIDPtr.ID ) )
		{
			IDPtr = GetDB()->Get( m_RefillGroupIDPtr.ID );

			if( NULL == IDPtr.MP )
			{
				HYSELECT_THROW( _T("Refill group ID (%s) is defined but not found in the database."), m_RefillGroupIDPtr.ID );
			}

			if( false == IDPtr.MP->IsClass( CLASS( CDB_RuledTable ) ) )
			{
				HYSELECT_THROW( _T("Refill group ID (%s) is found in the database but it's not a 'CDB_RuledTable' object."), m_RefillGroupIDPtr.ID );
			}
		}

		if( ePMPR_RefillNone != m_eRefillable && ( _T('\0') == *m_RefillGroupIDPtr.ID || 0 == _tcscmp( _NO_ID, m_RefillGroupIDPtr.ID ) ) )
		{
			// If refill is optional or mandatory, 'm_RefillGroupIDPtr' must be defined;
			HYSELECT_THROW( _T("If refill (CDB_TBPlenoVento::Refillable) is optional or mandatory, refill group ID (CDB_TBPlenoVento::RefillGroupID) must be defined.") );
		}
	
		if( ePMPR_RefillNone == m_eRefillable && _T('\0') != *m_RefillGroupIDPtr.ID && 0 != _tcscmp( _NO_ID, m_RefillGroupIDPtr.ID ) )
		{
			// If not refillable 'm_RefillGroupIDPtr' can't be defined;
			HYSELECT_THROW( _T("If no refill (CDB_TBPlenoVento::Refillable), refill group ID (CDB_TBPlenoVento::RefillGroupID) must not be defined.") );
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_TBPlenoVento::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

#define CDB_TBPV_VERSION	3
// Version 3: 2017-10-09 - 'm_arVesselVolumeLimits' added.
// Version 2: 2015-08-10: 'm_RefillGroupIDPtr' added.
void CDB_TBPlenoVento::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_TBPV_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CDB_TecBox::Write( outf );

	// Info.
	WriteDouble( outf, GetSystemVolume() );
	WriteDouble( outf, GetWorkingPressRangeMin() );
	WriteDouble( outf, GetWorkingPressRangeMax() );
	WriteDouble( outf, GetFlowWaterMakeUp() );
	WriteDouble( outf, GetKvs() );

	// Version 2.
	outf.write( (char *)&m_eRefillable, sizeof( m_eRefillable ) );
	WriteString( outf, m_RefillGroupIDPtr.ID );

	// Version 3.
	int iCount = m_arVesselVolumeLimits.GetCount();
	outf.write( (char *)&iCount, sizeof( iCount ) );

	if( iCount > 0 )
	{
		for( int i = 0; i < iCount; i++ )
		{
			double dPmin = m_arVesselVolumeLimits.GetAt( i ).m_dPmin;
			outf.write( (char *)&dPmin, sizeof( dPmin ) );

			double dPmax = m_arVesselVolumeLimits.GetAt( i ).m_dPmax;
			outf.write( (char *)&dPmax, sizeof( dPmax ) );

			double dMinimumVolume = m_arVesselVolumeLimits.GetAt( i ).m_dMinimumVolume;
			outf.write( (char *)&dMinimumVolume, sizeof( dMinimumVolume ) );
		}
	}
}

bool CDB_TBPlenoVento::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_TBPV_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CDB_TecBox::Read( inpf ) )
	{
		return false;
	}

	SetSystemVolume( ReadDouble( inpf ) );
	SetWorkingPressRangeMin( ReadDouble( inpf ) );
	SetWorkingPressRangeMax( ReadDouble( inpf ) );
	SetFlowWaterMakeUp( ReadDouble( inpf ) );
	SetKvs( ReadDouble( inpf ) );

	if( Version < 2 )
	{
		return true;
	}

	// Version 2.
	inpf.read( (char *)&m_eRefillable, sizeof( m_eRefillable ) );

	if( false == ReadString( inpf, m_RefillGroupIDPtr.ID, sizeof( m_RefillGroupIDPtr.ID ) ) )
	{
		return false;
	}

	if( Version < 3 )
	{
		return true;
	}

	m_arVesselVolumeLimits.RemoveAll();
	int iCount = 0;
	inpf.read( (char *)&iCount, sizeof( iCount ) );

	if( iCount > 0 )
	{
		for( int i = 0; i < iCount; i++ )
		{
			VesselVolumeLimit rVesselVolumeLimit;
			inpf.read( (char *)&rVesselVolumeLimit.m_dPmin, sizeof( rVesselVolumeLimit.m_dPmin ) );
			inpf.read( (char *)&rVesselVolumeLimit.m_dPmax, sizeof( rVesselVolumeLimit.m_dPmax ) );
			inpf.read( (char *)&rVesselVolumeLimit.m_dMinimumVolume, sizeof( rVesselVolumeLimit.m_dMinimumVolume ) );
			m_arVesselVolumeLimits.Add( rVesselVolumeLimit );
		}
	}

	return true;
}

#define TBPV_SystemVolume				_T("::SystemVolume=")
#define TBPV_WorkingPressRange			_T("::WorkingPressRange=")
#define TBPV_FlowWaterMakeUp			_T("::FlowWaterMakeUp=")
#define TBPV_Kvs						_T("::Kvs=")
#define TBPV_Refillable					_T("::Refillable=")
#define TBPV_RefillGroupID				_T("::RefillGroupID=")
#define TBPV_MinVesselVolume 			_T("::MinimumVesselVolume=")
void CDB_TBPlenoVento::InterpretInheritedData( CString *pStr )
{
	try
	{
		// Base class.
		int iPos = pStr->Find( CLASS( CDB_TBPlenoVento ) );

		if( _T("::") != pStr->Left( 2 ) && iPos < 0 )
		{
			CDB_TecBox::InterpretInheritedData( pStr );
		}
		else
		{
			if( iPos >= 0 )
			{
				pStr->Delete( iPos, _tcsclen( CLASS( CDB_TBPlenoVento ) ) );
			}

			int iEq = pStr->Find( _T("=") );
		
			if( iEq < 0 )
			{
				HYSELECT_THROW( _T("Inherited variable must be preceeded by '='.") );
			}

			CString strField = pStr->Mid( iEq + 1, pStr->GetLength() - iEq );

			if( pStr->Find( TBPV_SystemVolume ) > -1 )
			{
				m_dSystemVolume = _ttof( (LPCTSTR)strField );

				if( m_dSystemVolume < 0.0 && -1.0 != m_dSystemVolume )
				{
					HYSELECT_THROW( _T("'CDB_TBPlenoVento::SystemVolume' (%f) must be equal to -1.0 or greather or equal to 0.0."), m_dSystemVolume );
				}
			}
			else if( pStr->Find( TBPV_WorkingPressRange ) > -1 )
			{
				CArray<double> Ar;
				ParseDoubleList( &Ar,strField );
			
				m_dWorkingPressRangeMin = Ar[0];
				m_dWorkingPressRangeMax = Ar[1];

				if( m_dWorkingPressRangeMin > m_dWorkingPressRangeMax )
				{
					HYSELECT_THROW( _T("'CDB_TBPlenoVento::WorkingPressRange': Working pressure range min (%f) can't be higher than the working pressure range max (%f)."), m_dWorkingPressRangeMin, m_dWorkingPressRangeMax );
				}
			}
			else if( pStr->Find( TBPV_FlowWaterMakeUp ) > -1 )
			{
				m_dFlowWaterMakeUp = _ttof( (LPCTSTR)strField );

				if( m_dFlowWaterMakeUp < 0.0 && -1.0 != m_dFlowWaterMakeUp )
				{
					HYSELECT_THROW( _T("'CDB_TBPlenoVento::FlowWaterMakeUp' (%f) must be equal to -1.0 or greather or equal to 0.0."), m_dFlowWaterMakeUp );
				}
			}
			else if( pStr->Find( TBPV_Kvs ) > -1 )
			{
				m_dKvs = _ttof( (LPCTSTR)strField );

				if( m_dKvs < 0.0 && -1.0 != m_dKvs )
				{
					HYSELECT_THROW( _T("'CDB_TBPlenoVento::Kvs' (%f) must be equal to -1.0 or greather or equal to 0.0."), m_dFlowWaterMakeUp );
				}
			}
			else if( pStr->Find( TBPV_Refillable ) > -1 )
			{
				int iValue = ReadEnum( (LPCTSTR)strField );

				if( iValue != ePMPR_RefillNone && iValue != ePMPR_RefillOptional && iValue != ePMPR_RefillMandatory )
				{
					HYSELECT_THROW( _T("'CDB_TBPlenoVento::Refillable' value must be one of these values: '#ePMPR_RefillNone', '#ePMPR_RefillOptional' or '#ePMPR_RefillMandatory'.") );
				}

				m_eRefillable = (ePRRefillable)iValue;
			}
			else if( pStr->Find( TBPV_RefillGroupID ) > -1 )
			{
				if( strField.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("'CDB_TBPlenoVento::RefillGroupID' (%s) is too long (%i > %i)."), strField, strField.GetLength(), _ID_LENGTH );
				}

				m_RefillGroupIDPtr = _NULL_IDPTR;
				_tcsncpy_s( m_RefillGroupIDPtr.ID, _ID_LENGTH + 1, (LPCTSTR)strField, _ID_LENGTH );
				m_RefillGroupIDPtr.DB = GetDB();
			}
			else if( pStr->Find( TBPV_MinVesselVolume ) > -1 )
			{
				m_arVesselVolumeLimits.RemoveAll();
				int iStart = 0;
				CString strToken = strField.Tokenize( _T("\\"), iStart );

				if( true == strToken.IsEmpty() )
				{
					HYSELECT_THROW( _T("'CDB_TBPlenoVento::MinimumVesselVolume': at least one triplet must be defined.") );
				}

				VesselVolumeLimit rVesselVolumeLimit;

				while( false == strToken.IsEmpty() )
				{
					TCHAR *ptChar = NULL;
					rVesselVolumeLimit.m_dPmin = _tcstod( strToken, &ptChar );
					strToken = strField.Tokenize( _T("\\"), iStart );

					if( true == strToken.IsEmpty() )
					{
						HYSELECT_THROW( _T("'CDB_TBPlenoVento::MinimumVesselVolume': Pmax must be defined.") );
					}

					rVesselVolumeLimit.m_dPmax = _tcstod( strToken, &ptChar );
					strToken = strField.Tokenize( _T("\\"), iStart );

					if( true == strToken.IsEmpty() )
					{
						HYSELECT_THROW( _T("'CDB_TBPlenoVento::MinimumVesselVolume': Minimum vessel volume must be defined.") );
					}

					rVesselVolumeLimit.m_dMinimumVolume = _tcstod( strToken, &ptChar );
					m_arVesselVolumeLimits.Add( rVesselVolumeLimit );

					strToken = strField.Tokenize( _T("\\"), iStart );
				}
			}
			else
			{
				HYSELECT_THROW( _T("Can't find inherited variable in '%s'."), strField );
			}
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_TBPlenoVento::InterpretInheritedData' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_TBPlenoVento::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			IDPTR idptr = GetDB()->Get( ihID );

			if( _T('\0') == *idptr.ID )
			{
				HYSELECT_THROW( _T("ID for the base object must be defined (pos: %i)."), *pusLineCount );
			}

			( (CDB_TBPlenoVento *)idptr.MP )->Copy( this );
			
			CStringArray ar;
			GetInheritedModifiedData( inpf, pusLineCount, &ar );
		
			for( int i = 0; i < ar.GetCount(); i++ )
			{
				CString str = ar.GetAt( i );
				CDB_TBPlenoVento::InterpretInheritedData( &str );
			}
		}
		else
		{
			// Read base.
			CDB_TecBox::ReadText( inpf, pusLineCount );

			CStringArray TxtHdr;
			TxtHdr.Add( TBPV_SystemVolume );
			TxtHdr.Add( TBPV_WorkingPressRange );
			TxtHdr.Add( TBPV_FlowWaterMakeUp );
			TxtHdr.Add( TBPV_Kvs );
			TxtHdr.Add( TBPV_Refillable );
			TxtHdr.Add( TBPV_RefillGroupID );
			TxtHdr.Add( TBPV_MinVesselVolume );

			for( int i = 0; i < TxtHdr.GetSize(); i++ )
			{
				ptcLine = ReadTextLine( inpf, pusLineCount );

				CString str = TxtHdr[i] + CString(ptcLine );
				CDB_TBPlenoVento::InterpretInheritedData( &str );
			}
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_TBPlenoVento::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_TBPlenoVento::WriteText( OUTSTREAM outf, CString &strTab )
{
	/*
	if( m_arVesselVolumeLimits.GetCount() > 0 )
	{
		for( int i = 0; i < m_arVesselVolumeLimits.GetCount(); i++ )
		{
			str1 = WriteDouble( m_arVesselVolumeLimits.GetAt( i ).m_dPmin, 2, 1 );
			str2 = WriteDouble( m_arVesselVolumeLimits.GetAt( i ).m_dPmax, 2, 1 );
			CString str3 = WriteDouble( m_arVesselVolumeLimits.GetAt( i ).m_dMinimumVolume, 2, 1 );

			if( 0 == i )
			{
				str.Format( _T("\r\n%s \\ %s \\ %s"), str1, str2, str3 );
			}
			else
			{
				str.Format( _T(" \\ %s \\ %s \\ %s"), str1, str2, str3 );
			}
		}

		outf.write( (char *)(LPCTSTR)str, str.GetLength() * sizeof( TCHAR ) );
	}
	*/
}

///////////////////////////////////////////////////////////////////////////////////
//
//								CDB_PriceList
//
///////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_PriceList )
CDB_PriceList::CDB_PriceList( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
}

double CDB_PriceList::GetPrice( CString strArticleNumber )
{
	double dPrice = 0.0;
	
	CString strClean = strArticleNumber;
	_CleanArticleNumber( strClean );

	if( 0 != m_mapPriceList.count( strClean ) )
	{
		dPrice = m_mapPriceList[strClean];
	}

	return dPrice;
}

#define CDB_PRICELIST_VERSION	1
void CDB_PriceList::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_PRICELIST_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CData::Write( outf );

	int iCount = (int)m_mapPriceList.size();
	outf.write( (char *)&iCount, sizeof( iCount ) );

	for( std::map<CString, double>::iterator iter = m_mapPriceList.begin(); iter != m_mapPriceList.end(); iter++ )
	{
		WriteString( outf, (LPCTSTR)iter->first );
		WriteDouble( outf, iter->second );
	}
}

bool CDB_PriceList::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_PRICELIST_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	int iCount = 0;
	inpf.read( (char *)&iCount, sizeof( iCount ) );

	TCHAR tcArticle[_ID_LENGTH + 1];
	double dPrice;
	m_mapPriceList.clear();

	for( int iLoop = 0; iLoop < iCount; iLoop++ )
	{
		if( false == ReadString( inpf, tcArticle, sizeof( tcArticle ) ) )
		{
			return false;
		}

		dPrice = ReadDouble( inpf );

		m_mapPriceList[CString(tcArticle)] = dPrice;
	}

	return true;
}

void CDB_PriceList::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_PriceList format
		// line 0 : open curve bracket and call base class.
		// line 1 : Article number 1 \ price 1
		// line 2 : Article number 2 \ price 2
		// line ..
		// line 1+nline : Article number n \ price n
		// line 2+nline : close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		// Read base.
		CData::ReadText( inpf, pusLineCount );

		m_mapPriceList.clear();

		ptcLine = ReadTextLine( inpf, pusLineCount, false );
		CString strLine = ptcLine;

		while( false == strLine.IsEmpty() )
		{
			if( _T('}') == strLine.GetAt( 0 ) )
			{
				break;
			}

			int iPos = strLine.Find( _T("\\") );

			if( iPos < 0 )
			{
				CString strError;
				strError.Format( _T("Error when reading price list in line %i - Article number and price must be separated by a tabulation character\n"), *pusLineCount );
				TRACE( strError );
			
				ptcLine = ReadTextLine( inpf, pusLineCount, false );
				strLine = ptcLine;

				continue;
			}

			CString strArticleFull = strLine.Mid( 0, iPos );
			strArticleFull.Trim();
			_CleanArticleNumber( strArticleFull );

			if( true == strArticleFull.IsEmpty() )
			{
				CString strError;
				strError.Format( _T("Error when reading price list in line %i - Article number not correct\n"), *pusLineCount );
				TRACE( strError );
			
				ptcLine = ReadTextLine( inpf, pusLineCount, false );
				strLine = ptcLine;

				continue;
			}

			if( 0 != m_mapPriceList.count( strArticleFull ) ) 
			{
				CString strError;
				strError.Format( _T("Error when reading price list in line %i - Article number duplicated\n"), *pusLineCount );
				TRACE( strError );
			
				ptcLine = ReadTextLine( inpf, pusLineCount, false );
				strLine = ptcLine;

				continue;
			}

			CString strPrice = strLine.Mid( iPos + 1, strLine.GetLength() - iPos + 1 );
			strPrice.Trim();
			double dPrice = _ttof( (LPCTSTR)strPrice );

			if( dPrice <= 0.0 ) 
			{
				CString strError;
				strError.Format( _T("Error when reading price list in line %i - Price is not correct\n"), *pusLineCount );
				TRACE( strError );
			
				ptcLine = ReadTextLine( inpf, pusLineCount, false );
				strLine = ptcLine;

				continue;
			}

			m_mapPriceList[strArticleFull] = dPrice;

			ptcLine = ReadTextLine( inpf, pusLineCount, false );
			strLine = ptcLine;
		}

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_PriceList::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

void CDB_PriceList::_CleanArticleNumber( CString &strArticleNumber )
{
	strArticleNumber.Trim();
	CString strArticleCleaned = _T("");
	
	for( int i = 0; i < strArticleNumber.GetLength(); ++i )
	{
		if( 0 != _istalnum( strArticleNumber.GetAt( i ) ) )
		{
			strArticleCleaned.AppendChar( strArticleNumber.GetAt( i ) );
		}
	}

	strArticleNumber = strArticleCleaned;
}
#endif

#ifndef TACBX
IMPLEMENT_DATA( CDB_StringArray )
CDB_StringArray::CDB_StringArray( CDataBase *pDataBase, LPCTSTR ID )
	: CData( pDataBase, ID )
{
	m_nCol = 0;
	m_pVecStringTabs = NULL;
}

void CDB_StringArray::_Reset()
{
	if( NULL != m_pVecStringTabs )
	{
		if( false != m_pVecStringTabs->empty() )
		{
			int iSize = (int)m_pVecStringTabs->size();

			for (int i = 0; i < iSize; i++)
			{
				m_pVecStringTabs->at( i ).clear();
			}
			
			ASSERT( m_pVecStringTabs->empty() == true );
		}
		
		delete m_pVecStringTabs;
		m_pVecStringTabs = NULL;
	}
}

CDB_StringArray::~CDB_StringArray()
{
	_Reset();
}

void CDB_StringArray::GetStringTabs( vector<vector<CString>> **pVectStringTab )
{
	if( NULL == pVectStringTab )
	{
		return;
	}
	
	*pVectStringTab = new vector<vector<CString>>();
	int iSize = (int)m_pVecStringTabs->size();

	for (int i = 0; i < iSize; i++)
	{
		(*pVectStringTab)->push_back(m_pVecStringTabs->at(i));
	}
	
	ASSERT( (int)(*pVectStringTab)->size() == iSize );
}

void CDB_StringArray::SetStringTabs( vector<vector<CString>> *pVecStringTabs )
{
	HYSELECT_TRY
	{
		if( NULL == pVecStringTabs )
		{
			HYSELECT_THROW( _T("'pVecStringTabs' argument can't be null!") );
		}

		_Reset();

		m_pVecStringTabs = new vector<vector<CString>>();

		if( NULL == m_pVecStringTabs )
		{
			HYSELECT_THROW( _T("Can't instantiate the 'm_pVecStringTabs' variable!") );
		}

		for( auto &iter : *pVecStringTabs )
		{
			m_pVecStringTabs->push_back( iter );
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_StringArray::SetStringTabs' method with the object '%s'."), GetIDPtr().ID )
}

void CDB_StringArray::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_StringArray *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_StringArray' object!") );
		}

		// Base class.
		CData::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_StringArray" class.
		CDB_StringArray *pclDestinationStringArray = (CDB_StringArray *)( pclDestination );

		pclDestinationStringArray->SetCol( m_nCol );
		pclDestinationStringArray->SetStringTabs( m_pVecStringTabs );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_StringArray::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_STRING_ARRAY_VERSION	1
void CDB_StringArray::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_STRING_ARRAY_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CData::Write( outf );

	// Number of column.
	outf.write( (char *)&m_nCol, sizeof( m_nCol ) );
	
	if( 0 == m_nCol )
	{
		return;
	}
	
	// Write number of lines.
	int iSize = (int)m_pVecStringTabs->size();
	outf.write( (char *)&iSize, sizeof( iSize ) );

	// Write all lines.
	for( int iLoopRow = 0; iLoopRow < iSize; iLoopRow++ )
	{
		// Write all columns.
		for( int iLoopValue = 0; iLoopValue < (int)m_pVecStringTabs->at( iLoopRow ).size(); iLoopValue++ )
		{
			WriteString( outf, m_pVecStringTabs->at( iLoopRow ).at( iLoopValue ) );
		}
	}
}

bool CDB_StringArray::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );
	
	if( Version < 1 || Version > CDB_STRING_ARRAY_VERSION )
	{
		return false;
	}

	// Base class.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Number of column.
	inpf.read( (char *)&m_nCol, sizeof( m_nCol ) );

	if( 0 == m_nCol )
	{
		return false;
	}

	if( NULL != m_pVecStringTabs )
	{
		delete m_pVecStringTabs;
	}

	m_pVecStringTabs = new vector<vector<CString>>();
	CString strtmp = _T("");

	// Read number of lines.
	int iSize = 0;
	inpf.read( (char *)&iSize, sizeof( iSize ) );

	for( int iLoopRow = 0; iLoopRow < iSize; iLoopRow++ )
	{
		vector<CString> Arrtmp;

		for( int iLoopValue = 0; iLoopValue < m_nCol; iLoopValue++ )
		{
			ReadString( inpf, strtmp );
			Arrtmp.push_back( strtmp );
		}
		
		m_pVecStringTabs->push_back( Arrtmp );
	}

	return true;
}

void CDB_StringArray::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_StringArray format
		// line 0 : open curve bracket and call base class
		// line 1 : number of vertical entries 
		// line 2 to n-1 : definitions of objects selected
		// line n : close curve bracket

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine(inpf, pusLineCount);

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		_Reset();

		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			// Reach the close curve bracket.
			while( _T('}') != *ptcLine )
			{
				ptcLine = ReadTextLine(inpf, pusLineCount );
			}

			HYSELECT_THROW( _T("No inheritance available for this object (pos: %i)."), *pusLineCount );
		}

		// Read base.
		CData::ReadText( inpf, pusLineCount );

		// Read the number of vertical entries.
		ptcLine = ReadTextLine(inpf, pusLineCount);
		
		int iCols = _ttoi(ptcLine);

		if( iCols <= 0 )
		{
			HYSELECT_THROW( _T("Column (%i) can't lower or equal to 0 (pos: %i)."), iCols, *pusLineCount );
		}

		m_nCol = iCols;
		m_pVecStringTabs = new vector<vector<CString>>();

		// Read the first line (definitions of objects selected).
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') == *ptcLine )
		{
			HYSELECT_THROW( _T("Unexpected '}' (pos: %i)."), *pusLineCount );

		}
	
		while( _T('}') != *ptcLine )
		{
			int iCheck = 0;
			vector<CString> ArrTemp;
			int iCount = 0;

			TCHAR **pptcField = ParseTextLine( ptcLine, &iCheck );

			for( int iLoopVADefs = 0; iLoopVADefs < iCols; iLoopVADefs++ )
			{
				if( iCount < iCols )
				{
					CString str = pptcField[iLoopVADefs];
					ArrTemp.push_back( str );
					iCount++;
				}
			}
		
			m_pVecStringTabs->push_back( ArrTemp );
			ptcLine = ReadTextLine( inpf, pusLineCount );
		}

		// Read the close curve bracket.
		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_String::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

IMPLEMENT_DATA( CDB_BufferVesselTI )
CDB_BufferVesselTI::CDB_BufferVesselTI( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_StringArray( pDataBase, ID )
{
	m_vectVDList.clear();
	m_vectPSVList.clear();
	m_pVectStringList = NULL;
}

CDB_BufferVesselTI::~CDB_BufferVesselTI()
{
	Reset();
}

void CDB_BufferVesselTI::Reset()
{
	if( false != m_vectVDList.empty() )
	{
		m_vectVDList.clear();
		ASSERT( m_vectVDList.empty() == true );
	}

	if( false != m_vectPSVList.empty() )
	{
		m_vectPSVList.clear();
		ASSERT( m_vectPSVList.empty() == true );
	}

	if( NULL != m_pVectStringList )
	{
		if( false != m_pVectStringList->empty() )
		{
			m_pVectStringList->clear();
			ASSERT( m_pVectStringList->empty() == true );
		}

		delete m_pVectStringList;
		m_pVectStringList = NULL;
	}
}

void CDB_BufferVesselTI::CopyAllVectorsFrom( CDB_BufferVesselTI *pclSourceBufferVesselTI )
{
	HYSELECT_TRY
	{
		if( NULL == pclSourceBufferVesselTI )
		{
			HYSELECT_THROW( _T("'pclSourceBufferVesselTI' argument can't be null!") );
		}

		vector<CString> *pVectString = pclSourceBufferVesselTI->GetStringList();
		vector<std::pair<CString, double>> vectVDList = pclSourceBufferVesselTI->GetVectVDList();
		vector<std::pair<CString, double>> vectPSVList = pclSourceBufferVesselTI->GetVectPSVList();

		if( NULL == pVectString || true == vectVDList.empty() || true == vectPSVList.empty() )
		{
			return;
		}

		Reset();

		m_vectVDList.clear();
		m_vectPSVList.clear();

		delete m_pVectStringList;
		m_pVectStringList = new vector<CString>();

		if( NULL == m_pVectStringList )
		{
			HYSELECT_THROW( _T("Internal error: 'm_pVectStringList' instantiation error.") );
		}

		for (int i = 0; i < (int)pVectString->size(); i++)
		{
			m_pVectStringList->push_back( pVectString->at( i ) );
			m_vectVDList.push_back( vectVDList.at( i ) );
			m_vectPSVList.push_back( vectPSVList.at( i ) );
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_BufferVesselTI::CopyAllVectors' method with the object '%s'."), GetIDPtr().ID )
}

void CDB_BufferVesselTI::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_BufferVesselTI *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_BufferVesselTI' object!") );
		}

		// Base class.
		CDB_StringArray::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_BufferVesselTI" class.
		CDB_BufferVesselTI *pclDestinationBufferVesselTI = (CDB_BufferVesselTI *)pclDestination;

		pclDestinationBufferVesselTI->CopyAllVectorsFrom( this );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_BufferVesselTI::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_BUFFER_VESSEL_TI_VERSION	2
// Version 2: 2019-07-03: We don't need to write the 'CDB_StringArray' base class because it's redundant.
void CDB_BufferVesselTI::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_BUFFER_VESSEL_TI_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	CData::Write( outf );

	int iSizeVD = (int)m_vectVDList.size();
	int iSizePSV = (int)m_vectPSVList.size();
	int iSizeStr = (int)m_pVectStringList->size();

	if( ( iSizePSV != iSizeVD ) || ( 2 * iSizePSV != iSizeStr ) )
	{
		ASSERT_RETURN;
	}

	// Write number of objects saved.
	outf.write( (char *)&iSizeVD, sizeof( iSizeVD ) );

	int iLoopStr = 0;

	for( int iLoop = 0; iLoop < iSizeVD; iLoop++ )
	{
		// Object id.
		WriteString( outf, m_pVectStringList->at( iLoopStr++ ) );

		// "<" or ">".
		WriteString( outf, m_vectVDList.at( iLoop ).first );

		// Vd value.
		WriteDouble( outf, m_vectVDList.at( iLoop ).second );

		// "<" or ">".
		WriteString( outf, m_vectPSVList.at( iLoop ).first );

		// PSV value.
		WriteDouble( outf, m_vectPSVList.at( iLoop ).second );

		// Buffer vessel ID.
		WriteString( outf, m_pVectStringList->at( iLoopStr++ ) );
	}
}

bool CDB_BufferVesselTI::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_BUFFER_VESSEL_TI_VERSION )
	{
		return false;
	}

	// Base class.
	if( Version < 2 )
	{
		if( false == CDB_StringArray::Read( inpf ) )
		{
			return false;
		}
	}
	else
	{
		if( false == CData::Read( inpf ) )
		{
			return false;
		}
	}

	if( NULL != m_pVectStringList )
	{
		delete m_pVectStringList;
	}
	
	m_pVectStringList = new vector<CString>();
	ASSERT( NULL != m_pVectStringList );

	m_vectVDList.clear();
	m_vectPSVList.clear();
	CString strtmp = _T("");

	// Read number of objects saved.
	int iSizeVD = 0;
	inpf.read( (char *)&iSizeVD, sizeof( iSizeVD ) );

	if( iSizeVD > 0 )
	{
		for( int iLoop = 0; iLoop < iSizeVD; iLoop++ )
		{
			// Read object ID.
			ReadString( inpf, strtmp );
			m_pVectStringList->push_back( strtmp );

			CString strInfSup = _T("");
			double dVd = 0.0;
			double dPsv = 0.0;

			// Read "<" or ">" AND Vd value.
			ReadString( inpf, strInfSup );
			dVd = ReadDouble( inpf );
			m_vectVDList.push_back( std::make_pair( strInfSup, dVd ) );

			// Read "<" or ">" AND PSV value.
			strInfSup = _T("");
			ReadString( inpf, strInfSup );
			dPsv = ReadDouble( inpf );
			m_vectPSVList.push_back( std::make_pair( strInfSup, dPsv ) );

			// Read ID of buffer vessel.
			strtmp = _T("");
			ReadString( inpf, strtmp );
			m_pVectStringList->push_back( strtmp );
		
			strtmp = _T("");
		}
	}

	return true;
}

void CDB_BufferVesselTI::ReadText(INPSTREAM inpf, unsigned short *pusLineCount)
{
	try
	{
		// CDB_BufferVesselTI format
		// line 0 : open curve bracket and call base class

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine(inpf, pusLineCount);

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}
	
		_Reset();

		m_vectVDList.clear();
		m_vectPSVList.clear();
		m_pVectStringList = NULL;

		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			// Reach the close curve bracket.
			while( _T('}') != *ptcLine )
			{
				ptcLine = ReadTextLine( inpf, pusLineCount );
			}

			HYSELECT_THROW( _T("No inheritance available for this object (pos: %i)."), *pusLineCount );
		}

		// Read base.
		CDB_StringArray::ReadText( inpf, pusLineCount );
	
		// No element to read for the child class.

		m_pVectStringList = new vector<CString>();

		if( NULL == m_pVectStringList )
		{
			HYSELECT_THROW( _T("Internal error: 'm_pVectStringList' instantiation error (pos: %i)."), *pusLineCount );
		}

		vector<vector<CString>> *pVectarray = NULL;

		// Get the data of parent class.
		GetStringTabs( &pVectarray );

		for( int i = 0; i < (int)pVectarray->size(); i++ )
		{
			CString strtmp = _T("");
		
			// First: element ID of TI table.
			m_pVectStringList->push_back( pVectarray->at( i ).at( 0 ) );
		
			// Second: VD value.
			// Separate value and ">"
			int iOldSize = pVectarray->at( i ).at( 1 ).GetLength();
			pVectarray->at( i ).at( 1 ).Trim( _T("<") );
		
			if( iOldSize > pVectarray->at( i ).at( 1 ).GetLength() )
			{
				TCHAR *ptcEndPtr;
				double dVDValue = _tcstod( pVectarray->at( i ).at( 1 ), &ptcEndPtr );

				if( _T('\0') != *ptcEndPtr )
				{
					HYSELECT_THROW( _T("Can't convert VD value (%s) in double (pos: %i)."), pVectarray->at( i ).at( 1 ), *pusLineCount );
				}
			
				m_vectVDList.push_back(std::make_pair(_T("<"), dVDValue));
			}
			else
			{
				pVectarray->at( i ).at( 1 ).Trim( _T(">") );
			
				if( iOldSize > pVectarray->at( i ).at( 1 ).GetLength() )
				{
					TCHAR *ptcEndPtr;
					double dVDValue = _tcstod( pVectarray->at( i ).at( 1 ), &ptcEndPtr );

					if( _T('\0') != *ptcEndPtr )
					{
						HYSELECT_THROW( _T("Can't convert VD value (%s) in double (pos: %i)."), pVectarray->at( i ).at( 1 ), *pusLineCount );
					}
				
					m_vectVDList.push_back( std::make_pair( _T(">"), dVDValue ) );
				}
			}
			
			// Third: PSV value.
			// Separate value and ">".
			iOldSize = pVectarray->at( i ).at( 2 ).GetLength();
			pVectarray->at( i ).at( 2 ).Trim( _T("<") );
		
			if( iOldSize > pVectarray->at( i ).at( 2 ).GetLength() )
			{
				TCHAR *ptcEndPtr;
				double dPSVValue = _tcstod( pVectarray->at( i ).at( 2 ), &ptcEndPtr );

				if( _T('\0') != *ptcEndPtr )
				{
					delete pVectarray;
					HYSELECT_THROW( _T("Can't convert PSV value (%s) in double (pos: %i)."), pVectarray->at( i ).at( 2 ), *pusLineCount );
				}

				m_vectPSVList.push_back( std::make_pair( _T("<"), dPSVValue ) );
			}

			// Fourth: string ID buffer.
			m_pVectStringList->push_back( pVectarray->at( i ).at( 3 ) );
		}
	
		delete pVectarray;

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_BufferVesselTI::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

////////////////////////////////////////////////////////////////
//
//		CDB_BlowTankAllocation : Object that help to choose
//       blow tank device with safety valve.
//
////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_BlowTankAllocation )
CDB_BlowTankAllocation::CDB_BlowTankAllocation( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_StringArray( pDataBase, ID )
{
	m_mapBlowTankAllocation.clear();
}

CString CDB_BlowTankAllocation::GetBlowTank( CDB_SafetyValveBase *pclSafetyValve, double dPSV )
{
	if( NULL == pclSafetyValve )
	{
		return _T("");
	}

	if( 0 == m_mapBlowTankAllocation.count( pclSafetyValve->GetFamilyID() ) 
			|| 0 == m_mapBlowTankAllocation.at( pclSafetyValve->GetFamilyID() ).count( pclSafetyValve->GetSizeID() ) )
	{
		return _T("");
	}

	for( auto &iter : m_mapBlowTankAllocation.at( pclSafetyValve->GetFamilyID() ).at( pclSafetyValve->GetSizeID() ) )
	{
		if( OperatorSign::Undefined == iter.m_iOperatorSign )
		{
			continue;
		}

		if( ( OperatorSign::LowerThan == iter.m_iOperatorSign && dPSV < iter.m_dPSVLimit )
				|| ( OperatorSign::LowerOrEqualThan == iter.m_iOperatorSign && dPSV <= iter.m_dPSVLimit )
				|| ( OperatorSign::GreaterThan == iter.m_iOperatorSign && dPSV > iter.m_dPSVLimit )
				|| ( OperatorSign::GreaterOrEqualThan == iter.m_iOperatorSign && dPSV >= iter.m_dPSVLimit ) )
		{
			return iter.m_strBlowTankID;
		}
	}

	return _T("");
}

void CDB_BlowTankAllocation::CopyBlowTankAllocationFrom( CDB_BlowTankAllocation *pclSourceBlowTankAllocation )
{
	HYSELECT_TRY
	{
		if( NULL == pclSourceBlowTankAllocation )
		{
			HYSELECT_THROW( _T("'pclSourceBlowTankAllocation' argument can't be null!") );
		}

		m_mapBlowTankAllocation.clear();

		for( auto &iter : pclSourceBlowTankAllocation->GetBlowTankAllocation() )
		{
			m_mapBlowTankAllocation.insert( std::pair<CString, std::map<CString, std::vector<BTAllocData>>>( iter.first, iter.second ) );
	}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_BlowTankAllocation::CopyBlowTankAllocationFrom' method with the object '%s'."), GetIDPtr().ID )
}

void CDB_BlowTankAllocation::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_BlowTankAllocation *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_BlowTankAllocation' object!") );
		}

		// Base class.
		CDB_StringArray::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_BlowTankAllocation" class.
		CDB_BlowTankAllocation *pclDedstinationBlowTankAllocation = (CDB_BlowTankAllocation *)pclDestination;

		pclDedstinationBlowTankAllocation->CopyBlowTankAllocationFrom( this );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_BlowTankAllocation::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_BLOWTANKALLOCATION_VERSION	1
void CDB_BlowTankAllocation::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_BLOWTANKALLOCATION_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	// We intentionally don't call the 'CDB_StringArray' base class but directly 'CData'.
	// Otherwise we will write redundant information.
	CData::Write( outf );

	// Write number of safety valve family IDs saved.
	int iSize = m_mapBlowTankAllocation.size();
	outf.write( (char *)&iSize, sizeof( iSize ) );

	for( auto &iterSVFamily : m_mapBlowTankAllocation )
	{
		// Safety valve family ID.
		WriteString( outf, iterSVFamily.first );

		// Write number of safety valve size IDs saved for the current family.
		iSize = iterSVFamily.second.size();
		outf.write( (char *)&iSize, sizeof( iSize ) );

		for( auto &iterSVSize : iterSVFamily.second )
		{
			// Safety valve size ID.
			WriteString( outf, iterSVSize.first );

			// Write number of blow tank allocations for the current safety valve family and size.
			// Must be 2!!
			iSize = iterSVSize.second.size();
			outf.write( (char *)&iSize, sizeof( iSize ) );

			for( auto &iterBTAlloc : iterSVSize.second )
			{
				// Operator sign.
				outf.write( (char *)&iterBTAlloc.m_iOperatorSign, sizeof( iterBTAlloc.m_iOperatorSign ) );

				// PSV limit.
				WriteDouble( outf, iterBTAlloc.m_dPSVLimit );

				// Blow tank ID.
				WriteString( outf, iterBTAlloc.m_strBlowTankID );
			}
		}
	}
}

bool CDB_BlowTankAllocation::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_BLOWTANKALLOCATION_VERSION )
	{
		return false;
	}

	// Base class.
	// We intentionally didn't write with 'CDB_StringArray' base class but directly 'CData'.
	// Otherwise we will have redundant information.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Read number of safety valve family IDs saved.
	int iSVFamilyNumber = 0;
	inpf.read( (char *)&iSVFamilyNumber, sizeof( iSVFamilyNumber ) );

	if( 0 == iSVFamilyNumber )
	{
		return true;
	}

	for( int iLoopSVFamily = 0; iLoopSVFamily < iSVFamilyNumber; iLoopSVFamily++ )
	{
		// Read safety valve family ID.
		CString strSafetyValveFamilyID = _T("");
		ReadString( inpf, strSafetyValveFamilyID );

		// Read number of safety valve size IDs saved for the current family.
		int iSVSizeNumber = 0;
		inpf.read( (char *)&iSVSizeNumber, sizeof( iSVSizeNumber ) );
		std::map<CString, std::vector<BTAllocData>> mapAllSizeBlowTankAllocation;

		for( int iLoopSVSize = 0; iLoopSVSize < iSVSizeNumber; iLoopSVSize++ )
		{
			// Read safety valve size ID.
			CString strSafetyValveSizeID = _T("");
			ReadString( inpf, strSafetyValveSizeID );

			// Read number of allocations saved.
			int iBlowTankAllocationNumber = 0;
			inpf.read( (char *)&iBlowTankAllocationNumber, sizeof( iBlowTankAllocationNumber ) );
			std::vector<BTAllocData> vecBlowTankAllocation;

			for( int iLoopAlloc = 0; iLoopAlloc < iBlowTankAllocationNumber; iLoopAlloc++ )
			{
				BTAllocData rBTAllocData;

				// Read the operator sign.
				inpf.read( (char *)&rBTAllocData.m_iOperatorSign, sizeof( rBTAllocData.m_iOperatorSign ) );

				// Read psv limit.
				rBTAllocData.m_dPSVLimit = ReadDouble( inpf );

				// Read the blow tank ID.
				ReadString( inpf, rBTAllocData.m_strBlowTankID );

				vecBlowTankAllocation.push_back( rBTAllocData );
			}

			mapAllSizeBlowTankAllocation.insert( std::pair<CString, std::vector<BTAllocData>>( strSafetyValveSizeID, vecBlowTankAllocation ) );
		}

		m_mapBlowTankAllocation.insert( std::pair<CString, std::map<CString, std::vector<BTAllocData>>>( strSafetyValveFamilyID, mapAllSizeBlowTankAllocation ) );
	}

	return true;
}

void CDB_BlowTankAllocation::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// CDB_BlowTankAllocation format
		// line 0 : open curve bracket and call base class

		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		_Reset();

		m_mapBlowTankAllocation.clear();

		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			// Reach the close curve bracket.
			while( _T('}') != *ptcLine )
			{
				ptcLine = ReadTextLine( inpf, pusLineCount );
			}

			HYSELECT_THROW( _T("No inheritance available for this object (pos: %i)."), *pusLineCount );
		}

		// Read base.
		CDB_StringArray::ReadText( inpf, pusLineCount );
	
		// Get the data of parent class.
		vector< vector< CString > > *pVectarray = NULL;
		GetStringTabs( &pVectarray );

		for( int iLoopLine = 0; iLoopLine < (int)pVectarray->size(); iLoopLine++ )
		{
			CString strSafetyValveFamilyID = pVectarray->at( iLoopLine ).at( 0 );

			if( strSafetyValveFamilyID.GetLength() > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Safety valve family ID (%s) is too long (%i > %i) (pos: %i)."), strSafetyValveFamilyID, strSafetyValveFamilyID.GetLength(), _ID_LENGTH, *pusLineCount );
			}

			CString strSafetyValveSizeID = pVectarray->at( iLoopLine ).at( 1 );

			if( strSafetyValveSizeID.GetLength() > _ID_LENGTH )
			{
				HYSELECT_THROW( _T("Safety valve size ID (%s) is too long (%i > %i) (pos: %i)."), strSafetyValveSizeID, strSafetyValveSizeID.GetLength(), _ID_LENGTH, *pusLineCount );
			}

			std::vector<BTAllocData> vecBlowTankAllocation;
			int iLoopBT = 2;

			do
			{
				BTAllocData rBTAllocData;
				rBTAllocData.m_iOperatorSign = (int)OperatorSign::Undefined;

				// First element is the psv limit with operator sign.
				CString OperatorSigns[]  = { _T("<="), _T(">="), _T("<"), _T(">") };
			
				for( int i = 0; i < 4; i++ )
				{
					if( -1 != pVectarray->at( iLoopLine ).at( iLoopBT ).Find( OperatorSigns[i] ) )
					{
						rBTAllocData.m_iOperatorSign = (OperatorSign)i;
						pVectarray->at( iLoopLine ).at( iLoopBT ).Trim( OperatorSigns[i] );
					}
				}

				if( OperatorSign::Undefined == rBTAllocData.m_iOperatorSign && pVectarray->at( iLoopLine ).at( iLoopBT ).GetLength() > 0 )
				{
					HYSELECT_THROW( _T("If operator is not defined, we can't have a PSV value (%s) (pos: %i)."), pVectarray->at( iLoopLine ).at( iLoopBT ), *pusLineCount );
				}

				// Now read the psv limit.
				TCHAR *ptcEndPtr;
				rBTAllocData.m_dPSVLimit = _tcstod( pVectarray->at( iLoopLine ).at( iLoopBT ), &ptcEndPtr );

				if( _T('\0') != *ptcEndPtr )
				{
					HYSELECT_THROW( _T("Can't convert PSV value (%s) in double (pos: %i)."), pVectarray->at( iLoopLine ).at( iLoopBT ), *pusLineCount );
				}

				// Now read the blow tank ID.
				rBTAllocData.m_strBlowTankID = pVectarray->at( iLoopLine ).at( iLoopBT + 1 );

				if( rBTAllocData.m_strBlowTankID.GetLength() > _ID_LENGTH )
				{
					HYSELECT_THROW( _T("Blow tank ID (%s) is too long (%i > %i) (pos: %i)."), rBTAllocData.m_strBlowTankID, rBTAllocData.m_strBlowTankID.GetLength(), _ID_LENGTH, *pusLineCount );
				}

				vecBlowTankAllocation.push_back( rBTAllocData );
				iLoopBT += 2;

			}while( iLoopBT < 6 );

			if( 0 == m_mapBlowTankAllocation.count( strSafetyValveFamilyID ) )
			{
				// If family doesn't exist yet, we insert this new line.
				std::map<CString, std::vector<BTAllocData>> mapBTAlloc;
				mapBTAlloc.insert( std::pair<CString, std::vector<BTAllocData>>( strSafetyValveSizeID, vecBlowTankAllocation ) );
				m_mapBlowTankAllocation.insert( std::pair<CString, std::map<CString, std::vector<BTAllocData>>>( strSafetyValveFamilyID, mapBTAlloc ) );
			}
			else
			{
				if( 0 == m_mapBlowTankAllocation.at( strSafetyValveFamilyID ).count( strSafetyValveSizeID ) )
				{
					// We insert the new line in the existing family.
					m_mapBlowTankAllocation.at( strSafetyValveFamilyID ).insert( std::pair<CString, std::vector<BTAllocData>>( strSafetyValveSizeID, vecBlowTankAllocation ) );
				}
				else
				{
					HYSELECT_THROW( _T("Can't have the same safety valve size ID (%s) in the same safety valve family ID (%s) (pos: %i)."),strSafetyValveSizeID, strSafetyValveFamilyID, *pusLineCount );
				}
			}
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}

		delete pVectarray;
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_BlowTankAllocation::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}

////////////////////////////////////////////////////////////////
//
// CDB_6WayValveActuatorCompatibility
// This table contains for each circuit type, the power supply and input signal for the 
// actuator that are compatible with the 6-way valve.
////////////////////////////////////////////////////////////////

IMPLEMENT_DATA( CDB_6WayValveActuatorCompatibility )
CDB_6WayValveActuatorCompatibility::CDB_6WayValveActuatorCompatibility( CDataBase *pDataBase, LPCTSTR ID )
	: CDB_StringArray( pDataBase, ID )
{
	m_mapActuatorFilters.clear();
}

CDB_6WayValveActuatorCompatibility::ActuatorFilters *CDB_6WayValveActuatorCompatibility::GetOneActutorFilters( e6WayValveSelectionMode eSixWayAppType )
{
	ActuatorFilters *pReturn = NULL;

	if( m_mapActuatorFilters.count( eSixWayAppType ) )
	{
		pReturn = &m_mapActuatorFilters.at( eSixWayAppType );

		for( auto &iter : pReturn->m_6WayValveActuatorPowerSupplyIDCompatibilityList )
		{
			iter.DB = GetDB();
			Extend( &iter );
		}

		for( auto &iter : pReturn->m_6WayValveActuatorInputSignalIDCompatibilityList )
		{
			iter.DB = GetDB();
			Extend( &iter );
		}

		for( auto &iter : pReturn->m_PIBCValveActuatorFamilyIDCompatibilityList )
		{
			iter.DB = GetDB();
			Extend( &iter );
		}
	}

	return pReturn;
}

void CDB_6WayValveActuatorCompatibility::CopyAllActuatorFilters( CDB_6WayValveActuatorCompatibility *pclFrom6WayValveActuatorCompatibility )
{
	HYSELECT_TRY
	{
		if( NULL == pclFrom6WayValveActuatorCompatibility )
		{
			HYSELECT_THROW( _T("'pclFrom6WayValveActuatorCompatibility' argument can't be null!") );
		}

		if( NULL == pclFrom6WayValveActuatorCompatibility->GetAllActuatorFilters().empty() )
		{
			return;
		}

		m_mapActuatorFilters.clear();

		for( auto &iter : pclFrom6WayValveActuatorCompatibility->GetAllActuatorFilters() )
		{
			m_mapActuatorFilters.insert( std::pair<e6WayValveSelectionMode, ActuatorFilters>( iter.first, iter.second ) );
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_6WayValveActuatorCompatibility::CopyFrom' method with the object '%s'."), GetIDPtr().ID )
}

void CDB_6WayValveActuatorCompatibility::Copy( CData *pclDestination )
{
	HYSELECT_TRY
	{
		if( NULL == pclDestination )
		{
			HYSELECT_THROW( _T("'pclDestination' argument can't be null!") );
		}

		if( NULL == dynamic_cast<CDB_6WayValveActuatorCompatibility *>( pclDestination ) )
		{
			HYSELECT_THROW( _T("'pclDestination' argument is not a 'CDB_6WayValveActuatorCompatibility' object!") );
		}

		// Base class.
		CDB_StringArray::Copy( pclDestination );
		
		// Copy now what it is common to the "CDB_6WayValveActuatorCompatibility" class.
		CDB_6WayValveActuatorCompatibility *pclDestination6WayValveActuatorCompatibility = (CDB_6WayValveActuatorCompatibility *)pclDestination;

		pclDestination6WayValveActuatorCompatibility->CopyAllActuatorFilters( this );
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_6WayValveActuatorCompatibility::Copy' method with the object '%s'."), GetIDPtr().ID )
}

#define CDB_6WAYVALVEACTUATORCOMPATIBILITY_VERSION	1
void CDB_6WayValveActuatorCompatibility::Write( OUTSTREAM outf )
{
	// Version.
	BYTE Version = CDB_6WAYVALVEACTUATORCOMPATIBILITY_VERSION;
	outf.write( (char *)&Version, sizeof( Version ) );

	// Base class.
	// We intentionally don't call the 'CDB_StringArray' base class but directly 'CData'.
	// Otherwise we will write redundant information.
	CData::Write( outf );

	// Write number of type of circuit.
	int iSize = m_mapActuatorFilters.size();
	outf.write( (char *)&iSize, sizeof( iSize ) );

	for( auto &iterFilter : m_mapActuatorFilters )
	{
		// Type of circuit.
		outf.write( (char *)&iterFilter.first, sizeof( iterFilter.first ) );

		// Number of power supply ID defined for actuator compatible with 6-way valve.
		iSize = (int)iterFilter.second.m_6WayValveActuatorPowerSupplyIDCompatibilityList.size();
		outf.write( (char *)&iSize, sizeof( iSize ) );

		if( iSize > 0 )
		{
			for( auto &iterPowerSupplyIDPtr : iterFilter.second.m_6WayValveActuatorPowerSupplyIDCompatibilityList )
			{
				WriteString( outf, iterPowerSupplyIDPtr.ID );
			}
		}

		// Number of input signal ID defined for actuator compatible with 6-way valve.
		iSize = (int)iterFilter.second.m_6WayValveActuatorInputSignalIDCompatibilityList.size();
		outf.write( (char *)&iSize, sizeof( iSize ) );

		if( iSize > 0 )
		{
			for( auto &iterInputSignalIDPtr : iterFilter.second.m_6WayValveActuatorInputSignalIDCompatibilityList )
			{
				WriteString( outf, iterInputSignalIDPtr.ID );
			}
		}

		// Number of family ID for actuator compatible with PIBCV.
		iSize = (int)iterFilter.second.m_PIBCValveActuatorFamilyIDCompatibilityList.size();
		outf.write( (char *)&iSize, sizeof( iSize ) );

		if( iSize > 0 )
		{
			for( auto &iterFamilyIDPtr : iterFilter.second.m_PIBCValveActuatorFamilyIDCompatibilityList )
			{
				WriteString( outf, iterFamilyIDPtr.ID );
			}
		}
	}
}

bool CDB_6WayValveActuatorCompatibility::Read( INPSTREAM inpf )
{
	// Version.
	BYTE Version;
	inpf.read( (char *)&Version, sizeof( Version ) );

	if( Version < 1 || Version > CDB_6WAYVALVEACTUATORCOMPATIBILITY_VERSION )
	{
		return false;
	}

	// Base class.
	// We intentionally didn't write with 'CDB_StringArray' base class but directly 'CData'.
	// Otherwise we will have redundant information.
	if( false == CData::Read( inpf ) )
	{
		return false;
	}

	// Read number of circuit type saved.
	int iCircuitTypeNumber = 0;
	inpf.read( (char *)&iCircuitTypeNumber, sizeof( iCircuitTypeNumber ) );

	if( 0 == iCircuitTypeNumber )
	{
		return true;
	}

	for( int iLoopCircuitType = 0; iLoopCircuitType < iCircuitTypeNumber; iLoopCircuitType++ )
	{
		ActuatorFilters rActuatorFilters;
		rActuatorFilters.m_6WayValveActuatorPowerSupplyIDCompatibilityList.clear();
		rActuatorFilters.m_6WayValveActuatorInputSignalIDCompatibilityList.clear();

		// Type of circuit.
		e6WayValveSelectionMode eSixWayAppType;
		inpf.read( (char *)&eSixWayAppType, sizeof( eSixWayAppType ) );

		// Number of power supply ID defined for actuator compatible with 6-way valve.
		int iPowerSupplyIDNumber = 0;
		inpf.read( (char *)&iPowerSupplyIDNumber, sizeof( iPowerSupplyIDNumber ) );

		if( iPowerSupplyIDNumber > 0 )
		{
			for( int iLoopPowerSupplyID = 0; iLoopPowerSupplyID < iPowerSupplyIDNumber; iLoopPowerSupplyID++ )
			{
				IDPTR IDPtrPowerSupply = _NULL_IDPTR;

				if( false == ReadString( inpf, IDPtrPowerSupply.ID, sizeof( IDPtrPowerSupply.ID ) ) )
				{
					return false;
				}

				rActuatorFilters.m_6WayValveActuatorPowerSupplyIDCompatibilityList.push_back( IDPtrPowerSupply );
			}
		}

		// Number of input signal ID defined for actuator compatible with 6-way valve.
		int iInputSignalIDNumber = 0;
		inpf.read( (char *)&iInputSignalIDNumber, sizeof( iInputSignalIDNumber ) );

		if( iInputSignalIDNumber > 0 )
		{
			for( int iLoopInputSignalID = 0; iLoopInputSignalID < iInputSignalIDNumber; iLoopInputSignalID++ )
			{
				IDPTR IDPtrInputSignal = _NULL_IDPTR;

				if( false == ReadString( inpf, IDPtrInputSignal.ID, sizeof( IDPtrInputSignal.ID ) ) )
				{
					return false;
				}

				rActuatorFilters.m_6WayValveActuatorInputSignalIDCompatibilityList.push_back( IDPtrInputSignal );
			}
		}

		// Number of family ID defined for actuator compatible with PIBCV.
		int iFamilyIDNumber = 0;
		inpf.read( (char *)&iFamilyIDNumber, sizeof( iFamilyIDNumber ) );

		if( iFamilyIDNumber > 0 )
		{
			for( int iLoopFamilyID = 0; iLoopFamilyID < iFamilyIDNumber; iLoopFamilyID++ )
			{
				IDPTR IDPtrFamily = _NULL_IDPTR;

				if( false == ReadString( inpf, IDPtrFamily.ID, sizeof( IDPtrFamily.ID ) ) )
				{
					return false;
				}

				rActuatorFilters.m_PIBCValveActuatorFamilyIDCompatibilityList.push_back( IDPtrFamily );
			}
		}

		m_mapActuatorFilters.insert( std::pair<e6WayValveSelectionMode, ActuatorFilters>( eSixWayAppType, rActuatorFilters ) );
	}

	return true;
}

void CDB_6WayValveActuatorCompatibility::CrossVerifyID()
{
	HYSELECT_TRY
	{
		if( 0 == m_mapActuatorFilters.size() )
		{
			return;
		}

		for( auto &iterFilter : m_mapActuatorFilters )
		{
			// Verify list of power supply ID for actuator compatible with 6-way valve.
			for( auto &iterPowerSupplyID : iterFilter.second.m_6WayValveActuatorPowerSupplyIDCompatibilityList )
			{
				iterPowerSupplyID.DB = GetDB();
				Extend( &iterPowerSupplyID );

				if( NULL == iterPowerSupplyID.MP )
				{
					HYSELECT_THROW( _T("Power supply ID (%s) is defined but not found in the database."), iterPowerSupplyID.ID );
				}

				if( false == iterPowerSupplyID.MP->IsClass( CLASS( CDB_StringID ) ) )
				{
					HYSELECT_THROW( _T("Power supply ID (%s) is found in the database but it's not a 'CDB_StringID' object."), iterPowerSupplyID.ID );
				}
			}

			// Verify list of input signal ID for actuator compatible with 6-way valve.
			for( auto &iterInputSignalID : iterFilter.second.m_6WayValveActuatorInputSignalIDCompatibilityList )
			{
				iterInputSignalID.DB = GetDB();
				Extend( &iterInputSignalID );

				if( NULL == iterInputSignalID.MP )
				{
					HYSELECT_THROW( _T("Input signal ID (%s) is defined but not found in the database."), iterInputSignalID.ID );
				}

				if( false == iterInputSignalID.MP->IsClass( CLASS( CDB_StringID ) ) )
				{
					HYSELECT_THROW( _T("Input signal ID (%s) is found in the database but it's not a 'CDB_StringID' object."), iterInputSignalID.ID );
				}
			}

			// Verify list of family ID for actuator compatible with PIBCV.
			for( auto &iterFamilyID : iterFilter.second.m_PIBCValveActuatorFamilyIDCompatibilityList )
			{
				iterFamilyID.DB = GetDB();
				Extend( &iterFamilyID );

				if( NULL == iterFamilyID.MP )
				{
					HYSELECT_THROW( _T("Family ID (%s) is defined but not found in the database."), iterFamilyID.ID );
				}

				if( false == iterFamilyID.MP->IsClass( CLASS( CDB_StringID ) ) )
				{
					HYSELECT_THROW( _T("Family ID (%s) is found in the database but it's not a 'CDB_StringID' object."), iterFamilyID.ID );
				}
			}
		}
	}
	HYSELECT_CATCH_ARG( clHySelectException, _T("Error in 'CDB_6WayValveActuatorCompatibility::CrossVerifyID' with the object '%s'."), GetIDPtr().ID )
}

void CDB_6WayValveActuatorCompatibility::ReadText( INPSTREAM inpf, unsigned short *pusLineCount )
{
	try
	{
		// Skip the open curve bracket.
		TCHAR *ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('{') != *ptcLine )
		{
			HYSELECT_THROW( _T("First line must be '{' (pos: %i)."), *pusLineCount );
		}

		_Reset();

		m_mapActuatorFilters.clear();

		// Inherited ?
		CString ihID;

		if( true == InheritedID( ptcLine, ihID ) )
		{
			// Reach the close curve bracket.
			while( _T('}') != *ptcLine )
			{
				ptcLine = ReadTextLine( inpf, pusLineCount );
			}

			HYSELECT_THROW( _T("No inheritance available for this object (pos: %i)."), *pusLineCount );
		}

		// Read base.
		CDB_StringArray::ReadText( inpf, pusLineCount );
	
		// Get the data of parent class.
		vector< vector< CString > > *pVectarray = NULL;
		GetStringTabs( &pVectarray );

		for( int iLoopLine = 0; iLoopLine < (int)pVectarray->size(); iLoopLine++ )
		{
			// Read the circuit type.
			int iValue = ReadEnum( pVectarray->at( iLoopLine ).at( 0 ) );

			if( iValue != e6Way_Alone && iValue != e6Way_EQMControl && iValue != e6Way_OnOffControlWithPIBCV && iValue != e6Way_OnOffControlWithSTAD )
			{
				HYSELECT_THROW( _T("Circuit type value must be one of these values: '#e6Way_Alone', '#e6Way_EQMControl', '#e6Way_OnOffControlWithPIBCV' or '#e6Way_OnOffControlWithSTAD' (pos: %i)."), *pusLineCount );
			}

			e6WayValveSelectionMode eSixWayAppType = (e6WayValveSelectionMode)iValue;

			ActuatorFilters rActuatorFilters;
			rActuatorFilters.m_6WayValveActuatorPowerSupplyIDCompatibilityList.clear();
			rActuatorFilters.m_6WayValveActuatorInputSignalIDCompatibilityList.clear();

			// Read power supply ID defined for actuator compatible with 6-way valve.
			if( false == pVectarray->at( iLoopLine ).at( 1 ).IsEmpty() )
			{
				ParseIDList( rActuatorFilters.m_6WayValveActuatorPowerSupplyIDCompatibilityList, pVectarray->at( iLoopLine ).at( 1 ), _T('|') );
			}

			// Read input signal ID defined for actuator compatible with 6-way valve.
			if( false == pVectarray->at( iLoopLine ).at( 2 ).IsEmpty() )
			{
				ParseIDList( rActuatorFilters.m_6WayValveActuatorInputSignalIDCompatibilityList, pVectarray->at( iLoopLine ).at( 2 ), _T('|') );
			}

			// Read family ID defined for actuator compatible with PIBCV.
			if( false == pVectarray->at( iLoopLine ).at( 3 ).IsEmpty() )
			{
				ParseIDList( rActuatorFilters.m_PIBCValveActuatorFamilyIDCompatibilityList, pVectarray->at( iLoopLine ).at( 3 ), _T('|') );
			}

			m_mapActuatorFilters.insert( std::pair<e6WayValveSelectionMode, ActuatorFilters>( eSixWayAppType, rActuatorFilters ) );
		}

		// Read the close curve bracket.
		ptcLine = ReadTextLine( inpf, pusLineCount );

		if( _T('}') != *ptcLine )
		{
			HYSELECT_THROW( _T("Last line must be '}' (pos: %i)."), *pusLineCount );
		}

		delete pVectarray;
	}
	catch( CHySelectException &clHySelectException )
	{
		clHySelectException.AddMessage( _T("Error in 'CDB_6WayValveActuatorCompatibility::ReadText' with the object '%s'."), __LINE__, __FILE__, GetIDPtr().ID );
		throw;
	}
}
#endif

////////////////////////////////////////////////////////////////
//
//		CTableDN : Table containing all DN.
//
////////////////////////////////////////////////////////////////
IMPLEMENT_DATA( CTableDN )

CTableDN::CTableDN( CDataBase *pDataBase, LPCTSTR ID )
	: CTable( pDataBase, ID )
{
	m_iLowestDN = INT_MAX;
	m_iBiggestDN = INT_MIN;
}

int CTableDN::GetLowestDN()
{
	if( INT_MAX != m_iLowestDN )
	{
		return m_iLowestDN;
	}

	for( IDPTR IDPtr = GetFirst(); NULL != IDPtr.MP; IDPtr = GetNext( IDPtr.MP ) )
	{
		CDB_StringID *pclStringID = dynamic_cast<CDB_StringID *>( IDPtr.MP );

		if( NULL == pclStringID )
		{
			ASSERT( 0 );
			continue;
		}

		int iDN;
		pclStringID->GetIDstrAs<int>( 0, iDN );

		if( iDN < m_iLowestDN )
		{
			m_iLowestDN = iDN;
		}
	}

	return m_iLowestDN;
}

int CTableDN::GetBiggestDN()
{
	if( INT_MIN != m_iBiggestDN )
	{
		return m_iBiggestDN;
	}

	for( IDPTR IDPtr = GetFirst(); NULL != IDPtr.MP; IDPtr = GetNext( IDPtr.MP ) )
	{
		CDB_StringID *pclStringID = dynamic_cast<CDB_StringID *>( IDPtr.MP );

		if( NULL == pclStringID )
		{
			ASSERT( 0 );
			continue;
		}

		int iDN;
		pclStringID->GetIDstrAs<int>( 0, iDN );

		if( iDN > m_iBiggestDN )
		{
			m_iBiggestDN = iDN;
		}
	}

	return m_iBiggestDN;
}

int CTableDN::GetSize( _string strID )
{
	IDPTR IDPtr = Get( strID.c_str() );

	CDB_StringID *pclStringID = dynamic_cast<CDB_StringID *>( IDPtr.MP );

	if( NULL == pclStringID )
	{
		return -1;
	}

	int iDN;
	pclStringID->GetIDstrAs<int>( 0, iDN );

	return iDN;
}
